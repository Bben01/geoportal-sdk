(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("itowns", [], factory);
	else if(typeof exports === 'object')
		exports["itowns"] = factory();
	else
		root["itowns"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp_name_"];
/******/ 	window["webpackJsonp_name_"] = function webpackJsonpCallback(chunkIds, moreModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, callbacks = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId])
/******/ 				callbacks.push.apply(callbacks, installedChunks[chunkId]);
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			modules[moduleId] = moreModules[moduleId];
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);
/******/ 		while(callbacks.length)
/******/ 			callbacks.shift().call(null, __webpack_require__);
/******/ 		if(moreModules[0]) {
/******/ 			installedModules[0] = 0;
/******/ 			return __webpack_require__(0);
/******/ 		}
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// "0" means "already loaded"
/******/ 	// Array means "loading", array contains callbacks
/******/ 	var installedChunks = {
/******/ 		1:0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId, callback) {
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] === 0)
/******/ 			return callback.call(null, __webpack_require__);
/******/
/******/ 		// an array means "currently loading".
/******/ 		if(installedChunks[chunkId] !== undefined) {
/******/ 			installedChunks[chunkId].push(callback);
/******/ 		} else {
/******/ 			// start chunk loading
/******/ 			installedChunks[chunkId] = [callback];
/******/ 			var head = document.getElementsByTagName('head')[0];
/******/ 			var script = document.createElement('script');
/******/ 			script.type = 'text/javascript';
/******/ 			script.charset = 'utf-8';
/******/ 			script.async = true;
/******/
/******/ 			script.src = __webpack_require__.p + "" + chunkId + "." + ({"0":"debug"}[chunkId]||chunkId) + ".js";
/******/ 			head.appendChild(script);
/******/ 		}
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(217);
	__webpack_require__(220);
	__webpack_require__(221);
	module.exports = __webpack_require__(222);


/***/ },
/* 1 */,
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(3), __esModule: true };

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(4);
	module.exports = __webpack_require__(15).Object.getPrototypeOf;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 Object.getPrototypeOf(O)
	var toObject        = __webpack_require__(5)
	  , $getPrototypeOf = __webpack_require__(7);
	
	__webpack_require__(13)('getPrototypeOf', function(){
	  return function getPrototypeOf(it){
	    return $getPrototypeOf(toObject(it));
	  };
	});

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.13 ToObject(argument)
	var defined = __webpack_require__(6);
	module.exports = function(it){
	  return Object(defined(it));
	};

/***/ },
/* 6 */
/***/ function(module, exports) {

	// 7.2.1 RequireObjectCoercible(argument)
	module.exports = function(it){
	  if(it == undefined)throw TypeError("Can't call method on  " + it);
	  return it;
	};

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
	var has         = __webpack_require__(8)
	  , toObject    = __webpack_require__(5)
	  , IE_PROTO    = __webpack_require__(9)('IE_PROTO')
	  , ObjectProto = Object.prototype;
	
	module.exports = Object.getPrototypeOf || function(O){
	  O = toObject(O);
	  if(has(O, IE_PROTO))return O[IE_PROTO];
	  if(typeof O.constructor == 'function' && O instanceof O.constructor){
	    return O.constructor.prototype;
	  } return O instanceof Object ? ObjectProto : null;
	};

/***/ },
/* 8 */
/***/ function(module, exports) {

	var hasOwnProperty = {}.hasOwnProperty;
	module.exports = function(it, key){
	  return hasOwnProperty.call(it, key);
	};

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var shared = __webpack_require__(10)('keys')
	  , uid    = __webpack_require__(12);
	module.exports = function(key){
	  return shared[key] || (shared[key] = uid(key));
	};

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	var global = __webpack_require__(11)
	  , SHARED = '__core-js_shared__'
	  , store  = global[SHARED] || (global[SHARED] = {});
	module.exports = function(key){
	  return store[key] || (store[key] = {});
	};

/***/ },
/* 11 */
/***/ function(module, exports) {

	// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
	var global = module.exports = typeof window != 'undefined' && window.Math == Math
	  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
	if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 12 */
/***/ function(module, exports) {

	var id = 0
	  , px = Math.random();
	module.exports = function(key){
	  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
	};

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	// most Object methods by ES6 should accept primitives
	var $export = __webpack_require__(14)
	  , core    = __webpack_require__(15)
	  , fails   = __webpack_require__(24);
	module.exports = function(KEY, exec){
	  var fn  = (core.Object || {})[KEY] || Object[KEY]
	    , exp = {};
	  exp[KEY] = exec(fn);
	  $export($export.S + $export.F * fails(function(){ fn(1); }), 'Object', exp);
	};

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(11)
	  , core      = __webpack_require__(15)
	  , ctx       = __webpack_require__(16)
	  , hide      = __webpack_require__(18)
	  , PROTOTYPE = 'prototype';
	
	var $export = function(type, name, source){
	  var IS_FORCED = type & $export.F
	    , IS_GLOBAL = type & $export.G
	    , IS_STATIC = type & $export.S
	    , IS_PROTO  = type & $export.P
	    , IS_BIND   = type & $export.B
	    , IS_WRAP   = type & $export.W
	    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
	    , expProto  = exports[PROTOTYPE]
	    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE]
	    , key, own, out;
	  if(IS_GLOBAL)source = name;
	  for(key in source){
	    // contains in native
	    own = !IS_FORCED && target && target[key] !== undefined;
	    if(own && key in exports)continue;
	    // export native or passed
	    out = own ? target[key] : source[key];
	    // prevent global pollution for namespaces
	    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key]
	    // bind timers to global for call from export context
	    : IS_BIND && own ? ctx(out, global)
	    // wrap global constructors for prevent change them in library
	    : IS_WRAP && target[key] == out ? (function(C){
	      var F = function(a, b, c){
	        if(this instanceof C){
	          switch(arguments.length){
	            case 0: return new C;
	            case 1: return new C(a);
	            case 2: return new C(a, b);
	          } return new C(a, b, c);
	        } return C.apply(this, arguments);
	      };
	      F[PROTOTYPE] = C[PROTOTYPE];
	      return F;
	    // make static versions for prototype methods
	    })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
	    // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%
	    if(IS_PROTO){
	      (exports.virtual || (exports.virtual = {}))[key] = out;
	      // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%
	      if(type & $export.R && expProto && !expProto[key])hide(expProto, key, out);
	    }
	  }
	};
	// type bitmap
	$export.F = 1;   // forced
	$export.G = 2;   // global
	$export.S = 4;   // static
	$export.P = 8;   // proto
	$export.B = 16;  // bind
	$export.W = 32;  // wrap
	$export.U = 64;  // safe
	$export.R = 128; // real proto method for `library` 
	module.exports = $export;

/***/ },
/* 15 */
/***/ function(module, exports) {

	var core = module.exports = {version: '2.4.0'};
	if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	// optional / simple context binding
	var aFunction = __webpack_require__(17);
	module.exports = function(fn, that, length){
	  aFunction(fn);
	  if(that === undefined)return fn;
	  switch(length){
	    case 1: return function(a){
	      return fn.call(that, a);
	    };
	    case 2: return function(a, b){
	      return fn.call(that, a, b);
	    };
	    case 3: return function(a, b, c){
	      return fn.call(that, a, b, c);
	    };
	  }
	  return function(/* ...args */){
	    return fn.apply(that, arguments);
	  };
	};

/***/ },
/* 17 */
/***/ function(module, exports) {

	module.exports = function(it){
	  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
	  return it;
	};

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	var dP         = __webpack_require__(19)
	  , createDesc = __webpack_require__(27);
	module.exports = __webpack_require__(23) ? function(object, key, value){
	  return dP.f(object, key, createDesc(1, value));
	} : function(object, key, value){
	  object[key] = value;
	  return object;
	};

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	var anObject       = __webpack_require__(20)
	  , IE8_DOM_DEFINE = __webpack_require__(22)
	  , toPrimitive    = __webpack_require__(26)
	  , dP             = Object.defineProperty;
	
	exports.f = __webpack_require__(23) ? Object.defineProperty : function defineProperty(O, P, Attributes){
	  anObject(O);
	  P = toPrimitive(P, true);
	  anObject(Attributes);
	  if(IE8_DOM_DEFINE)try {
	    return dP(O, P, Attributes);
	  } catch(e){ /* empty */ }
	  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
	  if('value' in Attributes)O[P] = Attributes.value;
	  return O;
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(21);
	module.exports = function(it){
	  if(!isObject(it))throw TypeError(it + ' is not an object!');
	  return it;
	};

/***/ },
/* 21 */
/***/ function(module, exports) {

	module.exports = function(it){
	  return typeof it === 'object' ? it !== null : typeof it === 'function';
	};

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = !__webpack_require__(23) && !__webpack_require__(24)(function(){
	  return Object.defineProperty(__webpack_require__(25)('div'), 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	// Thank's IE8 for his funny defineProperty
	module.exports = !__webpack_require__(24)(function(){
	  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
	});

/***/ },
/* 24 */
/***/ function(module, exports) {

	module.exports = function(exec){
	  try {
	    return !!exec();
	  } catch(e){
	    return true;
	  }
	};

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(21)
	  , document = __webpack_require__(11).document
	  // in old IE typeof document.createElement is 'object'
	  , is = isObject(document) && isObject(document.createElement);
	module.exports = function(it){
	  return is ? document.createElement(it) : {};
	};

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.1 ToPrimitive(input [, PreferredType])
	var isObject = __webpack_require__(21);
	// instead of the ES6 spec version, we didn't implement @@toPrimitive case
	// and the second argument - flag - preferred type is a string
	module.exports = function(it, S){
	  if(!isObject(it))return it;
	  var fn, val;
	  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
	  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
	  throw TypeError("Can't convert object to primitive value");
	};

/***/ },
/* 27 */
/***/ function(module, exports) {

	module.exports = function(bitmap, value){
	  return {
	    enumerable  : !(bitmap & 1),
	    configurable: !(bitmap & 2),
	    writable    : !(bitmap & 4),
	    value       : value
	  };
	};

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(29), __esModule: true };

/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(30);
	__webpack_require__(54);
	module.exports = __webpack_require__(56);

/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(31);
	var global        = __webpack_require__(11)
	  , hide          = __webpack_require__(18)
	  , Iterators     = __webpack_require__(34)
	  , TO_STRING_TAG = __webpack_require__(53)('toStringTag');
	
	for(var collections = ['NodeList', 'DOMTokenList', 'MediaList', 'StyleSheetList', 'CSSRuleList'], i = 0; i < 5; i++){
	  var NAME       = collections[i]
	    , Collection = global[NAME]
	    , proto      = Collection && Collection.prototype;
	  if(proto && !proto[TO_STRING_TAG])hide(proto, TO_STRING_TAG, NAME);
	  Iterators[NAME] = Iterators.Array;
	}

/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var addToUnscopables = __webpack_require__(32)
	  , step             = __webpack_require__(33)
	  , Iterators        = __webpack_require__(34)
	  , toIObject        = __webpack_require__(35);
	
	// 22.1.3.4 Array.prototype.entries()
	// 22.1.3.13 Array.prototype.keys()
	// 22.1.3.29 Array.prototype.values()
	// 22.1.3.30 Array.prototype[@@iterator]()
	module.exports = __webpack_require__(38)(Array, 'Array', function(iterated, kind){
	  this._t = toIObject(iterated); // target
	  this._i = 0;                   // next index
	  this._k = kind;                // kind
	// 22.1.5.2.1 %ArrayIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , kind  = this._k
	    , index = this._i++;
	  if(!O || index >= O.length){
	    this._t = undefined;
	    return step(1);
	  }
	  if(kind == 'keys'  )return step(0, index);
	  if(kind == 'values')return step(0, O[index]);
	  return step(0, [index, O[index]]);
	}, 'values');
	
	// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)
	Iterators.Arguments = Iterators.Array;
	
	addToUnscopables('keys');
	addToUnscopables('values');
	addToUnscopables('entries');

/***/ },
/* 32 */
/***/ function(module, exports) {

	module.exports = function(){ /* empty */ };

/***/ },
/* 33 */
/***/ function(module, exports) {

	module.exports = function(done, value){
	  return {value: value, done: !!done};
	};

/***/ },
/* 34 */
/***/ function(module, exports) {

	module.exports = {};

/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	// to indexed object, toObject with fallback for non-array-like ES3 strings
	var IObject = __webpack_require__(36)
	  , defined = __webpack_require__(6);
	module.exports = function(it){
	  return IObject(defined(it));
	};

/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for non-array-like ES3 and non-enumerable old V8 strings
	var cof = __webpack_require__(37);
	module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
	  return cof(it) == 'String' ? it.split('') : Object(it);
	};

/***/ },
/* 37 */
/***/ function(module, exports) {

	var toString = {}.toString;
	
	module.exports = function(it){
	  return toString.call(it).slice(8, -1);
	};

/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY        = __webpack_require__(39)
	  , $export        = __webpack_require__(14)
	  , redefine       = __webpack_require__(40)
	  , hide           = __webpack_require__(18)
	  , has            = __webpack_require__(8)
	  , Iterators      = __webpack_require__(34)
	  , $iterCreate    = __webpack_require__(41)
	  , setToStringTag = __webpack_require__(52)
	  , getPrototypeOf = __webpack_require__(7)
	  , ITERATOR       = __webpack_require__(53)('iterator')
	  , BUGGY          = !([].keys && 'next' in [].keys()) // Safari has buggy iterators w/o `next`
	  , FF_ITERATOR    = '@@iterator'
	  , KEYS           = 'keys'
	  , VALUES         = 'values';
	
	var returnThis = function(){ return this; };
	
	module.exports = function(Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED){
	  $iterCreate(Constructor, NAME, next);
	  var getMethod = function(kind){
	    if(!BUGGY && kind in proto)return proto[kind];
	    switch(kind){
	      case KEYS: return function keys(){ return new Constructor(this, kind); };
	      case VALUES: return function values(){ return new Constructor(this, kind); };
	    } return function entries(){ return new Constructor(this, kind); };
	  };
	  var TAG        = NAME + ' Iterator'
	    , DEF_VALUES = DEFAULT == VALUES
	    , VALUES_BUG = false
	    , proto      = Base.prototype
	    , $native    = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT]
	    , $default   = $native || getMethod(DEFAULT)
	    , $entries   = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined
	    , $anyNative = NAME == 'Array' ? proto.entries || $native : $native
	    , methods, key, IteratorPrototype;
	  // Fix native
	  if($anyNative){
	    IteratorPrototype = getPrototypeOf($anyNative.call(new Base));
	    if(IteratorPrototype !== Object.prototype){
	      // Set @@toStringTag to native iterators
	      setToStringTag(IteratorPrototype, TAG, true);
	      // fix for some old engines
	      if(!LIBRARY && !has(IteratorPrototype, ITERATOR))hide(IteratorPrototype, ITERATOR, returnThis);
	    }
	  }
	  // fix Array#{values, @@iterator}.name in V8 / FF
	  if(DEF_VALUES && $native && $native.name !== VALUES){
	    VALUES_BUG = true;
	    $default = function values(){ return $native.call(this); };
	  }
	  // Define iterator
	  if((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])){
	    hide(proto, ITERATOR, $default);
	  }
	  // Plug for library
	  Iterators[NAME] = $default;
	  Iterators[TAG]  = returnThis;
	  if(DEFAULT){
	    methods = {
	      values:  DEF_VALUES ? $default : getMethod(VALUES),
	      keys:    IS_SET     ? $default : getMethod(KEYS),
	      entries: $entries
	    };
	    if(FORCED)for(key in methods){
	      if(!(key in proto))redefine(proto, key, methods[key]);
	    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
	  }
	  return methods;
	};

/***/ },
/* 39 */
/***/ function(module, exports) {

	module.exports = true;

/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(18);

/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var create         = __webpack_require__(42)
	  , descriptor     = __webpack_require__(27)
	  , setToStringTag = __webpack_require__(52)
	  , IteratorPrototype = {};
	
	// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
	__webpack_require__(18)(IteratorPrototype, __webpack_require__(53)('iterator'), function(){ return this; });
	
	module.exports = function(Constructor, NAME, next){
	  Constructor.prototype = create(IteratorPrototype, {next: descriptor(1, next)});
	  setToStringTag(Constructor, NAME + ' Iterator');
	};

/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	var anObject    = __webpack_require__(20)
	  , dPs         = __webpack_require__(43)
	  , enumBugKeys = __webpack_require__(50)
	  , IE_PROTO    = __webpack_require__(9)('IE_PROTO')
	  , Empty       = function(){ /* empty */ }
	  , PROTOTYPE   = 'prototype';
	
	// Create object with fake `null` prototype: use iframe Object with cleared prototype
	var createDict = function(){
	  // Thrash, waste and sodomy: IE GC bug
	  var iframe = __webpack_require__(25)('iframe')
	    , i      = enumBugKeys.length
	    , lt     = '<'
	    , gt     = '>'
	    , iframeDocument;
	  iframe.style.display = 'none';
	  __webpack_require__(51).appendChild(iframe);
	  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
	  // createDict = iframe.contentWindow.Object;
	  // html.removeChild(iframe);
	  iframeDocument = iframe.contentWindow.document;
	  iframeDocument.open();
	  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
	  iframeDocument.close();
	  createDict = iframeDocument.F;
	  while(i--)delete createDict[PROTOTYPE][enumBugKeys[i]];
	  return createDict();
	};
	
	module.exports = Object.create || function create(O, Properties){
	  var result;
	  if(O !== null){
	    Empty[PROTOTYPE] = anObject(O);
	    result = new Empty;
	    Empty[PROTOTYPE] = null;
	    // add "__proto__" for Object.getPrototypeOf polyfill
	    result[IE_PROTO] = O;
	  } else result = createDict();
	  return Properties === undefined ? result : dPs(result, Properties);
	};


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var dP       = __webpack_require__(19)
	  , anObject = __webpack_require__(20)
	  , getKeys  = __webpack_require__(44);
	
	module.exports = __webpack_require__(23) ? Object.defineProperties : function defineProperties(O, Properties){
	  anObject(O);
	  var keys   = getKeys(Properties)
	    , length = keys.length
	    , i = 0
	    , P;
	  while(length > i)dP.f(O, P = keys[i++], Properties[P]);
	  return O;
	};

/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 / 15.2.3.14 Object.keys(O)
	var $keys       = __webpack_require__(45)
	  , enumBugKeys = __webpack_require__(50);
	
	module.exports = Object.keys || function keys(O){
	  return $keys(O, enumBugKeys);
	};

/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	var has          = __webpack_require__(8)
	  , toIObject    = __webpack_require__(35)
	  , arrayIndexOf = __webpack_require__(46)(false)
	  , IE_PROTO     = __webpack_require__(9)('IE_PROTO');
	
	module.exports = function(object, names){
	  var O      = toIObject(object)
	    , i      = 0
	    , result = []
	    , key;
	  for(key in O)if(key != IE_PROTO)has(O, key) && result.push(key);
	  // Don't enum bug & hidden keys
	  while(names.length > i)if(has(O, key = names[i++])){
	    ~arrayIndexOf(result, key) || result.push(key);
	  }
	  return result;
	};

/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	// false -> Array#indexOf
	// true  -> Array#includes
	var toIObject = __webpack_require__(35)
	  , toLength  = __webpack_require__(47)
	  , toIndex   = __webpack_require__(49);
	module.exports = function(IS_INCLUDES){
	  return function($this, el, fromIndex){
	    var O      = toIObject($this)
	      , length = toLength(O.length)
	      , index  = toIndex(fromIndex, length)
	      , value;
	    // Array#includes uses SameValueZero equality algorithm
	    if(IS_INCLUDES && el != el)while(length > index){
	      value = O[index++];
	      if(value != value)return true;
	    // Array#toIndex ignores holes, Array#includes - not
	    } else for(;length > index; index++)if(IS_INCLUDES || index in O){
	      if(O[index] === el)return IS_INCLUDES || index || 0;
	    } return !IS_INCLUDES && -1;
	  };
	};

/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	// 7.1.15 ToLength
	var toInteger = __webpack_require__(48)
	  , min       = Math.min;
	module.exports = function(it){
	  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
	};

/***/ },
/* 48 */
/***/ function(module, exports) {

	// 7.1.4 ToInteger
	var ceil  = Math.ceil
	  , floor = Math.floor;
	module.exports = function(it){
	  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
	};

/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(48)
	  , max       = Math.max
	  , min       = Math.min;
	module.exports = function(index, length){
	  index = toInteger(index);
	  return index < 0 ? max(index + length, 0) : min(index, length);
	};

/***/ },
/* 50 */
/***/ function(module, exports) {

	// IE 8- don't enum bug keys
	module.exports = (
	  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'
	).split(',');

/***/ },
/* 51 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(11).document && document.documentElement;

/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

	var def = __webpack_require__(19).f
	  , has = __webpack_require__(8)
	  , TAG = __webpack_require__(53)('toStringTag');
	
	module.exports = function(it, tag, stat){
	  if(it && !has(it = stat ? it : it.prototype, TAG))def(it, TAG, {configurable: true, value: tag});
	};

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

	var store      = __webpack_require__(10)('wks')
	  , uid        = __webpack_require__(12)
	  , Symbol     = __webpack_require__(11).Symbol
	  , USE_SYMBOL = typeof Symbol == 'function';
	
	var $exports = module.exports = function(name){
	  return store[name] || (store[name] =
	    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
	};
	
	$exports.store = store;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $at  = __webpack_require__(55)(true);
	
	// 21.1.3.27 String.prototype[@@iterator]()
	__webpack_require__(38)(String, 'String', function(iterated){
	  this._t = String(iterated); // target
	  this._i = 0;                // next index
	// 21.1.5.2.1 %StringIteratorPrototype%.next()
	}, function(){
	  var O     = this._t
	    , index = this._i
	    , point;
	  if(index >= O.length)return {value: undefined, done: true};
	  point = $at(O, index);
	  this._i += point.length;
	  return {value: point, done: false};
	});

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

	var toInteger = __webpack_require__(48)
	  , defined   = __webpack_require__(6);
	// true  -> String#at
	// false -> String#codePointAt
	module.exports = function(TO_STRING){
	  return function(that, pos){
	    var s = String(defined(that))
	      , i = toInteger(pos)
	      , l = s.length
	      , a, b;
	    if(i < 0 || i >= l)return TO_STRING ? '' : undefined;
	    a = s.charCodeAt(i);
	    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff
	      ? TO_STRING ? s.charAt(i) : a
	      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
	  };
	};

/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	var anObject = __webpack_require__(20)
	  , get      = __webpack_require__(57);
	module.exports = __webpack_require__(15).getIterator = function(it){
	  var iterFn = get(it);
	  if(typeof iterFn != 'function')throw TypeError(it + ' is not iterable!');
	  return anObject(iterFn.call(it));
	};

/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	var classof   = __webpack_require__(58)
	  , ITERATOR  = __webpack_require__(53)('iterator')
	  , Iterators = __webpack_require__(34);
	module.exports = __webpack_require__(15).getIteratorMethod = function(it){
	  if(it != undefined)return it[ITERATOR]
	    || it['@@iterator']
	    || Iterators[classof(it)];
	};

/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

	// getting tag from 19.1.3.6 Object.prototype.toString()
	var cof = __webpack_require__(37)
	  , TAG = __webpack_require__(53)('toStringTag')
	  // ES3 wrong here
	  , ARG = cof(function(){ return arguments; }()) == 'Arguments';
	
	// fallback for IE11 Script Access Denied error
	var tryGet = function(it, key){
	  try {
	    return it[key];
	  } catch(e){ /* empty */ }
	};
	
	module.exports = function(it){
	  var O, T, B;
	  return it === undefined ? 'Undefined' : it === null ? 'Null'
	    // @@toStringTag case
	    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T
	    // builtinTag case
	    : ARG ? cof(O)
	    // ES3 arguments fallback
	    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
	};

/***/ },
/* 59 */,
/* 60 */,
/* 61 */,
/* 62 */,
/* 63 */,
/* 64 */,
/* 65 */,
/* 66 */,
/* 67 */,
/* 68 */,
/* 69 */,
/* 70 */,
/* 71 */,
/* 72 */,
/* 73 */,
/* 74 */,
/* 75 */,
/* 76 */,
/* 77 */,
/* 78 */,
/* 79 */,
/* 80 */,
/* 81 */,
/* 82 */,
/* 83 */,
/* 84 */,
/* 85 */,
/* 86 */,
/* 87 */,
/* 88 */,
/* 89 */,
/* 90 */,
/* 91 */,
/* 92 */,
/* 93 */,
/* 94 */
/***/ function(module, exports) {

	module.exports = function(module) {
		if(!module.webpackPolyfill) {
			module.deprecate = function() {};
			module.paths = [];
			// module.parent = undefined by default
			module.children = [];
			module.webpackPolyfill = 1;
		}
		return module;
	}


/***/ },
/* 95 */,
/* 96 */,
/* 97 */,
/* 98 */,
/* 99 */,
/* 100 */,
/* 101 */,
/* 102 */,
/* 103 */,
/* 104 */,
/* 105 */,
/* 106 */,
/* 107 */,
/* 108 */,
/* 109 */,
/* 110 */,
/* 111 */,
/* 112 */,
/* 113 */,
/* 114 */,
/* 115 */,
/* 116 */,
/* 117 */,
/* 118 */,
/* 119 */,
/* 120 */,
/* 121 */,
/* 122 */,
/* 123 */,
/* 124 */,
/* 125 */,
/* 126 */,
/* 127 */,
/* 128 */,
/* 129 */,
/* 130 */,
/* 131 */,
/* 132 */,
/* 133 */,
/* 134 */,
/* 135 */,
/* 136 */,
/* 137 */,
/* 138 */,
/* 139 */,
/* 140 */,
/* 141 */,
/* 142 */,
/* 143 */,
/* 144 */,
/* 145 */,
/* 146 */,
/* 147 */,
/* 148 */,
/* 149 */,
/* 150 */,
/* 151 */,
/* 152 */,
/* 153 */,
/* 154 */,
/* 155 */,
/* 156 */,
/* 157 */,
/* 158 */,
/* 159 */,
/* 160 */,
/* 161 */,
/* 162 */,
/* 163 */,
/* 164 */,
/* 165 */,
/* 166 */,
/* 167 */,
/* 168 */,
/* 169 */,
/* 170 */,
/* 171 */,
/* 172 */,
/* 173 */,
/* 174 */,
/* 175 */,
/* 176 */,
/* 177 */,
/* 178 */,
/* 179 */,
/* 180 */,
/* 181 */,
/* 182 */,
/* 183 */,
/* 184 */,
/* 185 */,
/* 186 */,
/* 187 */,
/* 188 */,
/* 189 */,
/* 190 */,
/* 191 */,
/* 192 */,
/* 193 */,
/* 194 */,
/* 195 */,
/* 196 */,
/* 197 */,
/* 198 */,
/* 199 */,
/* 200 */,
/* 201 */,
/* 202 */,
/* 203 */,
/* 204 */,
/* 205 */,
/* 206 */,
/* 207 */,
/* 208 */,
/* 209 */,
/* 210 */,
/* 211 */,
/* 212 */,
/* 213 */,
/* 214 */,
/* 215 */,
/* 216 */,
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	var require;/* WEBPACK VAR INJECTION */(function(process, global) {/*!
	 * @overview es6-promise - a tiny implementation of Promises/A+.
	 * @copyright Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors (Conversion to ES6 API by Jake Archibald)
	 * @license   Licensed under MIT license
	 *            See https://raw.githubusercontent.com/stefanpenner/es6-promise/master/LICENSE
	 * @version   4.0.5
	 */
	
	(function (global, factory) {
	     true ? module.exports = factory() :
	    typeof define === 'function' && define.amd ? define(factory) :
	    (global.ES6Promise = factory());
	}(this, (function () { 'use strict';
	
	function objectOrFunction(x) {
	  return typeof x === 'function' || typeof x === 'object' && x !== null;
	}
	
	function isFunction(x) {
	  return typeof x === 'function';
	}
	
	var _isArray = undefined;
	if (!Array.isArray) {
	  _isArray = function (x) {
	    return Object.prototype.toString.call(x) === '[object Array]';
	  };
	} else {
	  _isArray = Array.isArray;
	}
	
	var isArray = _isArray;
	
	var len = 0;
	var vertxNext = undefined;
	var customSchedulerFn = undefined;
	
	var asap = function asap(callback, arg) {
	  queue[len] = callback;
	  queue[len + 1] = arg;
	  len += 2;
	  if (len === 2) {
	    // If len is 2, that means that we need to schedule an async flush.
	    // If additional callbacks are queued before the queue is flushed, they
	    // will be processed by this flush that we are scheduling.
	    if (customSchedulerFn) {
	      customSchedulerFn(flush);
	    } else {
	      scheduleFlush();
	    }
	  }
	};
	
	function setScheduler(scheduleFn) {
	  customSchedulerFn = scheduleFn;
	}
	
	function setAsap(asapFn) {
	  asap = asapFn;
	}
	
	var browserWindow = typeof window !== 'undefined' ? window : undefined;
	var browserGlobal = browserWindow || {};
	var BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver;
	var isNode = typeof self === 'undefined' && typeof process !== 'undefined' && ({}).toString.call(process) === '[object process]';
	
	// test for web worker but not in IE10
	var isWorker = typeof Uint8ClampedArray !== 'undefined' && typeof importScripts !== 'undefined' && typeof MessageChannel !== 'undefined';
	
	// node
	function useNextTick() {
	  // node version 0.10.x displays a deprecation warning when nextTick is used recursively
	  // see https://github.com/cujojs/when/issues/410 for details
	  return function () {
	    return process.nextTick(flush);
	  };
	}
	
	// vertx
	function useVertxTimer() {
	  if (typeof vertxNext !== 'undefined') {
	    return function () {
	      vertxNext(flush);
	    };
	  }
	
	  return useSetTimeout();
	}
	
	function useMutationObserver() {
	  var iterations = 0;
	  var observer = new BrowserMutationObserver(flush);
	  var node = document.createTextNode('');
	  observer.observe(node, { characterData: true });
	
	  return function () {
	    node.data = iterations = ++iterations % 2;
	  };
	}
	
	// web worker
	function useMessageChannel() {
	  var channel = new MessageChannel();
	  channel.port1.onmessage = flush;
	  return function () {
	    return channel.port2.postMessage(0);
	  };
	}
	
	function useSetTimeout() {
	  // Store setTimeout reference so es6-promise will be unaffected by
	  // other code modifying setTimeout (like sinon.useFakeTimers())
	  var globalSetTimeout = setTimeout;
	  return function () {
	    return globalSetTimeout(flush, 1);
	  };
	}
	
	var queue = new Array(1000);
	function flush() {
	  for (var i = 0; i < len; i += 2) {
	    var callback = queue[i];
	    var arg = queue[i + 1];
	
	    callback(arg);
	
	    queue[i] = undefined;
	    queue[i + 1] = undefined;
	  }
	
	  len = 0;
	}
	
	function attemptVertx() {
	  try {
	    var r = require;
	    var vertx = __webpack_require__(219);
	    vertxNext = vertx.runOnLoop || vertx.runOnContext;
	    return useVertxTimer();
	  } catch (e) {
	    return useSetTimeout();
	  }
	}
	
	var scheduleFlush = undefined;
	// Decide what async method to use to triggering processing of queued callbacks:
	if (isNode) {
	  scheduleFlush = useNextTick();
	} else if (BrowserMutationObserver) {
	  scheduleFlush = useMutationObserver();
	} else if (isWorker) {
	  scheduleFlush = useMessageChannel();
	} else if (browserWindow === undefined && "function" === 'function') {
	  scheduleFlush = attemptVertx();
	} else {
	  scheduleFlush = useSetTimeout();
	}
	
	function then(onFulfillment, onRejection) {
	  var _arguments = arguments;
	
	  var parent = this;
	
	  var child = new this.constructor(noop);
	
	  if (child[PROMISE_ID] === undefined) {
	    makePromise(child);
	  }
	
	  var _state = parent._state;
	
	  if (_state) {
	    (function () {
	      var callback = _arguments[_state - 1];
	      asap(function () {
	        return invokeCallback(_state, child, callback, parent._result);
	      });
	    })();
	  } else {
	    subscribe(parent, child, onFulfillment, onRejection);
	  }
	
	  return child;
	}
	
	/**
	  `Promise.resolve` returns a promise that will become resolved with the
	  passed `value`. It is shorthand for the following:
	
	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    resolve(1);
	  });
	
	  promise.then(function(value){
	    // value === 1
	  });
	  ```
	
	  Instead of writing the above, your code now simply becomes the following:
	
	  ```javascript
	  let promise = Promise.resolve(1);
	
	  promise.then(function(value){
	    // value === 1
	  });
	  ```
	
	  @method resolve
	  @static
	  @param {Any} value value that the returned promise will be resolved with
	  Useful for tooling.
	  @return {Promise} a promise that will become fulfilled with the given
	  `value`
	*/
	function resolve(object) {
	  /*jshint validthis:true */
	  var Constructor = this;
	
	  if (object && typeof object === 'object' && object.constructor === Constructor) {
	    return object;
	  }
	
	  var promise = new Constructor(noop);
	  _resolve(promise, object);
	  return promise;
	}
	
	var PROMISE_ID = Math.random().toString(36).substring(16);
	
	function noop() {}
	
	var PENDING = void 0;
	var FULFILLED = 1;
	var REJECTED = 2;
	
	var GET_THEN_ERROR = new ErrorObject();
	
	function selfFulfillment() {
	  return new TypeError("You cannot resolve a promise with itself");
	}
	
	function cannotReturnOwn() {
	  return new TypeError('A promises callback cannot return that same promise.');
	}
	
	function getThen(promise) {
	  try {
	    return promise.then;
	  } catch (error) {
	    GET_THEN_ERROR.error = error;
	    return GET_THEN_ERROR;
	  }
	}
	
	function tryThen(then, value, fulfillmentHandler, rejectionHandler) {
	  try {
	    then.call(value, fulfillmentHandler, rejectionHandler);
	  } catch (e) {
	    return e;
	  }
	}
	
	function handleForeignThenable(promise, thenable, then) {
	  asap(function (promise) {
	    var sealed = false;
	    var error = tryThen(then, thenable, function (value) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	      if (thenable !== value) {
	        _resolve(promise, value);
	      } else {
	        fulfill(promise, value);
	      }
	    }, function (reason) {
	      if (sealed) {
	        return;
	      }
	      sealed = true;
	
	      _reject(promise, reason);
	    }, 'Settle: ' + (promise._label || ' unknown promise'));
	
	    if (!sealed && error) {
	      sealed = true;
	      _reject(promise, error);
	    }
	  }, promise);
	}
	
	function handleOwnThenable(promise, thenable) {
	  if (thenable._state === FULFILLED) {
	    fulfill(promise, thenable._result);
	  } else if (thenable._state === REJECTED) {
	    _reject(promise, thenable._result);
	  } else {
	    subscribe(thenable, undefined, function (value) {
	      return _resolve(promise, value);
	    }, function (reason) {
	      return _reject(promise, reason);
	    });
	  }
	}
	
	function handleMaybeThenable(promise, maybeThenable, then$$) {
	  if (maybeThenable.constructor === promise.constructor && then$$ === then && maybeThenable.constructor.resolve === resolve) {
	    handleOwnThenable(promise, maybeThenable);
	  } else {
	    if (then$$ === GET_THEN_ERROR) {
	      _reject(promise, GET_THEN_ERROR.error);
	    } else if (then$$ === undefined) {
	      fulfill(promise, maybeThenable);
	    } else if (isFunction(then$$)) {
	      handleForeignThenable(promise, maybeThenable, then$$);
	    } else {
	      fulfill(promise, maybeThenable);
	    }
	  }
	}
	
	function _resolve(promise, value) {
	  if (promise === value) {
	    _reject(promise, selfFulfillment());
	  } else if (objectOrFunction(value)) {
	    handleMaybeThenable(promise, value, getThen(value));
	  } else {
	    fulfill(promise, value);
	  }
	}
	
	function publishRejection(promise) {
	  if (promise._onerror) {
	    promise._onerror(promise._result);
	  }
	
	  publish(promise);
	}
	
	function fulfill(promise, value) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	
	  promise._result = value;
	  promise._state = FULFILLED;
	
	  if (promise._subscribers.length !== 0) {
	    asap(publish, promise);
	  }
	}
	
	function _reject(promise, reason) {
	  if (promise._state !== PENDING) {
	    return;
	  }
	  promise._state = REJECTED;
	  promise._result = reason;
	
	  asap(publishRejection, promise);
	}
	
	function subscribe(parent, child, onFulfillment, onRejection) {
	  var _subscribers = parent._subscribers;
	  var length = _subscribers.length;
	
	  parent._onerror = null;
	
	  _subscribers[length] = child;
	  _subscribers[length + FULFILLED] = onFulfillment;
	  _subscribers[length + REJECTED] = onRejection;
	
	  if (length === 0 && parent._state) {
	    asap(publish, parent);
	  }
	}
	
	function publish(promise) {
	  var subscribers = promise._subscribers;
	  var settled = promise._state;
	
	  if (subscribers.length === 0) {
	    return;
	  }
	
	  var child = undefined,
	      callback = undefined,
	      detail = promise._result;
	
	  for (var i = 0; i < subscribers.length; i += 3) {
	    child = subscribers[i];
	    callback = subscribers[i + settled];
	
	    if (child) {
	      invokeCallback(settled, child, callback, detail);
	    } else {
	      callback(detail);
	    }
	  }
	
	  promise._subscribers.length = 0;
	}
	
	function ErrorObject() {
	  this.error = null;
	}
	
	var TRY_CATCH_ERROR = new ErrorObject();
	
	function tryCatch(callback, detail) {
	  try {
	    return callback(detail);
	  } catch (e) {
	    TRY_CATCH_ERROR.error = e;
	    return TRY_CATCH_ERROR;
	  }
	}
	
	function invokeCallback(settled, promise, callback, detail) {
	  var hasCallback = isFunction(callback),
	      value = undefined,
	      error = undefined,
	      succeeded = undefined,
	      failed = undefined;
	
	  if (hasCallback) {
	    value = tryCatch(callback, detail);
	
	    if (value === TRY_CATCH_ERROR) {
	      failed = true;
	      error = value.error;
	      value = null;
	    } else {
	      succeeded = true;
	    }
	
	    if (promise === value) {
	      _reject(promise, cannotReturnOwn());
	      return;
	    }
	  } else {
	    value = detail;
	    succeeded = true;
	  }
	
	  if (promise._state !== PENDING) {
	    // noop
	  } else if (hasCallback && succeeded) {
	      _resolve(promise, value);
	    } else if (failed) {
	      _reject(promise, error);
	    } else if (settled === FULFILLED) {
	      fulfill(promise, value);
	    } else if (settled === REJECTED) {
	      _reject(promise, value);
	    }
	}
	
	function initializePromise(promise, resolver) {
	  try {
	    resolver(function resolvePromise(value) {
	      _resolve(promise, value);
	    }, function rejectPromise(reason) {
	      _reject(promise, reason);
	    });
	  } catch (e) {
	    _reject(promise, e);
	  }
	}
	
	var id = 0;
	function nextId() {
	  return id++;
	}
	
	function makePromise(promise) {
	  promise[PROMISE_ID] = id++;
	  promise._state = undefined;
	  promise._result = undefined;
	  promise._subscribers = [];
	}
	
	function Enumerator(Constructor, input) {
	  this._instanceConstructor = Constructor;
	  this.promise = new Constructor(noop);
	
	  if (!this.promise[PROMISE_ID]) {
	    makePromise(this.promise);
	  }
	
	  if (isArray(input)) {
	    this._input = input;
	    this.length = input.length;
	    this._remaining = input.length;
	
	    this._result = new Array(this.length);
	
	    if (this.length === 0) {
	      fulfill(this.promise, this._result);
	    } else {
	      this.length = this.length || 0;
	      this._enumerate();
	      if (this._remaining === 0) {
	        fulfill(this.promise, this._result);
	      }
	    }
	  } else {
	    _reject(this.promise, validationError());
	  }
	}
	
	function validationError() {
	  return new Error('Array Methods must be provided an Array');
	};
	
	Enumerator.prototype._enumerate = function () {
	  var length = this.length;
	  var _input = this._input;
	
	  for (var i = 0; this._state === PENDING && i < length; i++) {
	    this._eachEntry(_input[i], i);
	  }
	};
	
	Enumerator.prototype._eachEntry = function (entry, i) {
	  var c = this._instanceConstructor;
	  var resolve$$ = c.resolve;
	
	  if (resolve$$ === resolve) {
	    var _then = getThen(entry);
	
	    if (_then === then && entry._state !== PENDING) {
	      this._settledAt(entry._state, i, entry._result);
	    } else if (typeof _then !== 'function') {
	      this._remaining--;
	      this._result[i] = entry;
	    } else if (c === Promise) {
	      var promise = new c(noop);
	      handleMaybeThenable(promise, entry, _then);
	      this._willSettleAt(promise, i);
	    } else {
	      this._willSettleAt(new c(function (resolve$$) {
	        return resolve$$(entry);
	      }), i);
	    }
	  } else {
	    this._willSettleAt(resolve$$(entry), i);
	  }
	};
	
	Enumerator.prototype._settledAt = function (state, i, value) {
	  var promise = this.promise;
	
	  if (promise._state === PENDING) {
	    this._remaining--;
	
	    if (state === REJECTED) {
	      _reject(promise, value);
	    } else {
	      this._result[i] = value;
	    }
	  }
	
	  if (this._remaining === 0) {
	    fulfill(promise, this._result);
	  }
	};
	
	Enumerator.prototype._willSettleAt = function (promise, i) {
	  var enumerator = this;
	
	  subscribe(promise, undefined, function (value) {
	    return enumerator._settledAt(FULFILLED, i, value);
	  }, function (reason) {
	    return enumerator._settledAt(REJECTED, i, reason);
	  });
	};
	
	/**
	  `Promise.all` accepts an array of promises, and returns a new promise which
	  is fulfilled with an array of fulfillment values for the passed promises, or
	  rejected with the reason of the first passed promise to be rejected. It casts all
	  elements of the passed iterable to promises as it runs this algorithm.
	
	  Example:
	
	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = resolve(2);
	  let promise3 = resolve(3);
	  let promises = [ promise1, promise2, promise3 ];
	
	  Promise.all(promises).then(function(array){
	    // The array here would be [ 1, 2, 3 ];
	  });
	  ```
	
	  If any of the `promises` given to `all` are rejected, the first promise
	  that is rejected will be given as an argument to the returned promises's
	  rejection handler. For example:
	
	  Example:
	
	  ```javascript
	  let promise1 = resolve(1);
	  let promise2 = reject(new Error("2"));
	  let promise3 = reject(new Error("3"));
	  let promises = [ promise1, promise2, promise3 ];
	
	  Promise.all(promises).then(function(array){
	    // Code here never runs because there are rejected promises!
	  }, function(error) {
	    // error.message === "2"
	  });
	  ```
	
	  @method all
	  @static
	  @param {Array} entries array of promises
	  @param {String} label optional string for labeling the promise.
	  Useful for tooling.
	  @return {Promise} promise that is fulfilled when all `promises` have been
	  fulfilled, or rejected if any of them become rejected.
	  @static
	*/
	function all(entries) {
	  return new Enumerator(this, entries).promise;
	}
	
	/**
	  `Promise.race` returns a new promise which is settled in the same way as the
	  first passed promise to settle.
	
	  Example:
	
	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });
	
	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 2');
	    }, 100);
	  });
	
	  Promise.race([promise1, promise2]).then(function(result){
	    // result === 'promise 2' because it was resolved before promise1
	    // was resolved.
	  });
	  ```
	
	  `Promise.race` is deterministic in that only the state of the first
	  settled promise matters. For example, even if other promises given to the
	  `promises` array argument are resolved, but the first settled promise has
	  become rejected before the other promises became fulfilled, the returned
	  promise will become rejected:
	
	  ```javascript
	  let promise1 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      resolve('promise 1');
	    }, 200);
	  });
	
	  let promise2 = new Promise(function(resolve, reject){
	    setTimeout(function(){
	      reject(new Error('promise 2'));
	    }, 100);
	  });
	
	  Promise.race([promise1, promise2]).then(function(result){
	    // Code here never runs
	  }, function(reason){
	    // reason.message === 'promise 2' because promise 2 became rejected before
	    // promise 1 became fulfilled
	  });
	  ```
	
	  An example real-world use case is implementing timeouts:
	
	  ```javascript
	  Promise.race([ajax('foo.json'), timeout(5000)])
	  ```
	
	  @method race
	  @static
	  @param {Array} promises array of promises to observe
	  Useful for tooling.
	  @return {Promise} a promise which settles in the same way as the first passed
	  promise to settle.
	*/
	function race(entries) {
	  /*jshint validthis:true */
	  var Constructor = this;
	
	  if (!isArray(entries)) {
	    return new Constructor(function (_, reject) {
	      return reject(new TypeError('You must pass an array to race.'));
	    });
	  } else {
	    return new Constructor(function (resolve, reject) {
	      var length = entries.length;
	      for (var i = 0; i < length; i++) {
	        Constructor.resolve(entries[i]).then(resolve, reject);
	      }
	    });
	  }
	}
	
	/**
	  `Promise.reject` returns a promise rejected with the passed `reason`.
	  It is shorthand for the following:
	
	  ```javascript
	  let promise = new Promise(function(resolve, reject){
	    reject(new Error('WHOOPS'));
	  });
	
	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```
	
	  Instead of writing the above, your code now simply becomes the following:
	
	  ```javascript
	  let promise = Promise.reject(new Error('WHOOPS'));
	
	  promise.then(function(value){
	    // Code here doesn't run because the promise is rejected!
	  }, function(reason){
	    // reason.message === 'WHOOPS'
	  });
	  ```
	
	  @method reject
	  @static
	  @param {Any} reason value that the returned promise will be rejected with.
	  Useful for tooling.
	  @return {Promise} a promise rejected with the given `reason`.
	*/
	function reject(reason) {
	  /*jshint validthis:true */
	  var Constructor = this;
	  var promise = new Constructor(noop);
	  _reject(promise, reason);
	  return promise;
	}
	
	function needsResolver() {
	  throw new TypeError('You must pass a resolver function as the first argument to the promise constructor');
	}
	
	function needsNew() {
	  throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
	}
	
	/**
	  Promise objects represent the eventual result of an asynchronous operation. The
	  primary way of interacting with a promise is through its `then` method, which
	  registers callbacks to receive either a promise's eventual value or the reason
	  why the promise cannot be fulfilled.
	
	  Terminology
	  -----------
	
	  - `promise` is an object or function with a `then` method whose behavior conforms to this specification.
	  - `thenable` is an object or function that defines a `then` method.
	  - `value` is any legal JavaScript value (including undefined, a thenable, or a promise).
	  - `exception` is a value that is thrown using the throw statement.
	  - `reason` is a value that indicates why a promise was rejected.
	  - `settled` the final resting state of a promise, fulfilled or rejected.
	
	  A promise can be in one of three states: pending, fulfilled, or rejected.
	
	  Promises that are fulfilled have a fulfillment value and are in the fulfilled
	  state.  Promises that are rejected have a rejection reason and are in the
	  rejected state.  A fulfillment value is never a thenable.
	
	  Promises can also be said to *resolve* a value.  If this value is also a
	  promise, then the original promise's settled state will match the value's
	  settled state.  So a promise that *resolves* a promise that rejects will
	  itself reject, and a promise that *resolves* a promise that fulfills will
	  itself fulfill.
	
	
	  Basic Usage:
	  ------------
	
	  ```js
	  let promise = new Promise(function(resolve, reject) {
	    // on success
	    resolve(value);
	
	    // on failure
	    reject(reason);
	  });
	
	  promise.then(function(value) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```
	
	  Advanced Usage:
	  ---------------
	
	  Promises shine when abstracting away asynchronous interactions such as
	  `XMLHttpRequest`s.
	
	  ```js
	  function getJSON(url) {
	    return new Promise(function(resolve, reject){
	      let xhr = new XMLHttpRequest();
	
	      xhr.open('GET', url);
	      xhr.onreadystatechange = handler;
	      xhr.responseType = 'json';
	      xhr.setRequestHeader('Accept', 'application/json');
	      xhr.send();
	
	      function handler() {
	        if (this.readyState === this.DONE) {
	          if (this.status === 200) {
	            resolve(this.response);
	          } else {
	            reject(new Error('getJSON: `' + url + '` failed with status: [' + this.status + ']'));
	          }
	        }
	      };
	    });
	  }
	
	  getJSON('/posts.json').then(function(json) {
	    // on fulfillment
	  }, function(reason) {
	    // on rejection
	  });
	  ```
	
	  Unlike callbacks, promises are great composable primitives.
	
	  ```js
	  Promise.all([
	    getJSON('/posts'),
	    getJSON('/comments')
	  ]).then(function(values){
	    values[0] // => postsJSON
	    values[1] // => commentsJSON
	
	    return values;
	  });
	  ```
	
	  @class Promise
	  @param {function} resolver
	  Useful for tooling.
	  @constructor
	*/
	function Promise(resolver) {
	  this[PROMISE_ID] = nextId();
	  this._result = this._state = undefined;
	  this._subscribers = [];
	
	  if (noop !== resolver) {
	    typeof resolver !== 'function' && needsResolver();
	    this instanceof Promise ? initializePromise(this, resolver) : needsNew();
	  }
	}
	
	Promise.all = all;
	Promise.race = race;
	Promise.resolve = resolve;
	Promise.reject = reject;
	Promise._setScheduler = setScheduler;
	Promise._setAsap = setAsap;
	Promise._asap = asap;
	
	Promise.prototype = {
	  constructor: Promise,
	
	  /**
	    The primary way of interacting with a promise is through its `then` method,
	    which registers callbacks to receive either a promise's eventual value or the
	    reason why the promise cannot be fulfilled.
	  
	    ```js
	    findUser().then(function(user){
	      // user is available
	    }, function(reason){
	      // user is unavailable, and you are given the reason why
	    });
	    ```
	  
	    Chaining
	    --------
	  
	    The return value of `then` is itself a promise.  This second, 'downstream'
	    promise is resolved with the return value of the first promise's fulfillment
	    or rejection handler, or rejected if the handler throws an exception.
	  
	    ```js
	    findUser().then(function (user) {
	      return user.name;
	    }, function (reason) {
	      return 'default name';
	    }).then(function (userName) {
	      // If `findUser` fulfilled, `userName` will be the user's name, otherwise it
	      // will be `'default name'`
	    });
	  
	    findUser().then(function (user) {
	      throw new Error('Found user, but still unhappy');
	    }, function (reason) {
	      throw new Error('`findUser` rejected and we're unhappy');
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // if `findUser` fulfilled, `reason` will be 'Found user, but still unhappy'.
	      // If `findUser` rejected, `reason` will be '`findUser` rejected and we're unhappy'.
	    });
	    ```
	    If the downstream promise does not specify a rejection handler, rejection reasons will be propagated further downstream.
	  
	    ```js
	    findUser().then(function (user) {
	      throw new PedagogicalException('Upstream error');
	    }).then(function (value) {
	      // never reached
	    }).then(function (value) {
	      // never reached
	    }, function (reason) {
	      // The `PedgagocialException` is propagated all the way down to here
	    });
	    ```
	  
	    Assimilation
	    ------------
	  
	    Sometimes the value you want to propagate to a downstream promise can only be
	    retrieved asynchronously. This can be achieved by returning a promise in the
	    fulfillment or rejection handler. The downstream promise will then be pending
	    until the returned promise is settled. This is called *assimilation*.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // The user's comments are now available
	    });
	    ```
	  
	    If the assimliated promise rejects, then the downstream promise will also reject.
	  
	    ```js
	    findUser().then(function (user) {
	      return findCommentsByAuthor(user);
	    }).then(function (comments) {
	      // If `findCommentsByAuthor` fulfills, we'll have the value here
	    }, function (reason) {
	      // If `findCommentsByAuthor` rejects, we'll have the reason here
	    });
	    ```
	  
	    Simple Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let result;
	  
	    try {
	      result = findResult();
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	    findResult(function(result, err){
	      if (err) {
	        // failure
	      } else {
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findResult().then(function(result){
	      // success
	    }, function(reason){
	      // failure
	    });
	    ```
	  
	    Advanced Example
	    --------------
	  
	    Synchronous Example
	  
	    ```javascript
	    let author, books;
	  
	    try {
	      author = findAuthor();
	      books  = findBooksByAuthor(author);
	      // success
	    } catch(reason) {
	      // failure
	    }
	    ```
	  
	    Errback Example
	  
	    ```js
	  
	    function foundBooks(books) {
	  
	    }
	  
	    function failure(reason) {
	  
	    }
	  
	    findAuthor(function(author, err){
	      if (err) {
	        failure(err);
	        // failure
	      } else {
	        try {
	          findBoooksByAuthor(author, function(books, err) {
	            if (err) {
	              failure(err);
	            } else {
	              try {
	                foundBooks(books);
	              } catch(reason) {
	                failure(reason);
	              }
	            }
	          });
	        } catch(error) {
	          failure(err);
	        }
	        // success
	      }
	    });
	    ```
	  
	    Promise Example;
	  
	    ```javascript
	    findAuthor().
	      then(findBooksByAuthor).
	      then(function(books){
	        // found books
	    }).catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method then
	    @param {Function} onFulfilled
	    @param {Function} onRejected
	    Useful for tooling.
	    @return {Promise}
	  */
	  then: then,
	
	  /**
	    `catch` is simply sugar for `then(undefined, onRejection)` which makes it the same
	    as the catch block of a try/catch statement.
	  
	    ```js
	    function findAuthor(){
	      throw new Error('couldn't find that author');
	    }
	  
	    // synchronous
	    try {
	      findAuthor();
	    } catch(reason) {
	      // something went wrong
	    }
	  
	    // async with promises
	    findAuthor().catch(function(reason){
	      // something went wrong
	    });
	    ```
	  
	    @method catch
	    @param {Function} onRejection
	    Useful for tooling.
	    @return {Promise}
	  */
	  'catch': function _catch(onRejection) {
	    return this.then(null, onRejection);
	  }
	};
	
	function polyfill() {
	    var local = undefined;
	
	    if (typeof global !== 'undefined') {
	        local = global;
	    } else if (typeof self !== 'undefined') {
	        local = self;
	    } else {
	        try {
	            local = Function('return this')();
	        } catch (e) {
	            throw new Error('polyfill failed because global object is unavailable in this environment');
	        }
	    }
	
	    var P = local.Promise;
	
	    if (P) {
	        var promiseToString = null;
	        try {
	            promiseToString = Object.prototype.toString.call(P.resolve());
	        } catch (e) {
	            // silently ignored
	        }
	
	        if (promiseToString === '[object Promise]' && !P.cast) {
	            return;
	        }
	    }
	
	    local.Promise = Promise;
	}
	
	// Strange compat..
	Promise.polyfill = polyfill;
	Promise.Promise = Promise;
	
	return Promise;
	
	})));
	//# sourceMappingURL=es6-promise.map
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(218), (function() { return this; }())))

/***/ },
/* 218 */
/***/ function(module, exports) {

	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
	    throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
	    throw new Error('clearTimeout has not been defined');
	}
	(function () {
	    try {
	        if (typeof setTimeout === 'function') {
	            cachedSetTimeout = setTimeout;
	        } else {
	            cachedSetTimeout = defaultSetTimout;
	        }
	    } catch (e) {
	        cachedSetTimeout = defaultSetTimout;
	    }
	    try {
	        if (typeof clearTimeout === 'function') {
	            cachedClearTimeout = clearTimeout;
	        } else {
	            cachedClearTimeout = defaultClearTimeout;
	        }
	    } catch (e) {
	        cachedClearTimeout = defaultClearTimeout;
	    }
	} ())
	function runTimeout(fun) {
	    if (cachedSetTimeout === setTimeout) {
	        //normal enviroments in sane situations
	        return setTimeout(fun, 0);
	    }
	    // if setTimeout wasn't available but was latter defined
	    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
	        cachedSetTimeout = setTimeout;
	        return setTimeout(fun, 0);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedSetTimeout(fun, 0);
	    } catch(e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
	            return cachedSetTimeout.call(null, fun, 0);
	        } catch(e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
	            return cachedSetTimeout.call(this, fun, 0);
	        }
	    }
	
	
	}
	function runClearTimeout(marker) {
	    if (cachedClearTimeout === clearTimeout) {
	        //normal enviroments in sane situations
	        return clearTimeout(marker);
	    }
	    // if clearTimeout wasn't available but was latter defined
	    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
	        cachedClearTimeout = clearTimeout;
	        return clearTimeout(marker);
	    }
	    try {
	        // when when somebody has screwed with setTimeout but no I.E. maddness
	        return cachedClearTimeout(marker);
	    } catch (e){
	        try {
	            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
	            return cachedClearTimeout.call(null, marker);
	        } catch (e){
	            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
	            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
	            return cachedClearTimeout.call(this, marker);
	        }
	    }
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
	    if (!draining || !currentQueue) {
	        return;
	    }
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}
	
	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = runTimeout(cleanUpNextTick);
	    draining = true;
	
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            if (currentQueue) {
	                currentQueue[queueIndex].run();
	            }
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        runTimeout(drainQueue);
	    }
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	
	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 219 */
/***/ function(module, exports) {

	/* (ignored) */

/***/ },
/* 220 */
/***/ function(module, exports) {

	(function(self) {
	  'use strict';
	
	  if (self.fetch) {
	    return
	  }
	
	  var support = {
	    searchParams: 'URLSearchParams' in self,
	    iterable: 'Symbol' in self && 'iterator' in Symbol,
	    blob: 'FileReader' in self && 'Blob' in self && (function() {
	      try {
	        new Blob()
	        return true
	      } catch(e) {
	        return false
	      }
	    })(),
	    formData: 'FormData' in self,
	    arrayBuffer: 'ArrayBuffer' in self
	  }
	
	  if (support.arrayBuffer) {
	    var viewClasses = [
	      '[object Int8Array]',
	      '[object Uint8Array]',
	      '[object Uint8ClampedArray]',
	      '[object Int16Array]',
	      '[object Uint16Array]',
	      '[object Int32Array]',
	      '[object Uint32Array]',
	      '[object Float32Array]',
	      '[object Float64Array]'
	    ]
	
	    var isDataView = function(obj) {
	      return obj && DataView.prototype.isPrototypeOf(obj)
	    }
	
	    var isArrayBufferView = ArrayBuffer.isView || function(obj) {
	      return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1
	    }
	  }
	
	  function normalizeName(name) {
	    if (typeof name !== 'string') {
	      name = String(name)
	    }
	    if (/[^a-z0-9\-#$%&'*+.\^_`|~]/i.test(name)) {
	      throw new TypeError('Invalid character in header field name')
	    }
	    return name.toLowerCase()
	  }
	
	  function normalizeValue(value) {
	    if (typeof value !== 'string') {
	      value = String(value)
	    }
	    return value
	  }
	
	  // Build a destructive iterator for the value list
	  function iteratorFor(items) {
	    var iterator = {
	      next: function() {
	        var value = items.shift()
	        return {done: value === undefined, value: value}
	      }
	    }
	
	    if (support.iterable) {
	      iterator[Symbol.iterator] = function() {
	        return iterator
	      }
	    }
	
	    return iterator
	  }
	
	  function Headers(headers) {
	    this.map = {}
	
	    if (headers instanceof Headers) {
	      headers.forEach(function(value, name) {
	        this.append(name, value)
	      }, this)
	
	    } else if (headers) {
	      Object.getOwnPropertyNames(headers).forEach(function(name) {
	        this.append(name, headers[name])
	      }, this)
	    }
	  }
	
	  Headers.prototype.append = function(name, value) {
	    name = normalizeName(name)
	    value = normalizeValue(value)
	    var oldValue = this.map[name]
	    this.map[name] = oldValue ? oldValue+','+value : value
	  }
	
	  Headers.prototype['delete'] = function(name) {
	    delete this.map[normalizeName(name)]
	  }
	
	  Headers.prototype.get = function(name) {
	    name = normalizeName(name)
	    return this.has(name) ? this.map[name] : null
	  }
	
	  Headers.prototype.has = function(name) {
	    return this.map.hasOwnProperty(normalizeName(name))
	  }
	
	  Headers.prototype.set = function(name, value) {
	    this.map[normalizeName(name)] = normalizeValue(value)
	  }
	
	  Headers.prototype.forEach = function(callback, thisArg) {
	    for (var name in this.map) {
	      if (this.map.hasOwnProperty(name)) {
	        callback.call(thisArg, this.map[name], name, this)
	      }
	    }
	  }
	
	  Headers.prototype.keys = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push(name) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.values = function() {
	    var items = []
	    this.forEach(function(value) { items.push(value) })
	    return iteratorFor(items)
	  }
	
	  Headers.prototype.entries = function() {
	    var items = []
	    this.forEach(function(value, name) { items.push([name, value]) })
	    return iteratorFor(items)
	  }
	
	  if (support.iterable) {
	    Headers.prototype[Symbol.iterator] = Headers.prototype.entries
	  }
	
	  function consumed(body) {
	    if (body.bodyUsed) {
	      return Promise.reject(new TypeError('Already read'))
	    }
	    body.bodyUsed = true
	  }
	
	  function fileReaderReady(reader) {
	    return new Promise(function(resolve, reject) {
	      reader.onload = function() {
	        resolve(reader.result)
	      }
	      reader.onerror = function() {
	        reject(reader.error)
	      }
	    })
	  }
	
	  function readBlobAsArrayBuffer(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsArrayBuffer(blob)
	    return promise
	  }
	
	  function readBlobAsText(blob) {
	    var reader = new FileReader()
	    var promise = fileReaderReady(reader)
	    reader.readAsText(blob)
	    return promise
	  }
	
	  function readArrayBufferAsText(buf) {
	    var view = new Uint8Array(buf)
	    var chars = new Array(view.length)
	
	    for (var i = 0; i < view.length; i++) {
	      chars[i] = String.fromCharCode(view[i])
	    }
	    return chars.join('')
	  }
	
	  function bufferClone(buf) {
	    if (buf.slice) {
	      return buf.slice(0)
	    } else {
	      var view = new Uint8Array(buf.byteLength)
	      view.set(new Uint8Array(buf))
	      return view.buffer
	    }
	  }
	
	  function Body() {
	    this.bodyUsed = false
	
	    this._initBody = function(body) {
	      this._bodyInit = body
	      if (!body) {
	        this._bodyText = ''
	      } else if (typeof body === 'string') {
	        this._bodyText = body
	      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
	        this._bodyBlob = body
	      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
	        this._bodyFormData = body
	      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	        this._bodyText = body.toString()
	      } else if (support.arrayBuffer && support.blob && isDataView(body)) {
	        this._bodyArrayBuffer = bufferClone(body.buffer)
	        // IE 10-11 can't handle a DataView body.
	        this._bodyInit = new Blob([this._bodyArrayBuffer])
	      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
	        this._bodyArrayBuffer = bufferClone(body)
	      } else {
	        throw new Error('unsupported BodyInit type')
	      }
	
	      if (!this.headers.get('content-type')) {
	        if (typeof body === 'string') {
	          this.headers.set('content-type', 'text/plain;charset=UTF-8')
	        } else if (this._bodyBlob && this._bodyBlob.type) {
	          this.headers.set('content-type', this._bodyBlob.type)
	        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
	          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8')
	        }
	      }
	    }
	
	    if (support.blob) {
	      this.blob = function() {
	        var rejected = consumed(this)
	        if (rejected) {
	          return rejected
	        }
	
	        if (this._bodyBlob) {
	          return Promise.resolve(this._bodyBlob)
	        } else if (this._bodyArrayBuffer) {
	          return Promise.resolve(new Blob([this._bodyArrayBuffer]))
	        } else if (this._bodyFormData) {
	          throw new Error('could not read FormData body as blob')
	        } else {
	          return Promise.resolve(new Blob([this._bodyText]))
	        }
	      }
	
	      this.arrayBuffer = function() {
	        if (this._bodyArrayBuffer) {
	          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)
	        } else {
	          return this.blob().then(readBlobAsArrayBuffer)
	        }
	      }
	    }
	
	    this.text = function() {
	      var rejected = consumed(this)
	      if (rejected) {
	        return rejected
	      }
	
	      if (this._bodyBlob) {
	        return readBlobAsText(this._bodyBlob)
	      } else if (this._bodyArrayBuffer) {
	        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))
	      } else if (this._bodyFormData) {
	        throw new Error('could not read FormData body as text')
	      } else {
	        return Promise.resolve(this._bodyText)
	      }
	    }
	
	    if (support.formData) {
	      this.formData = function() {
	        return this.text().then(decode)
	      }
	    }
	
	    this.json = function() {
	      return this.text().then(JSON.parse)
	    }
	
	    return this
	  }
	
	  // HTTP methods whose capitalization should be normalized
	  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT']
	
	  function normalizeMethod(method) {
	    var upcased = method.toUpperCase()
	    return (methods.indexOf(upcased) > -1) ? upcased : method
	  }
	
	  function Request(input, options) {
	    options = options || {}
	    var body = options.body
	
	    if (input instanceof Request) {
	      if (input.bodyUsed) {
	        throw new TypeError('Already read')
	      }
	      this.url = input.url
	      this.credentials = input.credentials
	      if (!options.headers) {
	        this.headers = new Headers(input.headers)
	      }
	      this.method = input.method
	      this.mode = input.mode
	      if (!body && input._bodyInit != null) {
	        body = input._bodyInit
	        input.bodyUsed = true
	      }
	    } else {
	      this.url = String(input)
	    }
	
	    this.credentials = options.credentials || this.credentials || 'omit'
	    if (options.headers || !this.headers) {
	      this.headers = new Headers(options.headers)
	    }
	    this.method = normalizeMethod(options.method || this.method || 'GET')
	    this.mode = options.mode || this.mode || null
	    this.referrer = null
	
	    if ((this.method === 'GET' || this.method === 'HEAD') && body) {
	      throw new TypeError('Body not allowed for GET or HEAD requests')
	    }
	    this._initBody(body)
	  }
	
	  Request.prototype.clone = function() {
	    return new Request(this, { body: this._bodyInit })
	  }
	
	  function decode(body) {
	    var form = new FormData()
	    body.trim().split('&').forEach(function(bytes) {
	      if (bytes) {
	        var split = bytes.split('=')
	        var name = split.shift().replace(/\+/g, ' ')
	        var value = split.join('=').replace(/\+/g, ' ')
	        form.append(decodeURIComponent(name), decodeURIComponent(value))
	      }
	    })
	    return form
	  }
	
	  function parseHeaders(rawHeaders) {
	    var headers = new Headers()
	    rawHeaders.split(/\r?\n/).forEach(function(line) {
	      var parts = line.split(':')
	      var key = parts.shift().trim()
	      if (key) {
	        var value = parts.join(':').trim()
	        headers.append(key, value)
	      }
	    })
	    return headers
	  }
	
	  Body.call(Request.prototype)
	
	  function Response(bodyInit, options) {
	    if (!options) {
	      options = {}
	    }
	
	    this.type = 'default'
	    this.status = 'status' in options ? options.status : 200
	    this.ok = this.status >= 200 && this.status < 300
	    this.statusText = 'statusText' in options ? options.statusText : 'OK'
	    this.headers = new Headers(options.headers)
	    this.url = options.url || ''
	    this._initBody(bodyInit)
	  }
	
	  Body.call(Response.prototype)
	
	  Response.prototype.clone = function() {
	    return new Response(this._bodyInit, {
	      status: this.status,
	      statusText: this.statusText,
	      headers: new Headers(this.headers),
	      url: this.url
	    })
	  }
	
	  Response.error = function() {
	    var response = new Response(null, {status: 0, statusText: ''})
	    response.type = 'error'
	    return response
	  }
	
	  var redirectStatuses = [301, 302, 303, 307, 308]
	
	  Response.redirect = function(url, status) {
	    if (redirectStatuses.indexOf(status) === -1) {
	      throw new RangeError('Invalid status code')
	    }
	
	    return new Response(null, {status: status, headers: {location: url}})
	  }
	
	  self.Headers = Headers
	  self.Request = Request
	  self.Response = Response
	
	  self.fetch = function(input, init) {
	    return new Promise(function(resolve, reject) {
	      var request = new Request(input, init)
	      var xhr = new XMLHttpRequest()
	
	      xhr.onload = function() {
	        var options = {
	          status: xhr.status,
	          statusText: xhr.statusText,
	          headers: parseHeaders(xhr.getAllResponseHeaders() || '')
	        }
	        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL')
	        var body = 'response' in xhr ? xhr.response : xhr.responseText
	        resolve(new Response(body, options))
	      }
	
	      xhr.onerror = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.ontimeout = function() {
	        reject(new TypeError('Network request failed'))
	      }
	
	      xhr.open(request.method, request.url, true)
	
	      if (request.credentials === 'include') {
	        xhr.withCredentials = true
	      }
	
	      if ('responseType' in xhr && support.blob) {
	        xhr.responseType = 'blob'
	      }
	
	      request.headers.forEach(function(value, name) {
	        xhr.setRequestHeader(name, value)
	      })
	
	      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit)
	    })
	  }
	  self.fetch.polyfill = true
	})(typeof self !== 'undefined' ? self : this);


/***/ },
/* 221 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {
	var NativeCustomEvent = global.CustomEvent;
	
	function useNative () {
	  try {
	    var p = new NativeCustomEvent('cat', { detail: { foo: 'bar' } });
	    return  'cat' === p.type && 'bar' === p.detail.foo;
	  } catch (e) {
	  }
	  return false;
	}
	
	/**
	 * Cross-browser `CustomEvent` constructor.
	 *
	 * https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent.CustomEvent
	 *
	 * @public
	 */
	
	module.exports = useNative() ? NativeCustomEvent :
	
	// IE >= 9
	'undefined' !== typeof document && 'function' === typeof document.createEvent ? function CustomEvent (type, params) {
	  var e = document.createEvent('CustomEvent');
	  if (params) {
	    e.initCustomEvent(type, params.bubbles, params.cancelable, params.detail);
	  } else {
	    e.initCustomEvent(type, false, false, void 0);
	  }
	  return e;
	} :
	
	// IE <= 8
	function CustomEvent (type, params) {
	  var e = document.createEventObject();
	  e.type = type;
	  if (params) {
	    e.bubbles = Boolean(params.bubbles);
	    e.cancelable = Boolean(params.cancelable);
	    e.detail = params.detail;
	  } else {
	    e.bubbles = false;
	    e.cancelable = false;
	    e.detail = void 0;
	  }
	  return e;
	}
	
	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	exports.viewer = undefined;
	
	var _ApiGlobe = __webpack_require__(223);
	
	var _ApiGlobe2 = _interopRequireDefault(_ApiGlobe);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// browser execution or not ?
	var scope = typeof window !== 'undefined' ? window : {}; /*
	                                                          * To change this license header, choose License Headers in Project Properties.
	                                                          * To change this template file, choose Tools | Templates
	                                                          * and open the template in the editor.
	                                                          */
	
	var itowns = scope.itowns || {
	  viewer: new _ApiGlobe2.default()
	};
	scope.itowns = itowns;
	var viewer = exports.viewer = itowns.viewer;
	exports.default = scope.itowns;

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _promise = __webpack_require__(224);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _customEvent = __webpack_require__(221);
	
	var _customEvent2 = _interopRequireDefault(_customEvent);
	
	var _Scene = __webpack_require__(239);
	
	var _Scene2 = _interopRequireDefault(_Scene);
	
	var _Globe = __webpack_require__(300);
	
	var _Globe2 = _interopRequireDefault(_Globe);
	
	var _WMTS_Provider = __webpack_require__(368);
	
	var _WMTS_Provider2 = _interopRequireDefault(_WMTS_Provider);
	
	var _WMS_Provider = __webpack_require__(336);
	
	var _WMS_Provider2 = _interopRequireDefault(_WMS_Provider);
	
	var _TileProvider = __webpack_require__(372);
	
	var _TileProvider2 = _interopRequireDefault(_TileProvider);
	
	var _GpxUtils = __webpack_require__(376);
	
	var _GpxUtils2 = _interopRequireDefault(_GpxUtils);
	
	var _Coordinates = __webpack_require__(289);
	
	var _Projection = __webpack_require__(302);
	
	var _Projection2 = _interopRequireDefault(_Projection);
	
	var _Fetcher = __webpack_require__(340);
	
	var _Fetcher2 = _interopRequireDefault(_Fetcher);
	
	var _LayerUpdateStrategy = __webpack_require__(346);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var sceneIsLoaded = false; /**
	                            * Generated On: 2015-10-5
	                            * Class: ApiGlobe
	                            * Description: Classe façade pour attaquer les fonctionnalités du code.
	                            */
	
	var eventLoaded = new _customEvent2.default('globe-loaded');
	var eventRange = new _customEvent2.default('rangeChanged', {
	    detail: {
	        oldRange: undefined
	    }
	});
	var eventCenter = new _customEvent2.default('centerchanged', {
	    detail: {
	        oldCenter: {
	            longitude: undefined,
	            latitude: undefined
	        },
	        newCenter: {
	            longitude: undefined,
	            latitude: undefined
	        }
	    }
	});
	var eventOrientation = new _customEvent2.default('orientationchanged', {
	    detail: {
	        oldOrientation: {
	            tilt: undefined,
	            heading: undefined
	        },
	        newOrientation: {
	            tilt: undefined,
	            heading: undefined
	        }
	    }
	});
	var eventPan = new _customEvent2.default('panchanged');
	var eventLayerAdded = new _customEvent2.default('layeradded', {
	    detail: {
	        layerId: undefined
	    }
	});
	var eventLayerRemoved = new _customEvent2.default('layerremoved', {
	    detail: {
	        layerId: undefined
	    }
	});
	var eventLayerChanged = new _customEvent2.default('layerchanged', {
	    detail: {
	        layerId: undefined,
	        visibility: {
	            oldVisibility: undefined,
	            newVisibility: undefined
	        },
	        opacity: {
	            oldOpacity: undefined,
	            newOpacity: undefined
	        },
	        index: {
	            oldIndex: undefined,
	            newIndex: undefined
	        }
	    }
	});
	var eventLayerChangedVisible = new _customEvent2.default('layerchanged:visible', {
	    detail: {
	        layerId: undefined,
	        oldVisibility: undefined,
	        newVisibility: undefined
	    }
	});
	var eventLayerChangedOpacity = new _customEvent2.default('layerchanged:opacity', {
	    detail: {
	        layerId: undefined,
	        oldOpacity: undefined,
	        newOpacity: undefined
	    }
	});
	var eventLayerChangedIndex = new _customEvent2.default('layerchanged:index', {
	    detail: {
	        layerId: undefined,
	        oldIndex: undefined,
	        newIndex: undefined
	    }
	});
	var eventError = new _customEvent2.default('error');
	var eventZoom = new _customEvent2.default('zoomchanged', {
	    detail: {
	        oldZoom: undefined,
	        newZoom: undefined
	    }
	});
	
	/* eslint-disable no-console */
	var logStep = function logStep(step) {
	    console.log('----------------------------------------');
	    console.log('               Test ', step);
	    console.log('----------------------------------------');
	};
	
	var enableAnimation = false;
	
	var defer = function defer() {
	    var deferedPromise = {};
	    deferedPromise.promise = new _promise2.default(function (resolve, reject) {
	        deferedPromise.resolve = resolve;
	        deferedPromise.reject = reject;
	    });
	    return deferedPromise;
	};
	
	function ApiGlobe() {
	    // Constructor
	    this.scene = null;
	    this.commandsTree = null;
	    this.projection = new _Projection2.default();
	    this.viewerDiv = null;
	    this.callback = null;
	}
	
	ApiGlobe.prototype.constructor = ApiGlobe;
	
	/**
	 * @param Command
	 */
	ApiGlobe.prototype.add = function add() /* Command*/{
	    // TODO: Implement Me
	
	};
	
	/**
	 * @param commandTemplate
	 */
	ApiGlobe.prototype.createCommand = function createCommand() /* commandTemplate*/{
	    // TODO: Implement Me
	
	};
	
	/**
	 */
	ApiGlobe.prototype.execute = function execute() {
	    // TODO: Implement Me
	
	};
	
	ApiGlobe.prototype.getProtocolProvider = function getProtocolProvider(protocol) {
	    return this.scene.scheduler.getProtocolProvider(protocol);
	};
	
	/**
	 * This function gives a chance to the matching provider to pre-process some
	 * values for a layer.
	 */
	function preprocessLayer(layer, provider) {
	    if (!layer.updateStrategy) {
	        layer.updateStrategy = {
	            type: _LayerUpdateStrategy.STRATEGY_MIN_NETWORK_TRAFFIC
	        };
	    }
	
	    if (provider.tileInsideLimit) {
	        layer.tileInsideLimit = provider.tileInsideLimit.bind(provider);
	    }
	
	    if (provider.tileTextureCount) {
	        layer.tileTextureCount = provider.tileTextureCount.bind(provider);
	    }
	
	    if (provider.preprocessDataLayer) {
	        provider.preprocessDataLayer(layer);
	    }
	}
	
	/**
	 * Init the geometry layer of the Scene.
	 */
	ApiGlobe.prototype.init = function init() {
	    var map = this.scene.getMap();
	    map.tiles.init(map.layersConfiguration.getGeometryLayers()[0], map.layersConfiguration.lightingLayers[0]);
	};
	
	/**
	 * Add the geometry layer to the scene.
	 */
	ApiGlobe.prototype.addGeometryLayer = function addGeometryLayer(layer) {
	    preprocessLayer(layer, this.scene.scheduler.getProtocolProvider(layer.protocol));
	    var map = this.scene.getMap();
	    map.layersConfiguration.addGeometryLayer(layer);
	};
	
	/**
	 * This function adds an imagery layer to the scene. The layer id must be unique. The protocol rules wich parameters are then needed for the function.
	 * @constructor
	 * @param {Layer} layer.
	 */
	ApiGlobe.prototype.addImageryLayer = function addImageryLayer(layer) {
	    preprocessLayer(layer, this.scene.scheduler.getProtocolProvider(layer.protocol));
	
	    var map = this.scene.getMap();
	
	    map.layersConfiguration.addColorLayer(layer);
	    eventLayerAdded.detail.layerId = layer.id;
	    this.viewerDiv.dispatchEvent(eventLayerAdded);
	};
	
	/**
	 * This function adds an imagery layer to the scene using a JSON file. The layer id must be unique. The protocol rules wich parameters are then needed for the function.
	 * @constructor
	 * @param {Layer} layer.
	 * @return     {layer}  The Layer.
	 */
	
	ApiGlobe.prototype.addImageryLayerFromJSON = function addImageryLayerFromJSON(url) {
	    var _this = this;
	
	    return _Fetcher2.default.json(url).then(function (result) {
	        _this.addImageryLayer(result);
	    });
	};
	
	/**
	 * This function adds an imagery layer to the scene using an array of JSON files. The layer id must be unique. The protocol rules wich parameters are then needed for the function.
	 * @constructor
	 * @param {Layers} array - An array of JSON files.
	 * @return     {layer}  The Layers.
	 */
	
	ApiGlobe.prototype.addImageryLayersFromJSONArray = function addImageryLayersFromJSONArray(urls) {
	    var _this2 = this;
	
	    var proms = [];
	
	    for (var i = 0; i < urls.length; i++) {
	        proms.push(_Fetcher2.default.json(urls[i]).then(this.addImageryLayer.bind(this)));
	    }
	
	    return _promise2.default.all(proms).then(function () {
	        return _this2.scene.getMap().layersConfiguration.getColorLayers();
	    });
	};
	
	ApiGlobe.prototype.moveLayerUp = function moveLayerUp(layerId) {
	    this.scene.getMap().layersConfiguration.moveLayerUp(layerId);
	    this.scene.getMap().updateLayersOrdering();
	    this.scene.renderScene3D();
	};
	
	ApiGlobe.prototype.moveLayerDown = function moveLayerDown(layerId) {
	    this.scene.getMap().layersConfiguration.moveLayerDown(layerId);
	    this.scene.getMap().updateLayersOrdering();
	    this.scene.renderScene3D();
	};
	
	/**
	 * Moves a specific layer to a specific index in the layer list. This function has no effect if the layer is moved to its current index.
	 * @constructor
	 * @param      {string}  layerId   The layer's idendifiant
	 * @param      {number}  newIndex   The new index
	 */
	ApiGlobe.prototype.moveLayerToIndex = function moveLayerToIndex(layerId, newIndex) {
	    eventLayerChanged.detail.visibility.oldVisibility = this.scene.getMap().layersConfiguration.isColorLayerVisible(layerId);
	    eventLayerChanged.detail.visibility.newVisibility = this.scene.getMap().layersConfiguration.isColorLayerVisible(layerId);
	    eventLayerChanged.detail.opacity.oldOpacity = this.scene.getMap().layersConfiguration.getColorLayerOpacity(layerId);
	    eventLayerChanged.detail.opacity.newOpacity = this.scene.getMap().layersConfiguration.getColorLayerOpacity(layerId);
	    eventLayerChanged.detail.layerId = layerId;
	    eventLayerChanged.detail.index.oldIndex = this.scene.getMap().layersConfiguration.layersState[layerId].sequence;
	    eventLayerChanged.detail.index.newIndex = newIndex;
	    eventLayerChanged.detail.layerId = layerId;
	    eventLayerChangedIndex.detail.layerId = layerId;
	    eventLayerChangedIndex.detail.oldIndex = this.scene.getMap().layersConfiguration.layersState[layerId].sequence;
	    eventLayerChangedIndex.detail.newIndex = newIndex;
	    this.scene.getMap().layersConfiguration.moveLayerToIndex(layerId, newIndex);
	    this.scene.getMap().updateLayersOrdering();
	    this.scene.renderScene3D();
	    this.viewerDiv.dispatchEvent(eventLayerChangedIndex);
	};
	
	/**
	 * Removes a specific imagery layer from the current layer list. This removes layers inserted with addLayer().
	 * @constructor
	 * @param      {string}   id      The identifier
	 * @return     {boolean}  { description_of_the_return_value }
	 */
	ApiGlobe.prototype.removeImageryLayer = function removeImageryLayer(id) {
	    if (this.scene.getMap().layersConfiguration.removeColorLayer(id)) {
	        this.scene.getMap().removeColorLayer(id);
	        this.scene.renderScene3D();
	        eventLayerRemoved.detail.layerId = id;
	        this.viewerDiv.dispatchEvent(eventLayerRemoved);
	        return true;
	    }
	
	    return false;
	};
	
	/**
	 * Add an elevation layer to the map. Elevations layers are used to build the terrain.
	 * Only one elevation layer is used, so if multiple layers cover the same area, the one
	 * with best resolution is used (or the first one is resolution are identical).
	 * The layer id must be unique amongst all layers already inserted.
	 * The protocol rules which parameters are then needed for the function.
	 * @constructor
	 * @param {Layer} layer.
	 */
	
	ApiGlobe.prototype.addElevationLayer = function addElevationLayer(layer) {
	    preprocessLayer(layer, this.scene.scheduler.getProtocolProvider(layer.protocol));
	
	    var map = this.scene.getMap();
	    map.layersConfiguration.addElevationLayer(layer);
	    eventLayerAdded.detail.layerId = layer.id;
	    this.viewerDiv.dispatchEvent(eventLayerAdded);
	};
	
	/**
	 * Add an elevation layer to the map using a JSON file.
	 * Elevations layers are used to build the terrain.
	 * Only one elevation layer is used, so if multiple layers cover the same area, the one
	 * with best resolution is used (or the first one is resolution are identical).
	 * The layer id must be unique amongst all layers already inserted.
	 * The protocol rules which parameters are then needed for the function.
	 * @constructor
	 * @param {Layers} array - An array of JSON files.
	* @return     {layer}  The Layers.
	 */
	
	ApiGlobe.prototype.addElevationLayersFromJSON = function addElevationLayersFromJSON(url) {
	    var _this3 = this;
	
	    return _Fetcher2.default.json(url).then(function (result) {
	        _this3.addElevationLayer(result);
	    });
	};
	
	/**
	 * Add an elevation layer to the map using an array of JSON files.
	 * Elevations layers are used to build the terrain.
	 * Only one elevation layer is used, so if multiple layers cover the same area, the one
	 * with best resolution is used (or the first one is resolution are identical).
	 * The layer id must be unique amongst all layers already inserted.
	 * The protocol rules which parameters are then needed for the function.
	 * @constructor
	 * @param {Layer} layer.
	 * @return     {layer}  The Layers.
	 */
	
	ApiGlobe.prototype.addElevationLayersFromJSONArray = function addElevationLayersFromJSONArray(urls) {
	    var _this4 = this;
	
	    var proms = [];
	
	    for (var i = 0; i < urls.length; i++) {
	        proms.push(_Fetcher2.default.json(urls[i]).then(this.addElevationLayer.bind(this)));
	    }
	
	    return _promise2.default.all(proms).then(function () {
	        return _this4.scene.getMap().layersConfiguration.getElevationLayers();
	    });
	};
	
	/**
	 * Gets the minimum zoom level of the chosen layer.
	 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/66r8ugq0/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
	 * @constructor
	 * @param {index} index - The index of the layer.
	 * @return     {number}  The min of the level.
	 */
	ApiGlobe.prototype.getMinZoomLevel = function getMinZoomLevel(index) {
	    var layer = this.getImageryLayers()[index];
	    if (layer && layer.zoom) {
	        return layer.zoom.min;
	    } else {
	        var layers = this.getImageryLayers();
	        var min = Infinity;
	        for (var i = layers.length - 1; i >= 0; i--) {
	            if (layers[i].zoom) {
	                min = Math.min(min, layers[i].zoom.min);
	            }
	        }
	        return min;
	    }
	};
	
	/**
	 * Gets the maximun zoom level of the chosen layer.
	 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/y1xcqv4s/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
	 * @constructor
	 * @param {index} index - The index of the layer.
	 * @return     {number}  The max of the level.
	 */
	ApiGlobe.prototype.getMaxZoomLevel = function getMaxZoomLevel(index) {
	    var layer = this.getImageryLayers()[index];
	    if (layer && layer.zoom) {
	        return layer.zoom.max;
	    } else {
	        var layers = this.getImageryLayers();
	        var max = 0;
	        for (var i = layers.length - 1; i >= 0; i--) {
	            if (layers[i].zoom) {
	                max = Math.max(max, layers[i].zoom.max);
	            }
	        }
	        return max;
	    }
	};
	
	/**
	 * Return the list of all layers in the scene in the order of how they are stacked on top of each other.
	 * @constructor
	 * @return     {layer}  The Layers.
	 */
	ApiGlobe.prototype.getImageryLayers = function getImageryLayers() {
	    var map = this.scene.getMap();
	    return map.layersConfiguration.getColorLayers();
	};
	
	/**
	 * Creates the scene (the globe of iTowns).
	 * The first parameter is the coordinates on wich the globe will be centered at the initialization.
	 * The second one is the HTML div in wich the scene will be created.
	 * @constructor
	 * @param {Coords} coords.
	 * @params {Div} string.
	 */
	
	ApiGlobe.prototype.createSceneGlobe = function createSceneGlobe(coordCarto, viewerDiv) {
	    var _this5 = this;
	
	    // TODO: Normalement la creation de scene ne doit pas etre ici....
	    // Deplacer plus tard
	
	    this.viewerDiv = viewerDiv;
	
	    viewerDiv.addEventListener('globe-built', function () {
	        if (sceneIsLoaded === false) {
	            sceneIsLoaded = true;
	            _this5.scene.currentControls().updateCameraTransformation();
	            _this5.scene.updateScene3D();
	            viewerDiv.dispatchEvent(eventLoaded);
	        } else {
	            viewerDiv.dispatchEvent(eventError);
	        }
	    }, false);
	
	    var gLDebug = false; // true to support GLInspector addon
	    var debugMode = false;
	
	    var coordinate = new _Coordinates.C.EPSG_4326(coordCarto.longitude, coordCarto.latitude, coordCarto.altitude);
	
	    this.scene = (0, _Scene2.default)(coordinate, viewerDiv, debugMode, gLDebug);
	
	    var map = new _Globe2.default(gLDebug);
	
	    this.scene.add(map);
	
	    // Register all providers
	    var wmtsProvider = new _WMTS_Provider2.default({
	        support: map.gLDebug
	    });
	
	    this.scene.scheduler.addProtocolProvider('wmts', wmtsProvider);
	    this.scene.scheduler.addProtocolProvider('wmtsc', wmtsProvider);
	    this.scene.scheduler.addProtocolProvider('tile', new _TileProvider2.default());
	    this.scene.scheduler.addProtocolProvider('wms', new _WMS_Provider2.default({ support: map.gLDebug }));
	
	    this.sceneLoadedDeferred = defer();
	    this.addEventListener('globe-loaded', function () {
	        _this5.sceneLoadedDeferred.resolve();
	        _this5.sceneLoadedDeferred = defer();
	    });
	
	    return this.scene;
	};
	
	ApiGlobe.prototype.update = function update() {
	    this.scene.notifyChange(0, true);
	};
	
	ApiGlobe.prototype.showClouds = function showClouds(value, satelliteAnimation) {
	    this.scene.getMap().showClouds(value, satelliteAnimation);
	    this.scene.renderScene3D();
	};
	
	ApiGlobe.prototype.setRealisticLightingOn = function setRealisticLightingOn(value) {
	    this.scene.setLightingPos();
	    this.scene.getMap().setRealisticLightingOn(value);
	    var lightingLayers = this.scene.getMap().layersConfiguration.lightingLayers[0];
	    lightingLayers.enable = value;
	    lightingLayers.position = this.scene.lightingPos;
	    this.scene.browserScene.updateMaterialUniform('lightingEnabled', value);
	    this.scene.renderScene3D();
	};
	
	/**
	 * Sets the visibility of a layer. If the layer is not visible in the scene, this function will no effect until the camera looks at the layer.
	 * @constructor
	 * @param {id} string.
	 * @params {visible} boolean.
	 */
	
	ApiGlobe.prototype.setLayerVisibility = function setLayerVisibility(id, visible) {
	    eventLayerChanged.detail.index.oldIndex = this.scene.getMap().layersConfiguration.layersState[id].sequence;
	    eventLayerChanged.detail.index.newIndex = this.scene.getMap().layersConfiguration.layersState[id].sequence;
	    eventLayerChanged.detail.opacity.oldOpacity = this.scene.getMap().layersConfiguration.getColorLayerOpacity(id);
	    eventLayerChanged.detail.opacity.newOpacity = this.scene.getMap().layersConfiguration.getColorLayerOpacity(id);
	    eventLayerChanged.detail.visibility.oldVisibility = !visible;
	    eventLayerChanged.detail.visibility.newVisibility = visible;
	    eventLayerChanged.detail.layerId = id;
	    eventLayerChangedVisible.detail.layerId = id;
	    eventLayerChangedVisible.detail.oldVisibility = !visible;
	    eventLayerChangedVisible.detail.newVisibility = visible;
	    this.scene.getMap().setLayerVisibility(id, visible);
	    this.update();
	    this.viewerDiv.dispatchEvent(eventLayerChangedVisible);
	};
	
	ApiGlobe.prototype.animateTime = function animateTime(value) {
	    this.scene.animateTime(value);
	};
	
	ApiGlobe.prototype.orbit = function orbit(value) {
	    this.scene.orbit(value);
	};
	
	/**
	 * Sets the opacity of a layer. If the layer is not visible in the scene, this function will no effect until the layer becomes visible.
	 * @constructor
	 * @param {id} string.
	 * @params {visible} boolean.
	 */
	
	ApiGlobe.prototype.setLayerOpacity = function setLayerOpacity(id, opacity) {
	    eventLayerChanged.detail.index.oldIndex = this.scene.getMap().layersConfiguration.layersState[id].sequence;
	    eventLayerChanged.detail.index.newIndex = this.scene.getMap().layersConfiguration.layersState[id].sequence;
	    eventLayerChanged.detail.visibility.oldVisibility = this.scene.getMap().layersConfiguration.isColorLayerVisible(id);
	    eventLayerChanged.detail.visibility.newVisibility = this.scene.getMap().layersConfiguration.isColorLayerVisible(id);
	    eventLayerChanged.detail.opacity.oldOpacity = this.scene.getMap().layersConfiguration.getColorLayerOpacity(id);
	    eventLayerChanged.detail.opacity.newOpacity = opacity;
	    eventLayerChanged.detail.layerId = id;
	    eventLayerChangedOpacity.detail.layerId = id;
	    eventLayerChangedOpacity.detail.oldOpacity = this.scene.getMap().layersConfiguration.getColorLayerOpacity(id);
	    eventLayerChangedOpacity.detail.newOpacity = opacity;
	    this.scene.getMap().setLayerOpacity(id, opacity);
	    this.scene.renderScene3D();
	    this.viewerDiv.dispatchEvent(eventLayerChangedOpacity);
	};
	
	ApiGlobe.prototype.setStreetLevelImageryOn = function setStreetLevelImageryOn(value) {
	    this.scene.setStreetLevelImageryOn(value);
	};
	
	/**
	 * Returns the orientation angles of the current camera, in degrees.
	 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/okfj460p/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
	 * @constructor
	 */
	ApiGlobe.prototype.getCameraOrientation = function getCameraOrientation() {
	    var tiltCam = this.scene.currentControls().getTilt();
	    var headingCam = this.scene.currentControls().getHeading();
	    return [tiltCam, headingCam];
	};
	
	/**
	 * Returns the camera location projected on the ground in lat,lon.
	 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/mjv7ha02/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
	 * @constructor
	 * @return {Position} position
	 */
	
	ApiGlobe.prototype.getCameraLocation = function getCameraLocation() {
	    var cam = this.scene.currentCamera().camera3D;
	    return this.projection.cartesianToGeo(cam.position);
	};
	
	/**
	 * Retuns the coordinates of the central point on screen.
	 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/4tjgnv7z/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
	 * @constructor
	 * @return {Position} position
	 */
	
	ApiGlobe.prototype.getCenter = function getCenter() {
	    var controlCam = this.scene.currentControls();
	    return this.projection.cartesianToGeo(controlCam.getTargetCameraPosition());
	};
	
	/**
	 * Sets orientation angles of the current camera, in degrees.
	 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/9qr2mogh/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
	 * @constructor
	 * @param      {object}   orientation  The angle of the rotation in degrees
	 * @param      {boolean}  isAnimated   Indicates if animated
	 * @return     {Promise}   { description_of_the_return_value }
	 */
	ApiGlobe.prototype.setCameraOrientation = function setCameraOrientation(orientation, isAnimated) {
	    var _this6 = this;
	
	    eventOrientation.detail.oldOrientation.tilt = this.getCameraOrientation()[0] * 180 / Math.PI;
	    eventOrientation.detail.oldOrientation.heading = this.getCameraOrientation()[1] * 180 / Math.PI;
	    return this.scene.currentControls().setOrbitalPosition(undefined, orientation.heading, orientation.tilt, isAnimated).then(function () {
	        eventOrientation.detail.newOrientation.tilt = _this6.getCameraOrientation()[0] * 180 / Math.PI;
	        eventOrientation.detail.newOrientation.heading = _this6.getCameraOrientation()[1] * 180 / Math.PI;
	        _this6.viewerDiv.dispatchEvent(eventOrientation);
	    });
	};
	
	/**
	 * Pick a position on the globe at the given position.
	 * @constructor
	 * @param {Number | MouseEvent} x|event - The x-position inside the Globe element or a mouse event.
	 * @param {number | undefined} y - The y-position inside the Globe element.
	 * @return {Position} position
	 */
	ApiGlobe.prototype.pickPosition = function pickPosition(mouse, y) {
	    var coords = {
	        x: mouse.clientX || mouse,
	        y: mouse.clientY || y
	    };
	
	    var pickedPosition = this.scene.getPickPosition(coords);
	
	    this.scene.renderScene3D();
	
	    if (!pickedPosition) {
	        return;
	    }
	
	    return this.projection.cartesianToGeo(pickedPosition);
	};
	
	/**
	 * Returns the tilt in degrees.
	 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/kcx0of9j/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
	 * @constructor
	 * @return {Angle} number - The angle of the rotation in degrees.
	 */
	
	ApiGlobe.prototype.getTilt = function getTilt() {
	    var tiltCam = this.scene.currentControls().getTilt();
	    return tiltCam;
	};
	
	/**
	 * Returns the heading in degrees.
	 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/pxv1Lw16/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
	 * @constructor
	 * @return {Angle} number - The angle of the rotation in degrees.
	 */
	
	ApiGlobe.prototype.getHeading = function getHeading() {
	    var headingCam = this.scene.currentControls().getHeading();
	    return headingCam;
	};
	
	/**
	 * Returns the "range": the distance in meters between the camera and the current central point on the screen.
	 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/Lbt1vfek/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
	 * @constructor
	 * @return {Number} number
	 */
	
	ApiGlobe.prototype.getRange = function getRange() {
	    return this.scene.currentControls().getRange();
	};
	
	ApiGlobe.prototype.getRangeFromEllipsoid = function getRangeFromEllipsoid() {
	    // TODO: error is distance is big with ellipsoid.intersection(ray) because d < 0
	    var controlCam = this.scene.currentControls();
	    var ellipsoid = this.scene.getEllipsoid();
	    var ray = controlCam.getRay();
	    var intersection = ellipsoid.intersection(ray);
	    var camPosition = this.scene.currentCamera().position();
	    var range = intersection.distanceTo(camPosition);
	
	    return range;
	};
	
	/**
	 * Sets the animation enabled.
	 * @constructor
	 * @param      {boolean}  enable  The enable
	 */
	ApiGlobe.prototype.setAnimationEnabled = function setAnimationEnabled(enable) {
	    enableAnimation = enable;
	};
	
	/**
	 * Determines if animation enabled.
	 *
	 * @return     {boolean}  True if animation enabled, False otherwise.
	 */
	ApiGlobe.prototype.isAnimationEnabled = function isAnimationEnabled() {
	    return enableAnimation;
	};
	
	/**
	 * Change the tilt.
	 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/p6t76zox/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
	 * @constructor
	 * @param {Angle} Number - The angle.
	 * @param      {boolean}  isAnimated  Indicates if animated
	 * @return     {Promise}
	 */
	ApiGlobe.prototype.setTilt = function setTilt(tilt, isAnimated) {
	    var _this7 = this;
	
	    isAnimated = isAnimated || this.isAnimationEnabled();
	    eventOrientation.detail.oldOrientation.tilt = this.getTilt();
	    eventOrientation.detail.oldOrientation.heading = this.getHeading();
	    return this.scene.currentControls().setTilt(tilt, isAnimated).then(function () {
	        eventOrientation.detail.newOrientation.tilt = _this7.getCameraOrientation()[0];
	        eventOrientation.detail.newOrientation.heading = _this7.getCameraOrientation()[1];
	        _this7.viewerDiv.dispatchEvent(eventOrientation);
	        _this7.scene.notifyChange(1);
	    });
	};
	
	/**
	 * Change the heading.
	 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/rxe4xgxj/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
	 * @constructor
	 * @param {Angle} Number - The angle.
	 * @param      {boolean}  isAnimated  Indicates if animated
	 * @return     {Promise}
	 */
	ApiGlobe.prototype.setHeading = function setHeading(heading, isAnimated) {
	    var _this8 = this;
	
	    isAnimated = isAnimated || this.isAnimationEnabled();
	    eventOrientation.detail.oldOrientation.tilt = this.getTilt();
	    eventOrientation.detail.oldOrientation.heading = this.getHeading();
	    return this.scene.currentControls().setHeading(heading, isAnimated).then(function () {
	        eventOrientation.detail.newOrientation.tilt = _this8.getCameraOrientation()[0];
	        eventOrientation.detail.newOrientation.heading = _this8.getCameraOrientation()[1];
	        _this8.viewerDiv.dispatchEvent(eventOrientation);
	        _this8.scene.notifyChange(1);
	    });
	};
	
	/**
	 * Resets camera tilt -> sets the tilt to 0°.
	 * @constructor
	 * @param      {boolean}  isAnimated  Indicates if animated
	 * @return     {Promise}
	 */
	ApiGlobe.prototype.resetTilt = function resetTilt(isAnimated) {
	    isAnimated = isAnimated || this.isAnimationEnabled();
	    return this.scene.currentControls().setTilt(0, isAnimated);
	};
	
	/**
	 * Resets camera heading -> sets the heading to 0°.
	 * @constructor
	 * @param      {boolean}  isAnimated  Indicates if animated
	 * @return     {Promise}
	 */
	ApiGlobe.prototype.resetHeading = function resetHeading(isAnimated) {
	    isAnimated = isAnimated || this.isAnimationEnabled();
	    return this.scene.currentControls().setHeading(0, isAnimated);
	};
	
	/**
	 * Returns the distance in meter between two geographic positions.
	 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/0nLhws5u/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
	 * @constructor
	 * @param {Position} First - Position.
	 * @param {Position} Second - Position.
	 * @return {Number} distance
	 */
	
	ApiGlobe.prototype.computeDistance = function computeDistance(p1, p2) {
	    return this.scene.getEllipsoid().computeDistance(new _Coordinates.C.EPSG_4326(p1.lon, p1.lat, p1.alt), new _Coordinates.C.EPSG_4326(p2.lon, p2.lat, p2.alt));
	};
	
	ApiGlobe.prototype.setSceneLoaded = function setSceneLoaded() {
	    sceneIsLoaded = false;
	    return this.sceneLoadedDeferred.promise;
	};
	
	/**
	 * Changes the center of the scene on screen to the specified coordinates.
	 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/x06yhbq6/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
	 * @constructor
	 * @param {coordinates} coordinates - Properties : longitude and latitude
	 * @param      {boolean}  isAnimated  Indicates if animated
	 * @return     {Promise}
	 */
	ApiGlobe.prototype.setCenter = function setCenter(coordinates, isAnimated) {
	    var _this9 = this;
	
	    isAnimated = isAnimated || this.isAnimationEnabled();
	    eventCenter.detail.oldCenter.longitude = this.getCenter()._values[0] * 180 / Math.Pi;
	    eventCenter.detail.oldCenter.latitude = this.getCenter()._values[1] * 180 / Math.Pi;
	    var position3D = new _Coordinates.C.EPSG_4326(coordinates.longitude, coordinates.latitude, 0).as('EPSG:4978').xyz();
	    position3D.range = coordinates.range;
	    return this.scene.currentControls().setCenter(position3D, isAnimated).then(function () {
	        _this9.scene.notifyChange(1);
	        return _this9.setSceneLoaded().then(function () {
	            _this9.scene.currentControls().updateCameraTransformation();
	            eventCenter.detail.newCenter.longitude = _this9.getCenter()._values[0] * 180 / Math.Pi;
	            eventCenter.detail.newCenter.latitude = _this9.getCenter()._values[1] * 180 / Math.Pi;
	            _this9.viewerDiv.dispatchEvent(eventCenter);
	        });
	    });
	};
	
	/**
	 * Changes the center of the scene on screen to the specified coordinates.
	 * This function allows to change the central position, the zoom level, the range, the scale and the camera orientation at the same time.
	 * The level has to be between the [getMinZoomLevel(), getMaxZoomLevel()].
	 * The zoom level and the scale can't be set at the same time.
	 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/7yk0mpn0/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
	 * @constructor
	 * @param {Position} pPosition - The detailed position in the scene.
	 * @param      {boolean}  isAnimated  Indicates if animated
	 * @return     {Promise}
	 */
	ApiGlobe.prototype.setCenterAdvanced = function setCenterAdvanced(pPosition, isAnimated) {
	    var _this10 = this;
	
	    isAnimated = isAnimated || this.isAnimationEnabled();
	    return this.setCenter(pPosition, isAnimated).then(function () {
	        var p = _this10.scene.currentControls().setOrbitalPosition(undefined, pPosition.heading, pPosition.tilt, isAnimated);
	        return p;
	    });
	};
	
	/**
	 * Sets the "range": the distance in meters between the camera and the current central point on the screen.
	 * <iframe width="100%" height="400" src="//jsfiddle.net/iTownsIGN/Lt3jL5pd/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>
	 * @constructor
	 * @param {Number} pRange - The camera altitude.
	 * @param      {boolean}  isAnimated  Indicates if animated
	 * @return     {Promise}
	 */
	ApiGlobe.prototype.setRange = function setRange(pRange, isAnimated) {
	    var _this11 = this;
	
	    isAnimated = isAnimated || this.isAnimationEnabled();
	    eventRange.detail.oldRange = this.getRange();
	
	    return this.scene.currentControls().setRange(pRange, isAnimated).then(function () {
	        _this11.scene.notifyChange(1);
	        _this11.setSceneLoaded().then(function () {
	            _this11.scene.currentControls().updateCameraTransformation();
	            _this11.viewerDiv.dispatchEvent(eventRange);
	            eventZoom.detail.newZoom = _this11.getZoomLevel();
	        });
	    });
	};
	
	/**
	 * Displaces the central point to a specific amount of pixels from its current position.
	 * The view flies to the desired coordinate, i.e.is not teleported instantly. Note : The results can be strange in some cases, if ever possible, when e.g.the camera looks horizontally or if the displaced center would not pick the ground once displaced.
	 * @constructor
	 * @param      {vector}  pVector  The vector
	 */
	ApiGlobe.prototype.pan = function pan(pVector) {
	    var _this12 = this;
	
	    this.scene.currentControls().pan(pVector.x, pVector.y);
	    this.scene.notifyChange(1);
	    this.setSceneLoaded().then(function () {
	        _this12.scene.currentControls().updateCameraTransformation();
	        _this12.viewerDiv.dispatchEvent(eventPan);
	    });
	};
	
	/**
	 * Returns the actual zoom level. The level will always be between the [getMinZoomLevel(), getMaxZoomLevel()].
	 * @constructor
	 * @return     {number}  The zoom level.
	 */
	ApiGlobe.prototype.getZoomLevel = function getZoomLevel() {
	    return this.scene.getMap().getZoomLevel();
	};
	
	/**
	 * Gets the current zoom level, which is an index in the logical scales predefined for the application.
	 * The higher the level, the closer to the ground.
	 * The level is always in the [getMinZoomLevel(), getMaxZoomLevel()] range.
	 * @constructor
	 * @param      {number}  zoom    The zoom
	 * @param      {boolean}  isAnimated  Indicates if animated
	 * @return     {Promise}
	 */
	ApiGlobe.prototype.setZoomLevel = function setZoomLevel(zoom, isAnimated) {
	    eventZoom.detail.oldZoom = this.getZoomLevel();
	    zoom = Math.max(this.getMinZoomLevel(), zoom);
	    zoom = Math.min(this.getMaxZoomLevel(), zoom);
	    var distance = this.scene.getMap().computeDistanceForZoomLevel(zoom, this.scene.currentCamera());
	    this.viewerDiv.dispatchEvent(eventZoom);
	    return this.setRange(distance, isAnimated);
	};
	
	/**
	 * Return the current zoom scale at the central point of the view.
	 * This function compute the scale of a map
	 * @constructor
	 * @param      {number}  pitch   Screen pitch, in millimeters ; 0.28 by default
	 * @return     {number}  The zoom scale.
	 */
	ApiGlobe.prototype.getZoomScale = function getZoomScale(pitch) {
	    // TODO: Why error div size height in Chrome?
	    // Screen pitch, in millimeters
	    pitch = (pitch || 0.28) / 1000;
	
	    // To compute scale, we must to calculate the maximum vertical distance (in meter) perceived by the camera
	    // the maximum vertical distance 2xHS (look at the explanations below 'HS segment')
	    // There's two state
	    //     * Globe is inside the frustrum camera
	    //     * Globe intersects with the frustrum camera
	    var camera = this.scene.currentCamera();
	    var center = this.scene.currentControls().getTargetCameraPosition();
	    var rayon = center.length();
	    var range = center.distanceTo(camera.camera3D.position);
	    // compute distance camera/globe's center
	    var distance = rayon + range;
	    // Three points C,G and S
	    // C : Camera's position
	    // G : Globe's center
	    // S : The furthest interesection[camera verical frustrum, globe surface] from line CG
	    // HS is triangle CSG's altitude going through S and H is in GC segment
	    // alpha is angle GCS
	    // phi is angle CSG
	    var alpha = camera.FOV / 180 * Math.PI * 0.5;
	    var phi = Math.PI - Math.asin(distance / rayon * Math.sin(alpha));
	    // projection is projection segment HS on camera
	    var projection = void 0;
	
	    if (isNaN(phi)) {
	        // Globe is inside the frustrum camera
	        projection = distance * 2 * Math.tan(alpha);
	    } else {
	        // Globe intersects with the frustrum camera
	
	        // develop operation
	        // {
	        //     var beta = Math.PI - ( phi + alpha);
	        //     projection = rayon * Math.sin(beta) * 2.0;
	        // }
	        // factorisation ->
	        projection = 2.0 * rayon * Math.sin(phi + alpha);
	    }
	
	    var zoomScale = camera.height * pitch / projection;
	
	    return zoomScale;
	};
	
	/**
	 * Changes the zoom level of the central point of screen so that screen acts as a map with a specified scale.
	 *  The view flies to the desired zoom scale;
	 * @constructor
	 * @param      {number}  zoomScale  The zoom scale
	 * @param      {number}  pitch      The pitch
	 * @param      {boolean}  isAnimated  Indicates if animated
	 * @return     {Promise}
	 */
	ApiGlobe.prototype.setZoomScale = function setZoomScale(zoomScale, pitch, isAnimated) {
	    // Screen pitch, in millimeters
	    pitch = (pitch || 0.28) / 1000;
	
	    // To set scale, we must to calculate the maximum vertical distance (in meter) perceived by the camera
	    // the maximum vertical distance 2xHS (look at the explanations below 'HS segment')
	    // projection is projection segment HS on camera
	    // There's two state
	    //     * Globe is inside the frustrum camera
	    //     * Globe intersects with the frustrum camera
	
	    var camera = this.scene.currentCamera();
	    var projection = camera.height * pitch / zoomScale;
	    var rayon = this.scene.currentControls().getTargetCameraPosition().length();
	    var alpha = camera.FOV / 180 * Math.PI * 0.5;
	    // distance camera/globe's center
	    var distance = void 0;
	    // Three points C,G and S
	    // C camera's position
	    // G globe's center
	    // S = the furthest interesection[camera verical frustrum, globe surface] from line CG
	    // HS is triangle CSG's altitude going through S and H is in GC segment
	    // alpha is angle GCS
	    // phi is angle CSG
	    // beta is angle SGC
	    var sinBeta = projection / (2 * rayon);
	
	    if (sinBeta < 1.0) {
	        // Globe is inside the frustrum camera
	        var beta = Math.asin(sinBeta);
	        // develop operation
	        //  {
	        //      let phi = Math.PI - ( beta + alpha);
	        //      distance  = rayon * Math.sin(phi) / Math.sin(alpha) ;
	        //  }
	        //  factorisation ->
	        distance = rayon * Math.sin(beta + alpha) / Math.sin(alpha);
	    } else {
	        // Globe is inside the frustrum camera
	        distance = rayon / Math.tan(alpha) * sinBeta;
	    }
	
	    var range = distance - rayon;
	    return this.setRange(range, isAnimated);
	};
	
	/**
	 * Some event return the old value before the change. The available events are centerchanged, zoomchanged, orientationchanged, layerchanged:opacity, layerchanged:visible, layerchanged:ipr and layerchanged:index.
	 * @constructor
	 * @param {string} Eventname - The name of the event.
	 * @param {callback} Callback - The callback that is called when the event is heard.
	 */
	
	ApiGlobe.prototype.addEventListener = function addEventListenerProto(eventname, callback) {
	    if (eventname == 'layerchanged') {
	        this.viewerDiv.addEventListener('layerchanged', callback, false);
	        this.addEventListenerLayerChanged();
	    } else if (eventname == 'centerchanged') {
	        this.viewerDiv.addEventListener('centerchanged', callback, false);
	        this.addEventListenerCenterChanged();
	    } else if (eventname == 'zoomchanged') {
	        this.viewerDiv.addEventListener('zoomchanged', callback, false);
	        this.addEventListenerZoomChanged();
	    } else if (eventname == 'orientationchanged') {
	        this.viewerDiv.addEventListener('orientationchanged', callback, false);
	        this.addEventListenerOrientationChanged();
	    } else {
	        this.viewerDiv.addEventListener(eventname, callback, false);
	    }
	};
	
	ApiGlobe.prototype.testEvents = function testEvents(eventname, param) {
	    var _this13 = this;
	
	    var event = false;
	    if (eventname == 'zoomchanged') {
	        var callback = function callback() {
	            event = true;
	            logStep('NEW ZOOM LEVEL : ' + _this13.getZoomLevel());
	            logStep('\'' + eventname + '\' : ' + event);
	            event = false;
	        };
	        this.addEventListener(eventname, callback);
	        this.setZoomLevel(param.level);
	        this.removeEventListener(eventname, callback);
	    } else if (eventname == 'orientationchanged') {
	        var _callback = function _callback() {
	            event = true;
	            logStep('NEW ORIENTATION : tilt : ' + _this13.getTilt() + ', heading : ' + _this13.getHeading());
	            logStep('\'' + eventname + '\' : ' + event);
	            event = false;
	        };
	        this.addEventListener(eventname, _callback);
	        this.setTilt(param.tilt);
	        this.removeEventListener(eventname, _callback);
	    } else if (eventname == 'centerchanged') {
	        var _callback2 = function _callback2() {
	            event = true;
	            logStep('NEW CENTER : longitude : ' + _this13.getCenter()._values[1] * 180 / Math.PI + ', latitude : ' + _this13.getCenter()._values[0] * 180 / Math.PI);
	            logStep('\'' + eventname + '\' : ' + event);
	            event = false;
	        };
	        this.addEventListener(eventname, _callback2);
	        this.setCenter({ longitude: param.longitude, latitude: param.latitude });
	        this.removeEventListener(eventname, _callback2);
	    } else if (eventname == 'layerchanged:index' || eventname == 'layerchanged') {
	        var _callback3 = function _callback3() {
	            event = true;
	            logStep('LAYER INDEX CHANGED');
	            logStep('\'' + eventname + '\' : ' + event);
	            event = false;
	        };
	        this.addEventListener(eventname, _callback3);
	        this.moveLayerToIndex(param.layerId, param.index);
	        this.removeEventListener(eventname, _callback3);
	    } else if (eventname == 'layerchanged:visible' || eventname == 'layerchanged') {
	        var _callback4 = function _callback4() {
	            event = true;
	            logStep('LAYER VISIBILITY CHANGED');
	            logStep('\'' + eventname + '\' : ' + event);
	            event = false;
	        };
	        this.addEventListener(eventname, _callback4);
	        this.setLayerVisibility(param.layerId, param.visibility);
	        this.removeEventListener(eventname, _callback4);
	    } else if (eventname == 'layerchanged:opacity' || eventname == 'layerchanged') {
	        var _callback5 = function _callback5() {
	            event = true;
	            logStep('LAYER OPACITY CHANGED');
	            logStep('\'' + eventname + '\' : ' + event);
	            event = false;
	        };
	        this.addEventListener(eventname, _callback5);
	        this.setLayerOpacity(param.layerId, param.opacity);
	        this.removeEventListener(eventname, _callback5);
	    } else if (eventname == 'layeradded') {
	        var _callback6 = function _callback6() {
	            event = true;
	            logStep('LAYER ADDED');
	            logStep('\'' + eventname + '\' : ' + event);
	            event = false;
	        };
	        this.addEventListener(eventname, _callback6);
	        this.addImageryLayerFromJSON('examples/layers/JSONLayers/Ortho.json');
	        this.removeEventListener(eventname, _callback6);
	    } else if (eventname == 'animationstarted') {
	        var _callback7 = function _callback7() {
	            event = true;
	            logStep('ANIMATION STARTED');
	            logStep('\'' + eventname + '\' : ' + event);
	            event = false;
	        };
	        this.addEventListener(eventname, _callback7);
	        this.setCenter({ longitude: param.longitude, latitude: param.latitude }, param.isAnimated);
	        this.removeEventListener(eventname, _callback7);
	    } else if (eventname == 'animationstopped') {
	        var _callback8 = function _callback8() {
	            event = true;
	            logStep('ANIMATION STOPPED');
	            logStep('\'' + eventname + '\' : ' + event);
	            event = false;
	        };
	        this.addEventListener(eventname, _callback8);
	        this.setCenter({ longitude: param.longitude, latitude: param.latitude }, param.isAnimated);
	        this.removeEventListener(eventname, _callback8);
	    } else {
	        logStep('Event \'' + eventname + '\' : ' + event);
	    }
	};
	
	/* ApiGlobe.prototype.test_addEventListener = function addEventListener(eventname, callback, param) {
	    /* eslint-disable no-console */
	/* const nameTest = `addEventListener : ${eventname}`;
	logStep(nameTest);
	 // let resultTest = true;
	 const test = (eventname, callback, param) => this.setTilt(param.level).then(() => {
	    this.addEventListener(eventname, callback);
	    console.log('ZOOM CHANGED');
	});
	 logStep('ZOOM EVENT');
	test(eventname, callback, param);
	};*/
	
	ApiGlobe.prototype.addEventListenerLayerChanged = function addEventListenerLayerChanged() {
	    this.viewerDiv.addEventListener('layerchanged:visible', this.callbackLayerChanged, false);
	    this.viewerDiv.addEventListener('layerchanged:opacity', this.callbackLayerChanged, false);
	    this.viewerDiv.addEventListener('layerchanged:index', this.callbackLayerChanged, false);
	};
	
	ApiGlobe.prototype.callbackLayerChanged = function callbackLayerChanged() {
	    this.dispatchEvent(eventLayerChanged);
	};
	
	ApiGlobe.prototype.addEventListenerCenterChanged = function addEventListenerCenterChanged() {
	    var _this14 = this;
	
	    eventCenter.detail.newCenter.longitude = this.getCenter()._values[0] * 180 / Math.PI;
	    eventCenter.detail.newCenter.latitude = this.getCenter()._values[1] * 180 / Math.PI;
	    this.viewerDiv.addEventListener('centercontrolchanged', function () {
	        eventCenter.detail.oldCenter.longitude = eventCenter.detail.newCenter.longitude * 180 / Math.PI;
	        eventCenter.detail.oldCenter.latitude = eventCenter.detail.newCenter.latitude * 180 / Math.PI;
	        eventCenter.detail.newCenter.longitude = _this14.getCenter()._values[0] * 180 / Math.PI;
	        eventCenter.detail.newCenter.latitude = _this14.getCenter()._values[1] * 180 / Math.PI;
	        _this14.callbackCenterChanged();
	    }, false);
	};
	
	ApiGlobe.prototype.callbackCenterChanged = function callbackCenterChanged() {
	    this.viewerDiv.dispatchEvent(eventCenter);
	};
	
	ApiGlobe.prototype.addEventListenerZoomChanged = function addEventListenerZoomChanged() {
	    var _this15 = this;
	
	    eventZoom.detail.newZoom = this.getZoomLevel();
	    this.viewerDiv.addEventListener('zoomcontrolchanged', function () {
	        eventZoom.detail.oldZoom = eventZoom.detail.newZoom;
	        eventZoom.detail.newZoom = _this15.getZoomLevel();
	        _this15.callbackZoomChanged();
	    }, false);
	};
	
	ApiGlobe.prototype.callbackZoomChanged = function callbackZoomChanged() {
	    this.viewerDiv.dispatchEvent(eventZoom);
	};
	
	ApiGlobe.prototype.addEventListenerOrientationChanged = function addEventListenerOrientationChanged() {
	    var _this16 = this;
	
	    eventOrientation.detail.newOrientation.tilt = this.getTilt();
	    eventOrientation.detail.newOrientation.heading = this.getHeading();
	    this.viewerDiv.addEventListener('orientationcontrolchanged', function () {
	        eventOrientation.detail.oldOrientation.tilt = eventOrientation.detail.newOrientation.tilt;
	        eventOrientation.detail.oldOrientation.heading = eventOrientation.detail.newOrientation.heading;
	        eventOrientation.detail.newOrientation.tilt = _this16.getTilt();
	        eventOrientation.detail.newOrientation.heading = _this16.getHeading();
	        _this16.callbackOrientationChanged();
	    }, false);
	};
	
	ApiGlobe.prototype.callbackOrientationChanged = function callbackOrientationChanged() {
	    this.viewerDiv.dispatchEvent(eventOrientation);
	};
	
	/**
	 * Remove the event of events listener from the event target.
	 * @constructor
	 * @param {string} Eventname - The name of the event.
	 * @param {callback} Callback - The callback that is called when the event is heard.
	 */
	
	ApiGlobe.prototype.removeEventListener = function removeEventListenerProto(eventname, callback) {
	    if (eventname == 'layerchanged') {
	        this.viewerDiv.removeEventListener('layerchanged', callback, false);
	        this.removeEventListenerLayerChanged();
	    } else if (eventname == 'centerchanged') {
	        this.viewerDiv.removeEventListener('centerchanged', callback, false);
	        this.removeEventListenerCenterChanged();
	    } else if (eventname == 'zoomchanged') {
	        this.viewerDiv.removeEventListener('zoomchanged', callback, false);
	        this.removeEventListenerZoomChanged();
	    } else if (eventname == 'orientationchanged') {
	        this.viewerDiv.removeEventListener('orientationchanged', callback, false);
	        this.removeEventListenerOrientationChanged();
	    } else {
	        this.viewerDiv.removeEventListener(eventname, callback, false);
	    }
	};
	
	ApiGlobe.prototype.removeEventListenerLayerChanged = function removeEventListenerLayerChanged() {
	    this.viewerDiv.removeEventListener('layerchanged:visible', this.callbackLayerChanged, false);
	    this.viewerDiv.removeEventListener('layerchanged:opacity', this.callbackLayerChanged, false);
	    this.viewerDiv.removeEventListener('layerchanged:index', this.callbackLayerChanged, false);
	};
	
	ApiGlobe.prototype.removeEventListenerCenterChanged = function addEventListenerCenterChanged() {
	    this.viewerDiv.removeEventListener('centercontrolchanged', this.callbackCenterChanged, false);
	};
	ApiGlobe.prototype.removeEventListenerZoomChanged = function addEventListenerZoomChanged() {
	    this.viewerDiv.removeEventListener('zoomcontrolchanged', this.callbackZoomChanged, false);
	};
	ApiGlobe.prototype.removeEventListenerOrientationChanged = function addEventListenerOrientationChanged() {
	    this.viewerDiv.removeEventListener('orientationcontrolchanged', this.callbackOrientationChanged, false);
	};
	
	ApiGlobe.prototype.selectNodeById = function selectNodeById(id) {
	    this.scene.selectNodeId(id);
	    this.scene.update();
	    this.scene.renderScene3D();
	};
	
	ApiGlobe.prototype.showKML = function showKML(value) {
	    this.scene.getMap().showKML(value);
	    this.scene.renderScene3D();
	};
	
	ApiGlobe.prototype.loadGPX = function loadGPX(url) {
	    var _this17 = this;
	
	    (0, _GpxUtils2.default)(url).then(function (gpx) {
	        if (gpx) {
	            _this17.scene.getMap().gpxTracks.children[0].add(gpx);
	        }
	    });
	
	    this.scene.renderScene3D();
	};
	
	exports.default = ApiGlobe;

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(225), __esModule: true };

/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(226);
	__webpack_require__(54);
	__webpack_require__(30);
	__webpack_require__(227);
	module.exports = __webpack_require__(15).Promise;

/***/ },
/* 226 */
/***/ function(module, exports) {



/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var LIBRARY            = __webpack_require__(39)
	  , global             = __webpack_require__(11)
	  , ctx                = __webpack_require__(16)
	  , classof            = __webpack_require__(58)
	  , $export            = __webpack_require__(14)
	  , isObject           = __webpack_require__(21)
	  , aFunction          = __webpack_require__(17)
	  , anInstance         = __webpack_require__(228)
	  , forOf              = __webpack_require__(229)
	  , speciesConstructor = __webpack_require__(232)
	  , task               = __webpack_require__(233).set
	  , microtask          = __webpack_require__(235)()
	  , PROMISE            = 'Promise'
	  , TypeError          = global.TypeError
	  , process            = global.process
	  , $Promise           = global[PROMISE]
	  , process            = global.process
	  , isNode             = classof(process) == 'process'
	  , empty              = function(){ /* empty */ }
	  , Internal, GenericPromiseCapability, Wrapper;
	
	var USE_NATIVE = !!function(){
	  try {
	    // correct subclassing with @@species support
	    var promise     = $Promise.resolve(1)
	      , FakePromise = (promise.constructor = {})[__webpack_require__(53)('species')] = function(exec){ exec(empty, empty); };
	    // unhandled rejections tracking support, NodeJS Promise without it fails @@species test
	    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise;
	  } catch(e){ /* empty */ }
	}();
	
	// helpers
	var sameConstructor = function(a, b){
	  // with library wrapper special case
	  return a === b || a === $Promise && b === Wrapper;
	};
	var isThenable = function(it){
	  var then;
	  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
	};
	var newPromiseCapability = function(C){
	  return sameConstructor($Promise, C)
	    ? new PromiseCapability(C)
	    : new GenericPromiseCapability(C);
	};
	var PromiseCapability = GenericPromiseCapability = function(C){
	  var resolve, reject;
	  this.promise = new C(function($$resolve, $$reject){
	    if(resolve !== undefined || reject !== undefined)throw TypeError('Bad Promise constructor');
	    resolve = $$resolve;
	    reject  = $$reject;
	  });
	  this.resolve = aFunction(resolve);
	  this.reject  = aFunction(reject);
	};
	var perform = function(exec){
	  try {
	    exec();
	  } catch(e){
	    return {error: e};
	  }
	};
	var notify = function(promise, isReject){
	  if(promise._n)return;
	  promise._n = true;
	  var chain = promise._c;
	  microtask(function(){
	    var value = promise._v
	      , ok    = promise._s == 1
	      , i     = 0;
	    var run = function(reaction){
	      var handler = ok ? reaction.ok : reaction.fail
	        , resolve = reaction.resolve
	        , reject  = reaction.reject
	        , domain  = reaction.domain
	        , result, then;
	      try {
	        if(handler){
	          if(!ok){
	            if(promise._h == 2)onHandleUnhandled(promise);
	            promise._h = 1;
	          }
	          if(handler === true)result = value;
	          else {
	            if(domain)domain.enter();
	            result = handler(value);
	            if(domain)domain.exit();
	          }
	          if(result === reaction.promise){
	            reject(TypeError('Promise-chain cycle'));
	          } else if(then = isThenable(result)){
	            then.call(result, resolve, reject);
	          } else resolve(result);
	        } else reject(value);
	      } catch(e){
	        reject(e);
	      }
	    };
	    while(chain.length > i)run(chain[i++]); // variable length - can't use forEach
	    promise._c = [];
	    promise._n = false;
	    if(isReject && !promise._h)onUnhandled(promise);
	  });
	};
	var onUnhandled = function(promise){
	  task.call(global, function(){
	    var value = promise._v
	      , abrupt, handler, console;
	    if(isUnhandled(promise)){
	      abrupt = perform(function(){
	        if(isNode){
	          process.emit('unhandledRejection', value, promise);
	        } else if(handler = global.onunhandledrejection){
	          handler({promise: promise, reason: value});
	        } else if((console = global.console) && console.error){
	          console.error('Unhandled promise rejection', value);
	        }
	      });
	      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
	      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
	    } promise._a = undefined;
	    if(abrupt)throw abrupt.error;
	  });
	};
	var isUnhandled = function(promise){
	  if(promise._h == 1)return false;
	  var chain = promise._a || promise._c
	    , i     = 0
	    , reaction;
	  while(chain.length > i){
	    reaction = chain[i++];
	    if(reaction.fail || !isUnhandled(reaction.promise))return false;
	  } return true;
	};
	var onHandleUnhandled = function(promise){
	  task.call(global, function(){
	    var handler;
	    if(isNode){
	      process.emit('rejectionHandled', promise);
	    } else if(handler = global.onrejectionhandled){
	      handler({promise: promise, reason: promise._v});
	    }
	  });
	};
	var $reject = function(value){
	  var promise = this;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  promise._v = value;
	  promise._s = 2;
	  if(!promise._a)promise._a = promise._c.slice();
	  notify(promise, true);
	};
	var $resolve = function(value){
	  var promise = this
	    , then;
	  if(promise._d)return;
	  promise._d = true;
	  promise = promise._w || promise; // unwrap
	  try {
	    if(promise === value)throw TypeError("Promise can't be resolved itself");
	    if(then = isThenable(value)){
	      microtask(function(){
	        var wrapper = {_w: promise, _d: false}; // wrap
	        try {
	          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
	        } catch(e){
	          $reject.call(wrapper, e);
	        }
	      });
	    } else {
	      promise._v = value;
	      promise._s = 1;
	      notify(promise, false);
	    }
	  } catch(e){
	    $reject.call({_w: promise, _d: false}, e); // wrap
	  }
	};
	
	// constructor polyfill
	if(!USE_NATIVE){
	  // 25.4.3.1 Promise(executor)
	  $Promise = function Promise(executor){
	    anInstance(this, $Promise, PROMISE, '_h');
	    aFunction(executor);
	    Internal.call(this);
	    try {
	      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
	    } catch(err){
	      $reject.call(this, err);
	    }
	  };
	  Internal = function Promise(executor){
	    this._c = [];             // <- awaiting reactions
	    this._a = undefined;      // <- checked in isUnhandled reactions
	    this._s = 0;              // <- state
	    this._d = false;          // <- done
	    this._v = undefined;      // <- value
	    this._h = 0;              // <- rejection state, 0 - default, 1 - handled, 2 - unhandled
	    this._n = false;          // <- notify
	  };
	  Internal.prototype = __webpack_require__(236)($Promise.prototype, {
	    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
	    then: function then(onFulfilled, onRejected){
	      var reaction    = newPromiseCapability(speciesConstructor(this, $Promise));
	      reaction.ok     = typeof onFulfilled == 'function' ? onFulfilled : true;
	      reaction.fail   = typeof onRejected == 'function' && onRejected;
	      reaction.domain = isNode ? process.domain : undefined;
	      this._c.push(reaction);
	      if(this._a)this._a.push(reaction);
	      if(this._s)notify(this, false);
	      return reaction.promise;
	    },
	    // 25.4.5.1 Promise.prototype.catch(onRejected)
	    'catch': function(onRejected){
	      return this.then(undefined, onRejected);
	    }
	  });
	  PromiseCapability = function(){
	    var promise  = new Internal;
	    this.promise = promise;
	    this.resolve = ctx($resolve, promise, 1);
	    this.reject  = ctx($reject, promise, 1);
	  };
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Promise: $Promise});
	__webpack_require__(52)($Promise, PROMISE);
	__webpack_require__(237)(PROMISE);
	Wrapper = __webpack_require__(15)[PROMISE];
	
	// statics
	$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
	  // 25.4.4.5 Promise.reject(r)
	  reject: function reject(r){
	    var capability = newPromiseCapability(this)
	      , $$reject   = capability.reject;
	    $$reject(r);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
	  // 25.4.4.6 Promise.resolve(x)
	  resolve: function resolve(x){
	    // instanceof instead of internal slot check because we should fix it without replacement native Promise core
	    if(x instanceof $Promise && sameConstructor(x.constructor, this))return x;
	    var capability = newPromiseCapability(this)
	      , $$resolve  = capability.resolve;
	    $$resolve(x);
	    return capability.promise;
	  }
	});
	$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(238)(function(iter){
	  $Promise.all(iter)['catch'](empty);
	})), PROMISE, {
	  // 25.4.4.1 Promise.all(iterable)
	  all: function all(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , resolve    = capability.resolve
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      var values    = []
	        , index     = 0
	        , remaining = 1;
	      forOf(iterable, false, function(promise){
	        var $index        = index++
	          , alreadyCalled = false;
	        values.push(undefined);
	        remaining++;
	        C.resolve(promise).then(function(value){
	          if(alreadyCalled)return;
	          alreadyCalled  = true;
	          values[$index] = value;
	          --remaining || resolve(values);
	        }, reject);
	      });
	      --remaining || resolve(values);
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  },
	  // 25.4.4.4 Promise.race(iterable)
	  race: function race(iterable){
	    var C          = this
	      , capability = newPromiseCapability(C)
	      , reject     = capability.reject;
	    var abrupt = perform(function(){
	      forOf(iterable, false, function(promise){
	        C.resolve(promise).then(capability.resolve, reject);
	      });
	    });
	    if(abrupt)reject(abrupt.error);
	    return capability.promise;
	  }
	});

/***/ },
/* 228 */
/***/ function(module, exports) {

	module.exports = function(it, Constructor, name, forbiddenField){
	  if(!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)){
	    throw TypeError(name + ': incorrect invocation!');
	  } return it;
	};

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	var ctx         = __webpack_require__(16)
	  , call        = __webpack_require__(230)
	  , isArrayIter = __webpack_require__(231)
	  , anObject    = __webpack_require__(20)
	  , toLength    = __webpack_require__(47)
	  , getIterFn   = __webpack_require__(57)
	  , BREAK       = {}
	  , RETURN      = {};
	var exports = module.exports = function(iterable, entries, fn, that, ITERATOR){
	  var iterFn = ITERATOR ? function(){ return iterable; } : getIterFn(iterable)
	    , f      = ctx(fn, that, entries ? 2 : 1)
	    , index  = 0
	    , length, step, iterator, result;
	  if(typeof iterFn != 'function')throw TypeError(iterable + ' is not iterable!');
	  // fast case for arrays with default iterator
	  if(isArrayIter(iterFn))for(length = toLength(iterable.length); length > index; index++){
	    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
	    if(result === BREAK || result === RETURN)return result;
	  } else for(iterator = iterFn.call(iterable); !(step = iterator.next()).done; ){
	    result = call(iterator, f, step.value, entries);
	    if(result === BREAK || result === RETURN)return result;
	  }
	};
	exports.BREAK  = BREAK;
	exports.RETURN = RETURN;

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	// call something on iterator step with safe closing on error
	var anObject = __webpack_require__(20);
	module.exports = function(iterator, fn, value, entries){
	  try {
	    return entries ? fn(anObject(value)[0], value[1]) : fn(value);
	  // 7.4.6 IteratorClose(iterator, completion)
	  } catch(e){
	    var ret = iterator['return'];
	    if(ret !== undefined)anObject(ret.call(iterator));
	    throw e;
	  }
	};

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	// check on default Array iterator
	var Iterators  = __webpack_require__(34)
	  , ITERATOR   = __webpack_require__(53)('iterator')
	  , ArrayProto = Array.prototype;
	
	module.exports = function(it){
	  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
	};

/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	// 7.3.20 SpeciesConstructor(O, defaultConstructor)
	var anObject  = __webpack_require__(20)
	  , aFunction = __webpack_require__(17)
	  , SPECIES   = __webpack_require__(53)('species');
	module.exports = function(O, D){
	  var C = anObject(O).constructor, S;
	  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
	};

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	var ctx                = __webpack_require__(16)
	  , invoke             = __webpack_require__(234)
	  , html               = __webpack_require__(51)
	  , cel                = __webpack_require__(25)
	  , global             = __webpack_require__(11)
	  , process            = global.process
	  , setTask            = global.setImmediate
	  , clearTask          = global.clearImmediate
	  , MessageChannel     = global.MessageChannel
	  , counter            = 0
	  , queue              = {}
	  , ONREADYSTATECHANGE = 'onreadystatechange'
	  , defer, channel, port;
	var run = function(){
	  var id = +this;
	  if(queue.hasOwnProperty(id)){
	    var fn = queue[id];
	    delete queue[id];
	    fn();
	  }
	};
	var listener = function(event){
	  run.call(event.data);
	};
	// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
	if(!setTask || !clearTask){
	  setTask = function setImmediate(fn){
	    var args = [], i = 1;
	    while(arguments.length > i)args.push(arguments[i++]);
	    queue[++counter] = function(){
	      invoke(typeof fn == 'function' ? fn : Function(fn), args);
	    };
	    defer(counter);
	    return counter;
	  };
	  clearTask = function clearImmediate(id){
	    delete queue[id];
	  };
	  // Node.js 0.8-
	  if(__webpack_require__(37)(process) == 'process'){
	    defer = function(id){
	      process.nextTick(ctx(run, id, 1));
	    };
	  // Browsers with MessageChannel, includes WebWorkers
	  } else if(MessageChannel){
	    channel = new MessageChannel;
	    port    = channel.port2;
	    channel.port1.onmessage = listener;
	    defer = ctx(port.postMessage, port, 1);
	  // Browsers with postMessage, skip WebWorkers
	  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
	  } else if(global.addEventListener && typeof postMessage == 'function' && !global.importScripts){
	    defer = function(id){
	      global.postMessage(id + '', '*');
	    };
	    global.addEventListener('message', listener, false);
	  // IE8-
	  } else if(ONREADYSTATECHANGE in cel('script')){
	    defer = function(id){
	      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function(){
	        html.removeChild(this);
	        run.call(id);
	      };
	    };
	  // Rest old browsers
	  } else {
	    defer = function(id){
	      setTimeout(ctx(run, id, 1), 0);
	    };
	  }
	}
	module.exports = {
	  set:   setTask,
	  clear: clearTask
	};

/***/ },
/* 234 */
/***/ function(module, exports) {

	// fast apply, http://jsperf.lnkit.com/fast-apply/5
	module.exports = function(fn, args, that){
	  var un = that === undefined;
	  switch(args.length){
	    case 0: return un ? fn()
	                      : fn.call(that);
	    case 1: return un ? fn(args[0])
	                      : fn.call(that, args[0]);
	    case 2: return un ? fn(args[0], args[1])
	                      : fn.call(that, args[0], args[1]);
	    case 3: return un ? fn(args[0], args[1], args[2])
	                      : fn.call(that, args[0], args[1], args[2]);
	    case 4: return un ? fn(args[0], args[1], args[2], args[3])
	                      : fn.call(that, args[0], args[1], args[2], args[3]);
	  } return              fn.apply(that, args);
	};

/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	var global    = __webpack_require__(11)
	  , macrotask = __webpack_require__(233).set
	  , Observer  = global.MutationObserver || global.WebKitMutationObserver
	  , process   = global.process
	  , Promise   = global.Promise
	  , isNode    = __webpack_require__(37)(process) == 'process';
	
	module.exports = function(){
	  var head, last, notify;
	
	  var flush = function(){
	    var parent, fn;
	    if(isNode && (parent = process.domain))parent.exit();
	    while(head){
	      fn   = head.fn;
	      head = head.next;
	      try {
	        fn();
	      } catch(e){
	        if(head)notify();
	        else last = undefined;
	        throw e;
	      }
	    } last = undefined;
	    if(parent)parent.enter();
	  };
	
	  // Node.js
	  if(isNode){
	    notify = function(){
	      process.nextTick(flush);
	    };
	  // browsers with MutationObserver
	  } else if(Observer){
	    var toggle = true
	      , node   = document.createTextNode('');
	    new Observer(flush).observe(node, {characterData: true}); // eslint-disable-line no-new
	    notify = function(){
	      node.data = toggle = !toggle;
	    };
	  // environments with maybe non-completely correct, but existent Promise
	  } else if(Promise && Promise.resolve){
	    var promise = Promise.resolve();
	    notify = function(){
	      promise.then(flush);
	    };
	  // for other environments - macrotask based on:
	  // - setImmediate
	  // - MessageChannel
	  // - window.postMessag
	  // - onreadystatechange
	  // - setTimeout
	  } else {
	    notify = function(){
	      // strange IE + webpack dev server bug - use .call(global)
	      macrotask.call(global, flush);
	    };
	  }
	
	  return function(fn){
	    var task = {fn: fn, next: undefined};
	    if(last)last.next = task;
	    if(!head){
	      head = task;
	      notify();
	    } last = task;
	  };
	};

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	var hide = __webpack_require__(18);
	module.exports = function(target, src, safe){
	  for(var key in src){
	    if(safe && target[key])target[key] = src[key];
	    else hide(target, key, src[key]);
	  } return target;
	};

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global      = __webpack_require__(11)
	  , core        = __webpack_require__(15)
	  , dP          = __webpack_require__(19)
	  , DESCRIPTORS = __webpack_require__(23)
	  , SPECIES     = __webpack_require__(53)('species');
	
	module.exports = function(KEY){
	  var C = typeof core[KEY] == 'function' ? core[KEY] : global[KEY];
	  if(DESCRIPTORS && C && !C[SPECIES])dP.f(C, SPECIES, {
	    configurable: true,
	    get: function(){ return this; }
	  });
	};

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	var ITERATOR     = __webpack_require__(53)('iterator')
	  , SAFE_CLOSING = false;
	
	try {
	  var riter = [7][ITERATOR]();
	  riter['return'] = function(){ SAFE_CLOSING = true; };
	  Array.from(riter, function(){ throw 2; });
	} catch(e){ /* empty */ }
	
	module.exports = function(exec, skipClosing){
	  if(!skipClosing && !SAFE_CLOSING)return false;
	  var safe = false;
	  try {
	    var arr  = [7]
	      , iter = arr[ITERATOR]();
	    iter.next = function(){ return {done: safe = true}; };
	    arr[ITERATOR] = function(){ return iter; };
	    exec(arr);
	  } catch(e){ /* empty */ }
	  return safe;
	};

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	exports.default = function (coordinate, viewerDiv, debugMode, gLDebug) {
	    instanceScene = instanceScene || new Scene(coordinate, viewerDiv, debugMode, gLDebug);
	    return instanceScene;
	};
	
	var _customEvent = __webpack_require__(221);
	
	var _customEvent2 = _interopRequireDefault(_customEvent);
	
	var _c3DEngine = __webpack_require__(240);
	
	var _c3DEngine2 = _interopRequireDefault(_c3DEngine);
	
	var _Globe = __webpack_require__(300);
	
	var _Globe2 = _interopRequireDefault(_Globe);
	
	var _Scheduler = __webpack_require__(305);
	
	var _Scheduler2 = _interopRequireDefault(_Scheduler);
	
	var _BrowseTree = __webpack_require__(348);
	
	var _BrowseTree2 = _interopRequireDefault(_BrowseTree);
	
	var _NodeProcess = __webpack_require__(345);
	
	var _NodeProcess2 = _interopRequireDefault(_NodeProcess);
	
	var _Quadtree = __webpack_require__(304);
	
	var _Quadtree2 = _interopRequireDefault(_Quadtree);
	
	var _CoordStars = __webpack_require__(349);
	
	var _CoordStars2 = _interopRequireDefault(_CoordStars);
	
	var _Coordinates = __webpack_require__(289);
	
	var _Layer = __webpack_require__(301);
	
	var _Layer2 = _interopRequireDefault(_Layer);
	
	var _MobileMappingLayer = __webpack_require__(350);
	
	var _MobileMappingLayer2 = _interopRequireDefault(_MobileMappingLayer);
	
	var _StyleManager = __webpack_require__(366);
	
	var _StyleManager2 = _interopRequireDefault(_StyleManager);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: Scene
	 * Description: La Scene est l'instance principale du client. Elle est le chef orchestre de l'application.
	 */
	
	/* global window, requestAnimationFrame */
	
	var instanceScene = null;
	
	var RENDERING_PAUSED = 0;
	var RENDERING_ACTIVE = 1;
	
	function Scene(coordinate, viewerDiv, debugMode, gLDebug) {
	    if (instanceScene !== null) {
	        throw new Error('Cannot instantiate more than one Scene');
	    }
	
	    var positionCamera = coordinate.as('EPSG:4978');
	
	    this.layers = [];
	    this.map = null;
	
	    this.cameras = null;
	    this.selectNodes = null;
	    this.scheduler = (0, _Scheduler2.default)(this);
	    this.orbitOn = false;
	
	    this.stylesManager = new _StyleManager2.default();
	
	    this.gLDebug = gLDebug;
	    this.gfxEngine = (0, _c3DEngine2.default)(this, positionCamera.xyz(), viewerDiv, debugMode, gLDebug);
	    this.browserScene = new _BrowseTree2.default(this.gfxEngine);
	
	    this.needsRedraw = false;
	    this.lastRenderTime = 0;
	    this.maxFramePerSec = 60;
	
	    this.time = 0;
	    this.orbitOn = false;
	    this.rAF = null;
	
	    this.viewerDiv = viewerDiv;
	    this.renderingState = RENDERING_PAUSED;
	}
	
	Scene.prototype.constructor = Scene;
	/**
	 */
	Scene.prototype.updateCommand = function updateCommand() {
	    // TODO: Implement Me
	
	};
	
	/**
	 * @documentation: return current camera
	 * @returns {Scene_L7.Scene.gfxEngine.camera}
	 */
	Scene.prototype.currentCamera = function currentCamera() {
	    return this.gfxEngine.camera;
	};
	
	Scene.prototype.currentControls = function currentControls() {
	    return this.gfxEngine.controls;
	};
	
	Scene.prototype.getPickPosition = function getPickPosition(mouse) {
	    return this.gfxEngine.getPickingPositionFromDepth(mouse);
	};
	
	Scene.prototype.getStyle = function getStyle(name) {
	    return this.stylesManager.getStyle(name);
	};
	
	Scene.prototype.removeStyle = function removeStyle(name) {
	    return this.stylesManager.removeStyle(name);
	};
	
	Scene.prototype.getStyles = function getStyles() {
	    return this.stylesManager.getStyles();
	};
	
	Scene.prototype.getEllipsoid = function getEllipsoid() {
	    return this.ellipsoid;
	};
	
	Scene.prototype.size = function size() {
	    return (0, _Coordinates.ellipsoidSizes)();
	};
	
	/**
	 *
	 * @returns {undefined}
	 */
	Scene.prototype.updateScene3D = function updateScene3D() {
	    this.gfxEngine.update();
	};
	
	/**
	 * Notifies the scene it needs to be updated due to changes exterior to the
	 * scene itself (e.g. camera movement).
	 * Using a non-0 delay allows to delay update - useful to reduce CPU load for
	 * non-interactive events (e.g: texture loaded)
	 * needsRedraw param indicates if notified change requires a full scene redraw.
	 */
	Scene.prototype.notifyChange = function notifyChange(delay, needsRedraw) {
	    var _this = this;
	
	    if (delay) {
	        window.setTimeout(function () {
	            _this.scheduleUpdate(needsRedraw);
	        }, delay);
	    } else {
	        this.scheduleUpdate(needsRedraw);
	    }
	};
	
	Scene.prototype.scheduleUpdate = function scheduleUpdate(forceRedraw) {
	    var _this2 = this;
	
	    this.needsRedraw |= forceRedraw;
	
	    if (this.renderingState !== RENDERING_ACTIVE) {
	        this.renderingState = RENDERING_ACTIVE;
	
	        requestAnimationFrame(function () {
	            _this2.step();
	        });
	    }
	};
	
	Scene.prototype.update = function update() {
	    for (var l = 0; l < this.layers.length; l++) {
	        var layer = this.layers[l].node;
	
	        for (var sl = 0; sl < layer.children.length; sl++) {
	            var sLayer = layer.children[sl];
	
	            if (sLayer instanceof _Quadtree2.default) {
	                this.browserScene.updateQuadtree(this.layers[l], this.map.layersConfiguration, this.currentCamera());
	            } else if (sLayer instanceof _MobileMappingLayer2.default) {
	                this.browserScene.updateMobileMappingLayer(sLayer, this.currentCamera());
	            } else if (sLayer instanceof _Layer2.default) {
	                this.browserScene.updateLayer(sLayer, this.currentCamera());
	            }
	        }
	    }
	};
	
	Scene.prototype.step = function step() {
	    var _this3 = this;
	
	    // update data-structure
	    this.update();
	
	    // Check if we're done (no command left).
	    // We need to make sure we didn't executed any commands because these commands
	    // might spawn other commands in a next update turn.
	    var executedDuringUpdate = this.scheduler.resetCommandsCount('executed');
	    if (this.scheduler.commandsWaitingExecutionCount() == 0 && executedDuringUpdate == 0) {
	        this.viewerDiv.dispatchEvent(new _customEvent2.default('globe-built'));
	
	        // one last rendering before pausing
	        this.renderScene3D();
	
	        // reset rendering flag
	        this.renderingState = RENDERING_PAUSED;
	    } else {
	        var ts = Date.now();
	
	        // update rendering
	        if (1000.0 / this.maxFramePerSec < ts - this.lastRenderTime) {
	            // only perform rendering if needed
	            if (this.needsRedraw || executedDuringUpdate > 0) {
	                this.renderScene3D();
	                this.lastRenderTime = ts;
	            }
	        }
	
	        requestAnimationFrame(function () {
	            _this3.step();
	        });
	    }
	};
	
	/**
	 */
	Scene.prototype.renderScene3D = function renderScene3D() {
	    this.gfxEngine.renderScene();
	    this.needsRedraw = false;
	};
	
	Scene.prototype.scene3D = function scene3D() {
	    return this.gfxEngine.scene3D;
	};
	
	/**
	 * @documentation: Ajoute des Layers dans la scène.
	 *
	 * @param node {[object Object]}
	 */
	Scene.prototype.add = function add(node, nodeProcess) {
	    if (node instanceof _Globe2.default) {
	        this.map = node;
	        nodeProcess = nodeProcess || new _NodeProcess2.default(this);
	    }
	
	    this.layers.push({
	        node: node,
	        process: nodeProcess
	    });
	    this.gfxEngine.add3DScene(node.getMesh());
	};
	
	Scene.prototype.getMap = function getMap() {
	    return this.map;
	};
	
	/**
	 * @documentation: Retire des layers de la scène
	 *
	 * @param layer {[object Object]}
	 */
	Scene.prototype.remove = function remove() /* layer*/{
	    // TODO: Implement Me
	
	};
	
	/**
	 * @param layers {[object Object]}
	 */
	Scene.prototype.select = function select() /* layers*/{
	    // TODO: Implement Me
	
	};
	
	Scene.prototype.selectNodeId = function selectNodeId(id) {
	    this.browserScene.selectedNodeId = id;
	};
	
	Scene.prototype.setStreetLevelImageryOn = function setStreetLevelImageryOn(value) {
	    if (value) {
	        if (this.layers[1]) {
	            this.layers[1].node.visible = true;
	            this.layers[1].node.children[0].visible = true;
	        } else {
	            var mobileMappingLayer = new _MobileMappingLayer2.default();
	            mobileMappingLayer.initiatePanoramic();
	
	            var immersive = new _Layer2.default();
	            immersive.add(mobileMappingLayer);
	            this.add(immersive);
	        }
	    } else {
	        this.layers[1].node.visible = false;
	        this.layers[1].node.children[0].visible = false; // mobileMappingLayer
	    }
	
	    this.updateScene3D();
	};
	
	Scene.prototype.setLightingPos = function setLightingPos(pos) {
	    if (pos) {
	        this.lightingPos = pos;
	    } else {
	        var coSun = _CoordStars2.default.getSunPositionInScene(new Date().getTime(), 48.85, 2.35);
	        this.lightingPos = coSun.normalize();
	    }
	
	    this.browserScene.updateMaterialUniform('lightPosition', this.lightingPos.clone().normalize());
	    this.layers[0].node.updateLightingPos(this.lightingPos);
	};
	
	// Should be moved in time module: A single loop update registered object every n millisec
	Scene.prototype.animateTime = function animateTime(value) {
	    if (value) {
	        this.time += 4000;
	
	        if (this.time) {
	            var nMilliSeconds = this.time;
	            var coSun = _CoordStars2.default.getSunPositionInScene(new Date().getTime() + 3.6 * nMilliSeconds, 0, 0);
	            this.lightingPos = coSun;
	            this.browserScene.updateMaterialUniform('lightPosition', this.lightingPos.clone().normalize());
	            this.layers[0].node.updateLightingPos(this.lightingPos);
	            if (this.orbitOn) {
	                // ISS orbit is 0.0667 degree per second -> every 60th of sec: 0.00111;
	                var p = this.gfxEngine.camera.camera3D.position;
	                var r = Math.sqrt(p.z * p.z + p.x * p.x);
	                var alpha = Math.atan2(p.z, p.x) + 0.0001;
	                p.x = r * Math.cos(alpha);
	                p.z = r * Math.sin(alpha);
	            }
	
	            this.gfxEngine.update();
	            // this.gfxEngine.renderScene();
	        }
	        this.rAF = requestAnimationFrame(this.animateTime.bind(this));
	    } else {
	        window.cancelAnimationFrame(this.rAF);
	    }
	};
	
	Scene.prototype.orbit = function orbit(value) {
	    // this.gfxEngine.controls = null;
	    this.orbitOn = value;
	};

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	exports.default = function (scene, positionCamera, viewerDiv, debugMode, gLDebug) {
	    instance3DEngine = instance3DEngine || new c3DEngine(scene, positionCamera, viewerDiv, debugMode, gLDebug);
	    return instance3DEngine;
	};
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _GlobeControls = __webpack_require__(242);
	
	var _GlobeControls2 = _interopRequireDefault(_GlobeControls);
	
	var _Camera = __webpack_require__(278);
	
	var _Camera2 = _interopRequireDefault(_Camera);
	
	var _Atmosphere = __webpack_require__(280);
	
	var _Atmosphere2 = _interopRequireDefault(_Atmosphere);
	
	var _Capabilities = __webpack_require__(298);
	
	var _Capabilities2 = _interopRequireDefault(_Capabilities);
	
	var _RendererConstant = __webpack_require__(299);
	
	var _RendererConstant2 = _interopRequireDefault(_RendererConstant);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: c3DEngine
	 * Description: 3DEngine est l'interface avec le framework webGL.
	 */
	
	/* global Uint8Array, Float64Array, document, window, Image */
	
	var instance3DEngine = null;
	
	function c3DEngine(scene, positionCamera, viewerDiv, debugMode, gLDebug) {
	    var _this = this;
	
	    // Constructor
	
	    if (instance3DEngine !== null) {
	        throw new Error('Cannot instantiate more than one c3DEngine');
	    }
	
	    var caps = new _Capabilities2.default();
	    var NOIE = !caps.isInternetExplorer();
	    this.gLDebug = gLDebug;
	    this.viewerDiv = viewerDiv;
	    this.debug = debugMode;
	    this.scene3D = new THREE.Scene();
	    this.scene3D.autoUpdate = false;
	    this.scene3D.sortObjects = false;
	    this.width = this.debug ? viewerDiv.clientWidth * 0.5 : viewerDiv.clientWidth;
	    this.height = viewerDiv.clientHeight;
	    this.camDebug = undefined;
	    this.dnear = 0.0;
	    this.dfar = 0.0;
	    this.stateRender = _RendererConstant2.default.FINAL;
	    this.positionBuffer = null;
	
	    this.camera = new _Camera2.default(this.width, this.height, this.debug);
	
	    if (this.debug) {
	        this.camDebug = new THREE.PerspectiveCamera(30, this.camera.ratio);
	    }
	
	    this.pickingTexture = new THREE.WebGLRenderTarget(this.width, this.height);
	    this.pickingTexture.texture.minFilter = THREE.LinearFilter;
	    this.pickingTexture.texture.generateMipmaps = false;
	
	    this.renderScene = function renderScene() {
	        if (this.camera.camHelper()) {
	            this.camera.camHelper().visible = false;
	        }
	
	        this.renderer.clear();
	        this.renderer.setViewport(0, 0, this.width, this.height);
	        this.renderer.render(this.scene3D, this.camera.camera3D);
	
	        if (this.debug) {
	            this.enableRTC(false);
	            this.camera.camHelper().visible = true;
	
	            var target = this.controls.moveTarget();
	            var position = this.camera.position();
	            var posDebug = new THREE.Vector3().subVectors(position, target);
	
	            posDebug.setLength(posDebug.length() * 2.0);
	            posDebug.add(target);
	            posDebug.setLength((posDebug.length() - this.size) * 3.0 + this.size);
	
	            this.camDebug.position.copy(posDebug);
	            this.camDebug.lookAt(target);
	            this.camDebug.translateX(posDebug.length() / 2);
	            this.camDebug.lookAt(target);
	            this.renderer.setViewport(this.width, 0, this.width, this.height);
	            this.renderer.render(this.scene3D, this.camDebug);
	
	            this.enableRTC(true);
	            this.camera.camHelper().visible = false;
	        }
	    }.bind(this);
	
	    this.update = function update() {
	        this.camera.update();
	        this.updateControl();
	        this.scene.notifyChange(0, true);
	    }.bind(this);
	
	    this.onWindowResize = function onWindowResize() {
	        this.width = this.viewerDiv.clientWidth * (this.debug ? 0.5 : 1);
	        this.height = this.viewerDiv.clientHeight;
	        this.camera.resize(this.width, this.height);
	        this.controls.updateCamera(this.camera);
	
	        if (this.camDebug) {
	            this.camDebug.aspect = this.camera.ratio;
	            this.camDebug.updateProjectionMatrix();
	        }
	
	        this.pickingTexture.setSize(this.width, this.height);
	        this.renderer.setSize(this.viewerDiv.clientWidth, this.height);
	        this.update();
	    }.bind(this);
	
	    this.scene = scene;
	    this.size = this.scene.size().x;
	
	    //
	    // init camera
	    //
	    this.camera.setPosition(positionCamera);
	    this.camera.camera3D.near = this.size * 2.333; // if near is too small --> bug no camera helper
	    this.camera.camera3D.far = this.size * 10;
	    this.camera.camera3D.updateProjectionMatrix();
	    this.camera.camera3D.updateMatrixWorld(true);
	
	    if (this.debug) {
	        this.camDebug.position.x = this.size * 6;
	        this.camDebug.lookAt(new THREE.Vector3(0, 0, 0));
	        this.camDebug.near = this.size * 0.1;
	        this.camDebug.far = this.size * 10;
	        this.camDebug.updateProjectionMatrix();
	        this.camera.createCamHelper();
	        this.scene3D.add(this.camera.camHelper());
	        var axisHelper = new THREE.AxisHelper(this.size * 1.33);
	        this.scene3D.add(axisHelper);
	    }
	
	    this.camera.camera3D.near = Math.max(15.0, 0.000002352 * this.size);
	    this.camera.camera3D.updateProjectionMatrix();
	
	    //
	    // Create canvas
	    //
	
	    var canvas = document.createElement('canvas');
	    canvas.id = 'canvasWebGL';
	
	    //
	    // Create renderer
	    //
	
	    this.renderer = new THREE.WebGLRenderer({
	        canvas: canvas,
	        antialias: true,
	        alpha: true,
	        logarithmicDepthBuffer: this.gLDebug || NOIE
	    });
	    this.renderer.setPixelRatio(viewerDiv.devicePixelRatio);
	    this.renderer.setSize(viewerDiv.clientWidth, viewerDiv.clientHeight);
	    this.renderer.setClearColor(0x030508);
	    this.renderer.autoClear = false;
	
	    // this.viewerDiv.appendChild(canvas);
	    viewerDiv.appendChild(this.renderer.domElement);
	
	    //
	    // Create Control
	    //
	    this.controls = new _GlobeControls2.default(this.camera.camera3D, this.renderer.domElement, this);
	    this.controls.rotateSpeed = 0.25;
	    this.controls.zoomSpeed = 2.0;
	    this.controls.minDistance = 30;
	    this.controls.maxDistance = this.size * 8.0;
	    this.camera.update();
	
	    var gl = this.renderer.context;
	    var maxTexturesUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
	
	    var debugInfo = gl.getExtension('WEBGL_debug_renderer_info');
	    if (debugInfo !== null) {
	        var vendor = gl.getParameter(debugInfo.UNMASKED_VENDOR_WEBGL);
	        // var renderer = gl.getParameter(debugInfo.UNMASKED_RENDERER_WEBGL);
	
	        if (vendor.indexOf('mesa') > -1 || vendor.indexOf('Mesa') > -1) {
	            maxTexturesUnits = Math.min(16, maxTexturesUnits);
	        }
	    } else {
	        maxTexturesUnits = Math.min(16, maxTexturesUnits);
	    }
	
	    this.glParams = {
	        maxTexturesUnits: maxTexturesUnits
	    };
	
	    window.addEventListener('resize', this.onWindowResize, false);
	    this.controls.addEventListener('change', this.update);
	
	    // select
	    this.renderer.domElement.addEventListener('selectClick', function (event) {
	        _this.selectNodeAt(event.mouse);
	        _this.update();
	    }, false);
	}
	
	/**
	 * TODO : temporaire
	 * update control parameter in function of distance of globe
	 * @returns {undefined}
	 */
	c3DEngine.prototype.updateControl = function updateControl() {
	    var len = this.camera.position().length();
	    var lim = this.size * 1.1;
	
	    if (len < lim) {
	        var t = Math.pow(Math.cos((lim - len) / (lim - this.size * 0.9981) * Math.PI * 0.5), 1.5);
	        var color = new THREE.Color(0x93d5f8);
	        this.renderer.setClearColor(color.multiplyScalar(1.0 - t));
	    } else if (len >= lim) {
	        this.renderer.setClearColor(0x030508);
	    }
	};
	
	c3DEngine.prototype.enableRTC = function enableRTC(enable) {
	    for (var x = 0; x < this.scene3D.children.length; x++) {
	        var node = this.scene3D.children[x];
	
	        if (node instanceof _Atmosphere2.default) {
	            node.visible = enable;
	        } else if (node.enableRTC) {
	            node.traverseVisible(enable ? this.rtcOn.bind(this) : this.rtcOff.bind(this));
	        }
	    }
	};
	
	/**
	 * change state all visible nodes
	 * @param {type} state new state to apply
	 * @returns {undefined}
	 */
	c3DEngine.prototype.changeStateNodesScene = function changeStateNodesScene(state) {
	    // build traverse function
	    var changeStateFunction = function getChangeStateFunctionFn() {
	        return function changeStateFunction(object3D) {
	            object3D.changeState(state);
	        };
	    }();
	
	    var enable = state === _RendererConstant2.default.FINAL;
	
	    for (var x = 0; x < this.scene3D.children.length; x++) {
	        var node = this.scene3D.children[x];
	
	        if (node.changeState) {
	            node.traverseVisible(changeStateFunction);
	        } else if (node.layer) {
	            node.visible = enable ? node.layer.visible : false;
	        }
	    }
	};
	
	c3DEngine.prototype.rtcOn = function rtcOn(obj3D) {
	    obj3D.enableRTC(true);
	    obj3D.matrixAutoUpdate = false;
	};
	
	c3DEngine.prototype.rtcOff = function rtcOff(obj3D) {
	    obj3D.enableRTC(false);
	    obj3D.matrixWorldNeedsUpdate = true;
	    obj3D.matrixAutoUpdate = true;
	};
	
	/**
	 */
	c3DEngine.prototype.style2Engine = function style2Engine() {
	    // TODO: Implement Me
	
	};
	
	/**
	 * TODO : to delete
	 * @param {type} mesh
	 * @param {type} texture
	 * @returns {undefined}
	 */
	c3DEngine.prototype.setTexture = function setTexture(mesh, texture) {
	    // TODO: Implement Me
	    mesh.material = new THREE.MeshBasicMaterial({
	        color: 0xffffff,
	        map: texture
	    });
	};
	
	/**
	 * add nodeMesh in scene 3D
	 * @param {type} node
	 * @returns {undefined}
	 */
	c3DEngine.prototype.add3DScene = function add3DScene(node) {
	    if (Array.isArray(node)) {
	        this.scene3D.add.apply(this.scene3D, node);
	    } else {
	        this.scene3D.add(node);
	    }
	};
	
	c3DEngine.prototype.removeAll = function removeAll() {
	    this.scene3D.children = [];
	};
	
	/**
	 */
	c3DEngine.prototype.precision = function precision() {
	    // TODO: Implement Me
	
	};
	
	/*
	 * return
	 */
	c3DEngine.prototype.getWindowSize = function getWindowSize() {
	    return new THREE.Vector2(this.width, this.height);
	};
	
	/**
	 * return renderer THREE.js
	 * @returns {undefined|c3DEngine_L7.THREE.WebGLRenderer}
	 */
	c3DEngine.prototype.getRenderer = function getRenderer() {
	    return this.renderer;
	};
	
	c3DEngine.prototype.setStateRender = function setStateRender(stateRender) {
	    if (this.stateRender !== stateRender) {
	        this.stateRender = stateRender;
	
	        this.changeStateNodesScene(stateRender);
	    }
	};
	
	c3DEngine.prototype.renderTobuffer = function renderTobuffer(x, y, width, height, mode) {
	    // TODO Deallocate render texture
	    var originalState = this.stateRender;
	    this.setStateRender(mode);
	    this.renderer.clear();
	    this.renderer.setViewport(x, y, width, height);
	    this.renderer.render(this.scene3D, this.camera.camera3D, this.pickingTexture);
	    this.setStateRender(originalState);
	    var pixelBuffer = new Uint8Array(4);
	    this.renderer.readRenderTargetPixels(this.pickingTexture, x, y, width, height, pixelBuffer);
	    return pixelBuffer;
	};
	
	c3DEngine.prototype.bufferToImage = function bufferToImage(pixelBuffer, width, height) {
	    var canvas = document.createElement('canvas');
	    var ctx = canvas.getContext('2d');
	
	    // size the canvas to your desired image
	    canvas.width = width;
	    canvas.height = height;
	
	    var imgData = ctx.getImageData(0, 0, width, height);
	    imgData.data.set(pixelBuffer);
	
	    ctx.putImageData(imgData, 0, 0);
	
	    // create a new img object
	    var image = new Image();
	
	    // set the img.src to the canvas data url
	    image.src = canvas.toDataURL();
	
	    return image;
	};
	
	c3DEngine.prototype.updatePositionBuffer = function updatePositionBuffer() {
	    this.camera.camera3D.updateMatrixWorld();
	    this.positionBuffer = this.renderTobuffer(0, 0, this.width, this.height, _RendererConstant2.default.DEPTH);
	    this.renderScene(); // TODO debug to remove white screen, but why?
	};
	
	c3DEngine.prototype.pickingInPositionBuffer = function pickingInPositionBuffer(mouse, scene) {
	    if (this.positionBuffer === null) {
	        this.updatePositionBuffer();
	    }
	
	    if (mouse === undefined) {
	        mouse = new THREE.Vector2(Math.floor(this.width / 2), Math.floor(this.height / 2));
	    }
	
	    var coord = new THREE.Vector2(mouse.x, this.height - mouse.y);
	
	    var i = (coord.y * this.width + coord.x) * 4;
	
	    if (scene) {
	        scene.selectNodeId(this.positionBuffer[i + 3]);
	    }
	
	    var glslPosition = new THREE.Vector3(this.positionBuffer[i + 0], this.positionBuffer[i + 1], this.positionBuffer[i + 2]);
	
	    var worldPosition = glslPosition.applyMatrix4(this.camera.camera3D.matrixWorld);
	
	    return worldPosition;
	};
	
	/**
	 *
	 * @param {type} mouse : mouse position on screen in pixel
	 * @param {type} scene
	 * @returns THREE.Vector3 position cartesien in world space
	 * */
	c3DEngine.prototype.getPickingPosition = function getPickingPosition(mouse, scene) {
	    if (mouse === undefined) {
	        mouse = new THREE.Vector2(Math.floor(this.width / 2), Math.floor(this.height / 2));
	    }
	
	    var camera = this.camera.camera3D;
	
	    camera.updateMatrixWorld();
	
	    var buffer = this.renderTobuffer(mouse.x, this.height - mouse.y, 1, 1, _RendererConstant2.default.DEPTH);
	
	    var glslPosition = new THREE.Vector3().fromArray(buffer);
	
	    if (scene) {
	        scene.selectNodeId(buffer[3]);
	    }
	
	    var worldPosition = glslPosition.applyMatrix4(camera.matrixWorld);
	
	    if (worldPosition.length() > 10000000) {
	        return undefined;
	    }
	
	    return worldPosition;
	};
	
	var unpack1K = function unpack1K(color, factor) {
	    var bitSh = new THREE.Vector4(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0);
	    return bitSh.dot(color) * factor;
	};
	
	/**
	 *
	 * @param {Vecto2D} mouse : mouse position on screen in pixel
	 * @returns {int} uuid's node
	 * */
	c3DEngine.prototype.screenCoordsToNodeId = function screenCoordsToNodeId(mouse) {
	    var camera = this.camera.camera3D;
	
	    camera.updateMatrixWorld();
	
	    var buffer = this.renderTobuffer(mouse.x, this.height - mouse.y, 1, 1, _RendererConstant2.default.ID);
	
	    var depthRGBA = new THREE.Vector4().fromArray(buffer).divideScalar(255.0);
	
	    // unpack RGBA to float
	    var unpack = unpack1K(depthRGBA, 10000);
	
	    return Math.round(unpack);
	};
	
	/**
	 *
	 * @param {Vecto2D} mouse : mouse position on screen in pixel
	 * Select node under mouse
	 **/
	c3DEngine.prototype.selectNodeAt = function selectNodeAt(mouse) {
	    this.scene.selectNodeId(this.screenCoordsToNodeId(mouse));
	};
	
	c3DEngine.prototype.getPickingPositionFromDepth = function getGetPickingPosFromDepthFn() {
	    var matrix = new THREE.Matrix4();
	    matrix.elements = new Float64Array(16); // /!\ WARNING Matrix JS are in Float32Array
	    var screen = new THREE.Vector2();
	    var pickWorldPosition = new THREE.Vector3();
	    var ray = new THREE.Ray();
	    var direction = new THREE.Vector3();
	    var depthRGBA = new THREE.Vector4();
	
	    return function getPickingPositionFromDepth(mouse) {
	        if (mouse === undefined) {
	            mouse = new THREE.Vector2(Math.floor(this.width / 2), Math.floor(this.height / 2));
	        }
	
	        var camera = this.camera.camera3D;
	
	        camera.updateMatrixWorld();
	
	        var buffer = this.renderTobuffer(mouse.x, this.height - mouse.y, 1, 1, _RendererConstant2.default.DEPTH);
	
	        screen.x = mouse.x / this.width * 2 - 1;
	        screen.y = -(mouse.y / this.height) * 2 + 1;
	
	        camera.matrixWorld.setPosition(camera.position);
	
	        // Origin
	        ray.origin.copy(camera.position);
	
	        // Direction
	        ray.direction.set(screen.x, screen.y, 0.5);
	        // Unproject
	        matrix.multiplyMatrices(camera.matrixWorld, matrix.getInverse(camera.projectionMatrix));
	        ray.direction.applyMatrix4(matrix);
	        ray.direction.sub(ray.origin);
	
	        direction.set(0, 0, 1.0);
	        direction.applyMatrix4(matrix);
	        direction.sub(ray.origin);
	
	        var angle = direction.angleTo(ray.direction);
	
	        depthRGBA.fromArray(buffer).divideScalar(255.0);
	
	        var depth = unpack1K(depthRGBA, 100000000.0) / Math.cos(angle);
	
	        pickWorldPosition.addVectors(camera.position, ray.direction.setLength(depth));
	
	        if (pickWorldPosition.length() > 10000000) {
	            return undefined;
	        }
	
	        return pickWorldPosition;
	    };
	}();
	
	c3DEngine.prototype.placeDummy = function placeDummy(dummy, position) {
	    dummy.position.copy(position);
	    var size = position.clone().sub(this.camera.position()).length() / 200; // TODO distance
	    dummy.scale.copy(new THREE.Vector3(size, size, size));
	    dummy.lookAt(new THREE.Vector3());
	    dummy.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2));
	    dummy.translateY(size);
	    dummy.updateMatrix();
	    dummy.updateMatrixWorld();
	};
	
	c3DEngine.prototype.getRTCMatrixFromCenter = function getRTCMatrixFromCenterFn() {
	    var position = new THREE.Vector3();
	    var matrix = new THREE.Matrix4();
	    return function getRTCMatrixFromCenter(center, camera) {
	        position.subVectors(camera.camera3D.position, center);
	        matrix.copy(camera.camera3D.matrixWorld);
	        matrix.setPosition(position);
	        matrix.getInverse(matrix);
	        return new THREE.Matrix4().multiplyMatrices(camera.camera3D.projectionMatrix, matrix);
	    };
	}();
	
	c3DEngine.prototype.getRTCMatrixFromNode = function getRTCMatrixFromNode(node, camera) {
	    // TODO: Simplify this function like getRTCMatrixFromCenter()
	    var camera3D = camera.camera3D;
	    var positionWorld = new THREE.Vector3().setFromMatrixPosition(node.matrixWorld);
	    var position = new THREE.Vector3().subVectors(camera3D.position, positionWorld);
	    var quaternion = new THREE.Quaternion().copy(camera3D.quaternion);
	    var matrix = new THREE.Matrix4().compose(position, quaternion, new THREE.Vector3(1, 1, 1));
	    var matrixInv = new THREE.Matrix4().getInverse(matrix);
	    var model = node.matrixWorld.clone().setPosition(new THREE.Vector3());
	    matrixInv.multiply(model);
	
	    var centerEye = new THREE.Vector4().applyMatrix4(matrixInv);
	    var mvc = matrixInv.setPosition(centerEye);
	    return new THREE.Matrix4().multiplyMatrices(camera3D.projectionMatrix, mvc);
	};

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? factory(exports) :
		typeof define === 'function' && define.amd ? define(['exports'], factory) :
		(factory((global.THREE = global.THREE || {})));
	}(this, (function (exports) { 'use strict';
	
		// Polyfills
	
		if ( Number.EPSILON === undefined ) {
	
			Number.EPSILON = Math.pow( 2, - 52 );
	
		}
	
		//
	
		if ( Math.sign === undefined ) {
	
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
	
			Math.sign = function ( x ) {
	
				return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;
	
			};
	
		}
	
		if ( Function.prototype.name === undefined ) {
	
			// Missing in IE9-11.
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
	
			Object.defineProperty( Function.prototype, 'name', {
	
				get: function () {
	
					return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];
	
				}
	
			} );
	
		}
	
		if ( Object.assign === undefined ) {
	
			// Missing in IE.
			// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	
			( function () {
	
				Object.assign = function ( target ) {
	
					'use strict';
	
					if ( target === undefined || target === null ) {
	
						throw new TypeError( 'Cannot convert undefined or null to object' );
	
					}
	
					var output = Object( target );
	
					for ( var index = 1; index < arguments.length; index ++ ) {
	
						var source = arguments[ index ];
	
						if ( source !== undefined && source !== null ) {
	
							for ( var nextKey in source ) {
	
								if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {
	
									output[ nextKey ] = source[ nextKey ];
	
								}
	
							}
	
						}
	
					}
	
					return output;
	
				};
	
			} )();
	
		}
	
		/**
		 * https://github.com/mrdoob/eventdispatcher.js/
		 */
	
		function EventDispatcher() {}
	
		EventDispatcher.prototype = {
	
			addEventListener: function ( type, listener ) {
	
				if ( this._listeners === undefined ) this._listeners = {};
	
				var listeners = this._listeners;
	
				if ( listeners[ type ] === undefined ) {
	
					listeners[ type ] = [];
	
				}
	
				if ( listeners[ type ].indexOf( listener ) === - 1 ) {
	
					listeners[ type ].push( listener );
	
				}
	
			},
	
			hasEventListener: function ( type, listener ) {
	
				if ( this._listeners === undefined ) return false;
	
				var listeners = this._listeners;
	
				return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;
	
			},
	
			removeEventListener: function ( type, listener ) {
	
				if ( this._listeners === undefined ) return;
	
				var listeners = this._listeners;
				var listenerArray = listeners[ type ];
	
				if ( listenerArray !== undefined ) {
	
					var index = listenerArray.indexOf( listener );
	
					if ( index !== - 1 ) {
	
						listenerArray.splice( index, 1 );
	
					}
	
				}
	
			},
	
			dispatchEvent: function ( event ) {
	
				if ( this._listeners === undefined ) return;
	
				var listeners = this._listeners;
				var listenerArray = listeners[ event.type ];
	
				if ( listenerArray !== undefined ) {
	
					event.target = this;
	
					var array = [], i = 0;
					var length = listenerArray.length;
	
					for ( i = 0; i < length; i ++ ) {
	
						array[ i ] = listenerArray[ i ];
	
					}
	
					for ( i = 0; i < length; i ++ ) {
	
						array[ i ].call( this, event );
	
					}
	
				}
	
			}
	
		};
	
		var REVISION = '84';
		var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
		var CullFaceNone = 0;
		var CullFaceBack = 1;
		var CullFaceFront = 2;
		var CullFaceFrontBack = 3;
		var FrontFaceDirectionCW = 0;
		var FrontFaceDirectionCCW = 1;
		var BasicShadowMap = 0;
		var PCFShadowMap = 1;
		var PCFSoftShadowMap = 2;
		var FrontSide = 0;
		var BackSide = 1;
		var DoubleSide = 2;
		var FlatShading = 1;
		var SmoothShading = 2;
		var NoColors = 0;
		var FaceColors = 1;
		var VertexColors = 2;
		var NoBlending = 0;
		var NormalBlending = 1;
		var AdditiveBlending = 2;
		var SubtractiveBlending = 3;
		var MultiplyBlending = 4;
		var CustomBlending = 5;
		var AddEquation = 100;
		var SubtractEquation = 101;
		var ReverseSubtractEquation = 102;
		var MinEquation = 103;
		var MaxEquation = 104;
		var ZeroFactor = 200;
		var OneFactor = 201;
		var SrcColorFactor = 202;
		var OneMinusSrcColorFactor = 203;
		var SrcAlphaFactor = 204;
		var OneMinusSrcAlphaFactor = 205;
		var DstAlphaFactor = 206;
		var OneMinusDstAlphaFactor = 207;
		var DstColorFactor = 208;
		var OneMinusDstColorFactor = 209;
		var SrcAlphaSaturateFactor = 210;
		var NeverDepth = 0;
		var AlwaysDepth = 1;
		var LessDepth = 2;
		var LessEqualDepth = 3;
		var EqualDepth = 4;
		var GreaterEqualDepth = 5;
		var GreaterDepth = 6;
		var NotEqualDepth = 7;
		var MultiplyOperation = 0;
		var MixOperation = 1;
		var AddOperation = 2;
		var NoToneMapping = 0;
		var LinearToneMapping = 1;
		var ReinhardToneMapping = 2;
		var Uncharted2ToneMapping = 3;
		var CineonToneMapping = 4;
		var UVMapping = 300;
		var CubeReflectionMapping = 301;
		var CubeRefractionMapping = 302;
		var EquirectangularReflectionMapping = 303;
		var EquirectangularRefractionMapping = 304;
		var SphericalReflectionMapping = 305;
		var CubeUVReflectionMapping = 306;
		var CubeUVRefractionMapping = 307;
		var RepeatWrapping = 1000;
		var ClampToEdgeWrapping = 1001;
		var MirroredRepeatWrapping = 1002;
		var NearestFilter = 1003;
		var NearestMipMapNearestFilter = 1004;
		var NearestMipMapLinearFilter = 1005;
		var LinearFilter = 1006;
		var LinearMipMapNearestFilter = 1007;
		var LinearMipMapLinearFilter = 1008;
		var UnsignedByteType = 1009;
		var ByteType = 1010;
		var ShortType = 1011;
		var UnsignedShortType = 1012;
		var IntType = 1013;
		var UnsignedIntType = 1014;
		var FloatType = 1015;
		var HalfFloatType = 1016;
		var UnsignedShort4444Type = 1017;
		var UnsignedShort5551Type = 1018;
		var UnsignedShort565Type = 1019;
		var UnsignedInt248Type = 1020;
		var AlphaFormat = 1021;
		var RGBFormat = 1022;
		var RGBAFormat = 1023;
		var LuminanceFormat = 1024;
		var LuminanceAlphaFormat = 1025;
		var RGBEFormat = RGBAFormat;
		var DepthFormat = 1026;
		var DepthStencilFormat = 1027;
		var RGB_S3TC_DXT1_Format = 2001;
		var RGBA_S3TC_DXT1_Format = 2002;
		var RGBA_S3TC_DXT3_Format = 2003;
		var RGBA_S3TC_DXT5_Format = 2004;
		var RGB_PVRTC_4BPPV1_Format = 2100;
		var RGB_PVRTC_2BPPV1_Format = 2101;
		var RGBA_PVRTC_4BPPV1_Format = 2102;
		var RGBA_PVRTC_2BPPV1_Format = 2103;
		var RGB_ETC1_Format = 2151;
		var LoopOnce = 2200;
		var LoopRepeat = 2201;
		var LoopPingPong = 2202;
		var InterpolateDiscrete = 2300;
		var InterpolateLinear = 2301;
		var InterpolateSmooth = 2302;
		var ZeroCurvatureEnding = 2400;
		var ZeroSlopeEnding = 2401;
		var WrapAroundEnding = 2402;
		var TrianglesDrawMode = 0;
		var TriangleStripDrawMode = 1;
		var TriangleFanDrawMode = 2;
		var LinearEncoding = 3000;
		var sRGBEncoding = 3001;
		var GammaEncoding = 3007;
		var RGBEEncoding = 3002;
		var LogLuvEncoding = 3003;
		var RGBM7Encoding = 3004;
		var RGBM16Encoding = 3005;
		var RGBDEncoding = 3006;
		var BasicDepthPacking = 3200;
		var RGBADepthPacking = 3201;
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		var _Math = {
	
			DEG2RAD: Math.PI / 180,
			RAD2DEG: 180 / Math.PI,
	
			generateUUID: function () {
	
				// http://www.broofa.com/Tools/Math.uuid.htm
	
				var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
				var uuid = new Array( 36 );
				var rnd = 0, r;
	
				return function generateUUID() {
	
					for ( var i = 0; i < 36; i ++ ) {
	
						if ( i === 8 || i === 13 || i === 18 || i === 23 ) {
	
							uuid[ i ] = '-';
	
						} else if ( i === 14 ) {
	
							uuid[ i ] = '4';
	
						} else {
	
							if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
							r = rnd & 0xf;
							rnd = rnd >> 4;
							uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];
	
						}
	
					}
	
					return uuid.join( '' );
	
				};
	
			}(),
	
			clamp: function ( value, min, max ) {
	
				return Math.max( min, Math.min( max, value ) );
	
			},
	
			// compute euclidian modulo of m % n
			// https://en.wikipedia.org/wiki/Modulo_operation
	
			euclideanModulo: function ( n, m ) {
	
				return ( ( n % m ) + m ) % m;
	
			},
	
			// Linear mapping from range <a1, a2> to range <b1, b2>
	
			mapLinear: function ( x, a1, a2, b1, b2 ) {
	
				return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );
	
			},
	
			// https://en.wikipedia.org/wiki/Linear_interpolation
	
			lerp: function ( x, y, t ) {
	
				return ( 1 - t ) * x + t * y;
	
			},
	
			// http://en.wikipedia.org/wiki/Smoothstep
	
			smoothstep: function ( x, min, max ) {
	
				if ( x <= min ) return 0;
				if ( x >= max ) return 1;
	
				x = ( x - min ) / ( max - min );
	
				return x * x * ( 3 - 2 * x );
	
			},
	
			smootherstep: function ( x, min, max ) {
	
				if ( x <= min ) return 0;
				if ( x >= max ) return 1;
	
				x = ( x - min ) / ( max - min );
	
				return x * x * x * ( x * ( x * 6 - 15 ) + 10 );
	
			},
	
			// Random integer from <low, high> interval
	
			randInt: function ( low, high ) {
	
				return low + Math.floor( Math.random() * ( high - low + 1 ) );
	
			},
	
			// Random float from <low, high> interval
	
			randFloat: function ( low, high ) {
	
				return low + Math.random() * ( high - low );
	
			},
	
			// Random float from <-range/2, range/2> interval
	
			randFloatSpread: function ( range ) {
	
				return range * ( 0.5 - Math.random() );
	
			},
	
			degToRad: function ( degrees ) {
	
				return degrees * _Math.DEG2RAD;
	
			},
	
			radToDeg: function ( radians ) {
	
				return radians * _Math.RAD2DEG;
	
			},
	
			isPowerOfTwo: function ( value ) {
	
				return ( value & ( value - 1 ) ) === 0 && value !== 0;
	
			},
	
			nearestPowerOfTwo: function ( value ) {
	
				return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );
	
			},
	
			nextPowerOfTwo: function ( value ) {
	
				value --;
				value |= value >> 1;
				value |= value >> 2;
				value |= value >> 4;
				value |= value >> 8;
				value |= value >> 16;
				value ++;
	
				return value;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author philogb / http://blog.thejit.org/
		 * @author egraether / http://egraether.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */
	
		function Vector2( x, y ) {
	
			this.x = x || 0;
			this.y = y || 0;
	
		}
	
		Vector2.prototype = {
	
			constructor: Vector2,
	
			isVector2: true,
	
			get width() {
	
				return this.x;
	
			},
	
			set width( value ) {
	
				this.x = value;
	
			},
	
			get height() {
	
				return this.y;
	
			},
	
			set height( value ) {
	
				this.y = value;
	
			},
	
			//
	
			set: function ( x, y ) {
	
				this.x = x;
				this.y = y;
	
				return this;
	
			},
	
			setScalar: function ( scalar ) {
	
				this.x = scalar;
				this.y = scalar;
	
				return this;
	
			},
	
			setX: function ( x ) {
	
				this.x = x;
	
				return this;
	
			},
	
			setY: function ( y ) {
	
				this.y = y;
	
				return this;
	
			},
	
			setComponent: function ( index, value ) {
	
				switch ( index ) {
	
					case 0: this.x = value; break;
					case 1: this.y = value; break;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
				return this;
	
			},
	
			getComponent: function ( index ) {
	
				switch ( index ) {
	
					case 0: return this.x;
					case 1: return this.y;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
			},
	
			clone: function () {
	
				return new this.constructor( this.x, this.y );
	
			},
	
			copy: function ( v ) {
	
				this.x = v.x;
				this.y = v.y;
	
				return this;
	
			},
	
			add: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );
	
				}
	
				this.x += v.x;
				this.y += v.y;
	
				return this;
	
			},
	
			addScalar: function ( s ) {
	
				this.x += s;
				this.y += s;
	
				return this;
	
			},
	
			addVectors: function ( a, b ) {
	
				this.x = a.x + b.x;
				this.y = a.y + b.y;
	
				return this;
	
			},
	
			addScaledVector: function ( v, s ) {
	
				this.x += v.x * s;
				this.y += v.y * s;
	
				return this;
	
			},
	
			sub: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );
	
				}
	
				this.x -= v.x;
				this.y -= v.y;
	
				return this;
	
			},
	
			subScalar: function ( s ) {
	
				this.x -= s;
				this.y -= s;
	
				return this;
	
			},
	
			subVectors: function ( a, b ) {
	
				this.x = a.x - b.x;
				this.y = a.y - b.y;
	
				return this;
	
			},
	
			multiply: function ( v ) {
	
				this.x *= v.x;
				this.y *= v.y;
	
				return this;
	
			},
	
			multiplyScalar: function ( scalar ) {
	
				if ( isFinite( scalar ) ) {
	
					this.x *= scalar;
					this.y *= scalar;
	
				} else {
	
					this.x = 0;
					this.y = 0;
	
				}
	
				return this;
	
			},
	
			divide: function ( v ) {
	
				this.x /= v.x;
				this.y /= v.y;
	
				return this;
	
			},
	
			divideScalar: function ( scalar ) {
	
				return this.multiplyScalar( 1 / scalar );
	
			},
	
			min: function ( v ) {
	
				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
	
				return this;
	
			},
	
			max: function ( v ) {
	
				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
	
				return this;
	
			},
	
			clamp: function ( min, max ) {
	
				// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
	
				return this;
	
			},
	
			clampScalar: function () {
	
				var min, max;
	
				return function clampScalar( minVal, maxVal ) {
	
					if ( min === undefined ) {
	
						min = new Vector2();
						max = new Vector2();
	
					}
	
					min.set( minVal, minVal );
					max.set( maxVal, maxVal );
	
					return this.clamp( min, max );
	
				};
	
			}(),
	
			clampLength: function ( min, max ) {
	
				var length = this.length();
	
				return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );
	
			},
	
			floor: function () {
	
				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
	
				return this;
	
			},
	
			ceil: function () {
	
				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
	
				return this;
	
			},
	
			round: function () {
	
				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
	
				return this;
	
			},
	
			roundToZero: function () {
	
				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
	
				return this;
	
			},
	
			negate: function () {
	
				this.x = - this.x;
				this.y = - this.y;
	
				return this;
	
			},
	
			dot: function ( v ) {
	
				return this.x * v.x + this.y * v.y;
	
			},
	
			lengthSq: function () {
	
				return this.x * this.x + this.y * this.y;
	
			},
	
			length: function () {
	
				return Math.sqrt( this.x * this.x + this.y * this.y );
	
			},
	
			lengthManhattan: function() {
	
				return Math.abs( this.x ) + Math.abs( this.y );
	
			},
	
			normalize: function () {
	
				return this.divideScalar( this.length() );
	
			},
	
			angle: function () {
	
				// computes the angle in radians with respect to the positive x-axis
	
				var angle = Math.atan2( this.y, this.x );
	
				if ( angle < 0 ) angle += 2 * Math.PI;
	
				return angle;
	
			},
	
			distanceTo: function ( v ) {
	
				return Math.sqrt( this.distanceToSquared( v ) );
	
			},
	
			distanceToSquared: function ( v ) {
	
				var dx = this.x - v.x, dy = this.y - v.y;
				return dx * dx + dy * dy;
	
			},
	
			distanceToManhattan: function ( v ) {
	
				return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );
	
			},
	
			setLength: function ( length ) {
	
				return this.multiplyScalar( length / this.length() );
	
			},
	
			lerp: function ( v, alpha ) {
	
				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
	
				return this;
	
			},
	
			lerpVectors: function ( v1, v2, alpha ) {
	
				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			},
	
			equals: function ( v ) {
	
				return ( ( v.x === this.x ) && ( v.y === this.y ) );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
	
				return array;
	
			},
	
			fromBufferAttribute: function ( attribute, index, offset ) {
	
				if ( offset !== undefined ) {
	
					console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );
	
				}
	
				this.x = attribute.getX( index );
				this.y = attribute.getY( index );
	
				return this;
	
			},
	
			rotateAround: function ( center, angle ) {
	
				var c = Math.cos( angle ), s = Math.sin( angle );
	
				var x = this.x - center.x;
				var y = this.y - center.y;
	
				this.x = x * c - y * s + center.x;
				this.y = x * s + y * c + center.y;
	
				return this;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 */
	
		var textureId = 0;
	
		function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
	
			Object.defineProperty( this, 'id', { value: textureId ++ } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
	
			this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
			this.mipmaps = [];
	
			this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
	
			this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
			this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
	
			this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
			this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;
	
			this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
	
			this.format = format !== undefined ? format : RGBAFormat;
			this.type = type !== undefined ? type : UnsignedByteType;
	
			this.offset = new Vector2( 0, 0 );
			this.repeat = new Vector2( 1, 1 );
	
			this.generateMipmaps = true;
			this.premultiplyAlpha = false;
			this.flipY = true;
			this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
	
	
			// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
			//
			// Also changing the encoding after already used by a Material will not automatically make the Material
			// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
			this.encoding = encoding !== undefined ? encoding : LinearEncoding;
	
			this.version = 0;
			this.onUpdate = null;
	
		}
	
		Texture.DEFAULT_IMAGE = undefined;
		Texture.DEFAULT_MAPPING = UVMapping;
	
		Texture.prototype = {
	
			constructor: Texture,
	
			isTexture: true,
	
			set needsUpdate( value ) {
	
				if ( value === true ) this.version ++;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( source ) {
	
				this.image = source.image;
				this.mipmaps = source.mipmaps.slice( 0 );
	
				this.mapping = source.mapping;
	
				this.wrapS = source.wrapS;
				this.wrapT = source.wrapT;
	
				this.magFilter = source.magFilter;
				this.minFilter = source.minFilter;
	
				this.anisotropy = source.anisotropy;
	
				this.format = source.format;
				this.type = source.type;
	
				this.offset.copy( source.offset );
				this.repeat.copy( source.repeat );
	
				this.generateMipmaps = source.generateMipmaps;
				this.premultiplyAlpha = source.premultiplyAlpha;
				this.flipY = source.flipY;
				this.unpackAlignment = source.unpackAlignment;
				this.encoding = source.encoding;
	
				return this;
	
			},
	
			toJSON: function ( meta ) {
	
				if ( meta.textures[ this.uuid ] !== undefined ) {
	
					return meta.textures[ this.uuid ];
	
				}
	
				function getDataURL( image ) {
	
					var canvas;
	
					if ( image.toDataURL !== undefined ) {
	
						canvas = image;
	
					} else {
	
						canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
						canvas.width = image.width;
						canvas.height = image.height;
	
						canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );
	
					}
	
					if ( canvas.width > 2048 || canvas.height > 2048 ) {
	
						return canvas.toDataURL( 'image/jpeg', 0.6 );
	
					} else {
	
						return canvas.toDataURL( 'image/png' );
	
					}
	
				}
	
				var output = {
					metadata: {
						version: 4.4,
						type: 'Texture',
						generator: 'Texture.toJSON'
					},
	
					uuid: this.uuid,
					name: this.name,
	
					mapping: this.mapping,
	
					repeat: [ this.repeat.x, this.repeat.y ],
					offset: [ this.offset.x, this.offset.y ],
					wrap: [ this.wrapS, this.wrapT ],
	
					minFilter: this.minFilter,
					magFilter: this.magFilter,
					anisotropy: this.anisotropy,
	
					flipY: this.flipY
				};
	
				if ( this.image !== undefined ) {
	
					// TODO: Move to THREE.Image
	
					var image = this.image;
	
					if ( image.uuid === undefined ) {
	
						image.uuid = _Math.generateUUID(); // UGH
	
					}
	
					if ( meta.images[ image.uuid ] === undefined ) {
	
						meta.images[ image.uuid ] = {
							uuid: image.uuid,
							url: getDataURL( image )
						};
	
					}
	
					output.image = image.uuid;
	
				}
	
				meta.textures[ this.uuid ] = output;
	
				return output;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			},
	
			transformUv: function ( uv ) {
	
				if ( this.mapping !== UVMapping ) return;
	
				uv.multiply( this.repeat );
				uv.add( this.offset );
	
				if ( uv.x < 0 || uv.x > 1 ) {
	
					switch ( this.wrapS ) {
	
						case RepeatWrapping:
	
							uv.x = uv.x - Math.floor( uv.x );
							break;
	
						case ClampToEdgeWrapping:
	
							uv.x = uv.x < 0 ? 0 : 1;
							break;
	
						case MirroredRepeatWrapping:
	
							if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {
	
								uv.x = Math.ceil( uv.x ) - uv.x;
	
							} else {
	
								uv.x = uv.x - Math.floor( uv.x );
	
							}
							break;
	
					}
	
				}
	
				if ( uv.y < 0 || uv.y > 1 ) {
	
					switch ( this.wrapT ) {
	
						case RepeatWrapping:
	
							uv.y = uv.y - Math.floor( uv.y );
							break;
	
						case ClampToEdgeWrapping:
	
							uv.y = uv.y < 0 ? 0 : 1;
							break;
	
						case MirroredRepeatWrapping:
	
							if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {
	
								uv.y = Math.ceil( uv.y ) - uv.y;
	
							} else {
	
								uv.y = uv.y - Math.floor( uv.y );
	
							}
							break;
	
					}
	
				}
	
				if ( this.flipY ) {
	
					uv.y = 1 - uv.y;
	
				}
	
			}
	
		};
	
		Object.assign( Texture.prototype, EventDispatcher.prototype );
	
		/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function Vector4( x, y, z, w ) {
	
			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
			this.w = ( w !== undefined ) ? w : 1;
	
		}
	
		Vector4.prototype = {
	
			constructor: Vector4,
	
			isVector4: true,
	
			set: function ( x, y, z, w ) {
	
				this.x = x;
				this.y = y;
				this.z = z;
				this.w = w;
	
				return this;
	
			},
	
			setScalar: function ( scalar ) {
	
				this.x = scalar;
				this.y = scalar;
				this.z = scalar;
				this.w = scalar;
	
				return this;
	
			},
	
			setX: function ( x ) {
	
				this.x = x;
	
				return this;
	
			},
	
			setY: function ( y ) {
	
				this.y = y;
	
				return this;
	
			},
	
			setZ: function ( z ) {
	
				this.z = z;
	
				return this;
	
			},
	
			setW: function ( w ) {
	
				this.w = w;
	
				return this;
	
			},
	
			setComponent: function ( index, value ) {
	
				switch ( index ) {
	
					case 0: this.x = value; break;
					case 1: this.y = value; break;
					case 2: this.z = value; break;
					case 3: this.w = value; break;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
				return this;
	
			},
	
			getComponent: function ( index ) {
	
				switch ( index ) {
	
					case 0: return this.x;
					case 1: return this.y;
					case 2: return this.z;
					case 3: return this.w;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
			},
	
			clone: function () {
	
				return new this.constructor( this.x, this.y, this.z, this.w );
	
			},
	
			copy: function ( v ) {
	
				this.x = v.x;
				this.y = v.y;
				this.z = v.z;
				this.w = ( v.w !== undefined ) ? v.w : 1;
	
				return this;
	
			},
	
			add: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );
	
				}
	
				this.x += v.x;
				this.y += v.y;
				this.z += v.z;
				this.w += v.w;
	
				return this;
	
			},
	
			addScalar: function ( s ) {
	
				this.x += s;
				this.y += s;
				this.z += s;
				this.w += s;
	
				return this;
	
			},
	
			addVectors: function ( a, b ) {
	
				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;
				this.w = a.w + b.w;
	
				return this;
	
			},
	
			addScaledVector: function ( v, s ) {
	
				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;
				this.w += v.w * s;
	
				return this;
	
			},
	
			sub: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );
	
				}
	
				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;
				this.w -= v.w;
	
				return this;
	
			},
	
			subScalar: function ( s ) {
	
				this.x -= s;
				this.y -= s;
				this.z -= s;
				this.w -= s;
	
				return this;
	
			},
	
			subVectors: function ( a, b ) {
	
				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;
				this.w = a.w - b.w;
	
				return this;
	
			},
	
			multiplyScalar: function ( scalar ) {
	
				if ( isFinite( scalar ) ) {
	
					this.x *= scalar;
					this.y *= scalar;
					this.z *= scalar;
					this.w *= scalar;
	
				} else {
	
					this.x = 0;
					this.y = 0;
					this.z = 0;
					this.w = 0;
	
				}
	
				return this;
	
			},
	
			applyMatrix4: function ( m ) {
	
				var x = this.x, y = this.y, z = this.z, w = this.w;
				var e = m.elements;
	
				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
				this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;
	
				return this;
	
			},
	
			divideScalar: function ( scalar ) {
	
				return this.multiplyScalar( 1 / scalar );
	
			},
	
			setAxisAngleFromQuaternion: function ( q ) {
	
				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	
				// q is assumed to be normalized
	
				this.w = 2 * Math.acos( q.w );
	
				var s = Math.sqrt( 1 - q.w * q.w );
	
				if ( s < 0.0001 ) {
	
					 this.x = 1;
					 this.y = 0;
					 this.z = 0;
	
				} else {
	
					 this.x = q.x / s;
					 this.y = q.y / s;
					 this.z = q.z / s;
	
				}
	
				return this;
	
			},
	
			setAxisAngleFromRotationMatrix: function ( m ) {
	
				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	
				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
				var angle, x, y, z,		// variables for result
					epsilon = 0.01,		// margin to allow for rounding errors
					epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees
	
					te = m.elements,
	
					m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
					m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
					m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
				if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
				     ( Math.abs( m13 - m31 ) < epsilon ) &&
				     ( Math.abs( m23 - m32 ) < epsilon ) ) {
	
					// singularity found
					// first check for identity matrix which must have +1 for all terms
					// in leading diagonal and zero in other terms
	
					if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
					     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
					     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
					     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {
	
						// this singularity is identity matrix so angle = 0
	
						this.set( 1, 0, 0, 0 );
	
						return this; // zero angle, arbitrary axis
	
					}
	
					// otherwise this singularity is angle = 180
	
					angle = Math.PI;
	
					var xx = ( m11 + 1 ) / 2;
					var yy = ( m22 + 1 ) / 2;
					var zz = ( m33 + 1 ) / 2;
					var xy = ( m12 + m21 ) / 4;
					var xz = ( m13 + m31 ) / 4;
					var yz = ( m23 + m32 ) / 4;
	
					if ( ( xx > yy ) && ( xx > zz ) ) {
	
						// m11 is the largest diagonal term
	
						if ( xx < epsilon ) {
	
							x = 0;
							y = 0.707106781;
							z = 0.707106781;
	
						} else {
	
							x = Math.sqrt( xx );
							y = xy / x;
							z = xz / x;
	
						}
	
					} else if ( yy > zz ) {
	
						// m22 is the largest diagonal term
	
						if ( yy < epsilon ) {
	
							x = 0.707106781;
							y = 0;
							z = 0.707106781;
	
						} else {
	
							y = Math.sqrt( yy );
							x = xy / y;
							z = yz / y;
	
						}
	
					} else {
	
						// m33 is the largest diagonal term so base result on this
	
						if ( zz < epsilon ) {
	
							x = 0.707106781;
							y = 0.707106781;
							z = 0;
	
						} else {
	
							z = Math.sqrt( zz );
							x = xz / z;
							y = yz / z;
	
						}
	
					}
	
					this.set( x, y, z, angle );
	
					return this; // return 180 deg rotation
	
				}
	
				// as we have reached here there are no singularities so we can handle normally
	
				var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
				                   ( m13 - m31 ) * ( m13 - m31 ) +
				                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize
	
				if ( Math.abs( s ) < 0.001 ) s = 1;
	
				// prevent divide by zero, should not happen if matrix is orthogonal and should be
				// caught by singularity test above, but I've left it in just in case
	
				this.x = ( m32 - m23 ) / s;
				this.y = ( m13 - m31 ) / s;
				this.z = ( m21 - m12 ) / s;
				this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );
	
				return this;
	
			},
	
			min: function ( v ) {
	
				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
				this.z = Math.min( this.z, v.z );
				this.w = Math.min( this.w, v.w );
	
				return this;
	
			},
	
			max: function ( v ) {
	
				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
				this.z = Math.max( this.z, v.z );
				this.w = Math.max( this.w, v.w );
	
				return this;
	
			},
	
			clamp: function ( min, max ) {
	
				// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
				this.z = Math.max( min.z, Math.min( max.z, this.z ) );
				this.w = Math.max( min.w, Math.min( max.w, this.w ) );
	
				return this;
	
			},
	
			clampScalar: function () {
	
				var min, max;
	
				return function clampScalar( minVal, maxVal ) {
	
					if ( min === undefined ) {
	
						min = new Vector4();
						max = new Vector4();
	
					}
	
					min.set( minVal, minVal, minVal, minVal );
					max.set( maxVal, maxVal, maxVal, maxVal );
	
					return this.clamp( min, max );
	
				};
	
			}(),
	
			floor: function () {
	
				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
				this.z = Math.floor( this.z );
				this.w = Math.floor( this.w );
	
				return this;
	
			},
	
			ceil: function () {
	
				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
				this.z = Math.ceil( this.z );
				this.w = Math.ceil( this.w );
	
				return this;
	
			},
	
			round: function () {
	
				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
				this.z = Math.round( this.z );
				this.w = Math.round( this.w );
	
				return this;
	
			},
	
			roundToZero: function () {
	
				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
				this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
				this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );
	
				return this;
	
			},
	
			negate: function () {
	
				this.x = - this.x;
				this.y = - this.y;
				this.z = - this.z;
				this.w = - this.w;
	
				return this;
	
			},
	
			dot: function ( v ) {
	
				return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	
			},
	
			lengthSq: function () {
	
				return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	
			},
	
			length: function () {
	
				return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
	
			},
	
			lengthManhattan: function () {
	
				return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );
	
			},
	
			normalize: function () {
	
				return this.divideScalar( this.length() );
	
			},
	
			setLength: function ( length ) {
	
				return this.multiplyScalar( length / this.length() );
	
			},
	
			lerp: function ( v, alpha ) {
	
				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
				this.z += ( v.z - this.z ) * alpha;
				this.w += ( v.w - this.w ) * alpha;
	
				return this;
	
			},
	
			lerpVectors: function ( v1, v2, alpha ) {
	
				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			},
	
			equals: function ( v ) {
	
				return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
				this.z = array[ offset + 2 ];
				this.w = array[ offset + 3 ];
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
				array[ offset + 2 ] = this.z;
				array[ offset + 3 ] = this.w;
	
				return array;
	
			},
	
			fromBufferAttribute: function ( attribute, index, offset ) {
	
				if ( offset !== undefined ) {
	
					console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );
	
				}
	
				this.x = attribute.getX( index );
				this.y = attribute.getY( index );
				this.z = attribute.getZ( index );
				this.w = attribute.getW( index );
	
				return this;
	
			}
	
		};
	
		/**
		 * @author szimek / https://github.com/szimek/
		 * @author alteredq / http://alteredqualia.com/
		 * @author Marius Kintel / https://github.com/kintel
		 */
	
		/*
		 In options, we can specify:
		 * Texture parameters for an auto-generated target texture
		 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
		*/
		function WebGLRenderTarget( width, height, options ) {
	
			this.uuid = _Math.generateUUID();
	
			this.width = width;
			this.height = height;
	
			this.scissor = new Vector4( 0, 0, width, height );
			this.scissorTest = false;
	
			this.viewport = new Vector4( 0, 0, width, height );
	
			options = options || {};
	
			if ( options.minFilter === undefined ) options.minFilter = LinearFilter;
	
			this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
	
			this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
			this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
			this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
	
		}
	
		WebGLRenderTarget.prototype = {
	
			constructor: WebGLRenderTarget,
	
			isWebGLRenderTarget: true,
	
			setSize: function ( width, height ) {
	
				if ( this.width !== width || this.height !== height ) {
	
					this.width = width;
					this.height = height;
	
					this.dispose();
	
				}
	
				this.viewport.set( 0, 0, width, height );
				this.scissor.set( 0, 0, width, height );
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( source ) {
	
				this.width = source.width;
				this.height = source.height;
	
				this.viewport.copy( source.viewport );
	
				this.texture = source.texture.clone();
	
				this.depthBuffer = source.depthBuffer;
				this.stencilBuffer = source.stencilBuffer;
				this.depthTexture = source.depthTexture;
	
				return this;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			}
	
		};
	
		Object.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype );
	
		/**
		 * @author alteredq / http://alteredqualia.com
		 */
	
		function WebGLRenderTargetCube( width, height, options ) {
	
			WebGLRenderTarget.call( this, width, height, options );
	
			this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
			this.activeMipMapLevel = 0;
	
		}
	
		WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
		WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
	
		WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */
	
		function Quaternion( x, y, z, w ) {
	
			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._w = ( w !== undefined ) ? w : 1;
	
		}
	
		Quaternion.prototype = {
	
			constructor: Quaternion,
	
			get x () {
	
				return this._x;
	
			},
	
			set x ( value ) {
	
				this._x = value;
				this.onChangeCallback();
	
			},
	
			get y () {
	
				return this._y;
	
			},
	
			set y ( value ) {
	
				this._y = value;
				this.onChangeCallback();
	
			},
	
			get z () {
	
				return this._z;
	
			},
	
			set z ( value ) {
	
				this._z = value;
				this.onChangeCallback();
	
			},
	
			get w () {
	
				return this._w;
	
			},
	
			set w ( value ) {
	
				this._w = value;
				this.onChangeCallback();
	
			},
	
			set: function ( x, y, z, w ) {
	
				this._x = x;
				this._y = y;
				this._z = z;
				this._w = w;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor( this._x, this._y, this._z, this._w );
	
			},
	
			copy: function ( quaternion ) {
	
				this._x = quaternion.x;
				this._y = quaternion.y;
				this._z = quaternion.z;
				this._w = quaternion.w;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			setFromEuler: function ( euler, update ) {
	
				if ( (euler && euler.isEuler) === false ) {
	
					throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );
	
				}
	
				// http://www.mathworks.com/matlabcentral/fileexchange/
				// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
				//	content/SpinCalc.m
	
				var c1 = Math.cos( euler._x / 2 );
				var c2 = Math.cos( euler._y / 2 );
				var c3 = Math.cos( euler._z / 2 );
				var s1 = Math.sin( euler._x / 2 );
				var s2 = Math.sin( euler._y / 2 );
				var s3 = Math.sin( euler._z / 2 );
	
				var order = euler.order;
	
				if ( order === 'XYZ' ) {
	
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
				} else if ( order === 'YXZ' ) {
	
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
				} else if ( order === 'ZXY' ) {
	
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
				} else if ( order === 'ZYX' ) {
	
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
				} else if ( order === 'YZX' ) {
	
					this._x = s1 * c2 * c3 + c1 * s2 * s3;
					this._y = c1 * s2 * c3 + s1 * c2 * s3;
					this._z = c1 * c2 * s3 - s1 * s2 * c3;
					this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
				} else if ( order === 'XZY' ) {
	
					this._x = s1 * c2 * c3 - c1 * s2 * s3;
					this._y = c1 * s2 * c3 - s1 * c2 * s3;
					this._z = c1 * c2 * s3 + s1 * s2 * c3;
					this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
				}
	
				if ( update !== false ) this.onChangeCallback();
	
				return this;
	
			},
	
			setFromAxisAngle: function ( axis, angle ) {
	
				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	
				// assumes axis is normalized
	
				var halfAngle = angle / 2, s = Math.sin( halfAngle );
	
				this._x = axis.x * s;
				this._y = axis.y * s;
				this._z = axis.z * s;
				this._w = Math.cos( halfAngle );
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			setFromRotationMatrix: function ( m ) {
	
				// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	
				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
				var te = m.elements,
	
					m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
					m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
					m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],
	
					trace = m11 + m22 + m33,
					s;
	
				if ( trace > 0 ) {
	
					s = 0.5 / Math.sqrt( trace + 1.0 );
	
					this._w = 0.25 / s;
					this._x = ( m32 - m23 ) * s;
					this._y = ( m13 - m31 ) * s;
					this._z = ( m21 - m12 ) * s;
	
				} else if ( m11 > m22 && m11 > m33 ) {
	
					s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
	
					this._w = ( m32 - m23 ) / s;
					this._x = 0.25 * s;
					this._y = ( m12 + m21 ) / s;
					this._z = ( m13 + m31 ) / s;
	
				} else if ( m22 > m33 ) {
	
					s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
	
					this._w = ( m13 - m31 ) / s;
					this._x = ( m12 + m21 ) / s;
					this._y = 0.25 * s;
					this._z = ( m23 + m32 ) / s;
	
				} else {
	
					s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
	
					this._w = ( m21 - m12 ) / s;
					this._x = ( m13 + m31 ) / s;
					this._y = ( m23 + m32 ) / s;
					this._z = 0.25 * s;
	
				}
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			setFromUnitVectors: function () {
	
				// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
	
				// assumes direction vectors vFrom and vTo are normalized
	
				var v1, r;
	
				var EPS = 0.000001;
	
				return function setFromUnitVectors( vFrom, vTo ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
	
					r = vFrom.dot( vTo ) + 1;
	
					if ( r < EPS ) {
	
						r = 0;
	
						if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
	
							v1.set( - vFrom.y, vFrom.x, 0 );
	
						} else {
	
							v1.set( 0, - vFrom.z, vFrom.y );
	
						}
	
					} else {
	
						v1.crossVectors( vFrom, vTo );
	
					}
	
					this._x = v1.x;
					this._y = v1.y;
					this._z = v1.z;
					this._w = r;
	
					return this.normalize();
	
				};
	
			}(),
	
			inverse: function () {
	
				return this.conjugate().normalize();
	
			},
	
			conjugate: function () {
	
				this._x *= - 1;
				this._y *= - 1;
				this._z *= - 1;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			dot: function ( v ) {
	
				return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	
			},
	
			lengthSq: function () {
	
				return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	
			},
	
			length: function () {
	
				return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
	
			},
	
			normalize: function () {
	
				var l = this.length();
	
				if ( l === 0 ) {
	
					this._x = 0;
					this._y = 0;
					this._z = 0;
					this._w = 1;
	
				} else {
	
					l = 1 / l;
	
					this._x = this._x * l;
					this._y = this._y * l;
					this._z = this._z * l;
					this._w = this._w * l;
	
				}
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			multiply: function ( q, p ) {
	
				if ( p !== undefined ) {
	
					console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
					return this.multiplyQuaternions( q, p );
	
				}
	
				return this.multiplyQuaternions( this, q );
	
			},
	
			premultiply: function ( q ) {
	
				return this.multiplyQuaternions( q, this );
	
			},
	
			multiplyQuaternions: function ( a, b ) {
	
				// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	
				var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
				var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
	
				this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
				this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
				this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
				this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			slerp: function ( qb, t ) {
	
				if ( t === 0 ) return this;
				if ( t === 1 ) return this.copy( qb );
	
				var x = this._x, y = this._y, z = this._z, w = this._w;
	
				// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	
				var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	
				if ( cosHalfTheta < 0 ) {
	
					this._w = - qb._w;
					this._x = - qb._x;
					this._y = - qb._y;
					this._z = - qb._z;
	
					cosHalfTheta = - cosHalfTheta;
	
				} else {
	
					this.copy( qb );
	
				}
	
				if ( cosHalfTheta >= 1.0 ) {
	
					this._w = w;
					this._x = x;
					this._y = y;
					this._z = z;
	
					return this;
	
				}
	
				var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );
	
				if ( Math.abs( sinHalfTheta ) < 0.001 ) {
	
					this._w = 0.5 * ( w + this._w );
					this._x = 0.5 * ( x + this._x );
					this._y = 0.5 * ( y + this._y );
					this._z = 0.5 * ( z + this._z );
	
					return this;
	
				}
	
				var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
				var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
	
				this._w = ( w * ratioA + this._w * ratioB );
				this._x = ( x * ratioA + this._x * ratioB );
				this._y = ( y * ratioA + this._y * ratioB );
				this._z = ( z * ratioA + this._z * ratioB );
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			equals: function ( quaternion ) {
	
				return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this._x = array[ offset ];
				this._y = array[ offset + 1 ];
				this._z = array[ offset + 2 ];
				this._w = array[ offset + 3 ];
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this._x;
				array[ offset + 1 ] = this._y;
				array[ offset + 2 ] = this._z;
				array[ offset + 3 ] = this._w;
	
				return array;
	
			},
	
			onChange: function ( callback ) {
	
				this.onChangeCallback = callback;
	
				return this;
	
			},
	
			onChangeCallback: function () {}
	
		};
	
		Object.assign( Quaternion, {
	
			slerp: function( qa, qb, qm, t ) {
	
				return qm.copy( qa ).slerp( qb, t );
	
			},
	
			slerpFlat: function(
					dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {
	
				// fuzz-free, array-based Quaternion SLERP operation
	
				var x0 = src0[ srcOffset0 + 0 ],
					y0 = src0[ srcOffset0 + 1 ],
					z0 = src0[ srcOffset0 + 2 ],
					w0 = src0[ srcOffset0 + 3 ],
	
					x1 = src1[ srcOffset1 + 0 ],
					y1 = src1[ srcOffset1 + 1 ],
					z1 = src1[ srcOffset1 + 2 ],
					w1 = src1[ srcOffset1 + 3 ];
	
				if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {
	
					var s = 1 - t,
	
						cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
	
						dir = ( cos >= 0 ? 1 : - 1 ),
						sqrSin = 1 - cos * cos;
	
					// Skip the Slerp for tiny steps to avoid numeric problems:
					if ( sqrSin > Number.EPSILON ) {
	
						var sin = Math.sqrt( sqrSin ),
							len = Math.atan2( sin, cos * dir );
	
						s = Math.sin( s * len ) / sin;
						t = Math.sin( t * len ) / sin;
	
					}
	
					var tDir = t * dir;
	
					x0 = x0 * s + x1 * tDir;
					y0 = y0 * s + y1 * tDir;
					z0 = z0 * s + z1 * tDir;
					w0 = w0 * s + w1 * tDir;
	
					// Normalize in case we just did a lerp:
					if ( s === 1 - t ) {
	
						var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );
	
						x0 *= f;
						y0 *= f;
						z0 *= f;
						w0 *= f;
	
					}
	
				}
	
				dst[ dstOffset ] = x0;
				dst[ dstOffset + 1 ] = y0;
				dst[ dstOffset + 2 ] = z0;
				dst[ dstOffset + 3 ] = w0;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author *kile / http://kile.stravaganza.org/
		 * @author philogb / http://blog.thejit.org/
		 * @author mikael emtinger / http://gomo.se/
		 * @author egraether / http://egraether.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function Vector3( x, y, z ) {
	
			this.x = x || 0;
			this.y = y || 0;
			this.z = z || 0;
	
		}
	
		Vector3.prototype = {
	
			constructor: Vector3,
	
			isVector3: true,
	
			set: function ( x, y, z ) {
	
				this.x = x;
				this.y = y;
				this.z = z;
	
				return this;
	
			},
	
			setScalar: function ( scalar ) {
	
				this.x = scalar;
				this.y = scalar;
				this.z = scalar;
	
				return this;
	
			},
	
			setX: function ( x ) {
	
				this.x = x;
	
				return this;
	
			},
	
			setY: function ( y ) {
	
				this.y = y;
	
				return this;
	
			},
	
			setZ: function ( z ) {
	
				this.z = z;
	
				return this;
	
			},
	
			setComponent: function ( index, value ) {
	
				switch ( index ) {
	
					case 0: this.x = value; break;
					case 1: this.y = value; break;
					case 2: this.z = value; break;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
				return this;
	
			},
	
			getComponent: function ( index ) {
	
				switch ( index ) {
	
					case 0: return this.x;
					case 1: return this.y;
					case 2: return this.z;
					default: throw new Error( 'index is out of range: ' + index );
	
				}
	
			},
	
			clone: function () {
	
				return new this.constructor( this.x, this.y, this.z );
	
			},
	
			copy: function ( v ) {
	
				this.x = v.x;
				this.y = v.y;
				this.z = v.z;
	
				return this;
	
			},
	
			add: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
					return this.addVectors( v, w );
	
				}
	
				this.x += v.x;
				this.y += v.y;
				this.z += v.z;
	
				return this;
	
			},
	
			addScalar: function ( s ) {
	
				this.x += s;
				this.y += s;
				this.z += s;
	
				return this;
	
			},
	
			addVectors: function ( a, b ) {
	
				this.x = a.x + b.x;
				this.y = a.y + b.y;
				this.z = a.z + b.z;
	
				return this;
	
			},
	
			addScaledVector: function ( v, s ) {
	
				this.x += v.x * s;
				this.y += v.y * s;
				this.z += v.z * s;
	
				return this;
	
			},
	
			sub: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
					return this.subVectors( v, w );
	
				}
	
				this.x -= v.x;
				this.y -= v.y;
				this.z -= v.z;
	
				return this;
	
			},
	
			subScalar: function ( s ) {
	
				this.x -= s;
				this.y -= s;
				this.z -= s;
	
				return this;
	
			},
	
			subVectors: function ( a, b ) {
	
				this.x = a.x - b.x;
				this.y = a.y - b.y;
				this.z = a.z - b.z;
	
				return this;
	
			},
	
			multiply: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
					return this.multiplyVectors( v, w );
	
				}
	
				this.x *= v.x;
				this.y *= v.y;
				this.z *= v.z;
	
				return this;
	
			},
	
			multiplyScalar: function ( scalar ) {
	
				if ( isFinite( scalar ) ) {
	
					this.x *= scalar;
					this.y *= scalar;
					this.z *= scalar;
	
				} else {
	
					this.x = 0;
					this.y = 0;
					this.z = 0;
	
				}
	
				return this;
	
			},
	
			multiplyVectors: function ( a, b ) {
	
				this.x = a.x * b.x;
				this.y = a.y * b.y;
				this.z = a.z * b.z;
	
				return this;
	
			},
	
			applyEuler: function () {
	
				var quaternion;
	
				return function applyEuler( euler ) {
	
					if ( (euler && euler.isEuler) === false ) {
	
						console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );
	
					}
	
					if ( quaternion === undefined ) quaternion = new Quaternion();
	
					return this.applyQuaternion( quaternion.setFromEuler( euler ) );
	
				};
	
			}(),
	
			applyAxisAngle: function () {
	
				var quaternion;
	
				return function applyAxisAngle( axis, angle ) {
	
					if ( quaternion === undefined ) quaternion = new Quaternion();
	
					return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );
	
				};
	
			}(),
	
			applyMatrix3: function ( m ) {
	
				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;
	
				this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
				this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
				this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;
	
				return this;
	
			},
	
			applyMatrix4: function ( m ) {
	
				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;
	
				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];
				var w =  e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ];
	
				return this.divideScalar( w );
	
			},
	
			applyQuaternion: function ( q ) {
	
				var x = this.x, y = this.y, z = this.z;
				var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
	
				// calculate quat * vector
	
				var ix =  qw * x + qy * z - qz * y;
				var iy =  qw * y + qz * x - qx * z;
				var iz =  qw * z + qx * y - qy * x;
				var iw = - qx * x - qy * y - qz * z;
	
				// calculate result * inverse quat
	
				this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
				this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
				this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;
	
				return this;
	
			},
	
			project: function () {
	
				var matrix;
	
				return function project( camera ) {
	
					if ( matrix === undefined ) matrix = new Matrix4();
	
					matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
					return this.applyMatrix4( matrix );
	
				};
	
			}(),
	
			unproject: function () {
	
				var matrix;
	
				return function unproject( camera ) {
	
					if ( matrix === undefined ) matrix = new Matrix4();
	
					matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
					return this.applyMatrix4( matrix );
	
				};
	
			}(),
	
			transformDirection: function ( m ) {
	
				// input: THREE.Matrix4 affine matrix
				// vector interpreted as a direction
	
				var x = this.x, y = this.y, z = this.z;
				var e = m.elements;
	
				this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
				this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
				this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;
	
				return this.normalize();
	
			},
	
			divide: function ( v ) {
	
				this.x /= v.x;
				this.y /= v.y;
				this.z /= v.z;
	
				return this;
	
			},
	
			divideScalar: function ( scalar ) {
	
				return this.multiplyScalar( 1 / scalar );
	
			},
	
			min: function ( v ) {
	
				this.x = Math.min( this.x, v.x );
				this.y = Math.min( this.y, v.y );
				this.z = Math.min( this.z, v.z );
	
				return this;
	
			},
	
			max: function ( v ) {
	
				this.x = Math.max( this.x, v.x );
				this.y = Math.max( this.y, v.y );
				this.z = Math.max( this.z, v.z );
	
				return this;
	
			},
	
			clamp: function ( min, max ) {
	
				// This function assumes min < max, if this assumption isn't true it will not operate correctly
	
				this.x = Math.max( min.x, Math.min( max.x, this.x ) );
				this.y = Math.max( min.y, Math.min( max.y, this.y ) );
				this.z = Math.max( min.z, Math.min( max.z, this.z ) );
	
				return this;
	
			},
	
			clampScalar: function () {
	
				var min, max;
	
				return function clampScalar( minVal, maxVal ) {
	
					if ( min === undefined ) {
	
						min = new Vector3();
						max = new Vector3();
	
					}
	
					min.set( minVal, minVal, minVal );
					max.set( maxVal, maxVal, maxVal );
	
					return this.clamp( min, max );
	
				};
	
			}(),
	
			clampLength: function ( min, max ) {
	
				var length = this.length();
	
				return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );
	
			},
	
			floor: function () {
	
				this.x = Math.floor( this.x );
				this.y = Math.floor( this.y );
				this.z = Math.floor( this.z );
	
				return this;
	
			},
	
			ceil: function () {
	
				this.x = Math.ceil( this.x );
				this.y = Math.ceil( this.y );
				this.z = Math.ceil( this.z );
	
				return this;
	
			},
	
			round: function () {
	
				this.x = Math.round( this.x );
				this.y = Math.round( this.y );
				this.z = Math.round( this.z );
	
				return this;
	
			},
	
			roundToZero: function () {
	
				this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
				this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
				this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
	
				return this;
	
			},
	
			negate: function () {
	
				this.x = - this.x;
				this.y = - this.y;
				this.z = - this.z;
	
				return this;
	
			},
	
			dot: function ( v ) {
	
				return this.x * v.x + this.y * v.y + this.z * v.z;
	
			},
	
			lengthSq: function () {
	
				return this.x * this.x + this.y * this.y + this.z * this.z;
	
			},
	
			length: function () {
	
				return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
	
			},
	
			lengthManhattan: function () {
	
				return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
	
			},
	
			normalize: function () {
	
				return this.divideScalar( this.length() );
	
			},
	
			setLength: function ( length ) {
	
				return this.multiplyScalar( length / this.length() );
	
			},
	
			lerp: function ( v, alpha ) {
	
				this.x += ( v.x - this.x ) * alpha;
				this.y += ( v.y - this.y ) * alpha;
				this.z += ( v.z - this.z ) * alpha;
	
				return this;
	
			},
	
			lerpVectors: function ( v1, v2, alpha ) {
	
				return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
			},
	
			cross: function ( v, w ) {
	
				if ( w !== undefined ) {
	
					console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
					return this.crossVectors( v, w );
	
				}
	
				var x = this.x, y = this.y, z = this.z;
	
				this.x = y * v.z - z * v.y;
				this.y = z * v.x - x * v.z;
				this.z = x * v.y - y * v.x;
	
				return this;
	
			},
	
			crossVectors: function ( a, b ) {
	
				var ax = a.x, ay = a.y, az = a.z;
				var bx = b.x, by = b.y, bz = b.z;
	
				this.x = ay * bz - az * by;
				this.y = az * bx - ax * bz;
				this.z = ax * by - ay * bx;
	
				return this;
	
			},
	
			projectOnVector: function ( vector ) {
	
				var scalar = vector.dot( this ) / vector.lengthSq();
	
				return this.copy( vector ).multiplyScalar( scalar );
	
			},
	
			projectOnPlane: function () {
	
				var v1;
	
				return function projectOnPlane( planeNormal ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
	
					v1.copy( this ).projectOnVector( planeNormal );
	
					return this.sub( v1 );
	
				};
	
			}(),
	
			reflect: function () {
	
				// reflect incident vector off plane orthogonal to normal
				// normal is assumed to have unit length
	
				var v1;
	
				return function reflect( normal ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
	
					return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );
	
				};
	
			}(),
	
			angleTo: function ( v ) {
	
				var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );
	
				// clamp, to handle numerical problems
	
				return Math.acos( _Math.clamp( theta, - 1, 1 ) );
	
			},
	
			distanceTo: function ( v ) {
	
				return Math.sqrt( this.distanceToSquared( v ) );
	
			},
	
			distanceToSquared: function ( v ) {
	
				var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
	
				return dx * dx + dy * dy + dz * dz;
	
			},
	
			distanceToManhattan: function ( v ) {
	
				return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );
	
			},
	
			setFromSpherical: function( s ) {
	
				var sinPhiRadius = Math.sin( s.phi ) * s.radius;
	
				this.x = sinPhiRadius * Math.sin( s.theta );
				this.y = Math.cos( s.phi ) * s.radius;
				this.z = sinPhiRadius * Math.cos( s.theta );
	
				return this;
	
			},
	
			setFromCylindrical: function( c ) {
	
				this.x = c.radius * Math.sin( c.theta );
				this.y = c.y;
				this.z = c.radius * Math.cos( c.theta );
	
				return this;
	
			},
	
			setFromMatrixPosition: function ( m ) {
	
				return this.setFromMatrixColumn( m, 3 );
	
			},
	
			setFromMatrixScale: function ( m ) {
	
				var sx = this.setFromMatrixColumn( m, 0 ).length();
				var sy = this.setFromMatrixColumn( m, 1 ).length();
				var sz = this.setFromMatrixColumn( m, 2 ).length();
	
				this.x = sx;
				this.y = sy;
				this.z = sz;
	
				return this;
	
			},
	
			setFromMatrixColumn: function ( m, index ) {
	
				if ( typeof m === 'number' ) {
	
					console.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );
					var temp = m;
					m = index;
					index = temp;
	
				}
	
				return this.fromArray( m.elements, index * 4 );
	
			},
	
			equals: function ( v ) {
	
				return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.x = array[ offset ];
				this.y = array[ offset + 1 ];
				this.z = array[ offset + 2 ];
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this.x;
				array[ offset + 1 ] = this.y;
				array[ offset + 2 ] = this.z;
	
				return array;
	
			},
	
			fromBufferAttribute: function ( attribute, index, offset ) {
	
				if ( offset !== undefined ) {
	
					console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );
	
				}
	
				this.x = attribute.getX( index );
				this.y = attribute.getY( index );
				this.z = attribute.getZ( index );
	
				return this;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author philogb / http://blog.thejit.org/
		 * @author jordi_ros / http://plattsoft.com
		 * @author D1plo1d / http://github.com/D1plo1d
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author timknip / http://www.floorplanner.com/
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function Matrix4() {
	
			this.elements = new Float32Array( [
	
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
	
			] );
	
			if ( arguments.length > 0 ) {
	
				console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );
	
			}
	
		}
	
		Matrix4.prototype = {
	
			constructor: Matrix4,
	
			isMatrix4: true,
	
			set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
	
				var te = this.elements;
	
				te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
				te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
				te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
				te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;
	
				return this;
	
			},
	
			identity: function () {
	
				this.set(
	
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			clone: function () {
	
				return new Matrix4().fromArray( this.elements );
	
			},
	
			copy: function ( m ) {
	
				this.elements.set( m.elements );
	
				return this;
	
			},
	
			copyPosition: function ( m ) {
	
				var te = this.elements;
				var me = m.elements;
	
				te[ 12 ] = me[ 12 ];
				te[ 13 ] = me[ 13 ];
				te[ 14 ] = me[ 14 ];
	
				return this;
	
			},
	
			extractBasis: function ( xAxis, yAxis, zAxis ) {
	
				xAxis.setFromMatrixColumn( this, 0 );
				yAxis.setFromMatrixColumn( this, 1 );
				zAxis.setFromMatrixColumn( this, 2 );
	
				return this;
	
			},
	
			makeBasis: function ( xAxis, yAxis, zAxis ) {
	
				this.set(
					xAxis.x, yAxis.x, zAxis.x, 0,
					xAxis.y, yAxis.y, zAxis.y, 0,
					xAxis.z, yAxis.z, zAxis.z, 0,
					0,       0,       0,       1
				);
	
				return this;
	
			},
	
			extractRotation: function () {
	
				var v1;
	
				return function extractRotation( m ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
	
					var te = this.elements;
					var me = m.elements;
	
					var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
					var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
					var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();
	
					te[ 0 ] = me[ 0 ] * scaleX;
					te[ 1 ] = me[ 1 ] * scaleX;
					te[ 2 ] = me[ 2 ] * scaleX;
	
					te[ 4 ] = me[ 4 ] * scaleY;
					te[ 5 ] = me[ 5 ] * scaleY;
					te[ 6 ] = me[ 6 ] * scaleY;
	
					te[ 8 ] = me[ 8 ] * scaleZ;
					te[ 9 ] = me[ 9 ] * scaleZ;
					te[ 10 ] = me[ 10 ] * scaleZ;
	
					return this;
	
				};
	
			}(),
	
			makeRotationFromEuler: function ( euler ) {
	
				if ( (euler && euler.isEuler) === false ) {
	
					console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
				}
	
				var te = this.elements;
	
				var x = euler.x, y = euler.y, z = euler.z;
				var a = Math.cos( x ), b = Math.sin( x );
				var c = Math.cos( y ), d = Math.sin( y );
				var e = Math.cos( z ), f = Math.sin( z );
	
				if ( euler.order === 'XYZ' ) {
	
					var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
					te[ 0 ] = c * e;
					te[ 4 ] = - c * f;
					te[ 8 ] = d;
	
					te[ 1 ] = af + be * d;
					te[ 5 ] = ae - bf * d;
					te[ 9 ] = - b * c;
	
					te[ 2 ] = bf - ae * d;
					te[ 6 ] = be + af * d;
					te[ 10 ] = a * c;
	
				} else if ( euler.order === 'YXZ' ) {
	
					var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
					te[ 0 ] = ce + df * b;
					te[ 4 ] = de * b - cf;
					te[ 8 ] = a * d;
	
					te[ 1 ] = a * f;
					te[ 5 ] = a * e;
					te[ 9 ] = - b;
	
					te[ 2 ] = cf * b - de;
					te[ 6 ] = df + ce * b;
					te[ 10 ] = a * c;
	
				} else if ( euler.order === 'ZXY' ) {
	
					var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
					te[ 0 ] = ce - df * b;
					te[ 4 ] = - a * f;
					te[ 8 ] = de + cf * b;
	
					te[ 1 ] = cf + de * b;
					te[ 5 ] = a * e;
					te[ 9 ] = df - ce * b;
	
					te[ 2 ] = - a * d;
					te[ 6 ] = b;
					te[ 10 ] = a * c;
	
				} else if ( euler.order === 'ZYX' ) {
	
					var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
					te[ 0 ] = c * e;
					te[ 4 ] = be * d - af;
					te[ 8 ] = ae * d + bf;
	
					te[ 1 ] = c * f;
					te[ 5 ] = bf * d + ae;
					te[ 9 ] = af * d - be;
	
					te[ 2 ] = - d;
					te[ 6 ] = b * c;
					te[ 10 ] = a * c;
	
				} else if ( euler.order === 'YZX' ) {
	
					var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
					te[ 0 ] = c * e;
					te[ 4 ] = bd - ac * f;
					te[ 8 ] = bc * f + ad;
	
					te[ 1 ] = f;
					te[ 5 ] = a * e;
					te[ 9 ] = - b * e;
	
					te[ 2 ] = - d * e;
					te[ 6 ] = ad * f + bc;
					te[ 10 ] = ac - bd * f;
	
				} else if ( euler.order === 'XZY' ) {
	
					var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
					te[ 0 ] = c * e;
					te[ 4 ] = - f;
					te[ 8 ] = d * e;
	
					te[ 1 ] = ac * f + bd;
					te[ 5 ] = a * e;
					te[ 9 ] = ad * f - bc;
	
					te[ 2 ] = bc * f - ad;
					te[ 6 ] = b * e;
					te[ 10 ] = bd * f + ac;
	
				}
	
				// last column
				te[ 3 ] = 0;
				te[ 7 ] = 0;
				te[ 11 ] = 0;
	
				// bottom row
				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;
	
				return this;
	
			},
	
			makeRotationFromQuaternion: function ( q ) {
	
				var te = this.elements;
	
				var x = q.x, y = q.y, z = q.z, w = q.w;
				var x2 = x + x, y2 = y + y, z2 = z + z;
				var xx = x * x2, xy = x * y2, xz = x * z2;
				var yy = y * y2, yz = y * z2, zz = z * z2;
				var wx = w * x2, wy = w * y2, wz = w * z2;
	
				te[ 0 ] = 1 - ( yy + zz );
				te[ 4 ] = xy - wz;
				te[ 8 ] = xz + wy;
	
				te[ 1 ] = xy + wz;
				te[ 5 ] = 1 - ( xx + zz );
				te[ 9 ] = yz - wx;
	
				te[ 2 ] = xz - wy;
				te[ 6 ] = yz + wx;
				te[ 10 ] = 1 - ( xx + yy );
	
				// last column
				te[ 3 ] = 0;
				te[ 7 ] = 0;
				te[ 11 ] = 0;
	
				// bottom row
				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;
	
				return this;
	
			},
	
			lookAt: function () {
	
				var x, y, z;
	
				return function lookAt( eye, target, up ) {
	
					if ( x === undefined ) {
	
						x = new Vector3();
						y = new Vector3();
						z = new Vector3();
	
					}
	
					var te = this.elements;
	
					z.subVectors( eye, target ).normalize();
	
					if ( z.lengthSq() === 0 ) {
	
						z.z = 1;
	
					}
	
					x.crossVectors( up, z ).normalize();
	
					if ( x.lengthSq() === 0 ) {
	
						z.z += 0.0001;
						x.crossVectors( up, z ).normalize();
	
					}
	
					y.crossVectors( z, x );
	
	
					te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
					te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
					te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;
	
					return this;
	
				};
	
			}(),
	
			multiply: function ( m, n ) {
	
				if ( n !== undefined ) {
	
					console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
					return this.multiplyMatrices( m, n );
	
				}
	
				return this.multiplyMatrices( this, m );
	
			},
	
			premultiply: function ( m ) {
	
				return this.multiplyMatrices( m, this );
	
			},
	
			multiplyMatrices: function ( a, b ) {
	
				var ae = a.elements;
				var be = b.elements;
				var te = this.elements;
	
				var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
				var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
				var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
				var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];
	
				var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
				var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
				var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
				var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];
	
				te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
				te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
				te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
				te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	
				te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
				te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
				te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
				te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	
				te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
				te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
				te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
				te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	
				te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
				te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
				te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
				te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	
				return this;
	
			},
	
			multiplyToArray: function ( a, b, r ) {
	
				var te = this.elements;
	
				this.multiplyMatrices( a, b );
	
				r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
				r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
				r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
				r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];
	
				return this;
	
			},
	
			multiplyScalar: function ( s ) {
	
				var te = this.elements;
	
				te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
				te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
				te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
				te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;
	
				return this;
	
			},
	
			applyToBufferAttribute: function () {
	
				var v1;
	
				return function applyToBufferAttribute( attribute ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
	
					for ( var i = 0, l = attribute.count; i < l; i ++ ) {
	
						v1.x = attribute.getX( i );
						v1.y = attribute.getY( i );
						v1.z = attribute.getZ( i );
	
						v1.applyMatrix4( this );
	
						attribute.setXYZ( i, v1.x, v1.y, v1.z );
	
					}
	
					return attribute;
	
				};
	
			}(),
	
			determinant: function () {
	
				var te = this.elements;
	
				var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
				var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
				var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
				var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];
	
				//TODO: make this more efficient
				//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
	
				return (
					n41 * (
						+ n14 * n23 * n32
						 - n13 * n24 * n32
						 - n14 * n22 * n33
						 + n12 * n24 * n33
						 + n13 * n22 * n34
						 - n12 * n23 * n34
					) +
					n42 * (
						+ n11 * n23 * n34
						 - n11 * n24 * n33
						 + n14 * n21 * n33
						 - n13 * n21 * n34
						 + n13 * n24 * n31
						 - n14 * n23 * n31
					) +
					n43 * (
						+ n11 * n24 * n32
						 - n11 * n22 * n34
						 - n14 * n21 * n32
						 + n12 * n21 * n34
						 + n14 * n22 * n31
						 - n12 * n24 * n31
					) +
					n44 * (
						- n13 * n22 * n31
						 - n11 * n23 * n32
						 + n11 * n22 * n33
						 + n13 * n21 * n32
						 - n12 * n21 * n33
						 + n12 * n23 * n31
					)
	
				);
	
			},
	
			transpose: function () {
	
				var te = this.elements;
				var tmp;
	
				tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
				tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
				tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;
	
				tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
				tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
				tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;
	
				return this;
	
			},
	
			setPosition: function ( v ) {
	
				var te = this.elements;
	
				te[ 12 ] = v.x;
				te[ 13 ] = v.y;
				te[ 14 ] = v.z;
	
				return this;
	
			},
	
			getInverse: function ( m, throwOnDegenerate ) {
	
				// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
				var te = this.elements,
					me = m.elements,
	
					n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
					n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
					n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
					n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],
	
					t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
					t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
					t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
					t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
	
				var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
	
				if ( det === 0 ) {
	
					var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";
	
					if ( throwOnDegenerate === true ) {
	
						throw new Error( msg );
	
					} else {
	
						console.warn( msg );
	
					}
	
					return this.identity();
	
				}
	
				var detInv = 1 / det;
	
				te[ 0 ] = t11 * detInv;
				te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
				te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
				te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;
	
				te[ 4 ] = t12 * detInv;
				te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
				te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
				te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;
	
				te[ 8 ] = t13 * detInv;
				te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
				te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
				te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;
	
				te[ 12 ] = t14 * detInv;
				te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
				te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
				te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;
	
				return this;
	
			},
	
			scale: function ( v ) {
	
				var te = this.elements;
				var x = v.x, y = v.y, z = v.z;
	
				te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
				te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
				te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
				te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;
	
				return this;
	
			},
	
			getMaxScaleOnAxis: function () {
	
				var te = this.elements;
	
				var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
				var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
				var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];
	
				return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );
	
			},
	
			makeTranslation: function ( x, y, z ) {
	
				this.set(
	
					1, 0, 0, x,
					0, 1, 0, y,
					0, 0, 1, z,
					0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			makeRotationX: function ( theta ) {
	
				var c = Math.cos( theta ), s = Math.sin( theta );
	
				this.set(
	
					1, 0,  0, 0,
					0, c, - s, 0,
					0, s,  c, 0,
					0, 0,  0, 1
	
				);
	
				return this;
	
			},
	
			makeRotationY: function ( theta ) {
	
				var c = Math.cos( theta ), s = Math.sin( theta );
	
				this.set(
	
					 c, 0, s, 0,
					 0, 1, 0, 0,
					- s, 0, c, 0,
					 0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			makeRotationZ: function ( theta ) {
	
				var c = Math.cos( theta ), s = Math.sin( theta );
	
				this.set(
	
					c, - s, 0, 0,
					s,  c, 0, 0,
					0,  0, 1, 0,
					0,  0, 0, 1
	
				);
	
				return this;
	
			},
	
			makeRotationAxis: function ( axis, angle ) {
	
				// Based on http://www.gamedev.net/reference/articles/article1199.asp
	
				var c = Math.cos( angle );
				var s = Math.sin( angle );
				var t = 1 - c;
				var x = axis.x, y = axis.y, z = axis.z;
				var tx = t * x, ty = t * y;
	
				this.set(
	
					tx * x + c, tx * y - s * z, tx * z + s * y, 0,
					tx * y + s * z, ty * y + c, ty * z - s * x, 0,
					tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
					0, 0, 0, 1
	
				);
	
				 return this;
	
			},
	
			makeScale: function ( x, y, z ) {
	
				this.set(
	
					x, 0, 0, 0,
					0, y, 0, 0,
					0, 0, z, 0,
					0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			makeShear: function ( x, y, z ) {
	
				this.set(
	
					1, y, z, 0,
					x, 1, z, 0,
					x, y, 1, 0,
					0, 0, 0, 1
	
				);
	
				return this;
	
			},
	
			compose: function ( position, quaternion, scale ) {
	
				this.makeRotationFromQuaternion( quaternion );
				this.scale( scale );
				this.setPosition( position );
	
				return this;
	
			},
	
			decompose: function () {
	
				var vector, matrix;
	
				return function decompose( position, quaternion, scale ) {
	
					if ( vector === undefined ) {
	
						vector = new Vector3();
						matrix = new Matrix4();
	
					}
	
					var te = this.elements;
	
					var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
					var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
					var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();
	
					// if determine is negative, we need to invert one scale
					var det = this.determinant();
					if ( det < 0 ) {
	
						sx = - sx;
	
					}
	
					position.x = te[ 12 ];
					position.y = te[ 13 ];
					position.z = te[ 14 ];
	
					// scale the rotation part
	
					matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()
	
					var invSX = 1 / sx;
					var invSY = 1 / sy;
					var invSZ = 1 / sz;
	
					matrix.elements[ 0 ] *= invSX;
					matrix.elements[ 1 ] *= invSX;
					matrix.elements[ 2 ] *= invSX;
	
					matrix.elements[ 4 ] *= invSY;
					matrix.elements[ 5 ] *= invSY;
					matrix.elements[ 6 ] *= invSY;
	
					matrix.elements[ 8 ] *= invSZ;
					matrix.elements[ 9 ] *= invSZ;
					matrix.elements[ 10 ] *= invSZ;
	
					quaternion.setFromRotationMatrix( matrix );
	
					scale.x = sx;
					scale.y = sy;
					scale.z = sz;
	
					return this;
	
				};
	
			}(),
	
			makePerspective: function ( left, right, top, bottom, near, far ) {
	
				if ( far === undefined ) {
	
					console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );
	
				}
	
				var te = this.elements;
				var x = 2 * near / ( right - left );
				var y = 2 * near / ( top - bottom );
	
				var a = ( right + left ) / ( right - left );
				var b = ( top + bottom ) / ( top - bottom );
				var c = - ( far + near ) / ( far - near );
				var d = - 2 * far * near / ( far - near );
	
				te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
				te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
				te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
				te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;
	
				return this;
	
			},
	
			makeOrthographic: function ( left, right, top, bottom, near, far ) {
	
				var te = this.elements;
				var w = 1.0 / ( right - left );
				var h = 1.0 / ( top - bottom );
				var p = 1.0 / ( far - near );
	
				var x = ( right + left ) * w;
				var y = ( top + bottom ) * h;
				var z = ( far + near ) * p;
	
				te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
				te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
				te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
				te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;
	
				return this;
	
			},
	
			equals: function ( matrix ) {
	
				var te = this.elements;
				var me = matrix.elements;
	
				for ( var i = 0; i < 16; i ++ ) {
	
					if ( te[ i ] !== me[ i ] ) return false;
	
				}
	
				return true;
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				for( var i = 0; i < 16; i ++ ) {
	
					this.elements[ i ] = array[ i + offset ];
	
				}
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				var te = this.elements;
	
				array[ offset ] = te[ 0 ];
				array[ offset + 1 ] = te[ 1 ];
				array[ offset + 2 ] = te[ 2 ];
				array[ offset + 3 ] = te[ 3 ];
	
				array[ offset + 4 ] = te[ 4 ];
				array[ offset + 5 ] = te[ 5 ];
				array[ offset + 6 ] = te[ 6 ];
				array[ offset + 7 ] = te[ 7 ];
	
				array[ offset + 8 ]  = te[ 8 ];
				array[ offset + 9 ]  = te[ 9 ];
				array[ offset + 10 ] = te[ 10 ];
				array[ offset + 11 ] = te[ 11 ];
	
				array[ offset + 12 ] = te[ 12 ];
				array[ offset + 13 ] = te[ 13 ];
				array[ offset + 14 ] = te[ 14 ];
				array[ offset + 15 ] = te[ 15 ];
	
				return array;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
	
			images = images !== undefined ? images : [];
			mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
	
			Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
			this.flipY = false;
	
		}
	
		CubeTexture.prototype = Object.create( Texture.prototype );
		CubeTexture.prototype.constructor = CubeTexture;
	
		CubeTexture.prototype.isCubeTexture = true;
	
		Object.defineProperty( CubeTexture.prototype, 'images', {
	
			get: function () {
	
				return this.image;
	
			},
	
			set: function ( value ) {
	
				this.image = value;
	
			}
	
		} );
	
		/**
		 * @author tschw
		 *
		 * Uniforms of a program.
		 * Those form a tree structure with a special top-level container for the root,
		 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
		 *
		 *
		 * Properties of inner nodes including the top-level container:
		 *
		 * .seq - array of nested uniforms
		 * .map - nested uniforms by name
		 *
		 *
		 * Methods of all nodes except the top-level container:
		 *
		 * .setValue( gl, value, [renderer] )
		 *
		 * 		uploads a uniform value(s)
		 *  	the 'renderer' parameter is needed for sampler uniforms
		 *
		 *
		 * Static methods of the top-level container (renderer factorizations):
		 *
		 * .upload( gl, seq, values, renderer )
		 *
		 * 		sets uniforms in 'seq' to 'values[id].value'
		 *
		 * .seqWithValue( seq, values ) : filteredSeq
		 *
		 * 		filters 'seq' entries with corresponding entry in values
		 *
		 *
		 * Methods of the top-level container (renderer factorizations):
		 *
		 * .setValue( gl, name, value )
		 *
		 * 		sets uniform with  name 'name' to 'value'
		 *
		 * .set( gl, obj, prop )
		 *
		 * 		sets uniform from object and property with same name than uniform
		 *
		 * .setOptional( gl, obj, prop )
		 *
		 * 		like .set for an optional property of the object
		 *
		 */
	
		var emptyTexture = new Texture();
		var emptyCubeTexture = new CubeTexture();
	
		// --- Base for inner nodes (including the root) ---
	
		function UniformContainer() {
	
			this.seq = [];
			this.map = {};
	
		}
	
		// --- Utilities ---
	
		// Array Caches (provide typed arrays for temporary by size)
	
		var arrayCacheF32 = [];
		var arrayCacheI32 = [];
	
		// Flattening for arrays of vectors and matrices
	
		function flatten( array, nBlocks, blockSize ) {
	
			var firstElem = array[ 0 ];
	
			if ( firstElem <= 0 || firstElem > 0 ) return array;
			// unoptimized: ! isNaN( firstElem )
			// see http://jacksondunstan.com/articles/983
	
			var n = nBlocks * blockSize,
				r = arrayCacheF32[ n ];
	
			if ( r === undefined ) {
	
				r = new Float32Array( n );
				arrayCacheF32[ n ] = r;
	
			}
	
			if ( nBlocks !== 0 ) {
	
				firstElem.toArray( r, 0 );
	
				for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {
	
					offset += blockSize;
					array[ i ].toArray( r, offset );
	
				}
	
			}
	
			return r;
	
		}
	
		// Texture unit allocation
	
		function allocTexUnits( renderer, n ) {
	
			var r = arrayCacheI32[ n ];
	
			if ( r === undefined ) {
	
				r = new Int32Array( n );
				arrayCacheI32[ n ] = r;
	
			}
	
			for ( var i = 0; i !== n; ++ i )
				r[ i ] = renderer.allocTextureUnit();
	
			return r;
	
		}
	
		// --- Setters ---
	
		// Note: Defining these methods externally, because they come in a bunch
		// and this way their names minify.
	
		// Single scalar
	
		function setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }
		function setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }
	
		// Single float vector (from flat array or THREE.VectorN)
	
		function setValue2fv( gl, v ) {
	
			if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
			else gl.uniform2f( this.addr, v.x, v.y );
	
		}
	
		function setValue3fv( gl, v ) {
	
			if ( v.x !== undefined )
				gl.uniform3f( this.addr, v.x, v.y, v.z );
			else if ( v.r !== undefined )
				gl.uniform3f( this.addr, v.r, v.g, v.b );
			else
				gl.uniform3fv( this.addr, v );
	
		}
	
		function setValue4fv( gl, v ) {
	
			if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
			else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );
	
		}
	
		// Single matrix (from flat array or MatrixN)
	
		function setValue2fm( gl, v ) {
	
			gl.uniformMatrix2fv( this.addr, false, v.elements || v );
	
		}
	
		function setValue3fm( gl, v ) {
	
			gl.uniformMatrix3fv( this.addr, false, v.elements || v );
	
		}
	
		function setValue4fm( gl, v ) {
	
			gl.uniformMatrix4fv( this.addr, false, v.elements || v );
	
		}
	
		// Single texture (2D / Cube)
	
		function setValueT1( gl, v, renderer ) {
	
			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			renderer.setTexture2D( v || emptyTexture, unit );
	
		}
	
		function setValueT6( gl, v, renderer ) {
	
			var unit = renderer.allocTextureUnit();
			gl.uniform1i( this.addr, unit );
			renderer.setTextureCube( v || emptyCubeTexture, unit );
	
		}
	
		// Integer / Boolean vectors or arrays thereof (always flat arrays)
	
		function setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }
		function setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }
		function setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }
	
		// Helper to pick the right setter for the singular case
	
		function getSingularSetter( type ) {
	
			switch ( type ) {
	
				case 0x1406: return setValue1f; // FLOAT
				case 0x8b50: return setValue2fv; // _VEC2
				case 0x8b51: return setValue3fv; // _VEC3
				case 0x8b52: return setValue4fv; // _VEC4
	
				case 0x8b5a: return setValue2fm; // _MAT2
				case 0x8b5b: return setValue3fm; // _MAT3
				case 0x8b5c: return setValue4fm; // _MAT4
	
				case 0x8b5e: return setValueT1; // SAMPLER_2D
				case 0x8b60: return setValueT6; // SAMPLER_CUBE
	
				case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4
	
			}
	
		}
	
		// Array of scalars
	
		function setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }
		function setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }
	
		// Array of vectors (flat or from THREE classes)
	
		function setValueV2a( gl, v ) {
	
			gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );
	
		}
	
		function setValueV3a( gl, v ) {
	
			gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );
	
		}
	
		function setValueV4a( gl, v ) {
	
			gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );
	
		}
	
		// Array of matrices (flat or from THREE clases)
	
		function setValueM2a( gl, v ) {
	
			gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );
	
		}
	
		function setValueM3a( gl, v ) {
	
			gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );
	
		}
	
		function setValueM4a( gl, v ) {
	
			gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );
	
		}
	
		// Array of textures (2D / Cube)
	
		function setValueT1a( gl, v, renderer ) {
	
			var n = v.length,
				units = allocTexUnits( renderer, n );
	
			gl.uniform1iv( this.addr, units );
	
			for ( var i = 0; i !== n; ++ i ) {
	
				renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );
	
			}
	
		}
	
		function setValueT6a( gl, v, renderer ) {
	
			var n = v.length,
				units = allocTexUnits( renderer, n );
	
			gl.uniform1iv( this.addr, units );
	
			for ( var i = 0; i !== n; ++ i ) {
	
				renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );
	
			}
	
		}
	
		// Helper to pick the right setter for a pure (bottom-level) array
	
		function getPureArraySetter( type ) {
	
			switch ( type ) {
	
				case 0x1406: return setValue1fv; // FLOAT
				case 0x8b50: return setValueV2a; // _VEC2
				case 0x8b51: return setValueV3a; // _VEC3
				case 0x8b52: return setValueV4a; // _VEC4
	
				case 0x8b5a: return setValueM2a; // _MAT2
				case 0x8b5b: return setValueM3a; // _MAT3
				case 0x8b5c: return setValueM4a; // _MAT4
	
				case 0x8b5e: return setValueT1a; // SAMPLER_2D
				case 0x8b60: return setValueT6a; // SAMPLER_CUBE
	
				case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
				case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
				case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
				case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4
	
			}
	
		}
	
		// --- Uniform Classes ---
	
		function SingleUniform( id, activeInfo, addr ) {
	
			this.id = id;
			this.addr = addr;
			this.setValue = getSingularSetter( activeInfo.type );
	
			// this.path = activeInfo.name; // DEBUG
	
		}
	
		function PureArrayUniform( id, activeInfo, addr ) {
	
			this.id = id;
			this.addr = addr;
			this.size = activeInfo.size;
			this.setValue = getPureArraySetter( activeInfo.type );
	
			// this.path = activeInfo.name; // DEBUG
	
		}
	
		function StructuredUniform( id ) {
	
			this.id = id;
	
			UniformContainer.call( this ); // mix-in
	
		}
	
		StructuredUniform.prototype.setValue = function( gl, value ) {
	
			// Note: Don't need an extra 'renderer' parameter, since samplers
			// are not allowed in structured uniforms.
	
			var seq = this.seq;
	
			for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
				var u = seq[ i ];
				u.setValue( gl, value[ u.id ] );
	
			}
	
		};
	
		// --- Top-level ---
	
		// Parser - builds up the property tree from the path strings
	
		var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
	
		// extracts
		// 	- the identifier (member name or array index)
		//  - followed by an optional right bracket (found when array index)
		//  - followed by an optional left bracket or dot (type of subscript)
		//
		// Note: These portions can be read in a non-overlapping fashion and
		// allow straightforward parsing of the hierarchy that WebGL encodes
		// in the uniform names.
	
		function addUniform( container, uniformObject ) {
	
			container.seq.push( uniformObject );
			container.map[ uniformObject.id ] = uniformObject;
	
		}
	
		function parseUniform( activeInfo, addr, container ) {
	
			var path = activeInfo.name,
				pathLength = path.length;
	
			// reset RegExp object, because of the early exit of a previous run
			RePathPart.lastIndex = 0;
	
			for (; ;) {
	
				var match = RePathPart.exec( path ),
					matchEnd = RePathPart.lastIndex,
	
					id = match[ 1 ],
					idIsIndex = match[ 2 ] === ']',
					subscript = match[ 3 ];
	
				if ( idIsIndex ) id = id | 0; // convert to integer
	
				if ( subscript === undefined ||
						subscript === '[' && matchEnd + 2 === pathLength ) {
					// bare name or "pure" bottom-level array "[0]" suffix
	
					addUniform( container, subscript === undefined ?
							new SingleUniform( id, activeInfo, addr ) :
							new PureArrayUniform( id, activeInfo, addr ) );
	
					break;
	
				} else {
					// step into inner node / create it in case it doesn't exist
	
					var map = container.map,
						next = map[ id ];
	
					if ( next === undefined ) {
	
						next = new StructuredUniform( id );
						addUniform( container, next );
	
					}
	
					container = next;
	
				}
	
			}
	
		}
	
		// Root Container
	
		function WebGLUniforms( gl, program, renderer ) {
	
			UniformContainer.call( this );
	
			this.renderer = renderer;
	
			var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );
	
			for ( var i = 0; i < n; ++ i ) {
	
				var info = gl.getActiveUniform( program, i ),
					path = info.name,
					addr = gl.getUniformLocation( program, path );
	
				parseUniform( info, addr, this );
	
			}
	
		}
	
		WebGLUniforms.prototype.setValue = function( gl, name, value ) {
	
			var u = this.map[ name ];
	
			if ( u !== undefined ) u.setValue( gl, value, this.renderer );
	
		};
	
		WebGLUniforms.prototype.set = function( gl, object, name ) {
	
			var u = this.map[ name ];
	
			if ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );
	
		};
	
		WebGLUniforms.prototype.setOptional = function( gl, object, name ) {
	
			var v = object[ name ];
	
			if ( v !== undefined ) this.setValue( gl, name, v );
	
		};
	
	
		// Static interface
	
		WebGLUniforms.upload = function( gl, seq, values, renderer ) {
	
			for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
				var u = seq[ i ],
					v = values[ u.id ];
	
				if ( v.needsUpdate !== false ) {
					// note: always updating when .needsUpdate is undefined
	
					u.setValue( gl, v.value, renderer );
	
				}
	
			}
	
		};
	
		WebGLUniforms.seqWithValue = function( seq, values ) {
	
			var r = [];
	
			for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
				var u = seq[ i ];
				if ( u.id in values ) r.push( u );
	
			}
	
			return r;
	
		};
	
		/**
		 * Uniform Utilities
		 */
	
		var UniformsUtils = {
	
			merge: function ( uniforms ) {
	
				var merged = {};
	
				for ( var u = 0; u < uniforms.length; u ++ ) {
	
					var tmp = this.clone( uniforms[ u ] );
	
					for ( var p in tmp ) {
	
						merged[ p ] = tmp[ p ];
	
					}
	
				}
	
				return merged;
	
			},
	
			clone: function ( uniforms_src ) {
	
				var uniforms_dst = {};
	
				for ( var u in uniforms_src ) {
	
					uniforms_dst[ u ] = {};
	
					for ( var p in uniforms_src[ u ] ) {
	
						var parameter_src = uniforms_src[ u ][ p ];
	
						if ( parameter_src && ( parameter_src.isColor ||
							parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
							parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
							parameter_src.isTexture ) ) {
	
							uniforms_dst[ u ][ p ] = parameter_src.clone();
	
						} else if ( Array.isArray( parameter_src ) ) {
	
							uniforms_dst[ u ][ p ] = parameter_src.slice();
	
						} else {
	
							uniforms_dst[ u ][ p ] = parameter_src;
	
						}
	
					}
	
				}
	
				return uniforms_dst;
	
			}
	
		};
	
		var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";
	
		var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";
	
		var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";
	
		var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";
	
		var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
	
		var begin_vertex = "\nvec3 transformed = vec3( position );\n";
	
		var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";
	
		var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 ltcTextureCoords( const in GeometricContext geometry, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5/LUT_SIZE;\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nvoid clipQuadToHorizon( inout vec3 L[5], out int n ) {\n\tint config = 0;\n\tif ( L[0].z > 0.0 ) config += 1;\n\tif ( L[1].z > 0.0 ) config += 2;\n\tif ( L[2].z > 0.0 ) config += 4;\n\tif ( L[3].z > 0.0 ) config += 8;\n\tn = 0;\n\tif ( config == 0 ) {\n\t} else if ( config == 1 ) {\n\t\tn = 3;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 2 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 3 ) {\n\t\tn = 4;\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t\tL[3] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 4 ) {\n\t\tn = 3;\n\t\tL[0] = -L[3].z * L[2] + L[2].z * L[3];\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t} else if ( config == 5 ) {\n\t\tn = 0;\n\t} else if ( config == 6 ) {\n\t\tn = 4;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 7 ) {\n\t\tn = 5;\n\t\tL[4] = -L[3].z * L[0] + L[0].z * L[3];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 8 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[1] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] =  L[3];\n\t} else if ( config == 9 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[2].z * L[3] + L[3].z * L[2];\n\t} else if ( config == 10 ) {\n\t\tn = 0;\n\t} else if ( config == 11 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 12 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t} else if ( config == 13 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = L[2];\n\t\tL[2] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t} else if ( config == 14 ) {\n\t\tn = 5;\n\t\tL[4] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t} else if ( config == 15 ) {\n\t\tn = 4;\n\t}\n\tif ( n == 3 )\n\t\tL[3] = L[0];\n\tif ( n == 4 )\n\t\tL[4] = L[0];\n}\nfloat integrateLtcBrdfOverRectEdge( vec3 v1, vec3 v2 ) {\n\tfloat cosTheta = dot( v1, v2 );\n\tfloat theta = acos( cosTheta );\n\tfloat res = cross( v1, v2 ).z * ( ( theta > 0.001 ) ? theta / sin( theta ) : 1.0 );\n\treturn res;\n}\nvoid initRectPoints( const in vec3 pos, const in vec3 halfWidth, const in vec3 halfHeight, out vec3 rectPoints[4] ) {\n\trectPoints[0] = pos - halfWidth - halfHeight;\n\trectPoints[1] = pos + halfWidth - halfHeight;\n\trectPoints[2] = pos + halfWidth + halfHeight;\n\trectPoints[3] = pos - halfWidth + halfHeight;\n}\nvec3 integrateLtcBrdfOverRect( const in GeometricContext geometry, const in mat3 brdfMat, const in vec3 rectPoints[4] ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot( V, N ));\n\tT2 = - cross( N, T1 );\n\tmat3 brdfWrtSurface = brdfMat * transpose( mat3( T1, T2, N ) );\n\tvec3 clippedRect[5];\n\tclippedRect[0] = brdfWrtSurface * ( rectPoints[0] - P );\n\tclippedRect[1] = brdfWrtSurface * ( rectPoints[1] - P );\n\tclippedRect[2] = brdfWrtSurface * ( rectPoints[2] - P );\n\tclippedRect[3] = brdfWrtSurface * ( rectPoints[3] - P );\n\tint n;\n\tclipQuadToHorizon(clippedRect, n);\n\tif ( n == 0 )\n\t\treturn vec3( 0, 0, 0 );\n\tclippedRect[0] = normalize( clippedRect[0] );\n\tclippedRect[1] = normalize( clippedRect[1] );\n\tclippedRect[2] = normalize( clippedRect[2] );\n\tclippedRect[3] = normalize( clippedRect[3] );\n\tclippedRect[4] = normalize( clippedRect[4] );\n\tfloat sum = 0.0;\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[0], clippedRect[1] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[1], clippedRect[2] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[2], clippedRect[3] );\n\tif (n >= 4)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[3], clippedRect[4] );\n\tif (n == 5)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[4], clippedRect[0] );\n\tsum = max( 0.0, sum );\n\tvec3 Lo_i = vec3( sum, sum, sum );\n\treturn Lo_i;\n}\nvec3 Rect_Area_Light_Specular_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight,\n\t\tconst in float roughness,\n\t\tconst in sampler2D ltcMat, const in sampler2D ltcMag ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tvec2 uv = ltcTextureCoords( geometry, roughness );\n\tvec4 brdfLtcApproxParams, t;\n\tbrdfLtcApproxParams = texture2D( ltcMat, uv );\n\tt = texture2D( ltcMat, uv );\n\tfloat brdfLtcScalar = texture2D( ltcMag, uv ).a;\n\tmat3 brdfLtcApproxMat = mat3(\n\t\tvec3(   1,   0, t.y ),\n\t\tvec3(   0, t.z,   0 ),\n\t\tvec3( t.w,   0, t.x )\n\t);\n\tvec3 specularReflectance = integrateLtcBrdfOverRect( geometry, brdfLtcApproxMat, rectPoints );\n\tspecularReflectance *= brdfLtcScalar;\n\treturn specularReflectance;\n}\nvec3 Rect_Area_Light_Diffuse_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tmat3 diffuseBrdfMat = mat3(1);\n\tvec3 diffuseReflectance = integrateLtcBrdfOverRect( geometry, diffuseBrdfMat, rectPoints );\n\treturn diffuseReflectance;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";
	
		var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";
	
		var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";
	
		var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";
	
		var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";
	
		var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";
	
		var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
	
		var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";
	
		var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
	
		var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
	
		var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n";
	
		var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";
	
		var defaultnormal_vertex = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";
	
		var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";
	
		var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";
	
		var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";
	
		var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";
	
		var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";
	
		var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM            = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.x, max( value.g, value.b ) );\n\tfloat D      = max( maxRange / maxRGB, 1.0 );\n\tD            = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n\tXp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract(Le);\n\tvResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n\treturn vec4( max(vRGB, 0.0), 1.0 );\n}\n";
	
		var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";
	
		var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";
	
		var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";
	
		var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";
	
		var fog_vertex = "\n#ifdef USE_FOG\nfogDepth = -mvPosition.z;\n#endif";
	
		var fog_pars_vertex = "#ifdef USE_FOG\n  varying float fogDepth;\n#endif\n";
	
		var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";
	
		var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif\n";
	
		var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";
	
		var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";
	
		var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
	
		var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";
	
		var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";
	
		var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";
	
		var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec / PI2;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff / PI2;\n\t}\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";
	
		var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";
	
		var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 matDiffColor = material.diffuseColor;\n\t\tvec3 matSpecColor = material.specularColor;\n\t\tvec3 lightColor   = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 spec = Rect_Area_Light_Specular_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n\t\t\t\troughness,\n\t\t\t\tltcMat, ltcMag );\n\t\tvec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n\t\t\t\tgeometry,\n\t\t\t\trectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n\t\treflectedLight.directSpecular += lightColor * matSpecColor * spec;\n\t\treflectedLight.directDiffuse  += lightColor * matDiffColor * diff;\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";
	
		var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";
	
		var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";
	
		var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";
	
		var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";
	
		var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";
	
		var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";
	
		var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";
	
		var map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";
	
		var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";
	
		var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n";
	
		var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
	
		var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";
	
		var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
	
		var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";
	
		var normal_flip = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";
	
		var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";
	
		var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";
	
		var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";
	
		var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";
	
		var project_vertex = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";
	
		var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n";
	
		var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
	
		var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";
	
		var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif\n";
	
		var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif\n";
	
		var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";
	
		var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
	
		var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";
	
		var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";
	
		var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";
	
		var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
	
		var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
	
		var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";
	
		var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";
	
		var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";
	
		var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";
	
		var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";
	
		var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
	
		var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";
	
		var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";
	
		var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";
	
		var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";
	
		var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";
	
		var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";
	
		var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";
	
		var distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";
	
		var distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";
	
		var equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";
	
		var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";
	
		var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}\n";
	
		var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";
	
		var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";
	
		var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}\n";
	
		var shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0 - getShadowMask() ) );\n}\n";
	
		var shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";
	
		var ShaderChunk = {
			alphamap_fragment: alphamap_fragment,
			alphamap_pars_fragment: alphamap_pars_fragment,
			alphatest_fragment: alphatest_fragment,
			aomap_fragment: aomap_fragment,
			aomap_pars_fragment: aomap_pars_fragment,
			begin_vertex: begin_vertex,
			beginnormal_vertex: beginnormal_vertex,
			bsdfs: bsdfs,
			bumpmap_pars_fragment: bumpmap_pars_fragment,
			clipping_planes_fragment: clipping_planes_fragment,
			clipping_planes_pars_fragment: clipping_planes_pars_fragment,
			clipping_planes_pars_vertex: clipping_planes_pars_vertex,
			clipping_planes_vertex: clipping_planes_vertex,
			color_fragment: color_fragment,
			color_pars_fragment: color_pars_fragment,
			color_pars_vertex: color_pars_vertex,
			color_vertex: color_vertex,
			common: common,
			cube_uv_reflection_fragment: cube_uv_reflection_fragment,
			defaultnormal_vertex: defaultnormal_vertex,
			displacementmap_pars_vertex: displacementmap_pars_vertex,
			displacementmap_vertex: displacementmap_vertex,
			emissivemap_fragment: emissivemap_fragment,
			emissivemap_pars_fragment: emissivemap_pars_fragment,
			encodings_fragment: encodings_fragment,
			encodings_pars_fragment: encodings_pars_fragment,
			envmap_fragment: envmap_fragment,
			envmap_pars_fragment: envmap_pars_fragment,
			envmap_pars_vertex: envmap_pars_vertex,
			envmap_vertex: envmap_vertex,
			fog_vertex: fog_vertex,
			fog_pars_vertex: fog_pars_vertex,
			fog_fragment: fog_fragment,
			fog_pars_fragment: fog_pars_fragment,
			gradientmap_pars_fragment: gradientmap_pars_fragment,
			lightmap_fragment: lightmap_fragment,
			lightmap_pars_fragment: lightmap_pars_fragment,
			lights_lambert_vertex: lights_lambert_vertex,
			lights_pars: lights_pars,
			lights_phong_fragment: lights_phong_fragment,
			lights_phong_pars_fragment: lights_phong_pars_fragment,
			lights_physical_fragment: lights_physical_fragment,
			lights_physical_pars_fragment: lights_physical_pars_fragment,
			lights_template: lights_template,
			logdepthbuf_fragment: logdepthbuf_fragment,
			logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
			logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
			logdepthbuf_vertex: logdepthbuf_vertex,
			map_fragment: map_fragment,
			map_pars_fragment: map_pars_fragment,
			map_particle_fragment: map_particle_fragment,
			map_particle_pars_fragment: map_particle_pars_fragment,
			metalnessmap_fragment: metalnessmap_fragment,
			metalnessmap_pars_fragment: metalnessmap_pars_fragment,
			morphnormal_vertex: morphnormal_vertex,
			morphtarget_pars_vertex: morphtarget_pars_vertex,
			morphtarget_vertex: morphtarget_vertex,
			normal_flip: normal_flip,
			normal_fragment: normal_fragment,
			normalmap_pars_fragment: normalmap_pars_fragment,
			packing: packing,
			premultiplied_alpha_fragment: premultiplied_alpha_fragment,
			project_vertex: project_vertex,
			roughnessmap_fragment: roughnessmap_fragment,
			roughnessmap_pars_fragment: roughnessmap_pars_fragment,
			shadowmap_pars_fragment: shadowmap_pars_fragment,
			shadowmap_pars_vertex: shadowmap_pars_vertex,
			shadowmap_vertex: shadowmap_vertex,
			shadowmask_pars_fragment: shadowmask_pars_fragment,
			skinbase_vertex: skinbase_vertex,
			skinning_pars_vertex: skinning_pars_vertex,
			skinning_vertex: skinning_vertex,
			skinnormal_vertex: skinnormal_vertex,
			specularmap_fragment: specularmap_fragment,
			specularmap_pars_fragment: specularmap_pars_fragment,
			tonemapping_fragment: tonemapping_fragment,
			tonemapping_pars_fragment: tonemapping_pars_fragment,
			uv_pars_fragment: uv_pars_fragment,
			uv_pars_vertex: uv_pars_vertex,
			uv_vertex: uv_vertex,
			uv2_pars_fragment: uv2_pars_fragment,
			uv2_pars_vertex: uv2_pars_vertex,
			uv2_vertex: uv2_vertex,
			worldpos_vertex: worldpos_vertex,
	
			cube_frag: cube_frag,
			cube_vert: cube_vert,
			depth_frag: depth_frag,
			depth_vert: depth_vert,
			distanceRGBA_frag: distanceRGBA_frag,
			distanceRGBA_vert: distanceRGBA_vert,
			equirect_frag: equirect_frag,
			equirect_vert: equirect_vert,
			linedashed_frag: linedashed_frag,
			linedashed_vert: linedashed_vert,
			meshbasic_frag: meshbasic_frag,
			meshbasic_vert: meshbasic_vert,
			meshlambert_frag: meshlambert_frag,
			meshlambert_vert: meshlambert_vert,
			meshphong_frag: meshphong_frag,
			meshphong_vert: meshphong_vert,
			meshphysical_frag: meshphysical_frag,
			meshphysical_vert: meshphysical_vert,
			normal_frag: normal_frag,
			normal_vert: normal_vert,
			points_frag: points_frag,
			points_vert: points_vert,
			shadow_frag: shadow_frag,
			shadow_vert: shadow_vert
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Color( r, g, b ) {
	
			if ( g === undefined && b === undefined ) {
	
				// r is THREE.Color, hex or string
				return this.set( r );
	
			}
	
			return this.setRGB( r, g, b );
	
		}
	
		Color.prototype = {
	
			constructor: Color,
	
			isColor: true,
	
			r: 1, g: 1, b: 1,
	
			set: function ( value ) {
	
				if ( value && value.isColor ) {
	
					this.copy( value );
	
				} else if ( typeof value === 'number' ) {
	
					this.setHex( value );
	
				} else if ( typeof value === 'string' ) {
	
					this.setStyle( value );
	
				}
	
				return this;
	
			},
	
			setScalar: function ( scalar ) {
	
				this.r = scalar;
				this.g = scalar;
				this.b = scalar;
	
				return this;
	
			},
	
			setHex: function ( hex ) {
	
				hex = Math.floor( hex );
	
				this.r = ( hex >> 16 & 255 ) / 255;
				this.g = ( hex >> 8 & 255 ) / 255;
				this.b = ( hex & 255 ) / 255;
	
				return this;
	
			},
	
			setRGB: function ( r, g, b ) {
	
				this.r = r;
				this.g = g;
				this.b = b;
	
				return this;
	
			},
	
			setHSL: function () {
	
				function hue2rgb( p, q, t ) {
	
					if ( t < 0 ) t += 1;
					if ( t > 1 ) t -= 1;
					if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
					if ( t < 1 / 2 ) return q;
					if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
					return p;
	
				}
	
				return function setHSL( h, s, l ) {
	
					// h,s,l ranges are in 0.0 - 1.0
					h = _Math.euclideanModulo( h, 1 );
					s = _Math.clamp( s, 0, 1 );
					l = _Math.clamp( l, 0, 1 );
	
					if ( s === 0 ) {
	
						this.r = this.g = this.b = l;
	
					} else {
	
						var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
						var q = ( 2 * l ) - p;
	
						this.r = hue2rgb( q, p, h + 1 / 3 );
						this.g = hue2rgb( q, p, h );
						this.b = hue2rgb( q, p, h - 1 / 3 );
	
					}
	
					return this;
	
				};
	
			}(),
	
			setStyle: function ( style ) {
	
				function handleAlpha( string ) {
	
					if ( string === undefined ) return;
	
					if ( parseFloat( string ) < 1 ) {
	
						console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );
	
					}
	
				}
	
	
				var m;
	
				if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {
	
					// rgb / hsl
	
					var color;
					var name = m[ 1 ];
					var components = m[ 2 ];
	
					switch ( name ) {
	
						case 'rgb':
						case 'rgba':
	
							if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
								// rgb(255,0,0) rgba(255,0,0,0.5)
								this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
								this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
								this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
	
								handleAlpha( color[ 5 ] );
	
								return this;
	
							}
	
							if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
								// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
								this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
								this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
								this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
	
								handleAlpha( color[ 5 ] );
	
								return this;
	
							}
	
							break;
	
						case 'hsl':
						case 'hsla':
	
							if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
								// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
								var h = parseFloat( color[ 1 ] ) / 360;
								var s = parseInt( color[ 2 ], 10 ) / 100;
								var l = parseInt( color[ 3 ], 10 ) / 100;
	
								handleAlpha( color[ 5 ] );
	
								return this.setHSL( h, s, l );
	
							}
	
							break;
	
					}
	
				} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {
	
					// hex color
	
					var hex = m[ 1 ];
					var size = hex.length;
	
					if ( size === 3 ) {
	
						// #ff0
						this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
						this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
						this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;
	
						return this;
	
					} else if ( size === 6 ) {
	
						// #ff0000
						this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
						this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
						this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;
	
						return this;
	
					}
	
				}
	
				if ( style && style.length > 0 ) {
	
					// color keywords
					var hex = ColorKeywords[ style ];
	
					if ( hex !== undefined ) {
	
						// red
						this.setHex( hex );
	
					} else {
	
						// unknown color
						console.warn( 'THREE.Color: Unknown color ' + style );
	
					}
	
				}
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor( this.r, this.g, this.b );
	
			},
	
			copy: function ( color ) {
	
				this.r = color.r;
				this.g = color.g;
				this.b = color.b;
	
				return this;
	
			},
	
			copyGammaToLinear: function ( color, gammaFactor ) {
	
				if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
				this.r = Math.pow( color.r, gammaFactor );
				this.g = Math.pow( color.g, gammaFactor );
				this.b = Math.pow( color.b, gammaFactor );
	
				return this;
	
			},
	
			copyLinearToGamma: function ( color, gammaFactor ) {
	
				if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
				var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;
	
				this.r = Math.pow( color.r, safeInverse );
				this.g = Math.pow( color.g, safeInverse );
				this.b = Math.pow( color.b, safeInverse );
	
				return this;
	
			},
	
			convertGammaToLinear: function () {
	
				var r = this.r, g = this.g, b = this.b;
	
				this.r = r * r;
				this.g = g * g;
				this.b = b * b;
	
				return this;
	
			},
	
			convertLinearToGamma: function () {
	
				this.r = Math.sqrt( this.r );
				this.g = Math.sqrt( this.g );
				this.b = Math.sqrt( this.b );
	
				return this;
	
			},
	
			getHex: function () {
	
				return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;
	
			},
	
			getHexString: function () {
	
				return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );
	
			},
	
			getHSL: function ( optionalTarget ) {
	
				// h,s,l ranges are in 0.0 - 1.0
	
				var hsl = optionalTarget || { h: 0, s: 0, l: 0 };
	
				var r = this.r, g = this.g, b = this.b;
	
				var max = Math.max( r, g, b );
				var min = Math.min( r, g, b );
	
				var hue, saturation;
				var lightness = ( min + max ) / 2.0;
	
				if ( min === max ) {
	
					hue = 0;
					saturation = 0;
	
				} else {
	
					var delta = max - min;
	
					saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );
	
					switch ( max ) {
	
						case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
						case g: hue = ( b - r ) / delta + 2; break;
						case b: hue = ( r - g ) / delta + 4; break;
	
					}
	
					hue /= 6;
	
				}
	
				hsl.h = hue;
				hsl.s = saturation;
				hsl.l = lightness;
	
				return hsl;
	
			},
	
			getStyle: function () {
	
				return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';
	
			},
	
			offsetHSL: function ( h, s, l ) {
	
				var hsl = this.getHSL();
	
				hsl.h += h; hsl.s += s; hsl.l += l;
	
				this.setHSL( hsl.h, hsl.s, hsl.l );
	
				return this;
	
			},
	
			add: function ( color ) {
	
				this.r += color.r;
				this.g += color.g;
				this.b += color.b;
	
				return this;
	
			},
	
			addColors: function ( color1, color2 ) {
	
				this.r = color1.r + color2.r;
				this.g = color1.g + color2.g;
				this.b = color1.b + color2.b;
	
				return this;
	
			},
	
			addScalar: function ( s ) {
	
				this.r += s;
				this.g += s;
				this.b += s;
	
				return this;
	
			},
	
			sub: function( color ) {
	
				this.r = Math.max( 0, this.r - color.r );
				this.g = Math.max( 0, this.g - color.g );
				this.b = Math.max( 0, this.b - color.b );
	
				return this;
	
			},
	
			multiply: function ( color ) {
	
				this.r *= color.r;
				this.g *= color.g;
				this.b *= color.b;
	
				return this;
	
			},
	
			multiplyScalar: function ( s ) {
	
				this.r *= s;
				this.g *= s;
				this.b *= s;
	
				return this;
	
			},
	
			lerp: function ( color, alpha ) {
	
				this.r += ( color.r - this.r ) * alpha;
				this.g += ( color.g - this.g ) * alpha;
				this.b += ( color.b - this.b ) * alpha;
	
				return this;
	
			},
	
			equals: function ( c ) {
	
				return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.r = array[ offset ];
				this.g = array[ offset + 1 ];
				this.b = array[ offset + 2 ];
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this.r;
				array[ offset + 1 ] = this.g;
				array[ offset + 2 ] = this.b;
	
				return array;
	
			},
	
			toJSON: function () {
	
				return this.getHex();
	
			}
	
		};
	
		var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
	
			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
			this.image = { data: data, width: width, height: height };
	
			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
	
			this.generateMipmaps  = false;
			this.flipY = false;
			this.unpackAlignment = 1;
	
		}
	
		DataTexture.prototype = Object.create( Texture.prototype );
		DataTexture.prototype.constructor = DataTexture;
	
		DataTexture.prototype.isDataTexture = true;
	
		/**
		 * Uniforms library for shared webgl shaders
		 */
	
		var UniformsLib = {
	
			common: {
	
				diffuse: { value: new Color( 0xeeeeee ) },
				opacity: { value: 1.0 },
	
				map: { value: null },
				offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },
	
				specularMap: { value: null },
				alphaMap: { value: null },
	
				envMap: { value: null },
				flipEnvMap: { value: - 1 },
				reflectivity: { value: 1.0 },
				refractionRatio: { value: 0.98 }
	
			},
	
			aomap: {
	
				aoMap: { value: null },
				aoMapIntensity: { value: 1 }
	
			},
	
			lightmap: {
	
				lightMap: { value: null },
				lightMapIntensity: { value: 1 }
	
			},
	
			emissivemap: {
	
				emissiveMap: { value: null }
	
			},
	
			bumpmap: {
	
				bumpMap: { value: null },
				bumpScale: { value: 1 }
	
			},
	
			normalmap: {
	
				normalMap: { value: null },
				normalScale: { value: new Vector2( 1, 1 ) }
	
			},
	
			displacementmap: {
	
				displacementMap: { value: null },
				displacementScale: { value: 1 },
				displacementBias: { value: 0 }
	
			},
	
			roughnessmap: {
	
				roughnessMap: { value: null }
	
			},
	
			metalnessmap: {
	
				metalnessMap: { value: null }
	
			},
	
			gradientmap: {
	
				gradientMap: { value: null }
	
			},
	
			fog: {
	
				fogDensity: { value: 0.00025 },
				fogNear: { value: 1 },
				fogFar: { value: 2000 },
				fogColor: { value: new Color( 0xffffff ) }
	
			},
	
			lights: {
	
				ambientLightColor: { value: [] },
	
				directionalLights: { value: [], properties: {
					direction: {},
					color: {},
	
					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },
	
				directionalShadowMap: { value: [] },
				directionalShadowMatrix: { value: [] },
	
				spotLights: { value: [], properties: {
					color: {},
					position: {},
					direction: {},
					distance: {},
					coneCos: {},
					penumbraCos: {},
					decay: {},
	
					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },
	
				spotShadowMap: { value: [] },
				spotShadowMatrix: { value: [] },
	
				pointLights: { value: [], properties: {
					color: {},
					position: {},
					decay: {},
					distance: {},
	
					shadow: {},
					shadowBias: {},
					shadowRadius: {},
					shadowMapSize: {}
				} },
	
				pointShadowMap: { value: [] },
				pointShadowMatrix: { value: [] },
	
				hemisphereLights: { value: [], properties: {
					direction: {},
					skyColor: {},
					groundColor: {}
				} },
	
				// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
				rectAreaLights: { value: [], properties: {
					color: {},
					position: {},
					width: {},
					height: {}
				} }
	
			},
	
			points: {
	
				diffuse: { value: new Color( 0xeeeeee ) },
				opacity: { value: 1.0 },
				size: { value: 1.0 },
				scale: { value: 1.0 },
				map: { value: null },
				offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 */
	
		var ShaderLib = {
	
			basic: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.fog
				] ),
	
				vertexShader: ShaderChunk.meshbasic_vert,
				fragmentShader: ShaderChunk.meshbasic_frag
	
			},
	
			lambert: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.fog,
					UniformsLib.lights,
					{
						emissive: { value: new Color( 0x000000 ) }
					}
				] ),
	
				vertexShader: ShaderChunk.meshlambert_vert,
				fragmentShader: ShaderChunk.meshlambert_frag
	
			},
	
			phong: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.gradientmap,
					UniformsLib.fog,
					UniformsLib.lights,
					{
						emissive: { value: new Color( 0x000000 ) },
						specular: { value: new Color( 0x111111 ) },
						shininess: { value: 30 }
					}
				] ),
	
				vertexShader: ShaderChunk.meshphong_vert,
				fragmentShader: ShaderChunk.meshphong_frag
	
			},
	
			standard: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.aomap,
					UniformsLib.lightmap,
					UniformsLib.emissivemap,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					UniformsLib.roughnessmap,
					UniformsLib.metalnessmap,
					UniformsLib.fog,
					UniformsLib.lights,
					{
						emissive: { value: new Color( 0x000000 ) },
						roughness: { value: 0.5 },
						metalness: { value: 0 },
						envMapIntensity: { value: 1 } // temporary
					}
				] ),
	
				vertexShader: ShaderChunk.meshphysical_vert,
				fragmentShader: ShaderChunk.meshphysical_frag
	
			},
	
			points: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.points,
					UniformsLib.fog
				] ),
	
				vertexShader: ShaderChunk.points_vert,
				fragmentShader: ShaderChunk.points_frag
	
			},
	
			dashed: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.fog,
					{
						scale: { value: 1 },
						dashSize: { value: 1 },
						totalSize: { value: 2 }
					}
				] ),
	
				vertexShader: ShaderChunk.linedashed_vert,
				fragmentShader: ShaderChunk.linedashed_frag
	
			},
	
			depth: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.displacementmap
				] ),
	
				vertexShader: ShaderChunk.depth_vert,
				fragmentShader: ShaderChunk.depth_frag
	
			},
	
			normal: {
	
				uniforms: UniformsUtils.merge( [
					UniformsLib.common,
					UniformsLib.bumpmap,
					UniformsLib.normalmap,
					UniformsLib.displacementmap,
					{
						opacity: { value: 1.0 }
					}
				] ),
	
				vertexShader: ShaderChunk.normal_vert,
				fragmentShader: ShaderChunk.normal_frag
	
			},
	
			/* -------------------------------------------------------------------------
			//	Cube map shader
			 ------------------------------------------------------------------------- */
	
			cube: {
	
				uniforms: {
					tCube: { value: null },
					tFlip: { value: - 1 },
					opacity: { value: 1.0 }
				},
	
				vertexShader: ShaderChunk.cube_vert,
				fragmentShader: ShaderChunk.cube_frag
	
			},
	
			/* -------------------------------------------------------------------------
			//	Cube map shader
			 ------------------------------------------------------------------------- */
	
			equirect: {
	
				uniforms: {
					tEquirect: { value: null },
					tFlip: { value: - 1 }
				},
	
				vertexShader: ShaderChunk.equirect_vert,
				fragmentShader: ShaderChunk.equirect_frag
	
			},
	
			distanceRGBA: {
	
				uniforms: {
					lightPos: { value: new Vector3() }
				},
	
				vertexShader: ShaderChunk.distanceRGBA_vert,
				fragmentShader: ShaderChunk.distanceRGBA_frag
	
			}
	
		};
	
		ShaderLib.physical = {
	
			uniforms: UniformsUtils.merge( [
				ShaderLib.standard.uniforms,
				{
					clearCoat: { value: 0 },
					clearCoatRoughness: { value: 0 }
				}
			] ),
	
			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 */
	
		function Box2( min, max ) {
	
			this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );
	
		}
	
		Box2.prototype = {
	
			constructor: Box2,
	
			set: function ( min, max ) {
	
				this.min.copy( min );
				this.max.copy( max );
	
				return this;
	
			},
	
			setFromPoints: function ( points ) {
	
				this.makeEmpty();
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					this.expandByPoint( points[ i ] );
	
				}
	
				return this;
	
			},
	
			setFromCenterAndSize: function () {
	
				var v1 = new Vector2();
	
				return function setFromCenterAndSize( center, size ) {
	
					var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
					this.min.copy( center ).sub( halfSize );
					this.max.copy( center ).add( halfSize );
	
					return this;
	
				};
	
			}(),
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( box ) {
	
				this.min.copy( box.min );
				this.max.copy( box.max );
	
				return this;
	
			},
	
			makeEmpty: function () {
	
				this.min.x = this.min.y = + Infinity;
				this.max.x = this.max.y = - Infinity;
	
				return this;
	
			},
	
			isEmpty: function () {
	
				// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
				return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );
	
			},
	
			getCenter: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector2();
				return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
			},
	
			getSize: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector2();
				return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );
	
			},
	
			expandByPoint: function ( point ) {
	
				this.min.min( point );
				this.max.max( point );
	
				return this;
	
			},
	
			expandByVector: function ( vector ) {
	
				this.min.sub( vector );
				this.max.add( vector );
	
				return this;
	
			},
	
			expandByScalar: function ( scalar ) {
	
				this.min.addScalar( - scalar );
				this.max.addScalar( scalar );
	
				return this;
	
			},
	
			containsPoint: function ( point ) {
	
				return point.x < this.min.x || point.x > this.max.x ||
					point.y < this.min.y || point.y > this.max.y ? false : true;
	
			},
	
			containsBox: function ( box ) {
	
				return this.min.x <= box.min.x && box.max.x <= this.max.x &&
					this.min.y <= box.min.y && box.max.y <= this.max.y;
	
			},
	
			getParameter: function ( point, optionalTarget ) {
	
				// This can potentially have a divide by zero if the box
				// has a size dimension of 0.
	
				var result = optionalTarget || new Vector2();
	
				return result.set(
					( point.x - this.min.x ) / ( this.max.x - this.min.x ),
					( point.y - this.min.y ) / ( this.max.y - this.min.y )
				);
	
			},
	
			intersectsBox: function ( box ) {
	
				// using 6 splitting planes to rule out intersections.
				return box.max.x < this.min.x || box.min.x > this.max.x ||
					box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
	
			},
	
			clampPoint: function ( point, optionalTarget ) {
	
				var result = optionalTarget || new Vector2();
				return result.copy( point ).clamp( this.min, this.max );
	
			},
	
			distanceToPoint: function () {
	
				var v1 = new Vector2();
	
				return function distanceToPoint( point ) {
	
					var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
					return clampedPoint.sub( point ).length();
	
				};
	
			}(),
	
			intersect: function ( box ) {
	
				this.min.max( box.min );
				this.max.min( box.max );
	
				return this;
	
			},
	
			union: function ( box ) {
	
				this.min.min( box.min );
				this.max.max( box.max );
	
				return this;
	
			},
	
			translate: function ( offset ) {
	
				this.min.add( offset );
				this.max.add( offset );
	
				return this;
	
			},
	
			equals: function ( box ) {
	
				return box.min.equals( this.min ) && box.max.equals( this.max );
	
			}
	
		};
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function LensFlarePlugin( renderer, flares ) {
	
			var gl = renderer.context;
			var state = renderer.state;
	
			var vertexBuffer, elementBuffer;
			var shader, program, attributes, uniforms;
	
			var tempTexture, occlusionTexture;
	
			function init() {
	
				var vertices = new Float32Array( [
					- 1, - 1,  0, 0,
					 1, - 1,  1, 0,
					 1,  1,  1, 1,
					- 1,  1,  0, 1
				] );
	
				var faces = new Uint16Array( [
					0, 1, 2,
					0, 2, 3
				] );
	
				// buffers
	
				vertexBuffer     = gl.createBuffer();
				elementBuffer    = gl.createBuffer();
	
				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
				gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
				// textures
	
				tempTexture      = gl.createTexture();
				occlusionTexture = gl.createTexture();
	
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	
				shader = {
	
					vertexShader: [
	
						"uniform lowp int renderType;",
	
						"uniform vec3 screenPosition;",
						"uniform vec2 scale;",
						"uniform float rotation;",
	
						"uniform sampler2D occlusionMap;",
	
						"attribute vec2 position;",
						"attribute vec2 uv;",
	
						"varying vec2 vUV;",
						"varying float vVisibility;",
	
						"void main() {",
	
							"vUV = uv;",
	
							"vec2 pos = position;",
	
							"if ( renderType == 2 ) {",
	
								"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
								"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",
	
								"vVisibility =        visibility.r / 9.0;",
								"vVisibility *= 1.0 - visibility.g / 9.0;",
								"vVisibility *=       visibility.b / 9.0;",
								"vVisibility *= 1.0 - visibility.a / 9.0;",
	
								"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
								"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",
	
							"}",
	
							"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",
	
						"}"
	
					].join( "\n" ),
	
					fragmentShader: [
	
						"uniform lowp int renderType;",
	
						"uniform sampler2D map;",
						"uniform float opacity;",
						"uniform vec3 color;",
	
						"varying vec2 vUV;",
						"varying float vVisibility;",
	
						"void main() {",
	
							// pink square
	
							"if ( renderType == 0 ) {",
	
								"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",
	
							// restore
	
							"} else if ( renderType == 1 ) {",
	
								"gl_FragColor = texture2D( map, vUV );",
	
							// flare
	
							"} else {",
	
								"vec4 texture = texture2D( map, vUV );",
								"texture.a *= opacity * vVisibility;",
								"gl_FragColor = texture;",
								"gl_FragColor.rgb *= color;",
	
							"}",
	
						"}"
	
					].join( "\n" )
	
				};
	
				program = createProgram( shader );
	
				attributes = {
					vertex: gl.getAttribLocation ( program, "position" ),
					uv:     gl.getAttribLocation ( program, "uv" )
				};
	
				uniforms = {
					renderType:     gl.getUniformLocation( program, "renderType" ),
					map:            gl.getUniformLocation( program, "map" ),
					occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
					opacity:        gl.getUniformLocation( program, "opacity" ),
					color:          gl.getUniformLocation( program, "color" ),
					scale:          gl.getUniformLocation( program, "scale" ),
					rotation:       gl.getUniformLocation( program, "rotation" ),
					screenPosition: gl.getUniformLocation( program, "screenPosition" )
				};
	
			}
	
			/*
			 * Render lens flares
			 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
			 *         reads these back and calculates occlusion.
			 */
	
			this.render = function ( scene, camera, viewport ) {
	
				if ( flares.length === 0 ) return;
	
				var tempPosition = new Vector3();
	
				var invAspect = viewport.w / viewport.z,
					halfViewportWidth = viewport.z * 0.5,
					halfViewportHeight = viewport.w * 0.5;
	
				var size = 16 / viewport.w,
					scale = new Vector2( size * invAspect, size );
	
				var screenPosition = new Vector3( 1, 1, 0 ),
					screenPositionPixels = new Vector2( 1, 1 );
	
				var validArea = new Box2();
	
				validArea.min.set( viewport.x, viewport.y );
				validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );
	
				if ( program === undefined ) {
	
					init();
	
				}
	
				gl.useProgram( program );
	
				state.initAttributes();
				state.enableAttribute( attributes.vertex );
				state.enableAttribute( attributes.uv );
				state.disableUnusedAttributes();
	
				// loop through all lens flares to update their occlusion and positions
				// setup gl and common used attribs/uniforms
	
				gl.uniform1i( uniforms.occlusionMap, 0 );
				gl.uniform1i( uniforms.map, 1 );
	
				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
				gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
				state.disable( gl.CULL_FACE );
				state.setDepthWrite( false );
	
				for ( var i = 0, l = flares.length; i < l; i ++ ) {
	
					size = 16 / viewport.w;
					scale.set( size * invAspect, size );
	
					// calc object screen position
	
					var flare = flares[ i ];
	
					tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );
	
					tempPosition.applyMatrix4( camera.matrixWorldInverse );
					tempPosition.applyMatrix4( camera.projectionMatrix );
	
					// setup arrays for gl programs
	
					screenPosition.copy( tempPosition );
	
					// horizontal and vertical coordinate of the lower left corner of the pixels to copy
	
					screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
					screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;
	
					// screen cull
	
					if ( validArea.containsPoint( screenPositionPixels ) === true ) {
	
						// save current RGB to temp texture
	
						state.activeTexture( gl.TEXTURE0 );
						state.bindTexture( gl.TEXTURE_2D, null );
						state.activeTexture( gl.TEXTURE1 );
						state.bindTexture( gl.TEXTURE_2D, tempTexture );
						gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );
	
	
						// render pink quad
	
						gl.uniform1i( uniforms.renderType, 0 );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
	
						state.disable( gl.BLEND );
						state.enable( gl.DEPTH_TEST );
	
						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
						// copy result to occlusionMap
	
						state.activeTexture( gl.TEXTURE0 );
						state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
						gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );
	
	
						// restore graphics
	
						gl.uniform1i( uniforms.renderType, 1 );
						state.disable( gl.DEPTH_TEST );
	
						state.activeTexture( gl.TEXTURE1 );
						state.bindTexture( gl.TEXTURE_2D, tempTexture );
						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
	
						// update object positions
	
						flare.positionScreen.copy( screenPosition );
	
						if ( flare.customUpdateCallback ) {
	
							flare.customUpdateCallback( flare );
	
						} else {
	
							flare.updateLensFlares();
	
						}
	
						// render flares
	
						gl.uniform1i( uniforms.renderType, 2 );
						state.enable( gl.BLEND );
	
						for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {
	
							var sprite = flare.lensFlares[ j ];
	
							if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {
	
								screenPosition.x = sprite.x;
								screenPosition.y = sprite.y;
								screenPosition.z = sprite.z;
	
								size = sprite.size * sprite.scale / viewport.w;
	
								scale.x = size * invAspect;
								scale.y = size;
	
								gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
								gl.uniform2f( uniforms.scale, scale.x, scale.y );
								gl.uniform1f( uniforms.rotation, sprite.rotation );
	
								gl.uniform1f( uniforms.opacity, sprite.opacity );
								gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );
	
								state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
								renderer.setTexture2D( sprite.texture, 1 );
	
								gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
							}
	
						}
	
					}
	
				}
	
				// restore gl
	
				state.enable( gl.CULL_FACE );
				state.enable( gl.DEPTH_TEST );
				state.setDepthWrite( true );
	
				renderer.resetGLState();
	
			};
	
			function createProgram( shader ) {
	
				var program = gl.createProgram();
	
				var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
				var vertexShader = gl.createShader( gl.VERTEX_SHADER );
	
				var prefix = "precision " + renderer.getPrecision() + " float;\n";
	
				gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
				gl.shaderSource( vertexShader, prefix + shader.vertexShader );
	
				gl.compileShader( fragmentShader );
				gl.compileShader( vertexShader );
	
				gl.attachShader( program, fragmentShader );
				gl.attachShader( program, vertexShader );
	
				gl.linkProgram( program );
	
				return program;
	
			}
	
		}
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function SpritePlugin( renderer, sprites ) {
	
			var gl = renderer.context;
			var state = renderer.state;
	
			var vertexBuffer, elementBuffer;
			var program, attributes, uniforms;
	
			var texture;
	
			// decompose matrixWorld
	
			var spritePosition = new Vector3();
			var spriteRotation = new Quaternion();
			var spriteScale = new Vector3();
	
			function init() {
	
				var vertices = new Float32Array( [
					- 0.5, - 0.5,  0, 0,
					  0.5, - 0.5,  1, 0,
					  0.5,   0.5,  1, 1,
					- 0.5,   0.5,  0, 1
				] );
	
				var faces = new Uint16Array( [
					0, 1, 2,
					0, 2, 3
				] );
	
				vertexBuffer  = gl.createBuffer();
				elementBuffer = gl.createBuffer();
	
				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );
	
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
				gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );
	
				program = createProgram();
	
				attributes = {
					position:			gl.getAttribLocation ( program, 'position' ),
					uv:					gl.getAttribLocation ( program, 'uv' )
				};
	
				uniforms = {
					uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
					uvScale:			gl.getUniformLocation( program, 'uvScale' ),
	
					rotation:			gl.getUniformLocation( program, 'rotation' ),
					scale:				gl.getUniformLocation( program, 'scale' ),
	
					color:				gl.getUniformLocation( program, 'color' ),
					map:				gl.getUniformLocation( program, 'map' ),
					opacity:			gl.getUniformLocation( program, 'opacity' ),
	
					modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
					projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),
	
					fogType:			gl.getUniformLocation( program, 'fogType' ),
					fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
					fogNear:			gl.getUniformLocation( program, 'fogNear' ),
					fogFar:				gl.getUniformLocation( program, 'fogFar' ),
					fogColor:			gl.getUniformLocation( program, 'fogColor' ),
	
					alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
				};
	
				var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = 8;
				canvas.height = 8;
	
				var context = canvas.getContext( '2d' );
				context.fillStyle = 'white';
				context.fillRect( 0, 0, 8, 8 );
	
				texture = new Texture( canvas );
				texture.needsUpdate = true;
	
			}
	
			this.render = function ( scene, camera ) {
	
				if ( sprites.length === 0 ) return;
	
				// setup gl
	
				if ( program === undefined ) {
	
					init();
	
				}
	
				gl.useProgram( program );
	
				state.initAttributes();
				state.enableAttribute( attributes.position );
				state.enableAttribute( attributes.uv );
				state.disableUnusedAttributes();
	
				state.disable( gl.CULL_FACE );
				state.enable( gl.BLEND );
	
				gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
				gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
				gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );
	
				gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
	
				gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );
	
				state.activeTexture( gl.TEXTURE0 );
				gl.uniform1i( uniforms.map, 0 );
	
				var oldFogType = 0;
				var sceneFogType = 0;
				var fog = scene.fog;
	
				if ( fog ) {
	
					gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );
	
					if ( fog.isFog ) {
	
						gl.uniform1f( uniforms.fogNear, fog.near );
						gl.uniform1f( uniforms.fogFar, fog.far );
	
						gl.uniform1i( uniforms.fogType, 1 );
						oldFogType = 1;
						sceneFogType = 1;
	
					} else if ( fog.isFogExp2 ) {
	
						gl.uniform1f( uniforms.fogDensity, fog.density );
	
						gl.uniform1i( uniforms.fogType, 2 );
						oldFogType = 2;
						sceneFogType = 2;
	
					}
	
				} else {
	
					gl.uniform1i( uniforms.fogType, 0 );
					oldFogType = 0;
					sceneFogType = 0;
	
				}
	
	
				// update positions and sort
	
				for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
					var sprite = sprites[ i ];
	
					sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
					sprite.z = - sprite.modelViewMatrix.elements[ 14 ];
	
				}
	
				sprites.sort( painterSortStable );
	
				// render all sprites
	
				var scale = [];
	
				for ( var i = 0, l = sprites.length; i < l; i ++ ) {
	
					var sprite = sprites[ i ];
					var material = sprite.material;
	
					if ( material.visible === false ) continue;
	
					gl.uniform1f( uniforms.alphaTest, material.alphaTest );
					gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );
	
					sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );
	
					scale[ 0 ] = spriteScale.x;
					scale[ 1 ] = spriteScale.y;
	
					var fogType = 0;
	
					if ( scene.fog && material.fog ) {
	
						fogType = sceneFogType;
	
					}
	
					if ( oldFogType !== fogType ) {
	
						gl.uniform1i( uniforms.fogType, fogType );
						oldFogType = fogType;
	
					}
	
					if ( material.map !== null ) {
	
						gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
						gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );
	
					} else {
	
						gl.uniform2f( uniforms.uvOffset, 0, 0 );
						gl.uniform2f( uniforms.uvScale, 1, 1 );
	
					}
	
					gl.uniform1f( uniforms.opacity, material.opacity );
					gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );
	
					gl.uniform1f( uniforms.rotation, material.rotation );
					gl.uniform2fv( uniforms.scale, scale );
	
					state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
					state.setDepthTest( material.depthTest );
					state.setDepthWrite( material.depthWrite );
	
					if ( material.map ) {
	
						renderer.setTexture2D( material.map, 0 );
	
					} else {
	
						renderer.setTexture2D( texture, 0 );
	
					}
	
					gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );
	
				}
	
				// restore gl
	
				state.enable( gl.CULL_FACE );
	
				renderer.resetGLState();
	
			};
	
			function createProgram() {
	
				var program = gl.createProgram();
	
				var vertexShader = gl.createShader( gl.VERTEX_SHADER );
				var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
	
				gl.shaderSource( vertexShader, [
	
					'precision ' + renderer.getPrecision() + ' float;',
	
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform float rotation;',
					'uniform vec2 scale;',
					'uniform vec2 uvOffset;',
					'uniform vec2 uvScale;',
	
					'attribute vec2 position;',
					'attribute vec2 uv;',
	
					'varying vec2 vUV;',
	
					'void main() {',
	
						'vUV = uvOffset + uv * uvScale;',
	
						'vec2 alignedPosition = position * scale;',
	
						'vec2 rotatedPosition;',
						'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
						'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',
	
						'vec4 finalPosition;',
	
						'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
						'finalPosition.xy += rotatedPosition;',
						'finalPosition = projectionMatrix * finalPosition;',
	
						'gl_Position = finalPosition;',
	
					'}'
	
				].join( '\n' ) );
	
				gl.shaderSource( fragmentShader, [
	
					'precision ' + renderer.getPrecision() + ' float;',
	
					'uniform vec3 color;',
					'uniform sampler2D map;',
					'uniform float opacity;',
	
					'uniform int fogType;',
					'uniform vec3 fogColor;',
					'uniform float fogDensity;',
					'uniform float fogNear;',
					'uniform float fogFar;',
					'uniform float alphaTest;',
	
					'varying vec2 vUV;',
	
					'void main() {',
	
						'vec4 texture = texture2D( map, vUV );',
	
						'if ( texture.a < alphaTest ) discard;',
	
						'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',
	
						'if ( fogType > 0 ) {',
	
							'float depth = gl_FragCoord.z / gl_FragCoord.w;',
							'float fogFactor = 0.0;',
	
							'if ( fogType == 1 ) {',
	
								'fogFactor = smoothstep( fogNear, fogFar, depth );',
	
							'} else {',
	
								'const float LOG2 = 1.442695;',
								'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
								'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',
	
							'}',
	
							'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',
	
						'}',
	
					'}'
	
				].join( '\n' ) );
	
				gl.compileShader( vertexShader );
				gl.compileShader( fragmentShader );
	
				gl.attachShader( program, vertexShader );
				gl.attachShader( program, fragmentShader );
	
				gl.linkProgram( program );
	
				return program;
	
			}
	
			function painterSortStable( a, b ) {
	
				if ( a.renderOrder !== b.renderOrder ) {
	
					return a.renderOrder - b.renderOrder;
	
				} else if ( a.z !== b.z ) {
	
					return b.z - a.z;
	
				} else {
	
					return b.id - a.id;
	
				}
	
			}
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		var materialId = 0;
	
		function Material() {
	
			Object.defineProperty( this, 'id', { value: materialId ++ } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.type = 'Material';
	
			this.fog = true;
			this.lights = true;
	
			this.blending = NormalBlending;
			this.side = FrontSide;
			this.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading
			this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors
	
			this.opacity = 1;
			this.transparent = false;
	
			this.blendSrc = SrcAlphaFactor;
			this.blendDst = OneMinusSrcAlphaFactor;
			this.blendEquation = AddEquation;
			this.blendSrcAlpha = null;
			this.blendDstAlpha = null;
			this.blendEquationAlpha = null;
	
			this.depthFunc = LessEqualDepth;
			this.depthTest = true;
			this.depthWrite = true;
	
			this.clippingPlanes = null;
			this.clipIntersection = false;
			this.clipShadows = false;
	
			this.colorWrite = true;
	
			this.precision = null; // override the renderer's default precision for this material
	
			this.polygonOffset = false;
			this.polygonOffsetFactor = 0;
			this.polygonOffsetUnits = 0;
	
			this.alphaTest = 0;
			this.premultipliedAlpha = false;
	
			this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer
	
			this.visible = true;
	
			this._needsUpdate = true;
	
		}
	
		Material.prototype = {
	
			constructor: Material,
	
			isMaterial: true,
	
			get needsUpdate() {
	
				return this._needsUpdate;
	
			},
	
			set needsUpdate( value ) {
	
				if ( value === true ) this.update();
				this._needsUpdate = value;
	
			},
	
			setValues: function ( values ) {
	
				if ( values === undefined ) return;
	
				for ( var key in values ) {
	
					var newValue = values[ key ];
	
					if ( newValue === undefined ) {
	
						console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
						continue;
	
					}
	
					var currentValue = this[ key ];
	
					if ( currentValue === undefined ) {
	
						console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
						continue;
	
					}
	
					if ( currentValue && currentValue.isColor ) {
	
						currentValue.set( newValue );
	
					} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {
	
						currentValue.copy( newValue );
	
					} else if ( key === 'overdraw' ) {
	
						// ensure overdraw is backwards-compatible with legacy boolean type
						this[ key ] = Number( newValue );
	
					} else {
	
						this[ key ] = newValue;
	
					}
	
				}
	
			},
	
			toJSON: function ( meta ) {
	
				var isRoot = meta === undefined;
	
				if ( isRoot ) {
	
					meta = {
						textures: {},
						images: {}
					};
	
				}
	
				var data = {
					metadata: {
						version: 4.4,
						type: 'Material',
						generator: 'Material.toJSON'
					}
				};
	
				// standard Material serialization
				data.uuid = this.uuid;
				data.type = this.type;
	
				if ( this.name !== '' ) data.name = this.name;
	
				if ( this.color && this.color.isColor ) data.color = this.color.getHex();
	
				if ( this.roughness !== undefined ) data.roughness = this.roughness;
				if ( this.metalness !== undefined ) data.metalness = this.metalness;
	
				if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
				if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
				if ( this.shininess !== undefined ) data.shininess = this.shininess;
				if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
				if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;
	
				if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
				if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
				if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
				if ( this.bumpMap && this.bumpMap.isTexture ) {
	
					data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
					data.bumpScale = this.bumpScale;
	
				}
				if ( this.normalMap && this.normalMap.isTexture ) {
	
					data.normalMap = this.normalMap.toJSON( meta ).uuid;
					data.normalScale = this.normalScale.toArray();
	
				}
				if ( this.displacementMap && this.displacementMap.isTexture ) {
	
					data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
					data.displacementScale = this.displacementScale;
					data.displacementBias = this.displacementBias;
	
				}
				if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
				if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;
	
				if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
				if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
	
				if ( this.envMap && this.envMap.isTexture ) {
	
					data.envMap = this.envMap.toJSON( meta ).uuid;
					data.reflectivity = this.reflectivity; // Scale behind envMap
	
				}
	
				if ( this.gradientMap && this.gradientMap.isTexture ) {
	
					data.gradientMap = this.gradientMap.toJSON( meta ).uuid;
	
				}
	
				if ( this.size !== undefined ) data.size = this.size;
				if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;
	
				if ( this.blending !== NormalBlending ) data.blending = this.blending;
				if ( this.shading !== SmoothShading ) data.shading = this.shading;
				if ( this.side !== FrontSide ) data.side = this.side;
				if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;
	
				if ( this.opacity < 1 ) data.opacity = this.opacity;
				if ( this.transparent === true ) data.transparent = this.transparent;
	
				data.depthFunc = this.depthFunc;
				data.depthTest = this.depthTest;
				data.depthWrite = this.depthWrite;
	
				if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
				if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
				if ( this.wireframe === true ) data.wireframe = this.wireframe;
				if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
				if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
				if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;
	
				data.skinning = this.skinning;
				data.morphTargets = this.morphTargets;
	
				// TODO: Copied from Object3D.toJSON
	
				function extractFromCache( cache ) {
	
					var values = [];
	
					for ( var key in cache ) {
	
						var data = cache[ key ];
						delete data.metadata;
						values.push( data );
	
					}
	
					return values;
	
				}
	
				if ( isRoot ) {
	
					var textures = extractFromCache( meta.textures );
					var images = extractFromCache( meta.images );
	
					if ( textures.length > 0 ) data.textures = textures;
					if ( images.length > 0 ) data.images = images;
	
				}
	
				return data;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( source ) {
	
				this.name = source.name;
	
				this.fog = source.fog;
				this.lights = source.lights;
	
				this.blending = source.blending;
				this.side = source.side;
				this.shading = source.shading;
				this.vertexColors = source.vertexColors;
	
				this.opacity = source.opacity;
				this.transparent = source.transparent;
	
				this.blendSrc = source.blendSrc;
				this.blendDst = source.blendDst;
				this.blendEquation = source.blendEquation;
				this.blendSrcAlpha = source.blendSrcAlpha;
				this.blendDstAlpha = source.blendDstAlpha;
				this.blendEquationAlpha = source.blendEquationAlpha;
	
				this.depthFunc = source.depthFunc;
				this.depthTest = source.depthTest;
				this.depthWrite = source.depthWrite;
	
				this.colorWrite = source.colorWrite;
	
				this.precision = source.precision;
	
				this.polygonOffset = source.polygonOffset;
				this.polygonOffsetFactor = source.polygonOffsetFactor;
				this.polygonOffsetUnits = source.polygonOffsetUnits;
	
				this.alphaTest = source.alphaTest;
	
				this.premultipliedAlpha = source.premultipliedAlpha;
	
				this.overdraw = source.overdraw;
	
				this.visible = source.visible;
				this.clipShadows = source.clipShadows;
				this.clipIntersection = source.clipIntersection;
	
				var srcPlanes = source.clippingPlanes,
					dstPlanes = null;
	
				if ( srcPlanes !== null ) {
	
					var n = srcPlanes.length;
					dstPlanes = new Array( n );
	
					for ( var i = 0; i !== n; ++ i )
						dstPlanes[ i ] = srcPlanes[ i ].clone();
	
				}
	
				this.clippingPlanes = dstPlanes;
	
				return this;
	
			},
	
			update: function () {
	
				this.dispatchEvent( { type: 'update' } );
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			}
	
		};
	
		Object.assign( Material.prototype, EventDispatcher.prototype );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  defines: { "label" : "value" },
		 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
		 *
		 *  fragmentShader: <string>,
		 *  vertexShader: <string>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  lights: <bool>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function ShaderMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'ShaderMaterial';
	
			this.defines = {};
			this.uniforms = {};
	
			this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
			this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
	
			this.linewidth = 1;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
	
			this.fog = false; // set to use scene fog
			this.lights = false; // set to use scene lights
			this.clipping = false; // set to use user-defined clipping planes
	
			this.skinning = false; // set to use skinning attribute streams
			this.morphTargets = false; // set to use morph targets
			this.morphNormals = false; // set to use morph normals
	
			this.extensions = {
				derivatives: false, // set to use derivatives
				fragDepth: false, // set to use fragment depth values
				drawBuffers: false, // set to use draw buffers
				shaderTextureLOD: false // set to use shader texture LOD
			};
	
			// When rendered geometry doesn't include these attributes but the material does,
			// use these default values in WebGL. This avoids errors when buffer data is missing.
			this.defaultAttributeValues = {
				'color': [ 1, 1, 1 ],
				'uv': [ 0, 0 ],
				'uv2': [ 0, 0 ]
			};
	
			this.index0AttributeName = undefined;
	
			if ( parameters !== undefined ) {
	
				if ( parameters.attributes !== undefined ) {
	
					console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );
	
				}
	
				this.setValues( parameters );
	
			}
	
		}
	
		ShaderMaterial.prototype = Object.create( Material.prototype );
		ShaderMaterial.prototype.constructor = ShaderMaterial;
	
		ShaderMaterial.prototype.isShaderMaterial = true;
	
		ShaderMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.fragmentShader = source.fragmentShader;
			this.vertexShader = source.vertexShader;
	
			this.uniforms = UniformsUtils.clone( source.uniforms );
	
			this.defines = source.defines;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
	
			this.lights = source.lights;
			this.clipping = source.clipping;
	
			this.skinning = source.skinning;
	
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			this.extensions = source.extensions;
	
			return this;
	
		};
	
		ShaderMaterial.prototype.toJSON = function ( meta ) {
	
			var data = Material.prototype.toJSON.call( this, meta );
	
			data.uniforms = this.uniforms;
			data.vertexShader = this.vertexShader;
			data.fragmentShader = this.fragmentShader;
	
			return data;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / https://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>
		 * }
		 */
	
		function MeshDepthMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'MeshDepthMaterial';
	
			this.depthPacking = BasicDepthPacking;
	
			this.skinning = false;
			this.morphTargets = false;
	
			this.map = null;
	
			this.alphaMap = null;
	
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
	
			this.fog = false;
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		MeshDepthMaterial.prototype = Object.create( Material.prototype );
		MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
	
		MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
	
		MeshDepthMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.depthPacking = source.depthPacking;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
	
			this.map = source.map;
	
			this.alphaMap = source.alphaMap;
	
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
	
			return this;
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function Box3( min, max ) {
	
			this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
			this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );
	
		}
	
		Box3.prototype = {
	
			constructor: Box3,
	
			isBox3: true,
	
			set: function ( min, max ) {
	
				this.min.copy( min );
				this.max.copy( max );
	
				return this;
	
			},
	
			setFromArray: function ( array ) {
	
				var minX = + Infinity;
				var minY = + Infinity;
				var minZ = + Infinity;
	
				var maxX = - Infinity;
				var maxY = - Infinity;
				var maxZ = - Infinity;
	
				for ( var i = 0, l = array.length; i < l; i += 3 ) {
	
					var x = array[ i ];
					var y = array[ i + 1 ];
					var z = array[ i + 2 ];
	
					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( z < minZ ) minZ = z;
	
					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;
					if ( z > maxZ ) maxZ = z;
	
				}
	
				this.min.set( minX, minY, minZ );
				this.max.set( maxX, maxY, maxZ );
	
				return this;
	
			},
	
			setFromBufferAttribute: function ( attribute ) {
	
				var minX = + Infinity;
				var minY = + Infinity;
				var minZ = + Infinity;
	
				var maxX = - Infinity;
				var maxY = - Infinity;
				var maxZ = - Infinity;
	
				for ( var i = 0, l = attribute.count; i < l; i ++ ) {
	
					var x = attribute.getX( i );
					var y = attribute.getY( i );
					var z = attribute.getZ( i );
	
					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( z < minZ ) minZ = z;
	
					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;
					if ( z > maxZ ) maxZ = z;
	
				}
	
				this.min.set( minX, minY, minZ );
				this.max.set( maxX, maxY, maxZ );
	
				return this;
	
			},
	
			setFromPoints: function ( points ) {
	
				this.makeEmpty();
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					this.expandByPoint( points[ i ] );
	
				}
	
				return this;
	
			},
	
			setFromCenterAndSize: function () {
	
				var v1 = new Vector3();
	
				return function setFromCenterAndSize( center, size ) {
	
					var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
	
					this.min.copy( center ).sub( halfSize );
					this.max.copy( center ).add( halfSize );
	
					return this;
	
				};
	
			}(),
	
			setFromObject: function ( object ) {
	
				this.makeEmpty();
	
				return this.expandByObject( object );
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( box ) {
	
				this.min.copy( box.min );
				this.max.copy( box.max );
	
				return this;
	
			},
	
			makeEmpty: function () {
	
				this.min.x = this.min.y = this.min.z = + Infinity;
				this.max.x = this.max.y = this.max.z = - Infinity;
	
				return this;
	
			},
	
			isEmpty: function () {
	
				// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
				return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );
	
			},
	
			getCenter: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
			},
	
			getSize: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );
	
			},
	
			expandByPoint: function ( point ) {
	
				this.min.min( point );
				this.max.max( point );
	
				return this;
	
			},
	
			expandByVector: function ( vector ) {
	
				this.min.sub( vector );
				this.max.add( vector );
	
				return this;
	
			},
	
			expandByScalar: function ( scalar ) {
	
				this.min.addScalar( - scalar );
				this.max.addScalar( scalar );
	
				return this;
	
			},
	
			expandByObject: function () {
	
				// Computes the world-axis-aligned bounding box of an object (including its children),
				// accounting for both the object's, and children's, world transforms
	
				var v1 = new Vector3();
	
				return function expandByObject( object ) {
	
					var scope = this;
	
					object.updateMatrixWorld( true );
	
					object.traverse( function ( node ) {
	
						var i, l;
	
						var geometry = node.geometry;
	
						if ( geometry !== undefined ) {
	
							if ( geometry.isGeometry ) {
	
								var vertices = geometry.vertices;
	
								for ( i = 0, l = vertices.length; i < l; i ++ ) {
	
									v1.copy( vertices[ i ] );
									v1.applyMatrix4( node.matrixWorld );
	
									scope.expandByPoint( v1 );
	
								}
	
							} else if ( geometry.isBufferGeometry ) {
	
								var attribute = geometry.attributes.position;
	
								if ( attribute !== undefined ) {
	
									for ( i = 0, l = attribute.count; i < l; i ++ ) {
	
										v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );
	
										scope.expandByPoint( v1 );
	
									}
	
								}
	
							}
	
						}
	
					} );
	
					return this;
	
				};
	
			}(),
	
			containsPoint: function ( point ) {
	
				return point.x < this.min.x || point.x > this.max.x ||
					point.y < this.min.y || point.y > this.max.y ||
					point.z < this.min.z || point.z > this.max.z ? false : true;
	
			},
	
			containsBox: function ( box ) {
	
				return this.min.x <= box.min.x && box.max.x <= this.max.x &&
					this.min.y <= box.min.y && box.max.y <= this.max.y &&
					this.min.z <= box.min.z && box.max.z <= this.max.z;
	
			},
	
			getParameter: function ( point, optionalTarget ) {
	
				// This can potentially have a divide by zero if the box
				// has a size dimension of 0.
	
				var result = optionalTarget || new Vector3();
	
				return result.set(
					( point.x - this.min.x ) / ( this.max.x - this.min.x ),
					( point.y - this.min.y ) / ( this.max.y - this.min.y ),
					( point.z - this.min.z ) / ( this.max.z - this.min.z )
				);
	
			},
	
			intersectsBox: function ( box ) {
	
				// using 6 splitting planes to rule out intersections.
				return box.max.x < this.min.x || box.min.x > this.max.x ||
					box.max.y < this.min.y || box.min.y > this.max.y ||
					box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
	
			},
	
			intersectsSphere: ( function () {
	
				var closestPoint;
	
				return function intersectsSphere( sphere ) {
	
					if ( closestPoint === undefined ) closestPoint = new Vector3();
	
					// Find the point on the AABB closest to the sphere center.
					this.clampPoint( sphere.center, closestPoint );
	
					// If that point is inside the sphere, the AABB and sphere intersect.
					return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );
	
				};
	
			} )(),
	
			intersectsPlane: function ( plane ) {
	
				// We compute the minimum and maximum dot product values. If those values
				// are on the same side (back or front) of the plane, then there is no intersection.
	
				var min, max;
	
				if ( plane.normal.x > 0 ) {
	
					min = plane.normal.x * this.min.x;
					max = plane.normal.x * this.max.x;
	
				} else {
	
					min = plane.normal.x * this.max.x;
					max = plane.normal.x * this.min.x;
	
				}
	
				if ( plane.normal.y > 0 ) {
	
					min += plane.normal.y * this.min.y;
					max += plane.normal.y * this.max.y;
	
				} else {
	
					min += plane.normal.y * this.max.y;
					max += plane.normal.y * this.min.y;
	
				}
	
				if ( plane.normal.z > 0 ) {
	
					min += plane.normal.z * this.min.z;
					max += plane.normal.z * this.max.z;
	
				} else {
	
					min += plane.normal.z * this.max.z;
					max += plane.normal.z * this.min.z;
	
				}
	
				return ( min <= plane.constant && max >= plane.constant );
	
			},
	
			clampPoint: function ( point, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.copy( point ).clamp( this.min, this.max );
	
			},
	
			distanceToPoint: function () {
	
				var v1 = new Vector3();
	
				return function distanceToPoint( point ) {
	
					var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
					return clampedPoint.sub( point ).length();
	
				};
	
			}(),
	
			getBoundingSphere: function () {
	
				var v1 = new Vector3();
	
				return function getBoundingSphere( optionalTarget ) {
	
					var result = optionalTarget || new Sphere();
	
					this.getCenter( result.center );
	
					result.radius = this.getSize( v1 ).length() * 0.5;
	
					return result;
	
				};
	
			}(),
	
			intersect: function ( box ) {
	
				this.min.max( box.min );
				this.max.min( box.max );
	
				// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
				if( this.isEmpty() ) this.makeEmpty();
	
				return this;
	
			},
	
			union: function ( box ) {
	
				this.min.min( box.min );
				this.max.max( box.max );
	
				return this;
	
			},
	
			applyMatrix4: function () {
	
				var points = [
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3(),
					new Vector3()
				];
	
				return function applyMatrix4( matrix ) {
	
					// transform of empty box is an empty box.
					if( this.isEmpty() ) return this;
	
					// NOTE: I am using a binary pattern to specify all 2^3 combinations below
					points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
					points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
					points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
					points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
					points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
					points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
					points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
					points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111
	
					this.setFromPoints( points );
	
					return this;
	
				};
	
			}(),
	
			translate: function ( offset ) {
	
				this.min.add( offset );
				this.max.add( offset );
	
				return this;
	
			},
	
			equals: function ( box ) {
	
				return box.min.equals( this.min ) && box.max.equals( this.max );
	
			}
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Sphere( center, radius ) {
	
			this.center = ( center !== undefined ) ? center : new Vector3();
			this.radius = ( radius !== undefined ) ? radius : 0;
	
		}
	
		Sphere.prototype = {
	
			constructor: Sphere,
	
			set: function ( center, radius ) {
	
				this.center.copy( center );
				this.radius = radius;
	
				return this;
	
			},
	
			setFromPoints: function () {
	
				var box;
	
				return function setFromPoints( points, optionalCenter ) {
	
					if ( box === undefined ) box = new Box3(); // see #10547
	
					var center = this.center;
	
					if ( optionalCenter !== undefined ) {
	
						center.copy( optionalCenter );
	
					} else {
	
						box.setFromPoints( points ).getCenter( center );
	
					}
	
					var maxRadiusSq = 0;
	
					for ( var i = 0, il = points.length; i < il; i ++ ) {
	
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );
	
					}
	
					this.radius = Math.sqrt( maxRadiusSq );
	
					return this;
	
				};
	
			}(),
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( sphere ) {
	
				this.center.copy( sphere.center );
				this.radius = sphere.radius;
	
				return this;
	
			},
	
			empty: function () {
	
				return ( this.radius <= 0 );
	
			},
	
			containsPoint: function ( point ) {
	
				return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );
	
			},
	
			distanceToPoint: function ( point ) {
	
				return ( point.distanceTo( this.center ) - this.radius );
	
			},
	
			intersectsSphere: function ( sphere ) {
	
				var radiusSum = this.radius + sphere.radius;
	
				return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );
	
			},
	
			intersectsBox: function ( box ) {
	
				return box.intersectsSphere( this );
	
			},
	
			intersectsPlane: function ( plane ) {
	
				// We use the following equation to compute the signed distance from
				// the center of the sphere to the plane.
				//
				// distance = q * n - d
				//
				// If this distance is greater than the radius of the sphere,
				// then there is no intersection.
	
				return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;
	
			},
	
			clampPoint: function ( point, optionalTarget ) {
	
				var deltaLengthSq = this.center.distanceToSquared( point );
	
				var result = optionalTarget || new Vector3();
	
				result.copy( point );
	
				if ( deltaLengthSq > ( this.radius * this.radius ) ) {
	
					result.sub( this.center ).normalize();
					result.multiplyScalar( this.radius ).add( this.center );
	
				}
	
				return result;
	
			},
	
			getBoundingBox: function ( optionalTarget ) {
	
				var box = optionalTarget || new Box3();
	
				box.set( this.center, this.center );
				box.expandByScalar( this.radius );
	
				return box;
	
			},
	
			applyMatrix4: function ( matrix ) {
	
				this.center.applyMatrix4( matrix );
				this.radius = this.radius * matrix.getMaxScaleOnAxis();
	
				return this;
	
			},
	
			translate: function ( offset ) {
	
				this.center.add( offset );
	
				return this;
	
			},
	
			equals: function ( sphere ) {
	
				return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 * @author tschw
		 */
	
		function Matrix3() {
	
			this.elements = new Float32Array( [
	
				1, 0, 0,
				0, 1, 0,
				0, 0, 1
	
			] );
	
			if ( arguments.length > 0 ) {
	
				console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );
	
			}
	
		}
	
		Matrix3.prototype = {
	
			constructor: Matrix3,
	
			isMatrix3: true,
	
			set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
	
				var te = this.elements;
	
				te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
				te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
				te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;
	
				return this;
	
			},
	
			identity: function () {
	
				this.set(
	
					1, 0, 0,
					0, 1, 0,
					0, 0, 1
	
				);
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().fromArray( this.elements );
	
			},
	
			copy: function ( m ) {
	
				var me = m.elements;
	
				this.set(
	
					me[ 0 ], me[ 3 ], me[ 6 ],
					me[ 1 ], me[ 4 ], me[ 7 ],
					me[ 2 ], me[ 5 ], me[ 8 ]
	
				);
	
				return this;
	
			},
	
			setFromMatrix4: function( m ) {
	
				var me = m.elements;
	
				this.set(
	
					me[ 0 ], me[ 4 ], me[  8 ],
					me[ 1 ], me[ 5 ], me[  9 ],
					me[ 2 ], me[ 6 ], me[ 10 ]
	
				);
	
				return this;
	
			},
	
			applyToBufferAttribute: function () {
	
				var v1;
	
				return function applyToBufferAttribute( attribute ) {
	
					if ( v1 === undefined ) v1 = new Vector3();
	
					for ( var i = 0, l = attribute.count; i < l; i ++ ) {
	
						v1.x = attribute.getX( i );
						v1.y = attribute.getY( i );
						v1.z = attribute.getZ( i );
	
						v1.applyMatrix3( this );
	
						attribute.setXYZ( i, v1.x, v1.y, v1.z );
	
					}
	
					return attribute;
	
				};
	
			}(),
	
			multiplyScalar: function ( s ) {
	
				var te = this.elements;
	
				te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
				te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
				te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;
	
				return this;
	
			},
	
			determinant: function () {
	
				var te = this.elements;
	
				var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
					d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
					g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];
	
				return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	
			},
	
			getInverse: function ( matrix, throwOnDegenerate ) {
	
				if ( matrix && matrix.isMatrix4 ) {
	
					console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );
	
				}
	
				var me = matrix.elements,
					te = this.elements,
	
					n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
					n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
					n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],
	
					t11 = n33 * n22 - n32 * n23,
					t12 = n32 * n13 - n33 * n12,
					t13 = n23 * n12 - n22 * n13,
	
					det = n11 * t11 + n21 * t12 + n31 * t13;
	
				if ( det === 0 ) {
	
					var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";
	
					if ( throwOnDegenerate === true ) {
	
						throw new Error( msg );
	
					} else {
	
						console.warn( msg );
	
					}
	
					return this.identity();
				}
	
				var detInv = 1 / det;
	
				te[ 0 ] = t11 * detInv;
				te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
				te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;
	
				te[ 3 ] = t12 * detInv;
				te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
				te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;
	
				te[ 6 ] = t13 * detInv;
				te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
				te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;
	
				return this;
	
			},
	
			transpose: function () {
	
				var tmp, m = this.elements;
	
				tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
				tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
				tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;
	
				return this;
	
			},
	
			getNormalMatrix: function ( matrix4 ) {
	
				return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();
	
			},
	
			transposeIntoArray: function ( r ) {
	
				var m = this.elements;
	
				r[ 0 ] = m[ 0 ];
				r[ 1 ] = m[ 3 ];
				r[ 2 ] = m[ 6 ];
				r[ 3 ] = m[ 1 ];
				r[ 4 ] = m[ 4 ];
				r[ 5 ] = m[ 7 ];
				r[ 6 ] = m[ 2 ];
				r[ 7 ] = m[ 5 ];
				r[ 8 ] = m[ 8 ];
	
				return this;
	
			},
	
			fromArray: function ( array, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				for( var i = 0; i < 9; i ++ ) {
	
					this.elements[ i ] = array[ i + offset ];
	
				}
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				var te = this.elements;
	
				array[ offset ] = te[ 0 ];
				array[ offset + 1 ] = te[ 1 ];
				array[ offset + 2 ] = te[ 2 ];
	
				array[ offset + 3 ] = te[ 3 ];
				array[ offset + 4 ] = te[ 4 ];
				array[ offset + 5 ] = te[ 5 ];
	
				array[ offset + 6 ] = te[ 6 ];
				array[ offset + 7 ] = te[ 7 ];
				array[ offset + 8 ]  = te[ 8 ];
	
				return array;
	
			}
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 */
	
		function Plane( normal, constant ) {
	
			this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
			this.constant = ( constant !== undefined ) ? constant : 0;
	
		}
	
		Plane.prototype = {
	
			constructor: Plane,
	
			set: function ( normal, constant ) {
	
				this.normal.copy( normal );
				this.constant = constant;
	
				return this;
	
			},
	
			setComponents: function ( x, y, z, w ) {
	
				this.normal.set( x, y, z );
				this.constant = w;
	
				return this;
	
			},
	
			setFromNormalAndCoplanarPoint: function ( normal, point ) {
	
				this.normal.copy( normal );
				this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized
	
				return this;
	
			},
	
			setFromCoplanarPoints: function () {
	
				var v1 = new Vector3();
				var v2 = new Vector3();
	
				return function setFromCoplanarPoints( a, b, c ) {
	
					var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();
	
					// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	
					this.setFromNormalAndCoplanarPoint( normal, a );
	
					return this;
	
				};
	
			}(),
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( plane ) {
	
				this.normal.copy( plane.normal );
				this.constant = plane.constant;
	
				return this;
	
			},
	
			normalize: function () {
	
				// Note: will lead to a divide by zero if the plane is invalid.
	
				var inverseNormalLength = 1.0 / this.normal.length();
				this.normal.multiplyScalar( inverseNormalLength );
				this.constant *= inverseNormalLength;
	
				return this;
	
			},
	
			negate: function () {
	
				this.constant *= - 1;
				this.normal.negate();
	
				return this;
	
			},
	
			distanceToPoint: function ( point ) {
	
				return this.normal.dot( point ) + this.constant;
	
			},
	
			distanceToSphere: function ( sphere ) {
	
				return this.distanceToPoint( sphere.center ) - sphere.radius;
	
			},
	
			projectPoint: function ( point, optionalTarget ) {
	
				return this.orthoPoint( point, optionalTarget ).sub( point ).negate();
	
			},
	
			orthoPoint: function ( point, optionalTarget ) {
	
				var perpendicularMagnitude = this.distanceToPoint( point );
	
				var result = optionalTarget || new Vector3();
				return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );
	
			},
	
			intersectLine: function () {
	
				var v1 = new Vector3();
	
				return function intersectLine( line, optionalTarget ) {
	
					var result = optionalTarget || new Vector3();
	
					var direction = line.delta( v1 );
	
					var denominator = this.normal.dot( direction );
	
					if ( denominator === 0 ) {
	
						// line is coplanar, return origin
						if ( this.distanceToPoint( line.start ) === 0 ) {
	
							return result.copy( line.start );
	
						}
	
						// Unsure if this is the correct method to handle this case.
						return undefined;
	
					}
	
					var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;
	
					if ( t < 0 || t > 1 ) {
	
						return undefined;
	
					}
	
					return result.copy( direction ).multiplyScalar( t ).add( line.start );
	
				};
	
			}(),
	
			intersectsLine: function ( line ) {
	
				// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
	
				var startSign = this.distanceToPoint( line.start );
				var endSign = this.distanceToPoint( line.end );
	
				return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );
	
			},
	
			intersectsBox: function ( box ) {
	
				return box.intersectsPlane( this );
	
			},
	
			intersectsSphere: function ( sphere ) {
	
				return sphere.intersectsPlane( this );
	
			},
	
			coplanarPoint: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.copy( this.normal ).multiplyScalar( - this.constant );
	
			},
	
			applyMatrix4: function () {
	
				var v1 = new Vector3();
				var m1 = new Matrix3();
	
				return function applyMatrix4( matrix, optionalNormalMatrix ) {
	
					var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );
	
					// transform normal based on theory here:
					// http://www.songho.ca/opengl/gl_normaltransform.html
					var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
					var normal = this.normal.applyMatrix3( normalMatrix ).normalize();
	
					// recalculate constant (like in setFromNormalAndCoplanarPoint)
					this.constant = - referencePoint.dot( normal );
	
					return this;
	
				};
	
			}(),
	
			translate: function ( offset ) {
	
				this.constant = this.constant - offset.dot( this.normal );
	
				return this;
	
			},
	
			equals: function ( plane ) {
	
				return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author bhouston / http://clara.io
		 */
	
		function Frustum( p0, p1, p2, p3, p4, p5 ) {
	
			this.planes = [
	
				( p0 !== undefined ) ? p0 : new Plane(),
				( p1 !== undefined ) ? p1 : new Plane(),
				( p2 !== undefined ) ? p2 : new Plane(),
				( p3 !== undefined ) ? p3 : new Plane(),
				( p4 !== undefined ) ? p4 : new Plane(),
				( p5 !== undefined ) ? p5 : new Plane()
	
			];
	
		}
	
		Frustum.prototype = {
	
			constructor: Frustum,
	
			set: function ( p0, p1, p2, p3, p4, p5 ) {
	
				var planes = this.planes;
	
				planes[ 0 ].copy( p0 );
				planes[ 1 ].copy( p1 );
				planes[ 2 ].copy( p2 );
				planes[ 3 ].copy( p3 );
				planes[ 4 ].copy( p4 );
				planes[ 5 ].copy( p5 );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( frustum ) {
	
				var planes = this.planes;
	
				for ( var i = 0; i < 6; i ++ ) {
	
					planes[ i ].copy( frustum.planes[ i ] );
	
				}
	
				return this;
	
			},
	
			setFromMatrix: function ( m ) {
	
				var planes = this.planes;
				var me = m.elements;
				var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
				var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
				var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
				var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];
	
				planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
				planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
				planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
				planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
				planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
				planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();
	
				return this;
	
			},
	
			intersectsObject: function () {
	
				var sphere = new Sphere();
	
				return function intersectsObject( object ) {
	
					var geometry = object.geometry;
	
					if ( geometry.boundingSphere === null )
						geometry.computeBoundingSphere();
	
					sphere.copy( geometry.boundingSphere )
						.applyMatrix4( object.matrixWorld );
	
					return this.intersectsSphere( sphere );
	
				};
	
			}(),
	
			intersectsSprite: function () {
	
				var sphere = new Sphere();
	
				return function intersectsSprite( sprite ) {
	
					sphere.center.set( 0, 0, 0 );
					sphere.radius = 0.7071067811865476;
					sphere.applyMatrix4( sprite.matrixWorld );
	
					return this.intersectsSphere( sphere );
	
				};
	
			}(),
	
			intersectsSphere: function ( sphere ) {
	
				var planes = this.planes;
				var center = sphere.center;
				var negRadius = - sphere.radius;
	
				for ( var i = 0; i < 6; i ++ ) {
	
					var distance = planes[ i ].distanceToPoint( center );
	
					if ( distance < negRadius ) {
	
						return false;
	
					}
	
				}
	
				return true;
	
			},
	
			intersectsBox: function () {
	
				var p1 = new Vector3(),
					p2 = new Vector3();
	
				return function intersectsBox( box ) {
	
					var planes = this.planes;
	
					for ( var i = 0; i < 6 ; i ++ ) {
	
						var plane = planes[ i ];
	
						p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
						p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
						p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
						p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
						p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
						p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;
	
						var d1 = plane.distanceToPoint( p1 );
						var d2 = plane.distanceToPoint( p2 );
	
						// if both outside plane, no intersection
	
						if ( d1 < 0 && d2 < 0 ) {
	
							return false;
	
						}
	
					}
	
					return true;
	
				};
	
			}(),
	
	
			containsPoint: function ( point ) {
	
				var planes = this.planes;
	
				for ( var i = 0; i < 6; i ++ ) {
	
					if ( planes[ i ].distanceToPoint( point ) < 0 ) {
	
						return false;
	
					}
	
				}
	
				return true;
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {
	
			var _gl = _renderer.context,
			_state = _renderer.state,
			_frustum = new Frustum(),
			_projScreenMatrix = new Matrix4(),
	
			_lightShadows = _lights.shadows,
	
			_shadowMapSize = new Vector2(),
			_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),
	
			_lookTarget = new Vector3(),
			_lightPositionWorld = new Vector3(),
	
			_renderList = [],
	
			_MorphingFlag = 1,
			_SkinningFlag = 2,
	
			_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,
	
			_depthMaterials = new Array( _NumberOfMaterialVariants ),
			_distanceMaterials = new Array( _NumberOfMaterialVariants ),
	
			_materialCache = {};
	
			var cubeDirections = [
				new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
				new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
			];
	
			var cubeUps = [
				new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
				new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
			];
	
			var cube2DViewPorts = [
				new Vector4(), new Vector4(), new Vector4(),
				new Vector4(), new Vector4(), new Vector4()
			];
	
			// init
	
			var depthMaterialTemplate = new MeshDepthMaterial();
			depthMaterialTemplate.depthPacking = RGBADepthPacking;
			depthMaterialTemplate.clipping = true;
	
			var distanceShader = ShaderLib[ "distanceRGBA" ];
			var distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );
	
			for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {
	
				var useMorphing = ( i & _MorphingFlag ) !== 0;
				var useSkinning = ( i & _SkinningFlag ) !== 0;
	
				var depthMaterial = depthMaterialTemplate.clone();
				depthMaterial.morphTargets = useMorphing;
				depthMaterial.skinning = useSkinning;
	
				_depthMaterials[ i ] = depthMaterial;
	
				var distanceMaterial = new ShaderMaterial( {
					defines: {
						'USE_SHADOWMAP': ''
					},
					uniforms: distanceUniforms,
					vertexShader: distanceShader.vertexShader,
					fragmentShader: distanceShader.fragmentShader,
					morphTargets: useMorphing,
					skinning: useSkinning,
					clipping: true
				} );
	
				_distanceMaterials[ i ] = distanceMaterial;
	
			}
	
			//
	
			var scope = this;
	
			this.enabled = false;
	
			this.autoUpdate = true;
			this.needsUpdate = false;
	
			this.type = PCFShadowMap;
	
			this.renderReverseSided = true;
			this.renderSingleSided = true;
	
			this.render = function ( scene, camera ) {
	
				if ( scope.enabled === false ) return;
				if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;
	
				if ( _lightShadows.length === 0 ) return;
	
				// Set GL state for depth map.
				_state.buffers.color.setClear( 1, 1, 1, 1 );
				_state.disable( _gl.BLEND );
				_state.setDepthTest( true );
				_state.setScissorTest( false );
	
				// render depth map
	
				var faceCount, isPointLight;
	
				for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {
	
					var light = _lightShadows[ i ];
					var shadow = light.shadow;
	
					if ( shadow === undefined ) {
	
						console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
						continue;
	
					}
	
					var shadowCamera = shadow.camera;
	
					_shadowMapSize.copy( shadow.mapSize );
					_shadowMapSize.min( _maxShadowMapSize );
	
					if ( light && light.isPointLight ) {
	
						faceCount = 6;
						isPointLight = true;
	
						var vpWidth = _shadowMapSize.x;
						var vpHeight = _shadowMapSize.y;
	
						// These viewports map a cube-map onto a 2D texture with the
						// following orientation:
						//
						//  xzXZ
						//   y Y
						//
						// X - Positive x direction
						// x - Negative x direction
						// Y - Positive y direction
						// y - Negative y direction
						// Z - Positive z direction
						// z - Negative z direction
	
						// positive X
						cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
						// negative X
						cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
						// positive Z
						cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
						// negative Z
						cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
						// positive Y
						cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
						// negative Y
						cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );
	
						_shadowMapSize.x *= 4.0;
						_shadowMapSize.y *= 2.0;
	
					} else {
	
						faceCount = 1;
						isPointLight = false;
	
					}
	
					if ( shadow.map === null ) {
	
						var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
	
						shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
	
						shadowCamera.updateProjectionMatrix();
	
					}
	
					if ( shadow.isSpotLightShadow ) {
	
						shadow.update( light );
	
					}
	
					// TODO (abelnation / sam-g-steel): is this needed?
					if (shadow && shadow.isRectAreaLightShadow ) {
	
						shadow.update( light );
	
					}
	
					var shadowMap = shadow.map;
					var shadowMatrix = shadow.matrix;
	
					_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
					shadowCamera.position.copy( _lightPositionWorld );
	
					_renderer.setRenderTarget( shadowMap );
					_renderer.clear();
	
					// render shadow map for each cube face (if omni-directional) or
					// run a single pass if not
	
					for ( var face = 0; face < faceCount; face ++ ) {
	
						if ( isPointLight ) {
	
							_lookTarget.copy( shadowCamera.position );
							_lookTarget.add( cubeDirections[ face ] );
							shadowCamera.up.copy( cubeUps[ face ] );
							shadowCamera.lookAt( _lookTarget );
	
							var vpDimensions = cube2DViewPorts[ face ];
							_state.viewport( vpDimensions );
	
						} else {
	
							_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
							shadowCamera.lookAt( _lookTarget );
	
						}
	
						shadowCamera.updateMatrixWorld();
						shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );
	
						// compute shadow matrix
	
						shadowMatrix.set(
							0.5, 0.0, 0.0, 0.5,
							0.0, 0.5, 0.0, 0.5,
							0.0, 0.0, 0.5, 0.5,
							0.0, 0.0, 0.0, 1.0
						);
	
						shadowMatrix.multiply( shadowCamera.projectionMatrix );
						shadowMatrix.multiply( shadowCamera.matrixWorldInverse );
	
						// update camera matrices and frustum
	
						_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
						_frustum.setFromMatrix( _projScreenMatrix );
	
						// set object matrices & frustum culling
	
						_renderList.length = 0;
	
						projectObject( scene, camera, shadowCamera );
	
						// render shadow map
						// render regular objects
	
						for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {
	
							var object = _renderList[ j ];
							var geometry = _objects.update( object );
							var material = object.material;
	
							if ( material && material.isMultiMaterial ) {
	
								var groups = geometry.groups;
								var materials = material.materials;
	
								for ( var k = 0, kl = groups.length; k < kl; k ++ ) {
	
									var group = groups[ k ];
									var groupMaterial = materials[ group.materialIndex ];
	
									if ( groupMaterial.visible === true ) {
	
										var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
										_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );
	
									}
	
								}
	
							} else {
	
								var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );
	
							}
	
						}
	
					}
	
				}
	
				// Restore GL state.
				var clearColor = _renderer.getClearColor(),
				clearAlpha = _renderer.getClearAlpha();
				_renderer.setClearColor( clearColor, clearAlpha );
	
				scope.needsUpdate = false;
	
			};
	
			function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {
	
				var geometry = object.geometry;
	
				var result = null;
	
				var materialVariants = _depthMaterials;
				var customMaterial = object.customDepthMaterial;
	
				if ( isPointLight ) {
	
					materialVariants = _distanceMaterials;
					customMaterial = object.customDistanceMaterial;
	
				}
	
				if ( ! customMaterial ) {
	
					var useMorphing = false;
	
					if ( material.morphTargets ) {
	
						if ( geometry && geometry.isBufferGeometry ) {
	
							useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
	
						} else if ( geometry && geometry.isGeometry ) {
	
							useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
	
						}
	
					}
	
					var useSkinning = object.isSkinnedMesh && material.skinning;
	
					var variantIndex = 0;
	
					if ( useMorphing ) variantIndex |= _MorphingFlag;
					if ( useSkinning ) variantIndex |= _SkinningFlag;
	
					result = materialVariants[ variantIndex ];
	
				} else {
	
					result = customMaterial;
	
				}
	
				if ( _renderer.localClippingEnabled &&
					 material.clipShadows === true &&
						material.clippingPlanes.length !== 0 ) {
	
					// in this case we need a unique material instance reflecting the
					// appropriate state
	
					var keyA = result.uuid, keyB = material.uuid;
	
					var materialsForVariant = _materialCache[ keyA ];
	
					if ( materialsForVariant === undefined ) {
	
						materialsForVariant = {};
						_materialCache[ keyA ] = materialsForVariant;
	
					}
	
					var cachedMaterial = materialsForVariant[ keyB ];
	
					if ( cachedMaterial === undefined ) {
	
						cachedMaterial = result.clone();
						materialsForVariant[ keyB ] = cachedMaterial;
	
					}
	
					result = cachedMaterial;
	
				}
	
				result.visible = material.visible;
				result.wireframe = material.wireframe;
	
				var side = material.side;
	
				if ( scope.renderSingleSided && side == DoubleSide ) {
	
					side = FrontSide;
	
				}
	
				if ( scope.renderReverseSided ) {
	
					if ( side === FrontSide ) side = BackSide;
					else if ( side === BackSide ) side = FrontSide;
	
				}
	
				result.side = side;
	
				result.clipShadows = material.clipShadows;
				result.clippingPlanes = material.clippingPlanes;
	
				result.wireframeLinewidth = material.wireframeLinewidth;
				result.linewidth = material.linewidth;
	
				if ( isPointLight && result.uniforms.lightPos !== undefined ) {
	
					result.uniforms.lightPos.value.copy( lightPositionWorld );
	
				}
	
				return result;
	
			}
	
			function projectObject( object, camera, shadowCamera ) {
	
				if ( object.visible === false ) return;
	
				var visible = ( object.layers.mask & camera.layers.mask ) !== 0;
	
				if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {
	
					if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {
	
						var material = object.material;
	
						if ( material.visible === true ) {
	
							object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
							_renderList.push( object );
	
						}
	
					}
	
				}
	
				var children = object.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					projectObject( children[ i ], camera, shadowCamera );
	
				}
	
			}
	
		}
	
		/**
		 * @author bhouston / http://clara.io
		 */
	
		function Ray( origin, direction ) {
	
			this.origin = ( origin !== undefined ) ? origin : new Vector3();
			this.direction = ( direction !== undefined ) ? direction : new Vector3();
	
		}
	
		Ray.prototype = {
	
			constructor: Ray,
	
			set: function ( origin, direction ) {
	
				this.origin.copy( origin );
				this.direction.copy( direction );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( ray ) {
	
				this.origin.copy( ray.origin );
				this.direction.copy( ray.direction );
	
				return this;
	
			},
	
			at: function ( t, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );
	
			},
	
			lookAt: function ( v ) {
	
				this.direction.copy( v ).sub( this.origin ).normalize();
	
				return this;
	
			},
	
			recast: function () {
	
				var v1 = new Vector3();
	
				return function recast( t ) {
	
					this.origin.copy( this.at( t, v1 ) );
	
					return this;
	
				};
	
			}(),
	
			closestPointToPoint: function ( point, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				result.subVectors( point, this.origin );
				var directionDistance = result.dot( this.direction );
	
				if ( directionDistance < 0 ) {
	
					return result.copy( this.origin );
	
				}
	
				return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
			},
	
			distanceToPoint: function ( point ) {
	
				return Math.sqrt( this.distanceSqToPoint( point ) );
	
			},
	
			distanceSqToPoint: function () {
	
				var v1 = new Vector3();
	
				return function distanceSqToPoint( point ) {
	
					var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );
	
					// point behind the ray
	
					if ( directionDistance < 0 ) {
	
						return this.origin.distanceToSquared( point );
	
					}
	
					v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
					return v1.distanceToSquared( point );
	
				};
	
			}(),
	
			distanceSqToSegment: function () {
	
				var segCenter = new Vector3();
				var segDir = new Vector3();
				var diff = new Vector3();
	
				return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {
	
					// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
					// It returns the min distance between the ray and the segment
					// defined by v0 and v1
					// It can also set two optional targets :
					// - The closest point on the ray
					// - The closest point on the segment
	
					segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
					segDir.copy( v1 ).sub( v0 ).normalize();
					diff.copy( this.origin ).sub( segCenter );
	
					var segExtent = v0.distanceTo( v1 ) * 0.5;
					var a01 = - this.direction.dot( segDir );
					var b0 = diff.dot( this.direction );
					var b1 = - diff.dot( segDir );
					var c = diff.lengthSq();
					var det = Math.abs( 1 - a01 * a01 );
					var s0, s1, sqrDist, extDet;
	
					if ( det > 0 ) {
	
						// The ray and segment are not parallel.
	
						s0 = a01 * b1 - b0;
						s1 = a01 * b0 - b1;
						extDet = segExtent * det;
	
						if ( s0 >= 0 ) {
	
							if ( s1 >= - extDet ) {
	
								if ( s1 <= extDet ) {
	
									// region 0
									// Minimum at interior points of ray and segment.
	
									var invDet = 1 / det;
									s0 *= invDet;
									s1 *= invDet;
									sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;
	
								} else {
	
									// region 1
	
									s1 = segExtent;
									s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
									sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
								}
	
							} else {
	
								// region 5
	
								s1 = - segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							}
	
						} else {
	
							if ( s1 <= - extDet ) {
	
								// region 4
	
								s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
								s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							} else if ( s1 <= extDet ) {
	
								// region 3
	
								s0 = 0;
								s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = s1 * ( s1 + 2 * b1 ) + c;
	
							} else {
	
								// region 2
	
								s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
								s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							}
	
						}
	
					} else {
	
						// Ray and segment are parallel.
	
						s1 = ( a01 > 0 ) ? - segExtent : segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
					}
	
					if ( optionalPointOnRay ) {
	
						optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );
	
					}
	
					if ( optionalPointOnSegment ) {
	
						optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );
	
					}
	
					return sqrDist;
	
				};
	
			}(),
	
			intersectSphere: function () {
	
				var v1 = new Vector3();
	
				return function intersectSphere( sphere, optionalTarget ) {
	
					v1.subVectors( sphere.center, this.origin );
					var tca = v1.dot( this.direction );
					var d2 = v1.dot( v1 ) - tca * tca;
					var radius2 = sphere.radius * sphere.radius;
	
					if ( d2 > radius2 ) return null;
	
					var thc = Math.sqrt( radius2 - d2 );
	
					// t0 = first intersect point - entrance on front of sphere
					var t0 = tca - thc;
	
					// t1 = second intersect point - exit point on back of sphere
					var t1 = tca + thc;
	
					// test to see if both t0 and t1 are behind the ray - if so, return null
					if ( t0 < 0 && t1 < 0 ) return null;
	
					// test to see if t0 is behind the ray:
					// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
					// in order to always return an intersect point that is in front of the ray.
					if ( t0 < 0 ) return this.at( t1, optionalTarget );
	
					// else t0 is in front of the ray, so return the first collision point scaled by t0
					return this.at( t0, optionalTarget );
	
				};
	
			}(),
	
			intersectsSphere: function ( sphere ) {
	
				return this.distanceToPoint( sphere.center ) <= sphere.radius;
	
			},
	
			distanceToPlane: function ( plane ) {
	
				var denominator = plane.normal.dot( this.direction );
	
				if ( denominator === 0 ) {
	
					// line is coplanar, return origin
					if ( plane.distanceToPoint( this.origin ) === 0 ) {
	
						return 0;
	
					}
	
					// Null is preferable to undefined since undefined means.... it is undefined
	
					return null;
	
				}
	
				var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;
	
				// Return if the ray never intersects the plane
	
				return t >= 0 ? t :  null;
	
			},
	
			intersectPlane: function ( plane, optionalTarget ) {
	
				var t = this.distanceToPlane( plane );
	
				if ( t === null ) {
	
					return null;
	
				}
	
				return this.at( t, optionalTarget );
	
			},
	
	
	
			intersectsPlane: function ( plane ) {
	
				// check if the ray lies on the plane first
	
				var distToPoint = plane.distanceToPoint( this.origin );
	
				if ( distToPoint === 0 ) {
	
					return true;
	
				}
	
				var denominator = plane.normal.dot( this.direction );
	
				if ( denominator * distToPoint < 0 ) {
	
					return true;
	
				}
	
				// ray origin is behind the plane (and is pointing behind it)
	
				return false;
	
			},
	
			intersectBox: function ( box, optionalTarget ) {
	
				var tmin, tmax, tymin, tymax, tzmin, tzmax;
	
				var invdirx = 1 / this.direction.x,
					invdiry = 1 / this.direction.y,
					invdirz = 1 / this.direction.z;
	
				var origin = this.origin;
	
				if ( invdirx >= 0 ) {
	
					tmin = ( box.min.x - origin.x ) * invdirx;
					tmax = ( box.max.x - origin.x ) * invdirx;
	
				} else {
	
					tmin = ( box.max.x - origin.x ) * invdirx;
					tmax = ( box.min.x - origin.x ) * invdirx;
	
				}
	
				if ( invdiry >= 0 ) {
	
					tymin = ( box.min.y - origin.y ) * invdiry;
					tymax = ( box.max.y - origin.y ) * invdiry;
	
				} else {
	
					tymin = ( box.max.y - origin.y ) * invdiry;
					tymax = ( box.min.y - origin.y ) * invdiry;
	
				}
	
				if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;
	
				// These lines also handle the case where tmin or tmax is NaN
				// (result of 0 * Infinity). x !== x returns true if x is NaN
	
				if ( tymin > tmin || tmin !== tmin ) tmin = tymin;
	
				if ( tymax < tmax || tmax !== tmax ) tmax = tymax;
	
				if ( invdirz >= 0 ) {
	
					tzmin = ( box.min.z - origin.z ) * invdirz;
					tzmax = ( box.max.z - origin.z ) * invdirz;
	
				} else {
	
					tzmin = ( box.max.z - origin.z ) * invdirz;
					tzmax = ( box.min.z - origin.z ) * invdirz;
	
				}
	
				if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;
	
				if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;
	
				if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;
	
				//return point closest to the ray (positive side)
	
				if ( tmax < 0 ) return null;
	
				return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );
	
			},
	
			intersectsBox: ( function () {
	
				var v = new Vector3();
	
				return function intersectsBox( box ) {
	
					return this.intersectBox( box, v ) !== null;
	
				};
	
			} )(),
	
			intersectTriangle: function () {
	
				// Compute the offset origin, edges, and normal.
				var diff = new Vector3();
				var edge1 = new Vector3();
				var edge2 = new Vector3();
				var normal = new Vector3();
	
				return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {
	
					// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
	
					edge1.subVectors( b, a );
					edge2.subVectors( c, a );
					normal.crossVectors( edge1, edge2 );
	
					// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
					// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
					//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
					//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
					//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
					var DdN = this.direction.dot( normal );
					var sign;
	
					if ( DdN > 0 ) {
	
						if ( backfaceCulling ) return null;
						sign = 1;
	
					} else if ( DdN < 0 ) {
	
						sign = - 1;
						DdN = - DdN;
	
					} else {
	
						return null;
	
					}
	
					diff.subVectors( this.origin, a );
					var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );
	
					// b1 < 0, no intersection
					if ( DdQxE2 < 0 ) {
	
						return null;
	
					}
	
					var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );
	
					// b2 < 0, no intersection
					if ( DdE1xQ < 0 ) {
	
						return null;
	
					}
	
					// b1+b2 > 1, no intersection
					if ( DdQxE2 + DdE1xQ > DdN ) {
	
						return null;
	
					}
	
					// Line intersects triangle, check if ray does.
					var QdN = - sign * diff.dot( normal );
	
					// t < 0, no intersection
					if ( QdN < 0 ) {
	
						return null;
	
					}
	
					// Ray intersects triangle.
					return this.at( QdN / DdN, optionalTarget );
	
				};
	
			}(),
	
			applyMatrix4: function ( matrix4 ) {
	
				this.direction.add( this.origin ).applyMatrix4( matrix4 );
				this.origin.applyMatrix4( matrix4 );
				this.direction.sub( this.origin );
				this.direction.normalize();
	
				return this;
	
			},
	
			equals: function ( ray ) {
	
				return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author bhouston / http://clara.io
		 */
	
		function Euler( x, y, z, order ) {
	
			this._x = x || 0;
			this._y = y || 0;
			this._z = z || 0;
			this._order = order || Euler.DefaultOrder;
	
		}
	
		Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
	
		Euler.DefaultOrder = 'XYZ';
	
		Euler.prototype = {
	
			constructor: Euler,
	
			isEuler: true,
	
			get x () {
	
				return this._x;
	
			},
	
			set x ( value ) {
	
				this._x = value;
				this.onChangeCallback();
	
			},
	
			get y () {
	
				return this._y;
	
			},
	
			set y ( value ) {
	
				this._y = value;
				this.onChangeCallback();
	
			},
	
			get z () {
	
				return this._z;
	
			},
	
			set z ( value ) {
	
				this._z = value;
				this.onChangeCallback();
	
			},
	
			get order () {
	
				return this._order;
	
			},
	
			set order ( value ) {
	
				this._order = value;
				this.onChangeCallback();
	
			},
	
			set: function ( x, y, z, order ) {
	
				this._x = x;
				this._y = y;
				this._z = z;
				this._order = order || this._order;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor( this._x, this._y, this._z, this._order );
	
			},
	
			copy: function ( euler ) {
	
				this._x = euler._x;
				this._y = euler._y;
				this._z = euler._z;
				this._order = euler._order;
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			setFromRotationMatrix: function ( m, order, update ) {
	
				var clamp = _Math.clamp;
	
				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
				var te = m.elements;
				var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
				var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
				var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
				order = order || this._order;
	
				if ( order === 'XYZ' ) {
	
					this._y = Math.asin( clamp( m13, - 1, 1 ) );
	
					if ( Math.abs( m13 ) < 0.99999 ) {
	
						this._x = Math.atan2( - m23, m33 );
						this._z = Math.atan2( - m12, m11 );
	
					} else {
	
						this._x = Math.atan2( m32, m22 );
						this._z = 0;
	
					}
	
				} else if ( order === 'YXZ' ) {
	
					this._x = Math.asin( - clamp( m23, - 1, 1 ) );
	
					if ( Math.abs( m23 ) < 0.99999 ) {
	
						this._y = Math.atan2( m13, m33 );
						this._z = Math.atan2( m21, m22 );
	
					} else {
	
						this._y = Math.atan2( - m31, m11 );
						this._z = 0;
	
					}
	
				} else if ( order === 'ZXY' ) {
	
					this._x = Math.asin( clamp( m32, - 1, 1 ) );
	
					if ( Math.abs( m32 ) < 0.99999 ) {
	
						this._y = Math.atan2( - m31, m33 );
						this._z = Math.atan2( - m12, m22 );
	
					} else {
	
						this._y = 0;
						this._z = Math.atan2( m21, m11 );
	
					}
	
				} else if ( order === 'ZYX' ) {
	
					this._y = Math.asin( - clamp( m31, - 1, 1 ) );
	
					if ( Math.abs( m31 ) < 0.99999 ) {
	
						this._x = Math.atan2( m32, m33 );
						this._z = Math.atan2( m21, m11 );
	
					} else {
	
						this._x = 0;
						this._z = Math.atan2( - m12, m22 );
	
					}
	
				} else if ( order === 'YZX' ) {
	
					this._z = Math.asin( clamp( m21, - 1, 1 ) );
	
					if ( Math.abs( m21 ) < 0.99999 ) {
	
						this._x = Math.atan2( - m23, m22 );
						this._y = Math.atan2( - m31, m11 );
	
					} else {
	
						this._x = 0;
						this._y = Math.atan2( m13, m33 );
	
					}
	
				} else if ( order === 'XZY' ) {
	
					this._z = Math.asin( - clamp( m12, - 1, 1 ) );
	
					if ( Math.abs( m12 ) < 0.99999 ) {
	
						this._x = Math.atan2( m32, m22 );
						this._y = Math.atan2( m13, m11 );
	
					} else {
	
						this._x = Math.atan2( - m23, m33 );
						this._y = 0;
	
					}
	
				} else {
	
					console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );
	
				}
	
				this._order = order;
	
				if ( update !== false ) this.onChangeCallback();
	
				return this;
	
			},
	
			setFromQuaternion: function () {
	
				var matrix;
	
				return function setFromQuaternion( q, order, update ) {
	
					if ( matrix === undefined ) matrix = new Matrix4();
	
					matrix.makeRotationFromQuaternion( q );
	
					return this.setFromRotationMatrix( matrix, order, update );
	
				};
	
			}(),
	
			setFromVector3: function ( v, order ) {
	
				return this.set( v.x, v.y, v.z, order || this._order );
	
			},
	
			reorder: function () {
	
				// WARNING: this discards revolution information -bhouston
	
				var q = new Quaternion();
	
				return function reorder( newOrder ) {
	
					q.setFromEuler( this );
	
					return this.setFromQuaternion( q, newOrder );
	
				};
	
			}(),
	
			equals: function ( euler ) {
	
				return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );
	
			},
	
			fromArray: function ( array ) {
	
				this._x = array[ 0 ];
				this._y = array[ 1 ];
				this._z = array[ 2 ];
				if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
	
				this.onChangeCallback();
	
				return this;
	
			},
	
			toArray: function ( array, offset ) {
	
				if ( array === undefined ) array = [];
				if ( offset === undefined ) offset = 0;
	
				array[ offset ] = this._x;
				array[ offset + 1 ] = this._y;
				array[ offset + 2 ] = this._z;
				array[ offset + 3 ] = this._order;
	
				return array;
	
			},
	
			toVector3: function ( optionalResult ) {
	
				if ( optionalResult ) {
	
					return optionalResult.set( this._x, this._y, this._z );
	
				} else {
	
					return new Vector3( this._x, this._y, this._z );
	
				}
	
			},
	
			onChange: function ( callback ) {
	
				this.onChangeCallback = callback;
	
				return this;
	
			},
	
			onChangeCallback: function () {}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Layers() {
	
			this.mask = 1;
	
		}
	
		Layers.prototype = {
	
			constructor: Layers,
	
			set: function ( channel ) {
	
				this.mask = 1 << channel;
	
			},
	
			enable: function ( channel ) {
	
				this.mask |= 1 << channel;
	
			},
	
			toggle: function ( channel ) {
	
				this.mask ^= 1 << channel;
	
			},
	
			disable: function ( channel ) {
	
				this.mask &= ~ ( 1 << channel );
	
			},
	
			test: function ( layers ) {
	
				return ( this.mask & layers.mask ) !== 0;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author WestLangley / http://github.com/WestLangley
		 * @author elephantatwork / www.elephantatwork.ch
		 */
	
		var object3DId = 0;
	
		function Object3D() {
	
			Object.defineProperty( this, 'id', { value: object3DId ++ } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.type = 'Object3D';
	
			this.parent = null;
			this.children = [];
	
			this.up = Object3D.DefaultUp.clone();
	
			var position = new Vector3();
			var rotation = new Euler();
			var quaternion = new Quaternion();
			var scale = new Vector3( 1, 1, 1 );
	
			function onRotationChange() {
	
				quaternion.setFromEuler( rotation, false );
	
			}
	
			function onQuaternionChange() {
	
				rotation.setFromQuaternion( quaternion, undefined, false );
	
			}
	
			rotation.onChange( onRotationChange );
			quaternion.onChange( onQuaternionChange );
	
			Object.defineProperties( this, {
				position: {
					enumerable: true,
					value: position
				},
				rotation: {
					enumerable: true,
					value: rotation
				},
				quaternion: {
					enumerable: true,
					value: quaternion
				},
				scale: {
					enumerable: true,
					value: scale
				},
				modelViewMatrix: {
					value: new Matrix4()
				},
				normalMatrix: {
					value: new Matrix3()
				}
			} );
	
			this.matrix = new Matrix4();
			this.matrixWorld = new Matrix4();
	
			this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
			this.matrixWorldNeedsUpdate = false;
	
			this.layers = new Layers();
			this.visible = true;
	
			this.castShadow = false;
			this.receiveShadow = false;
	
			this.frustumCulled = true;
			this.renderOrder = 0;
	
			this.userData = {};
	
			this.onBeforeRender = function () {};
			this.onAfterRender = function () {};
	
		}
	
		Object3D.DefaultUp = new Vector3( 0, 1, 0 );
		Object3D.DefaultMatrixAutoUpdate = true;
	
		Object3D.prototype = {
	
			constructor: Object3D,
	
			isObject3D: true,
	
			applyMatrix: function ( matrix ) {
	
				this.matrix.multiplyMatrices( matrix, this.matrix );
	
				this.matrix.decompose( this.position, this.quaternion, this.scale );
	
			},
	
			setRotationFromAxisAngle: function ( axis, angle ) {
	
				// assumes axis is normalized
	
				this.quaternion.setFromAxisAngle( axis, angle );
	
			},
	
			setRotationFromEuler: function ( euler ) {
	
				this.quaternion.setFromEuler( euler, true );
	
			},
	
			setRotationFromMatrix: function ( m ) {
	
				// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
				this.quaternion.setFromRotationMatrix( m );
	
			},
	
			setRotationFromQuaternion: function ( q ) {
	
				// assumes q is normalized
	
				this.quaternion.copy( q );
	
			},
	
			rotateOnAxis: function () {
	
				// rotate object on axis in object space
				// axis is assumed to be normalized
	
				var q1 = new Quaternion();
	
				return function rotateOnAxis( axis, angle ) {
	
					q1.setFromAxisAngle( axis, angle );
	
					this.quaternion.multiply( q1 );
	
					return this;
	
				};
	
			}(),
	
			rotateX: function () {
	
				var v1 = new Vector3( 1, 0, 0 );
	
				return function rotateX( angle ) {
	
					return this.rotateOnAxis( v1, angle );
	
				};
	
			}(),
	
			rotateY: function () {
	
				var v1 = new Vector3( 0, 1, 0 );
	
				return function rotateY( angle ) {
	
					return this.rotateOnAxis( v1, angle );
	
				};
	
			}(),
	
			rotateZ: function () {
	
				var v1 = new Vector3( 0, 0, 1 );
	
				return function rotateZ( angle ) {
	
					return this.rotateOnAxis( v1, angle );
	
				};
	
			}(),
	
			translateOnAxis: function () {
	
				// translate object by distance along axis in object space
				// axis is assumed to be normalized
	
				var v1 = new Vector3();
	
				return function translateOnAxis( axis, distance ) {
	
					v1.copy( axis ).applyQuaternion( this.quaternion );
	
					this.position.add( v1.multiplyScalar( distance ) );
	
					return this;
	
				};
	
			}(),
	
			translateX: function () {
	
				var v1 = new Vector3( 1, 0, 0 );
	
				return function translateX( distance ) {
	
					return this.translateOnAxis( v1, distance );
	
				};
	
			}(),
	
			translateY: function () {
	
				var v1 = new Vector3( 0, 1, 0 );
	
				return function translateY( distance ) {
	
					return this.translateOnAxis( v1, distance );
	
				};
	
			}(),
	
			translateZ: function () {
	
				var v1 = new Vector3( 0, 0, 1 );
	
				return function translateZ( distance ) {
	
					return this.translateOnAxis( v1, distance );
	
				};
	
			}(),
	
			localToWorld: function ( vector ) {
	
				return vector.applyMatrix4( this.matrixWorld );
	
			},
	
			worldToLocal: function () {
	
				var m1 = new Matrix4();
	
				return function worldToLocal( vector ) {
	
					return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );
	
				};
	
			}(),
	
			lookAt: function () {
	
				// This routine does not support objects with rotated and/or translated parent(s)
	
				var m1 = new Matrix4();
	
				return function lookAt( vector ) {
	
					m1.lookAt( vector, this.position, this.up );
	
					this.quaternion.setFromRotationMatrix( m1 );
	
				};
	
			}(),
	
			add: function ( object ) {
	
				if ( arguments.length > 1 ) {
	
					for ( var i = 0; i < arguments.length; i ++ ) {
	
						this.add( arguments[ i ] );
	
					}
	
					return this;
	
				}
	
				if ( object === this ) {
	
					console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
					return this;
	
				}
	
				if ( ( object && object.isObject3D ) ) {
	
					if ( object.parent !== null ) {
	
						object.parent.remove( object );
	
					}
	
					object.parent = this;
					object.dispatchEvent( { type: 'added' } );
	
					this.children.push( object );
	
				} else {
	
					console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );
	
				}
	
				return this;
	
			},
	
			remove: function ( object ) {
	
				if ( arguments.length > 1 ) {
	
					for ( var i = 0; i < arguments.length; i ++ ) {
	
						this.remove( arguments[ i ] );
	
					}
	
				}
	
				var index = this.children.indexOf( object );
	
				if ( index !== - 1 ) {
	
					object.parent = null;
	
					object.dispatchEvent( { type: 'removed' } );
	
					this.children.splice( index, 1 );
	
				}
	
			},
	
			getObjectById: function ( id ) {
	
				return this.getObjectByProperty( 'id', id );
	
			},
	
			getObjectByName: function ( name ) {
	
				return this.getObjectByProperty( 'name', name );
	
			},
	
			getObjectByProperty: function ( name, value ) {
	
				if ( this[ name ] === value ) return this;
	
				for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
					var child = this.children[ i ];
					var object = child.getObjectByProperty( name, value );
	
					if ( object !== undefined ) {
	
						return object;
	
					}
	
				}
	
				return undefined;
	
			},
	
			getWorldPosition: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				this.updateMatrixWorld( true );
	
				return result.setFromMatrixPosition( this.matrixWorld );
	
			},
	
			getWorldQuaternion: function () {
	
				var position = new Vector3();
				var scale = new Vector3();
	
				return function getWorldQuaternion( optionalTarget ) {
	
					var result = optionalTarget || new Quaternion();
	
					this.updateMatrixWorld( true );
	
					this.matrixWorld.decompose( position, result, scale );
	
					return result;
	
				};
	
			}(),
	
			getWorldRotation: function () {
	
				var quaternion = new Quaternion();
	
				return function getWorldRotation( optionalTarget ) {
	
					var result = optionalTarget || new Euler();
	
					this.getWorldQuaternion( quaternion );
	
					return result.setFromQuaternion( quaternion, this.rotation.order, false );
	
				};
	
			}(),
	
			getWorldScale: function () {
	
				var position = new Vector3();
				var quaternion = new Quaternion();
	
				return function getWorldScale( optionalTarget ) {
	
					var result = optionalTarget || new Vector3();
	
					this.updateMatrixWorld( true );
	
					this.matrixWorld.decompose( position, quaternion, result );
	
					return result;
	
				};
	
			}(),
	
			getWorldDirection: function () {
	
				var quaternion = new Quaternion();
	
				return function getWorldDirection( optionalTarget ) {
	
					var result = optionalTarget || new Vector3();
	
					this.getWorldQuaternion( quaternion );
	
					return result.set( 0, 0, 1 ).applyQuaternion( quaternion );
	
				};
	
			}(),
	
			raycast: function () {},
	
			traverse: function ( callback ) {
	
				callback( this );
	
				var children = this.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					children[ i ].traverse( callback );
	
				}
	
			},
	
			traverseVisible: function ( callback ) {
	
				if ( this.visible === false ) return;
	
				callback( this );
	
				var children = this.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					children[ i ].traverseVisible( callback );
	
				}
	
			},
	
			traverseAncestors: function ( callback ) {
	
				var parent = this.parent;
	
				if ( parent !== null ) {
	
					callback( parent );
	
					parent.traverseAncestors( callback );
	
				}
	
			},
	
			updateMatrix: function () {
	
				this.matrix.compose( this.position, this.quaternion, this.scale );
	
				this.matrixWorldNeedsUpdate = true;
	
			},
	
			updateMatrixWorld: function ( force ) {
	
				if ( this.matrixAutoUpdate === true ) this.updateMatrix();
	
				if ( this.matrixWorldNeedsUpdate === true || force === true ) {
	
					if ( this.parent === null ) {
	
						this.matrixWorld.copy( this.matrix );
	
					} else {
	
						this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
					}
	
					this.matrixWorldNeedsUpdate = false;
	
					force = true;
	
				}
	
				// update children
	
				var children = this.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					children[ i ].updateMatrixWorld( force );
	
				}
	
			},
	
			toJSON: function ( meta ) {
	
				// meta is '' when called from JSON.stringify
				var isRootObject = ( meta === undefined || meta === '' );
	
				var output = {};
	
				// meta is a hash used to collect geometries, materials.
				// not providing it implies that this is the root object
				// being serialized.
				if ( isRootObject ) {
	
					// initialize meta obj
					meta = {
						geometries: {},
						materials: {},
						textures: {},
						images: {}
					};
	
					output.metadata = {
						version: 4.4,
						type: 'Object',
						generator: 'Object3D.toJSON'
					};
	
				}
	
				// standard Object3D serialization
	
				var object = {};
	
				object.uuid = this.uuid;
				object.type = this.type;
	
				if ( this.name !== '' ) object.name = this.name;
				if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
				if ( this.castShadow === true ) object.castShadow = true;
				if ( this.receiveShadow === true ) object.receiveShadow = true;
				if ( this.visible === false ) object.visible = false;
	
				object.matrix = this.matrix.toArray();
	
				//
	
				if ( this.geometry !== undefined ) {
	
					if ( meta.geometries[ this.geometry.uuid ] === undefined ) {
	
						meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );
	
					}
	
					object.geometry = this.geometry.uuid;
	
				}
	
				if ( this.material !== undefined ) {
	
					if ( meta.materials[ this.material.uuid ] === undefined ) {
	
						meta.materials[ this.material.uuid ] = this.material.toJSON( meta );
	
					}
	
					object.material = this.material.uuid;
	
				}
	
				//
	
				if ( this.children.length > 0 ) {
	
					object.children = [];
	
					for ( var i = 0; i < this.children.length; i ++ ) {
	
						object.children.push( this.children[ i ].toJSON( meta ).object );
	
					}
	
				}
	
				if ( isRootObject ) {
	
					var geometries = extractFromCache( meta.geometries );
					var materials = extractFromCache( meta.materials );
					var textures = extractFromCache( meta.textures );
					var images = extractFromCache( meta.images );
	
					if ( geometries.length > 0 ) output.geometries = geometries;
					if ( materials.length > 0 ) output.materials = materials;
					if ( textures.length > 0 ) output.textures = textures;
					if ( images.length > 0 ) output.images = images;
	
				}
	
				output.object = object;
	
				return output;
	
				// extract data from the cache hash
				// remove metadata on each item
				// and return as array
				function extractFromCache( cache ) {
	
					var values = [];
					for ( var key in cache ) {
	
						var data = cache[ key ];
						delete data.metadata;
						values.push( data );
	
					}
					return values;
	
				}
	
			},
	
			clone: function ( recursive ) {
	
				return new this.constructor().copy( this, recursive );
	
			},
	
			copy: function ( source, recursive ) {
	
				if ( recursive === undefined ) recursive = true;
	
				this.name = source.name;
	
				this.up.copy( source.up );
	
				this.position.copy( source.position );
				this.quaternion.copy( source.quaternion );
				this.scale.copy( source.scale );
	
				this.matrix.copy( source.matrix );
				this.matrixWorld.copy( source.matrixWorld );
	
				this.matrixAutoUpdate = source.matrixAutoUpdate;
				this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
	
				this.layers.mask = source.layers.mask;
				this.visible = source.visible;
	
				this.castShadow = source.castShadow;
				this.receiveShadow = source.receiveShadow;
	
				this.frustumCulled = source.frustumCulled;
				this.renderOrder = source.renderOrder;
	
				this.userData = JSON.parse( JSON.stringify( source.userData ) );
	
				if ( recursive === true ) {
	
					for ( var i = 0; i < source.children.length; i ++ ) {
	
						var child = source.children[ i ];
						this.add( child.clone() );
	
					}
	
				}
	
				return this;
	
			}
	
		};
	
		Object.assign( Object3D.prototype, EventDispatcher.prototype );
	
		/**
		 * @author bhouston / http://clara.io
		 */
	
		function Line3( start, end ) {
	
			this.start = ( start !== undefined ) ? start : new Vector3();
			this.end = ( end !== undefined ) ? end : new Vector3();
	
		}
	
		Line3.prototype = {
	
			constructor: Line3,
	
			set: function ( start, end ) {
	
				this.start.copy( start );
				this.end.copy( end );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( line ) {
	
				this.start.copy( line.start );
				this.end.copy( line.end );
	
				return this;
	
			},
	
			getCenter: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );
	
			},
	
			delta: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.subVectors( this.end, this.start );
	
			},
	
			distanceSq: function () {
	
				return this.start.distanceToSquared( this.end );
	
			},
	
			distance: function () {
	
				return this.start.distanceTo( this.end );
	
			},
	
			at: function ( t, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				return this.delta( result ).multiplyScalar( t ).add( this.start );
	
			},
	
			closestPointToPointParameter: function () {
	
				var startP = new Vector3();
				var startEnd = new Vector3();
	
				return function closestPointToPointParameter( point, clampToLine ) {
	
					startP.subVectors( point, this.start );
					startEnd.subVectors( this.end, this.start );
	
					var startEnd2 = startEnd.dot( startEnd );
					var startEnd_startP = startEnd.dot( startP );
	
					var t = startEnd_startP / startEnd2;
	
					if ( clampToLine ) {
	
						t = _Math.clamp( t, 0, 1 );
	
					}
	
					return t;
	
				};
	
			}(),
	
			closestPointToPoint: function ( point, clampToLine, optionalTarget ) {
	
				var t = this.closestPointToPointParameter( point, clampToLine );
	
				var result = optionalTarget || new Vector3();
	
				return this.delta( result ).multiplyScalar( t ).add( this.start );
	
			},
	
			applyMatrix4: function ( matrix ) {
	
				this.start.applyMatrix4( matrix );
				this.end.applyMatrix4( matrix );
	
				return this;
	
			},
	
			equals: function ( line ) {
	
				return line.start.equals( this.start ) && line.end.equals( this.end );
	
			}
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Triangle( a, b, c ) {
	
			this.a = ( a !== undefined ) ? a : new Vector3();
			this.b = ( b !== undefined ) ? b : new Vector3();
			this.c = ( c !== undefined ) ? c : new Vector3();
	
		}
	
		Triangle.normal = function () {
	
			var v0 = new Vector3();
	
			return function normal( a, b, c, optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				result.subVectors( c, b );
				v0.subVectors( a, b );
				result.cross( v0 );
	
				var resultLengthSq = result.lengthSq();
				if ( resultLengthSq > 0 ) {
	
					return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );
	
				}
	
				return result.set( 0, 0, 0 );
	
			};
	
		}();
	
		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		Triangle.barycoordFromPoint = function () {
	
			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();
	
			return function barycoordFromPoint( point, a, b, c, optionalTarget ) {
	
				v0.subVectors( c, a );
				v1.subVectors( b, a );
				v2.subVectors( point, a );
	
				var dot00 = v0.dot( v0 );
				var dot01 = v0.dot( v1 );
				var dot02 = v0.dot( v2 );
				var dot11 = v1.dot( v1 );
				var dot12 = v1.dot( v2 );
	
				var denom = ( dot00 * dot11 - dot01 * dot01 );
	
				var result = optionalTarget || new Vector3();
	
				// collinear or singular triangle
				if ( denom === 0 ) {
	
					// arbitrary location outside of triangle?
					// not sure if this is the best idea, maybe should be returning undefined
					return result.set( - 2, - 1, - 1 );
	
				}
	
				var invDenom = 1 / denom;
				var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
				var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;
	
				// barycentric coordinates must always sum to 1
				return result.set( 1 - u - v, v, u );
	
			};
	
		}();
	
		Triangle.containsPoint = function () {
	
			var v1 = new Vector3();
	
			return function containsPoint( point, a, b, c ) {
	
				var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );
	
				return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );
	
			};
	
		}();
	
		Triangle.prototype = {
	
			constructor: Triangle,
	
			set: function ( a, b, c ) {
	
				this.a.copy( a );
				this.b.copy( b );
				this.c.copy( c );
	
				return this;
	
			},
	
			setFromPointsAndIndices: function ( points, i0, i1, i2 ) {
	
				this.a.copy( points[ i0 ] );
				this.b.copy( points[ i1 ] );
				this.c.copy( points[ i2 ] );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( triangle ) {
	
				this.a.copy( triangle.a );
				this.b.copy( triangle.b );
				this.c.copy( triangle.c );
	
				return this;
	
			},
	
			area: function () {
	
				var v0 = new Vector3();
				var v1 = new Vector3();
	
				return function area() {
	
					v0.subVectors( this.c, this.b );
					v1.subVectors( this.a, this.b );
	
					return v0.cross( v1 ).length() * 0.5;
	
				};
	
			}(),
	
			midpoint: function ( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
				return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );
	
			},
	
			normal: function ( optionalTarget ) {
	
				return Triangle.normal( this.a, this.b, this.c, optionalTarget );
	
			},
	
			plane: function ( optionalTarget ) {
	
				var result = optionalTarget || new Plane();
	
				return result.setFromCoplanarPoints( this.a, this.b, this.c );
	
			},
	
			barycoordFromPoint: function ( point, optionalTarget ) {
	
				return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );
	
			},
	
			containsPoint: function ( point ) {
	
				return Triangle.containsPoint( point, this.a, this.b, this.c );
	
			},
	
			closestPointToPoint: function () {
	
				var plane, edgeList, projectedPoint, closestPoint;
	
				return function closestPointToPoint( point, optionalTarget ) {
	
					if ( plane === undefined ) {
	
						plane = new Plane();
						edgeList = [ new Line3(), new Line3(), new Line3() ];
						projectedPoint = new Vector3();
						closestPoint = new Vector3();
	
					}
	
					var result = optionalTarget || new Vector3();
					var minDistance = Infinity;
	
					// project the point onto the plane of the triangle
	
					plane.setFromCoplanarPoints( this.a, this.b, this.c );
					plane.projectPoint( point, projectedPoint );
	
					// check if the projection lies within the triangle
	
					if( this.containsPoint( projectedPoint ) === true ) {
	
						// if so, this is the closest point
	
						result.copy( projectedPoint );
	
					} else {
	
						// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices
	
						edgeList[ 0 ].set( this.a, this.b );
						edgeList[ 1 ].set( this.b, this.c );
						edgeList[ 2 ].set( this.c, this.a );
	
						for( var i = 0; i < edgeList.length; i ++ ) {
	
							edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );
	
							var distance = projectedPoint.distanceToSquared( closestPoint );
	
							if( distance < minDistance ) {
	
								minDistance = distance;
	
								result.copy( closestPoint );
	
							}
	
						}
	
					}
	
					return result;
	
				};
	
			}(),
	
			equals: function ( triangle ) {
	
				return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Face3( a, b, c, normal, color, materialIndex ) {
	
			this.a = a;
			this.b = b;
			this.c = c;
	
			this.normal = (normal && normal.isVector3) ? normal : new Vector3();
			this.vertexNormals = Array.isArray( normal ) ? normal : [];
	
			this.color = (color && color.isColor) ? color : new Color();
			this.vertexColors = Array.isArray( color ) ? color : [];
	
			this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
	
		}
	
		Face3.prototype = {
	
			constructor: Face3,
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( source ) {
	
				this.a = source.a;
				this.b = source.b;
				this.c = source.c;
	
				this.normal.copy( source.normal );
				this.color.copy( source.color );
	
				this.materialIndex = source.materialIndex;
	
				for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {
	
					this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();
	
				}
	
				for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {
	
					this.vertexColors[ i ] = source.vertexColors[ i ].clone();
	
				}
	
				return this;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  shading: THREE.SmoothShading,
		 *  depthTest: <bool>,
		 *  depthWrite: <bool>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>
		 * }
		 */
	
		function MeshBasicMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'MeshBasicMaterial';
	
			this.color = new Color( 0xffffff ); // emissive
	
			this.map = null;
	
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
	
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
	
			this.specularMap = null;
	
			this.alphaMap = null;
	
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
	
			this.skinning = false;
			this.morphTargets = false;
	
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		MeshBasicMaterial.prototype = Object.create( Material.prototype );
		MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
	
		MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
	
		MeshBasicMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.map = source.map;
	
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
	
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
	
			this.specularMap = source.specularMap;
	
			this.alphaMap = source.alphaMap;
	
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function BufferAttribute( array, itemSize, normalized ) {
	
			if ( Array.isArray( array ) ) {
	
				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
	
			}
	
			this.uuid = _Math.generateUUID();
	
			this.array = array;
			this.itemSize = itemSize;
			this.count = array !== undefined ? array.length / itemSize : 0;
			this.normalized = normalized === true;
	
			this.dynamic = false;
			this.updateRange = { offset: 0, count: - 1 };
	
			this.onUploadCallback = function () {};
	
			this.version = 0;
	
		}
	
		BufferAttribute.prototype = {
	
			constructor: BufferAttribute,
	
			isBufferAttribute: true,
	
			set needsUpdate( value ) {
	
				if ( value === true ) this.version ++;
	
			},
	
			setArray: function ( array ) {
	
				if ( Array.isArray( array ) ) {
	
					throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
	
				}
	
				this.count = array !== undefined ? array.length / this.itemSize : 0;
				this.array = array;
	
			},
	
			setDynamic: function ( value ) {
	
				this.dynamic = value;
	
				return this;
	
			},
	
			copy: function ( source ) {
	
				this.array = new source.array.constructor( source.array );
				this.itemSize = source.itemSize;
				this.count = source.count;
				this.normalized = source.normalized;
	
				this.dynamic = source.dynamic;
	
				return this;
	
			},
	
			copyAt: function ( index1, attribute, index2 ) {
	
				index1 *= this.itemSize;
				index2 *= attribute.itemSize;
	
				for ( var i = 0, l = this.itemSize; i < l; i ++ ) {
	
					this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
				}
	
				return this;
	
			},
	
			copyArray: function ( array ) {
	
				this.array.set( array );
	
				return this;
	
			},
	
			copyColorsArray: function ( colors ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = colors.length; i < l; i ++ ) {
	
					var color = colors[ i ];
	
					if ( color === undefined ) {
	
						console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
						color = new Color();
	
					}
	
					array[ offset ++ ] = color.r;
					array[ offset ++ ] = color.g;
					array[ offset ++ ] = color.b;
	
				}
	
				return this;
	
			},
	
			copyIndicesArray: function ( indices ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = indices.length; i < l; i ++ ) {
	
					var index = indices[ i ];
	
					array[ offset ++ ] = index.a;
					array[ offset ++ ] = index.b;
					array[ offset ++ ] = index.c;
	
				}
	
				return this;
	
			},
	
			copyVector2sArray: function ( vectors ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
					var vector = vectors[ i ];
	
					if ( vector === undefined ) {
	
						console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
						vector = new Vector2();
	
					}
	
					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
	
				}
	
				return this;
	
			},
	
			copyVector3sArray: function ( vectors ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
					var vector = vectors[ i ];
	
					if ( vector === undefined ) {
	
						console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
						vector = new Vector3();
	
					}
	
					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
					array[ offset ++ ] = vector.z;
	
				}
	
				return this;
	
			},
	
			copyVector4sArray: function ( vectors ) {
	
				var array = this.array, offset = 0;
	
				for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
					var vector = vectors[ i ];
	
					if ( vector === undefined ) {
	
						console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
						vector = new Vector4();
	
					}
	
					array[ offset ++ ] = vector.x;
					array[ offset ++ ] = vector.y;
					array[ offset ++ ] = vector.z;
					array[ offset ++ ] = vector.w;
	
				}
	
				return this;
	
			},
	
			set: function ( value, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.array.set( value, offset );
	
				return this;
	
			},
	
			getX: function ( index ) {
	
				return this.array[ index * this.itemSize ];
	
			},
	
			setX: function ( index, x ) {
	
				this.array[ index * this.itemSize ] = x;
	
				return this;
	
			},
	
			getY: function ( index ) {
	
				return this.array[ index * this.itemSize + 1 ];
	
			},
	
			setY: function ( index, y ) {
	
				this.array[ index * this.itemSize + 1 ] = y;
	
				return this;
	
			},
	
			getZ: function ( index ) {
	
				return this.array[ index * this.itemSize + 2 ];
	
			},
	
			setZ: function ( index, z ) {
	
				this.array[ index * this.itemSize + 2 ] = z;
	
				return this;
	
			},
	
			getW: function ( index ) {
	
				return this.array[ index * this.itemSize + 3 ];
	
			},
	
			setW: function ( index, w ) {
	
				this.array[ index * this.itemSize + 3 ] = w;
	
				return this;
	
			},
	
			setXY: function ( index, x, y ) {
	
				index *= this.itemSize;
	
				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
	
				return this;
	
			},
	
			setXYZ: function ( index, x, y, z ) {
	
				index *= this.itemSize;
	
				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
				this.array[ index + 2 ] = z;
	
				return this;
	
			},
	
			setXYZW: function ( index, x, y, z, w ) {
	
				index *= this.itemSize;
	
				this.array[ index + 0 ] = x;
				this.array[ index + 1 ] = y;
				this.array[ index + 2 ] = z;
				this.array[ index + 3 ] = w;
	
				return this;
	
			},
	
			onUpload: function ( callback ) {
	
				this.onUploadCallback = callback;
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor( this.array, this.itemSize ).copy( this );
	
			}
	
		};
	
		//
	
		function Int8BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Int8Array( array ), itemSize );
	
		}
	
		Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
	
	
		function Uint8BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Uint8Array( array ), itemSize );
	
		}
	
		Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
	
	
		function Uint8ClampedBufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize );
	
		}
	
		Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
	
	
		function Int16BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Int16Array( array ), itemSize );
	
		}
	
		Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
	
	
		function Uint16BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Uint16Array( array ), itemSize );
	
		}
	
		Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
	
	
		function Int32BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Int32Array( array ), itemSize );
	
		}
	
		Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
	
	
		function Uint32BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Uint32Array( array ), itemSize );
	
		}
	
		Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
	
	
		function Float32BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Float32Array( array ), itemSize );
	
		}
	
		Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
	
	
		function Float64BufferAttribute( array, itemSize ) {
	
			BufferAttribute.call( this, new Float64Array( array ), itemSize );
	
		}
	
		Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function DirectGeometry() {
	
			this.indices = [];
			this.vertices = [];
			this.normals = [];
			this.colors = [];
			this.uvs = [];
			this.uvs2 = [];
	
			this.groups = [];
	
			this.morphTargets = {};
	
			this.skinWeights = [];
			this.skinIndices = [];
	
			// this.lineDistances = [];
	
			this.boundingBox = null;
			this.boundingSphere = null;
	
			// update flags
	
			this.verticesNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.groupsNeedUpdate = false;
	
		}
	
		Object.assign( DirectGeometry.prototype, {
	
			computeGroups: function ( geometry ) {
	
				var group;
				var groups = [];
				var materialIndex = undefined;
	
				var faces = geometry.faces;
	
				for ( var i = 0; i < faces.length; i ++ ) {
	
					var face = faces[ i ];
	
					// materials
	
					if ( face.materialIndex !== materialIndex ) {
	
						materialIndex = face.materialIndex;
	
						if ( group !== undefined ) {
	
							group.count = ( i * 3 ) - group.start;
							groups.push( group );
	
						}
	
						group = {
							start: i * 3,
							materialIndex: materialIndex
						};
	
					}
	
				}
	
				if ( group !== undefined ) {
	
					group.count = ( i * 3 ) - group.start;
					groups.push( group );
	
				}
	
				this.groups = groups;
	
			},
	
			fromGeometry: function ( geometry ) {
	
				var faces = geometry.faces;
				var vertices = geometry.vertices;
				var faceVertexUvs = geometry.faceVertexUvs;
	
				var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
				var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;
	
				// morphs
	
				var morphTargets = geometry.morphTargets;
				var morphTargetsLength = morphTargets.length;
	
				var morphTargetsPosition;
	
				if ( morphTargetsLength > 0 ) {
	
					morphTargetsPosition = [];
	
					for ( var i = 0; i < morphTargetsLength; i ++ ) {
	
						morphTargetsPosition[ i ] = [];
	
					}
	
					this.morphTargets.position = morphTargetsPosition;
	
				}
	
				var morphNormals = geometry.morphNormals;
				var morphNormalsLength = morphNormals.length;
	
				var morphTargetsNormal;
	
				if ( morphNormalsLength > 0 ) {
	
					morphTargetsNormal = [];
	
					for ( var i = 0; i < morphNormalsLength; i ++ ) {
	
						morphTargetsNormal[ i ] = [];
	
					}
	
					this.morphTargets.normal = morphTargetsNormal;
	
				}
	
				// skins
	
				var skinIndices = geometry.skinIndices;
				var skinWeights = geometry.skinWeights;
	
				var hasSkinIndices = skinIndices.length === vertices.length;
				var hasSkinWeights = skinWeights.length === vertices.length;
	
				//
	
				for ( var i = 0; i < faces.length; i ++ ) {
	
					var face = faces[ i ];
	
					this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );
	
					var vertexNormals = face.vertexNormals;
	
					if ( vertexNormals.length === 3 ) {
	
						this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );
	
					} else {
	
						var normal = face.normal;
	
						this.normals.push( normal, normal, normal );
	
					}
	
					var vertexColors = face.vertexColors;
	
					if ( vertexColors.length === 3 ) {
	
						this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );
	
					} else {
	
						var color = face.color;
	
						this.colors.push( color, color, color );
	
					}
	
					if ( hasFaceVertexUv === true ) {
	
						var vertexUvs = faceVertexUvs[ 0 ][ i ];
	
						if ( vertexUvs !== undefined ) {
	
							this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
						} else {
	
							console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );
	
							this.uvs.push( new Vector2(), new Vector2(), new Vector2() );
	
						}
	
					}
	
					if ( hasFaceVertexUv2 === true ) {
	
						var vertexUvs = faceVertexUvs[ 1 ][ i ];
	
						if ( vertexUvs !== undefined ) {
	
							this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
						} else {
	
							console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );
	
							this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );
	
						}
	
					}
	
					// morphs
	
					for ( var j = 0; j < morphTargetsLength; j ++ ) {
	
						var morphTarget = morphTargets[ j ].vertices;
	
						morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );
	
					}
	
					for ( var j = 0; j < morphNormalsLength; j ++ ) {
	
						var morphNormal = morphNormals[ j ].vertexNormals[ i ];
	
						morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );
	
					}
	
					// skins
	
					if ( hasSkinIndices ) {
	
						this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );
	
					}
	
					if ( hasSkinWeights ) {
	
						this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );
	
					}
	
				}
	
				this.computeGroups( geometry );
	
				this.verticesNeedUpdate = geometry.verticesNeedUpdate;
				this.normalsNeedUpdate = geometry.normalsNeedUpdate;
				this.colorsNeedUpdate = geometry.colorsNeedUpdate;
				this.uvsNeedUpdate = geometry.uvsNeedUpdate;
				this.groupsNeedUpdate = geometry.groupsNeedUpdate;
	
				return this;
	
			}
	
		} );
	
		// http://stackoverflow.com/questions/1669190/javascript-min-max-array-values/13440842#13440842
	
		function arrayMax( array ) {
	
			var length = array.length, max = - Infinity;
	
			while ( length -- ) {
	
				if ( array[ length ] > max ) {
	
					max = array[ length ];
	
				}
	
			}
	
			return max;
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author kile / http://kile.stravaganza.org/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author bhouston / http://clara.io
		 */
	
		var count = 0;
		function GeometryIdCount() { return count++; }
	
		function Geometry() {
	
			Object.defineProperty( this, 'id', { value: GeometryIdCount() } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.type = 'Geometry';
	
			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [[]];
	
			this.morphTargets = [];
			this.morphNormals = [];
	
			this.skinWeights = [];
			this.skinIndices = [];
	
			this.lineDistances = [];
	
			this.boundingBox = null;
			this.boundingSphere = null;
	
			// update flags
	
			this.elementsNeedUpdate = false;
			this.verticesNeedUpdate = false;
			this.uvsNeedUpdate = false;
			this.normalsNeedUpdate = false;
			this.colorsNeedUpdate = false;
			this.lineDistancesNeedUpdate = false;
			this.groupsNeedUpdate = false;
	
		}
	
		Geometry.prototype = {
	
			constructor: Geometry,
	
			isGeometry: true,
	
			applyMatrix: function ( matrix ) {
	
				var normalMatrix = new Matrix3().getNormalMatrix( matrix );
	
				for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {
	
					var vertex = this.vertices[ i ];
					vertex.applyMatrix4( matrix );
	
				}
	
				for ( var i = 0, il = this.faces.length; i < il; i ++ ) {
	
					var face = this.faces[ i ];
					face.normal.applyMatrix3( normalMatrix ).normalize();
	
					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
						face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();
	
					}
	
				}
	
				if ( this.boundingBox !== null ) {
	
					this.computeBoundingBox();
	
				}
	
				if ( this.boundingSphere !== null ) {
	
					this.computeBoundingSphere();
	
				}
	
				this.verticesNeedUpdate = true;
				this.normalsNeedUpdate = true;
	
				return this;
	
			},
	
			rotateX: function () {
	
				// rotate geometry around world x-axis
	
				var m1;
	
				return function rotateX( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationX( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			rotateY: function () {
	
				// rotate geometry around world y-axis
	
				var m1;
	
				return function rotateY( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationY( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			rotateZ: function () {
	
				// rotate geometry around world z-axis
	
				var m1;
	
				return function rotateZ( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationZ( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			translate: function () {
	
				// translate geometry
	
				var m1;
	
				return function translate( x, y, z ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeTranslation( x, y, z );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			scale: function () {
	
				// scale geometry
	
				var m1;
	
				return function scale( x, y, z ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeScale( x, y, z );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			lookAt: function () {
	
				var obj;
	
				return function lookAt( vector ) {
	
					if ( obj === undefined ) obj = new Object3D();
	
					obj.lookAt( vector );
	
					obj.updateMatrix();
	
					this.applyMatrix( obj.matrix );
	
				};
	
			}(),
	
			fromBufferGeometry: function ( geometry ) {
	
				var scope = this;
	
				var indices = geometry.index !== null ? geometry.index.array : undefined;
				var attributes = geometry.attributes;
	
				var positions = attributes.position.array;
				var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
				var colors = attributes.color !== undefined ? attributes.color.array : undefined;
				var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
				var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
	
				if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];
	
				var tempNormals = [];
				var tempUVs = [];
				var tempUVs2 = [];
	
				for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {
	
					scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );
	
					if ( normals !== undefined ) {
	
						tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );
	
					}
	
					if ( colors !== undefined ) {
	
						scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );
	
					}
	
					if ( uvs !== undefined ) {
	
						tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );
	
					}
	
					if ( uvs2 !== undefined ) {
	
						tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );
	
					}
	
				}
	
				function addFace( a, b, c, materialIndex ) {
	
					var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
					var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];
	
					var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );
	
					scope.faces.push( face );
	
					if ( uvs !== undefined ) {
	
						scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );
	
					}
	
					if ( uvs2 !== undefined ) {
	
						scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );
	
					}
	
				}
	
				if ( indices !== undefined ) {
	
					var groups = geometry.groups;
	
					if ( groups.length > 0 ) {
	
						for ( var i = 0; i < groups.length; i ++ ) {
	
							var group = groups[ i ];
	
							var start = group.start;
							var count = group.count;
	
							for ( var j = start, jl = start + count; j < jl; j += 3 ) {
	
								addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );
	
							}
	
						}
	
					} else {
	
						for ( var i = 0; i < indices.length; i += 3 ) {
	
							addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );
	
						}
	
					}
	
				} else {
	
					for ( var i = 0; i < positions.length / 3; i += 3 ) {
	
						addFace( i, i + 1, i + 2 );
	
					}
	
				}
	
				this.computeFaceNormals();
	
				if ( geometry.boundingBox !== null ) {
	
					this.boundingBox = geometry.boundingBox.clone();
	
				}
	
				if ( geometry.boundingSphere !== null ) {
	
					this.boundingSphere = geometry.boundingSphere.clone();
	
				}
	
				return this;
	
			},
	
			center: function () {
	
				this.computeBoundingBox();
	
				var offset = this.boundingBox.getCenter().negate();
	
				this.translate( offset.x, offset.y, offset.z );
	
				return offset;
	
			},
	
			normalize: function () {
	
				this.computeBoundingSphere();
	
				var center = this.boundingSphere.center;
				var radius = this.boundingSphere.radius;
	
				var s = radius === 0 ? 1 : 1.0 / radius;
	
				var matrix = new Matrix4();
				matrix.set(
					s, 0, 0, - s * center.x,
					0, s, 0, - s * center.y,
					0, 0, s, - s * center.z,
					0, 0, 0, 1
				);
	
				this.applyMatrix( matrix );
	
				return this;
	
			},
	
			computeFaceNormals: function () {
	
				var cb = new Vector3(), ab = new Vector3();
	
				for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					var face = this.faces[ f ];
	
					var vA = this.vertices[ face.a ];
					var vB = this.vertices[ face.b ];
					var vC = this.vertices[ face.c ];
	
					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );
	
					cb.normalize();
	
					face.normal.copy( cb );
	
				}
	
			},
	
			computeVertexNormals: function ( areaWeighted ) {
	
				if ( areaWeighted === undefined ) areaWeighted = true;
	
				var v, vl, f, fl, face, vertices;
	
				vertices = new Array( this.vertices.length );
	
				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
					vertices[ v ] = new Vector3();
	
				}
	
				if ( areaWeighted ) {
	
					// vertex normals weighted by triangle areas
					// http://www.iquilezles.org/www/articles/normals/normals.htm
	
					var vA, vB, vC;
					var cb = new Vector3(), ab = new Vector3();
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						face = this.faces[ f ];
	
						vA = this.vertices[ face.a ];
						vB = this.vertices[ face.b ];
						vC = this.vertices[ face.c ];
	
						cb.subVectors( vC, vB );
						ab.subVectors( vA, vB );
						cb.cross( ab );
	
						vertices[ face.a ].add( cb );
						vertices[ face.b ].add( cb );
						vertices[ face.c ].add( cb );
	
					}
	
				} else {
	
					this.computeFaceNormals();
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						face = this.faces[ f ];
	
						vertices[ face.a ].add( face.normal );
						vertices[ face.b ].add( face.normal );
						vertices[ face.c ].add( face.normal );
	
					}
	
				}
	
				for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
					vertices[ v ].normalize();
	
				}
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					var vertexNormals = face.vertexNormals;
	
					if ( vertexNormals.length === 3 ) {
	
						vertexNormals[ 0 ].copy( vertices[ face.a ] );
						vertexNormals[ 1 ].copy( vertices[ face.b ] );
						vertexNormals[ 2 ].copy( vertices[ face.c ] );
	
					} else {
	
						vertexNormals[ 0 ] = vertices[ face.a ].clone();
						vertexNormals[ 1 ] = vertices[ face.b ].clone();
						vertexNormals[ 2 ] = vertices[ face.c ].clone();
	
					}
	
				}
	
				if ( this.faces.length > 0 ) {
	
					this.normalsNeedUpdate = true;
	
				}
	
			},
	
			computeFlatVertexNormals: function () {
	
				var f, fl, face;
	
				this.computeFaceNormals();
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					var vertexNormals = face.vertexNormals;
	
					if ( vertexNormals.length === 3 ) {
	
						vertexNormals[ 0 ].copy( face.normal );
						vertexNormals[ 1 ].copy( face.normal );
						vertexNormals[ 2 ].copy( face.normal );
	
					} else {
	
						vertexNormals[ 0 ] = face.normal.clone();
						vertexNormals[ 1 ] = face.normal.clone();
						vertexNormals[ 2 ] = face.normal.clone();
	
					}
	
				}
	
				if ( this.faces.length > 0 ) {
	
					this.normalsNeedUpdate = true;
	
				}
	
			},
	
			computeMorphNormals: function () {
	
				var i, il, f, fl, face;
	
				// save original normals
				// - create temp variables on first access
				//   otherwise just copy (for faster repeated calls)
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					if ( ! face.__originalFaceNormal ) {
	
						face.__originalFaceNormal = face.normal.clone();
	
					} else {
	
						face.__originalFaceNormal.copy( face.normal );
	
					}
	
					if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];
	
					for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {
	
						if ( ! face.__originalVertexNormals[ i ] ) {
	
							face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();
	
						} else {
	
							face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );
	
						}
	
					}
	
				}
	
				// use temp geometry to compute face and vertex normals for each morph
	
				var tmpGeo = new Geometry();
				tmpGeo.faces = this.faces;
	
				for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {
	
					// create on first access
	
					if ( ! this.morphNormals[ i ] ) {
	
						this.morphNormals[ i ] = {};
						this.morphNormals[ i ].faceNormals = [];
						this.morphNormals[ i ].vertexNormals = [];
	
						var dstNormalsFace = this.morphNormals[ i ].faceNormals;
						var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;
	
						var faceNormal, vertexNormals;
	
						for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
							faceNormal = new Vector3();
							vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
	
							dstNormalsFace.push( faceNormal );
							dstNormalsVertex.push( vertexNormals );
	
						}
	
					}
	
					var morphNormals = this.morphNormals[ i ];
	
					// set vertices to morph target
	
					tmpGeo.vertices = this.morphTargets[ i ].vertices;
	
					// compute morph normals
	
					tmpGeo.computeFaceNormals();
					tmpGeo.computeVertexNormals();
	
					// store morph normals
	
					var faceNormal, vertexNormals;
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						face = this.faces[ f ];
	
						faceNormal = morphNormals.faceNormals[ f ];
						vertexNormals = morphNormals.vertexNormals[ f ];
	
						faceNormal.copy( face.normal );
	
						vertexNormals.a.copy( face.vertexNormals[ 0 ] );
						vertexNormals.b.copy( face.vertexNormals[ 1 ] );
						vertexNormals.c.copy( face.vertexNormals[ 2 ] );
	
					}
	
				}
	
				// restore original normals
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					face.normal = face.__originalFaceNormal;
					face.vertexNormals = face.__originalVertexNormals;
	
				}
	
			},
	
			computeLineDistances: function () {
	
				var d = 0;
				var vertices = this.vertices;
	
				for ( var i = 0, il = vertices.length; i < il; i ++ ) {
	
					if ( i > 0 ) {
	
						d += vertices[ i ].distanceTo( vertices[ i - 1 ] );
	
					}
	
					this.lineDistances[ i ] = d;
	
				}
	
			},
	
			computeBoundingBox: function () {
	
				if ( this.boundingBox === null ) {
	
					this.boundingBox = new Box3();
	
				}
	
				this.boundingBox.setFromPoints( this.vertices );
	
			},
	
			computeBoundingSphere: function () {
	
				if ( this.boundingSphere === null ) {
	
					this.boundingSphere = new Sphere();
	
				}
	
				this.boundingSphere.setFromPoints( this.vertices );
	
			},
	
			merge: function ( geometry, matrix, materialIndexOffset ) {
	
				if ( ( geometry && geometry.isGeometry ) === false ) {
	
					console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
					return;
	
				}
	
				var normalMatrix,
				vertexOffset = this.vertices.length,
				vertices1 = this.vertices,
				vertices2 = geometry.vertices,
				faces1 = this.faces,
				faces2 = geometry.faces,
				uvs1 = this.faceVertexUvs[ 0 ],
				uvs2 = geometry.faceVertexUvs[ 0 ],
				colors1 = this.colors,
				colors2 = geometry.colors;
	
				if ( materialIndexOffset === undefined ) materialIndexOffset = 0;
	
				if ( matrix !== undefined ) {
	
					normalMatrix = new Matrix3().getNormalMatrix( matrix );
	
				}
	
				// vertices
	
				for ( var i = 0, il = vertices2.length; i < il; i ++ ) {
	
					var vertex = vertices2[ i ];
	
					var vertexCopy = vertex.clone();
	
					if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );
	
					vertices1.push( vertexCopy );
	
				}
	
				// colors
	
				for ( var i = 0, il = colors2.length; i < il; i ++ ) {
	
					colors1.push( colors2[ i ].clone() );
	
				}
	
				// faces
	
				for ( i = 0, il = faces2.length; i < il; i ++ ) {
	
					var face = faces2[ i ], faceCopy, normal, color,
					faceVertexNormals = face.vertexNormals,
					faceVertexColors = face.vertexColors;
	
					faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
					faceCopy.normal.copy( face.normal );
	
					if ( normalMatrix !== undefined ) {
	
						faceCopy.normal.applyMatrix3( normalMatrix ).normalize();
	
					}
	
					for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {
	
						normal = faceVertexNormals[ j ].clone();
	
						if ( normalMatrix !== undefined ) {
	
							normal.applyMatrix3( normalMatrix ).normalize();
	
						}
	
						faceCopy.vertexNormals.push( normal );
	
					}
	
					faceCopy.color.copy( face.color );
	
					for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {
	
						color = faceVertexColors[ j ];
						faceCopy.vertexColors.push( color.clone() );
	
					}
	
					faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
	
					faces1.push( faceCopy );
	
				}
	
				// uvs
	
				for ( i = 0, il = uvs2.length; i < il; i ++ ) {
	
					var uv = uvs2[ i ], uvCopy = [];
	
					if ( uv === undefined ) {
	
						continue;
	
					}
	
					for ( var j = 0, jl = uv.length; j < jl; j ++ ) {
	
						uvCopy.push( uv[ j ].clone() );
	
					}
	
					uvs1.push( uvCopy );
	
				}
	
			},
	
			mergeMesh: function ( mesh ) {
	
				if ( ( mesh && mesh.isMesh ) === false ) {
	
					console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
					return;
	
				}
	
				mesh.matrixAutoUpdate && mesh.updateMatrix();
	
				this.merge( mesh.geometry, mesh.matrix );
	
			},
	
			/*
			 * Checks for duplicate vertices with hashmap.
			 * Duplicated vertices are removed
			 * and faces' vertices are updated.
			 */
	
			mergeVertices: function () {
	
				var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
				var unique = [], changes = [];
	
				var v, key;
				var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
				var precision = Math.pow( 10, precisionPoints );
				var i, il, face;
				var indices, j, jl;
	
				for ( i = 0, il = this.vertices.length; i < il; i ++ ) {
	
					v = this.vertices[ i ];
					key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );
	
					if ( verticesMap[ key ] === undefined ) {
	
						verticesMap[ key ] = i;
						unique.push( this.vertices[ i ] );
						changes[ i ] = unique.length - 1;
	
					} else {
	
						//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
						changes[ i ] = changes[ verticesMap[ key ] ];
	
					}
	
				}
	
	
				// if faces are completely degenerate after merging vertices, we
				// have to remove them from the geometry.
				var faceIndicesToRemove = [];
	
				for ( i = 0, il = this.faces.length; i < il; i ++ ) {
	
					face = this.faces[ i ];
	
					face.a = changes[ face.a ];
					face.b = changes[ face.b ];
					face.c = changes[ face.c ];
	
					indices = [ face.a, face.b, face.c ];
	
					// if any duplicate vertices are found in a Face3
					// we have to remove the face as nothing can be saved
					for ( var n = 0; n < 3; n ++ ) {
	
						if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {
	
							faceIndicesToRemove.push( i );
							break;
	
						}
	
					}
	
				}
	
				for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
	
					var idx = faceIndicesToRemove[ i ];
	
					this.faces.splice( idx, 1 );
	
					for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {
	
						this.faceVertexUvs[ j ].splice( idx, 1 );
	
					}
	
				}
	
				// Use unique set of vertices
	
				var diff = this.vertices.length - unique.length;
				this.vertices = unique;
				return diff;
	
			},
	
			sortFacesByMaterialIndex: function () {
	
				var faces = this.faces;
				var length = faces.length;
	
				// tag faces
	
				for ( var i = 0; i < length; i ++ ) {
	
					faces[ i ]._id = i;
	
				}
	
				// sort faces
	
				function materialIndexSort( a, b ) {
	
					return a.materialIndex - b.materialIndex;
	
				}
	
				faces.sort( materialIndexSort );
	
				// sort uvs
	
				var uvs1 = this.faceVertexUvs[ 0 ];
				var uvs2 = this.faceVertexUvs[ 1 ];
	
				var newUvs1, newUvs2;
	
				if ( uvs1 && uvs1.length === length ) newUvs1 = [];
				if ( uvs2 && uvs2.length === length ) newUvs2 = [];
	
				for ( var i = 0; i < length; i ++ ) {
	
					var id = faces[ i ]._id;
	
					if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
					if ( newUvs2 ) newUvs2.push( uvs2[ id ] );
	
				}
	
				if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
				if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;
	
			},
	
			toJSON: function () {
	
				var data = {
					metadata: {
						version: 4.4,
						type: 'Geometry',
						generator: 'Geometry.toJSON'
					}
				};
	
				// standard Geometry serialization
	
				data.uuid = this.uuid;
				data.type = this.type;
				if ( this.name !== '' ) data.name = this.name;
	
				if ( this.parameters !== undefined ) {
	
					var parameters = this.parameters;
	
					for ( var key in parameters ) {
	
						if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
					}
	
					return data;
	
				}
	
				var vertices = [];
	
				for ( var i = 0; i < this.vertices.length; i ++ ) {
	
					var vertex = this.vertices[ i ];
					vertices.push( vertex.x, vertex.y, vertex.z );
	
				}
	
				var faces = [];
				var normals = [];
				var normalsHash = {};
				var colors = [];
				var colorsHash = {};
				var uvs = [];
				var uvsHash = {};
	
				for ( var i = 0; i < this.faces.length; i ++ ) {
	
					var face = this.faces[ i ];
	
					var hasMaterial = true;
					var hasFaceUv = false; // deprecated
					var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
					var hasFaceNormal = face.normal.length() > 0;
					var hasFaceVertexNormal = face.vertexNormals.length > 0;
					var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
					var hasFaceVertexColor = face.vertexColors.length > 0;
	
					var faceType = 0;
	
					faceType = setBit( faceType, 0, 0 ); // isQuad
					faceType = setBit( faceType, 1, hasMaterial );
					faceType = setBit( faceType, 2, hasFaceUv );
					faceType = setBit( faceType, 3, hasFaceVertexUv );
					faceType = setBit( faceType, 4, hasFaceNormal );
					faceType = setBit( faceType, 5, hasFaceVertexNormal );
					faceType = setBit( faceType, 6, hasFaceColor );
					faceType = setBit( faceType, 7, hasFaceVertexColor );
	
					faces.push( faceType );
					faces.push( face.a, face.b, face.c );
					faces.push( face.materialIndex );
	
					if ( hasFaceVertexUv ) {
	
						var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];
	
						faces.push(
							getUvIndex( faceVertexUvs[ 0 ] ),
							getUvIndex( faceVertexUvs[ 1 ] ),
							getUvIndex( faceVertexUvs[ 2 ] )
						);
	
					}
	
					if ( hasFaceNormal ) {
	
						faces.push( getNormalIndex( face.normal ) );
	
					}
	
					if ( hasFaceVertexNormal ) {
	
						var vertexNormals = face.vertexNormals;
	
						faces.push(
							getNormalIndex( vertexNormals[ 0 ] ),
							getNormalIndex( vertexNormals[ 1 ] ),
							getNormalIndex( vertexNormals[ 2 ] )
						);
	
					}
	
					if ( hasFaceColor ) {
	
						faces.push( getColorIndex( face.color ) );
	
					}
	
					if ( hasFaceVertexColor ) {
	
						var vertexColors = face.vertexColors;
	
						faces.push(
							getColorIndex( vertexColors[ 0 ] ),
							getColorIndex( vertexColors[ 1 ] ),
							getColorIndex( vertexColors[ 2 ] )
						);
	
					}
	
				}
	
				function setBit( value, position, enabled ) {
	
					return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );
	
				}
	
				function getNormalIndex( normal ) {
	
					var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
	
					if ( normalsHash[ hash ] !== undefined ) {
	
						return normalsHash[ hash ];
	
					}
	
					normalsHash[ hash ] = normals.length / 3;
					normals.push( normal.x, normal.y, normal.z );
	
					return normalsHash[ hash ];
	
				}
	
				function getColorIndex( color ) {
	
					var hash = color.r.toString() + color.g.toString() + color.b.toString();
	
					if ( colorsHash[ hash ] !== undefined ) {
	
						return colorsHash[ hash ];
	
					}
	
					colorsHash[ hash ] = colors.length;
					colors.push( color.getHex() );
	
					return colorsHash[ hash ];
	
				}
	
				function getUvIndex( uv ) {
	
					var hash = uv.x.toString() + uv.y.toString();
	
					if ( uvsHash[ hash ] !== undefined ) {
	
						return uvsHash[ hash ];
	
					}
	
					uvsHash[ hash ] = uvs.length / 2;
					uvs.push( uv.x, uv.y );
	
					return uvsHash[ hash ];
	
				}
	
				data.data = {};
	
				data.data.vertices = vertices;
				data.data.normals = normals;
				if ( colors.length > 0 ) data.data.colors = colors;
				if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
				data.data.faces = faces;
	
				return data;
	
			},
	
			clone: function () {
	
				/*
				// Handle primitives
	
				var parameters = this.parameters;
	
				if ( parameters !== undefined ) {
	
					var values = [];
	
					for ( var key in parameters ) {
	
						values.push( parameters[ key ] );
	
					}
	
					var geometry = Object.create( this.constructor.prototype );
					this.constructor.apply( geometry, values );
					return geometry;
	
				}
	
				return new this.constructor().copy( this );
				*/
	
				return new Geometry().copy( this );
	
			},
	
			copy: function ( source ) {
	
				var i, il, j, jl, k, kl;
	
				// reset
	
				this.vertices = [];
				this.colors = [];
				this.faces = [];
				this.faceVertexUvs = [[]];
				this.morphTargets = [];
				this.morphNormals = [];
				this.skinWeights = [];
				this.skinIndices = [];
				this.lineDistances = [];
				this.boundingBox = null;
				this.boundingSphere = null;
	
				// name
	
				this.name = source.name;
	
				// vertices
	
				var vertices = source.vertices;
	
				for ( i = 0, il = vertices.length; i < il; i ++ ) {
	
					this.vertices.push( vertices[ i ].clone() );
	
				}
	
				// colors
	
				var colors = source.colors;
	
				for ( i = 0, il = colors.length; i < il; i ++ ) {
	
					this.colors.push( colors[ i ].clone() );
	
				}
	
				// faces
	
				var faces = source.faces;
	
				for ( i = 0, il = faces.length; i < il; i ++ ) {
	
					this.faces.push( faces[ i ].clone() );
	
				}
	
				// face vertex uvs
	
				for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {
	
					var faceVertexUvs = source.faceVertexUvs[ i ];
	
					if ( this.faceVertexUvs[ i ] === undefined ) {
	
						this.faceVertexUvs[ i ] = [];
	
					}
	
					for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {
	
						var uvs = faceVertexUvs[ j ], uvsCopy = [];
	
						for ( k = 0, kl = uvs.length; k < kl; k ++ ) {
	
							var uv = uvs[ k ];
	
							uvsCopy.push( uv.clone() );
	
						}
	
						this.faceVertexUvs[ i ].push( uvsCopy );
	
					}
	
				}
	
				// morph targets
	
				var morphTargets = source.morphTargets;
	
				for ( i = 0, il = morphTargets.length; i < il; i ++ ) {
	
					var morphTarget = {};
					morphTarget.name = morphTargets[ i ].name;
	
					// vertices
	
					if ( morphTargets[ i ].vertices !== undefined ) {
	
						morphTarget.vertices = [];
	
						for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {
	
							morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );
	
						}
	
					}
	
					// normals
	
					if ( morphTargets[ i ].normals !== undefined ) {
	
						morphTarget.normals = [];
	
						for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {
	
							morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );
	
						}
	
					}
	
					this.morphTargets.push( morphTarget );
	
				}
	
				// morph normals
	
				var morphNormals = source.morphNormals;
	
				for ( i = 0, il = morphNormals.length; i < il; i ++ ) {
	
					var morphNormal = {};
	
					// vertex normals
	
					if ( morphNormals[ i ].vertexNormals !== undefined ) {
	
						morphNormal.vertexNormals = [];
	
						for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {
	
							var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
							var destVertexNormal = {};
	
							destVertexNormal.a = srcVertexNormal.a.clone();
							destVertexNormal.b = srcVertexNormal.b.clone();
							destVertexNormal.c = srcVertexNormal.c.clone();
	
							morphNormal.vertexNormals.push( destVertexNormal );
	
						}
	
					}
	
					// face normals
	
					if ( morphNormals[ i ].faceNormals !== undefined ) {
	
						morphNormal.faceNormals = [];
	
						for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {
	
							morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );
	
						}
	
					}
	
					this.morphNormals.push( morphNormal );
	
				}
	
				// skin weights
	
				var skinWeights = source.skinWeights;
	
				for ( i = 0, il = skinWeights.length; i < il; i ++ ) {
	
					this.skinWeights.push( skinWeights[ i ].clone() );
	
				}
	
				// skin indices
	
				var skinIndices = source.skinIndices;
	
				for ( i = 0, il = skinIndices.length; i < il; i ++ ) {
	
					this.skinIndices.push( skinIndices[ i ].clone() );
	
				}
	
				// line distances
	
				var lineDistances = source.lineDistances;
	
				for ( i = 0, il = lineDistances.length; i < il; i ++ ) {
	
					this.lineDistances.push( lineDistances[ i ] );
	
				}
	
				// bounding box
	
				var boundingBox = source.boundingBox;
	
				if ( boundingBox !== null ) {
	
					this.boundingBox = boundingBox.clone();
	
				}
	
				// bounding sphere
	
				var boundingSphere = source.boundingSphere;
	
				if ( boundingSphere !== null ) {
	
					this.boundingSphere = boundingSphere.clone();
	
				}
	
				// update flags
	
				this.elementsNeedUpdate = source.elementsNeedUpdate;
				this.verticesNeedUpdate = source.verticesNeedUpdate;
				this.uvsNeedUpdate = source.uvsNeedUpdate;
				this.normalsNeedUpdate = source.normalsNeedUpdate;
				this.colorsNeedUpdate = source.colorsNeedUpdate;
				this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
				this.groupsNeedUpdate = source.groupsNeedUpdate;
	
				return this;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			}
	
		};
	
		Object.assign( Geometry.prototype, EventDispatcher.prototype );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function BufferGeometry() {
	
			Object.defineProperty( this, 'id', { value: GeometryIdCount() } );
	
			this.uuid = _Math.generateUUID();
	
			this.name = '';
			this.type = 'BufferGeometry';
	
			this.index = null;
			this.attributes = {};
	
			this.morphAttributes = {};
	
			this.groups = [];
	
			this.boundingBox = null;
			this.boundingSphere = null;
	
			this.drawRange = { start: 0, count: Infinity };
	
		}
	
		BufferGeometry.prototype = {
	
			constructor: BufferGeometry,
	
			isBufferGeometry: true,
	
			getIndex: function () {
	
				return this.index;
	
			},
	
			setIndex: function ( index ) {
	
				if ( Array.isArray( index ) ) {
	
					this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );
	
				} else {
	
					this.index = index;
	
				}
	
			},
	
			addAttribute: function ( name, attribute ) {
	
				if ( ( attribute && attribute.isBufferAttribute ) === false && ( attribute && attribute.isInterleavedBufferAttribute ) === false ) {
	
					console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );
	
					this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );
	
					return;
	
				}
	
				if ( name === 'index' ) {
	
					console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
					this.setIndex( attribute );
	
					return;
	
				}
	
				this.attributes[ name ] = attribute;
	
				return this;
	
			},
	
			getAttribute: function ( name ) {
	
				return this.attributes[ name ];
	
			},
	
			removeAttribute: function ( name ) {
	
				delete this.attributes[ name ];
	
				return this;
	
			},
	
			addGroup: function ( start, count, materialIndex ) {
	
				this.groups.push( {
	
					start: start,
					count: count,
					materialIndex: materialIndex !== undefined ? materialIndex : 0
	
				} );
	
			},
	
			clearGroups: function () {
	
				this.groups = [];
	
			},
	
			setDrawRange: function ( start, count ) {
	
				this.drawRange.start = start;
				this.drawRange.count = count;
	
			},
	
			applyMatrix: function ( matrix ) {
	
				var position = this.attributes.position;
	
				if ( position !== undefined ) {
	
					matrix.applyToBufferAttribute( position );
					position.needsUpdate = true;
	
				}
	
				var normal = this.attributes.normal;
	
				if ( normal !== undefined ) {
	
					var normalMatrix = new Matrix3().getNormalMatrix( matrix );
	
					normalMatrix.applyToBufferAttribute( normal );
					normal.needsUpdate = true;
	
				}
	
				if ( this.boundingBox !== null ) {
	
					this.computeBoundingBox();
	
				}
	
				if ( this.boundingSphere !== null ) {
	
					this.computeBoundingSphere();
	
				}
	
				return this;
	
			},
	
			rotateX: function () {
	
				// rotate geometry around world x-axis
	
				var m1;
	
				return function rotateX( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationX( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			rotateY: function () {
	
				// rotate geometry around world y-axis
	
				var m1;
	
				return function rotateY( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationY( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			rotateZ: function () {
	
				// rotate geometry around world z-axis
	
				var m1;
	
				return function rotateZ( angle ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeRotationZ( angle );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			translate: function () {
	
				// translate geometry
	
				var m1;
	
				return function translate( x, y, z ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeTranslation( x, y, z );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			scale: function () {
	
				// scale geometry
	
				var m1;
	
				return function scale( x, y, z ) {
	
					if ( m1 === undefined ) m1 = new Matrix4();
	
					m1.makeScale( x, y, z );
	
					this.applyMatrix( m1 );
	
					return this;
	
				};
	
			}(),
	
			lookAt: function () {
	
				var obj;
	
				return function lookAt( vector ) {
	
					if ( obj === undefined ) obj = new Object3D();
	
					obj.lookAt( vector );
	
					obj.updateMatrix();
	
					this.applyMatrix( obj.matrix );
	
				};
	
			}(),
	
			center: function () {
	
				this.computeBoundingBox();
	
				var offset = this.boundingBox.getCenter().negate();
	
				this.translate( offset.x, offset.y, offset.z );
	
				return offset;
	
			},
	
			setFromObject: function ( object ) {
	
				// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
	
				var geometry = object.geometry;
	
				if ( object.isPoints || object.isLine ) {
	
					var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
					var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );
	
					this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
					this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );
	
					if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {
	
						var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );
	
						this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );
	
					}
	
					if ( geometry.boundingSphere !== null ) {
	
						this.boundingSphere = geometry.boundingSphere.clone();
	
					}
	
					if ( geometry.boundingBox !== null ) {
	
						this.boundingBox = geometry.boundingBox.clone();
	
					}
	
				} else if ( object.isMesh ) {
	
					if ( geometry && geometry.isGeometry ) {
	
						this.fromGeometry( geometry );
	
					}
	
				}
	
				return this;
	
			},
	
			updateFromObject: function ( object ) {
	
				var geometry = object.geometry;
	
				if ( object.isMesh ) {
	
					var direct = geometry.__directGeometry;
	
					if ( geometry.elementsNeedUpdate === true ) {
	
						direct = undefined;
						geometry.elementsNeedUpdate = false;
	
					}
	
					if ( direct === undefined ) {
	
						return this.fromGeometry( geometry );
	
					}
	
					direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
					direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
					direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
					direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
					direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
	
					geometry.verticesNeedUpdate = false;
					geometry.normalsNeedUpdate = false;
					geometry.colorsNeedUpdate = false;
					geometry.uvsNeedUpdate = false;
					geometry.groupsNeedUpdate = false;
	
					geometry = direct;
	
				}
	
				var attribute;
	
				if ( geometry.verticesNeedUpdate === true ) {
	
					attribute = this.attributes.position;
	
					if ( attribute !== undefined ) {
	
						attribute.copyVector3sArray( geometry.vertices );
						attribute.needsUpdate = true;
	
					}
	
					geometry.verticesNeedUpdate = false;
	
				}
	
				if ( geometry.normalsNeedUpdate === true ) {
	
					attribute = this.attributes.normal;
	
					if ( attribute !== undefined ) {
	
						attribute.copyVector3sArray( geometry.normals );
						attribute.needsUpdate = true;
	
					}
	
					geometry.normalsNeedUpdate = false;
	
				}
	
				if ( geometry.colorsNeedUpdate === true ) {
	
					attribute = this.attributes.color;
	
					if ( attribute !== undefined ) {
	
						attribute.copyColorsArray( geometry.colors );
						attribute.needsUpdate = true;
	
					}
	
					geometry.colorsNeedUpdate = false;
	
				}
	
				if ( geometry.uvsNeedUpdate ) {
	
					attribute = this.attributes.uv;
	
					if ( attribute !== undefined ) {
	
						attribute.copyVector2sArray( geometry.uvs );
						attribute.needsUpdate = true;
	
					}
	
					geometry.uvsNeedUpdate = false;
	
				}
	
				if ( geometry.lineDistancesNeedUpdate ) {
	
					attribute = this.attributes.lineDistance;
	
					if ( attribute !== undefined ) {
	
						attribute.copyArray( geometry.lineDistances );
						attribute.needsUpdate = true;
	
					}
	
					geometry.lineDistancesNeedUpdate = false;
	
				}
	
				if ( geometry.groupsNeedUpdate ) {
	
					geometry.computeGroups( object.geometry );
					this.groups = geometry.groups;
	
					geometry.groupsNeedUpdate = false;
	
				}
	
				return this;
	
			},
	
			fromGeometry: function ( geometry ) {
	
				geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );
	
				return this.fromDirectGeometry( geometry.__directGeometry );
	
			},
	
			fromDirectGeometry: function ( geometry ) {
	
				var positions = new Float32Array( geometry.vertices.length * 3 );
				this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );
	
				if ( geometry.normals.length > 0 ) {
	
					var normals = new Float32Array( geometry.normals.length * 3 );
					this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );
	
				}
	
				if ( geometry.colors.length > 0 ) {
	
					var colors = new Float32Array( geometry.colors.length * 3 );
					this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );
	
				}
	
				if ( geometry.uvs.length > 0 ) {
	
					var uvs = new Float32Array( geometry.uvs.length * 2 );
					this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );
	
				}
	
				if ( geometry.uvs2.length > 0 ) {
	
					var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
					this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );
	
				}
	
				if ( geometry.indices.length > 0 ) {
	
					var TypeArray = arrayMax( geometry.indices ) > 65535 ? Uint32Array : Uint16Array;
					var indices = new TypeArray( geometry.indices.length * 3 );
					this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );
	
				}
	
				// groups
	
				this.groups = geometry.groups;
	
				// morphs
	
				for ( var name in geometry.morphTargets ) {
	
					var array = [];
					var morphTargets = geometry.morphTargets[ name ];
	
					for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {
	
						var morphTarget = morphTargets[ i ];
	
						var attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );
	
						array.push( attribute.copyVector3sArray( morphTarget ) );
	
					}
	
					this.morphAttributes[ name ] = array;
	
				}
	
				// skinning
	
				if ( geometry.skinIndices.length > 0 ) {
	
					var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
					this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );
	
				}
	
				if ( geometry.skinWeights.length > 0 ) {
	
					var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
					this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );
	
				}
	
				//
	
				if ( geometry.boundingSphere !== null ) {
	
					this.boundingSphere = geometry.boundingSphere.clone();
	
				}
	
				if ( geometry.boundingBox !== null ) {
	
					this.boundingBox = geometry.boundingBox.clone();
	
				}
	
				return this;
	
			},
	
			computeBoundingBox: function () {
	
				if ( this.boundingBox === null ) {
	
					this.boundingBox = new Box3();
	
				}
	
				var position = this.attributes.position;
	
				if ( position !== undefined ) {
	
					this.boundingBox.setFromBufferAttribute( position );
	
				} else {
	
					this.boundingBox.makeEmpty();
	
				}
	
				if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {
	
					console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );
	
				}
	
			},
	
			computeBoundingSphere: function () {
	
				var box = new Box3();
				var vector = new Vector3();
	
				return function computeBoundingSphere() {
	
					if ( this.boundingSphere === null ) {
	
						this.boundingSphere = new Sphere();
	
					}
	
					var position = this.attributes.position;
	
					if ( position ) {
	
						var center = this.boundingSphere.center;
	
						box.setFromBufferAttribute( position );
						box.getCenter( center );
	
						// hoping to find a boundingSphere with a radius smaller than the
						// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
	
						var maxRadiusSq = 0;
	
						for ( var i = 0, il = position.count; i < il; i ++ ) {
	
							vector.x = position.getX( i );
							vector.y = position.getY( i );
							vector.z = position.getZ( i );
							maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );
	
						}
	
						this.boundingSphere.radius = Math.sqrt( maxRadiusSq );
	
						if ( isNaN( this.boundingSphere.radius ) ) {
	
							console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );
	
						}
	
					}
	
				};
	
			}(),
	
			computeFaceNormals: function () {
	
				// backwards compatibility
	
			},
	
			computeVertexNormals: function () {
	
				var index = this.index;
				var attributes = this.attributes;
				var groups = this.groups;
	
				if ( attributes.position ) {
	
					var positions = attributes.position.array;
	
					if ( attributes.normal === undefined ) {
	
						this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );
	
					} else {
	
						// reset existing normals to zero
	
						var array = attributes.normal.array;
	
						for ( var i = 0, il = array.length; i < il; i ++ ) {
	
							array[ i ] = 0;
	
						}
	
					}
	
					var normals = attributes.normal.array;
	
					var vA, vB, vC;
					var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
					var cb = new Vector3(), ab = new Vector3();
	
					// indexed elements
	
					if ( index ) {
	
						var indices = index.array;
	
						if ( groups.length === 0 ) {
	
							this.addGroup( 0, indices.length );
	
						}
	
						for ( var j = 0, jl = groups.length; j < jl; ++ j ) {
	
							var group = groups[ j ];
	
							var start = group.start;
							var count = group.count;
	
							for ( var i = start, il = start + count; i < il; i += 3 ) {
	
								vA = indices[ i + 0 ] * 3;
								vB = indices[ i + 1 ] * 3;
								vC = indices[ i + 2 ] * 3;
	
								pA.fromArray( positions, vA );
								pB.fromArray( positions, vB );
								pC.fromArray( positions, vC );
	
								cb.subVectors( pC, pB );
								ab.subVectors( pA, pB );
								cb.cross( ab );
	
								normals[ vA ] += cb.x;
								normals[ vA + 1 ] += cb.y;
								normals[ vA + 2 ] += cb.z;
	
								normals[ vB ] += cb.x;
								normals[ vB + 1 ] += cb.y;
								normals[ vB + 2 ] += cb.z;
	
								normals[ vC ] += cb.x;
								normals[ vC + 1 ] += cb.y;
								normals[ vC + 2 ] += cb.z;
	
							}
	
						}
	
					} else {
	
						// non-indexed elements (unconnected triangle soup)
	
						for ( var i = 0, il = positions.length; i < il; i += 9 ) {
	
							pA.fromArray( positions, i );
							pB.fromArray( positions, i + 3 );
							pC.fromArray( positions, i + 6 );
	
							cb.subVectors( pC, pB );
							ab.subVectors( pA, pB );
							cb.cross( ab );
	
							normals[ i ] = cb.x;
							normals[ i + 1 ] = cb.y;
							normals[ i + 2 ] = cb.z;
	
							normals[ i + 3 ] = cb.x;
							normals[ i + 4 ] = cb.y;
							normals[ i + 5 ] = cb.z;
	
							normals[ i + 6 ] = cb.x;
							normals[ i + 7 ] = cb.y;
							normals[ i + 8 ] = cb.z;
	
						}
	
					}
	
					this.normalizeNormals();
	
					attributes.normal.needsUpdate = true;
	
				}
	
			},
	
			merge: function ( geometry, offset ) {
	
				if ( ( geometry && geometry.isBufferGeometry ) === false ) {
	
					console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
					return;
	
				}
	
				if ( offset === undefined ) offset = 0;
	
				var attributes = this.attributes;
	
				for ( var key in attributes ) {
	
					if ( geometry.attributes[ key ] === undefined ) continue;
	
					var attribute1 = attributes[ key ];
					var attributeArray1 = attribute1.array;
	
					var attribute2 = geometry.attributes[ key ];
					var attributeArray2 = attribute2.array;
	
					var attributeSize = attribute2.itemSize;
	
					for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {
	
						attributeArray1[ j ] = attributeArray2[ i ];
	
					}
	
				}
	
				return this;
	
			},
	
			normalizeNormals: function () {
	
				var normals = this.attributes.normal.array;
	
				var x, y, z, n;
	
				for ( var i = 0, il = normals.length; i < il; i += 3 ) {
	
					x = normals[ i ];
					y = normals[ i + 1 ];
					z = normals[ i + 2 ];
	
					n = 1.0 / Math.sqrt( x * x + y * y + z * z );
	
					normals[ i ] *= n;
					normals[ i + 1 ] *= n;
					normals[ i + 2 ] *= n;
	
				}
	
			},
	
			toNonIndexed: function () {
	
				if ( this.index === null ) {
	
					console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
					return this;
	
				}
	
				var geometry2 = new BufferGeometry();
	
				var indices = this.index.array;
				var attributes = this.attributes;
	
				for ( var name in attributes ) {
	
					var attribute = attributes[ name ];
	
					var array = attribute.array;
					var itemSize = attribute.itemSize;
	
					var array2 = new array.constructor( indices.length * itemSize );
	
					var index = 0, index2 = 0;
	
					for ( var i = 0, l = indices.length; i < l; i ++ ) {
	
						index = indices[ i ] * itemSize;
	
						for ( var j = 0; j < itemSize; j ++ ) {
	
							array2[ index2 ++ ] = array[ index ++ ];
	
						}
	
					}
	
					geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );
	
				}
	
				return geometry2;
	
			},
	
			toJSON: function () {
	
				var data = {
					metadata: {
						version: 4.4,
						type: 'BufferGeometry',
						generator: 'BufferGeometry.toJSON'
					}
				};
	
				// standard BufferGeometry serialization
	
				data.uuid = this.uuid;
				data.type = this.type;
				if ( this.name !== '' ) data.name = this.name;
	
				if ( this.parameters !== undefined ) {
	
					var parameters = this.parameters;
	
					for ( var key in parameters ) {
	
						if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
					}
	
					return data;
	
				}
	
				data.data = { attributes: {} };
	
				var index = this.index;
	
				if ( index !== null ) {
	
					var array = Array.prototype.slice.call( index.array );
	
					data.data.index = {
						type: index.array.constructor.name,
						array: array
					};
	
				}
	
				var attributes = this.attributes;
	
				for ( var key in attributes ) {
	
					var attribute = attributes[ key ];
	
					var array = Array.prototype.slice.call( attribute.array );
	
					data.data.attributes[ key ] = {
						itemSize: attribute.itemSize,
						type: attribute.array.constructor.name,
						array: array,
						normalized: attribute.normalized
					};
	
				}
	
				var groups = this.groups;
	
				if ( groups.length > 0 ) {
	
					data.data.groups = JSON.parse( JSON.stringify( groups ) );
	
				}
	
				var boundingSphere = this.boundingSphere;
	
				if ( boundingSphere !== null ) {
	
					data.data.boundingSphere = {
						center: boundingSphere.center.toArray(),
						radius: boundingSphere.radius
					};
	
				}
	
				return data;
	
			},
	
			clone: function () {
	
				/*
				// Handle primitives
	
				var parameters = this.parameters;
	
				if ( parameters !== undefined ) {
	
					var values = [];
	
					for ( var key in parameters ) {
	
						values.push( parameters[ key ] );
	
					}
	
					var geometry = Object.create( this.constructor.prototype );
					this.constructor.apply( geometry, values );
					return geometry;
	
				}
	
				return new this.constructor().copy( this );
				*/
	
				return new BufferGeometry().copy( this );
	
			},
	
			copy: function ( source ) {
	
				var name, i, l;
	
				// reset
	
				this.index = null;
				this.attributes = {};
				this.morphAttributes = {};
				this.groups = [];
				this.boundingBox = null;
				this.boundingSphere = null;
	
				// name
	
				this.name = source.name;
	
				// index
	
				var index = source.index;
	
				if ( index !== null ) {
	
					this.setIndex( index.clone() );
	
				}
	
				// attributes
	
				var attributes = source.attributes;
	
				for ( name in attributes ) {
	
					var attribute = attributes[ name ];
					this.addAttribute( name, attribute.clone() );
	
				}
	
				// morph attributes
	
				var morphAttributes = source.morphAttributes;
	
				for ( name in morphAttributes ) {
	
					var array = [];
					var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes
	
					for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {
	
						array.push( morphAttribute[ i ].clone() );
	
					}
	
					this.morphAttributes[ name ] = array;
	
				}
	
				// groups
	
				var groups = source.groups;
	
				for ( i = 0, l = groups.length; i < l; i ++ ) {
	
					var group = groups[ i ];
					this.addGroup( group.start, group.count, group.materialIndex );
	
				}
	
				// bounding box
	
				var boundingBox = source.boundingBox;
	
				if ( boundingBox !== null ) {
	
					this.boundingBox = boundingBox.clone();
	
				}
	
				// bounding sphere
	
				var boundingSphere = source.boundingSphere;
	
				if ( boundingSphere !== null ) {
	
					this.boundingSphere = boundingSphere.clone();
	
				}
	
				// draw range
	
				this.drawRange.start = source.drawRange.start;
				this.drawRange.count = source.drawRange.count;
	
				return this;
	
			},
	
			dispose: function () {
	
				this.dispatchEvent( { type: 'dispose' } );
	
			}
	
		};
	
		BufferGeometry.MaxIndex = 65535;
	
		Object.assign( BufferGeometry.prototype, EventDispatcher.prototype );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author jonobr1 / http://jonobr1.com/
		 */
	
		function Mesh( geometry, material ) {
	
			Object3D.call( this );
	
			this.type = 'Mesh';
	
			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );
	
			this.drawMode = TrianglesDrawMode;
	
			this.updateMorphTargets();
	
		}
	
		Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Mesh,
	
			isMesh: true,
	
			setDrawMode: function ( value ) {
	
				this.drawMode = value;
	
			},
	
			copy: function ( source ) {
	
				Object3D.prototype.copy.call( this, source );
	
				this.drawMode = source.drawMode;
	
				return this;
	
			},
	
			updateMorphTargets: function () {
	
				var morphTargets = this.geometry.morphTargets;
	
				if ( morphTargets !== undefined && morphTargets.length > 0 ) {
	
					this.morphTargetInfluences = [];
					this.morphTargetDictionary = {};
	
					for ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {
	
						this.morphTargetInfluences.push( 0 );
						this.morphTargetDictionary[ morphTargets[ m ].name ] = m;
	
					}
	
				}
	
			},
	
			raycast: ( function () {
	
				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();
	
				var vA = new Vector3();
				var vB = new Vector3();
				var vC = new Vector3();
	
				var tempA = new Vector3();
				var tempB = new Vector3();
				var tempC = new Vector3();
	
				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();
	
				var barycoord = new Vector3();
	
				var intersectionPoint = new Vector3();
				var intersectionPointWorld = new Vector3();
	
				function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {
	
					Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );
	
					uv1.multiplyScalar( barycoord.x );
					uv2.multiplyScalar( barycoord.y );
					uv3.multiplyScalar( barycoord.z );
	
					uv1.add( uv2 ).add( uv3 );
	
					return uv1.clone();
	
				}
	
				function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {
	
					var intersect;
					var material = object.material;
	
					if ( material.side === BackSide ) {
	
						intersect = ray.intersectTriangle( pC, pB, pA, true, point );
	
					} else {
	
						intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );
	
					}
	
					if ( intersect === null ) return null;
	
					intersectionPointWorld.copy( point );
					intersectionPointWorld.applyMatrix4( object.matrixWorld );
	
					var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );
	
					if ( distance < raycaster.near || distance > raycaster.far ) return null;
	
					return {
						distance: distance,
						point: intersectionPointWorld.clone(),
						object: object
					};
	
				}
	
				function checkBufferGeometryIntersection( object, raycaster, ray, position, uv, a, b, c ) {
	
					vA.fromBufferAttribute( position, a );
					vB.fromBufferAttribute( position, b );
					vC.fromBufferAttribute( position, c );
	
					var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );
	
					if ( intersection ) {
	
						if ( uv ) {
	
							uvA.fromBufferAttribute( uv, a );
							uvB.fromBufferAttribute( uv, b );
							uvC.fromBufferAttribute( uv, c );
	
							intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC, uvA, uvB, uvC );
	
						}
	
						intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
						intersection.faceIndex = a;
	
					}
	
					return intersection;
	
				}
	
				return function raycast( raycaster, intersects ) {
	
					var geometry = this.geometry;
					var material = this.material;
					var matrixWorld = this.matrixWorld;
	
					if ( material === undefined ) return;
	
					// Checking boundingSphere distance to ray
	
					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );
	
					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
					//
	
					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
					// Check boundingBox before continuing
	
					if ( geometry.boundingBox !== null ) {
	
						if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;
	
					}
	
					var intersection;
	
					if ( geometry.isBufferGeometry ) {
	
						var a, b, c;
						var index = geometry.index;
						var position = geometry.attributes.position;
						var uv = geometry.attributes.uv;
						var i, l;
	
						if ( index !== null ) {
	
							// indexed buffer geometry
	
							for ( i = 0, l = index.count; i < l; i += 3 ) {
	
								a = index.getX( i );
								b = index.getX( i + 1 );
								c = index.getX( i + 2 );
	
								intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );
	
								if ( intersection ) {
	
									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
									intersects.push( intersection );
	
								}
	
							}
	
						} else {
	
							// non-indexed buffer geometry
	
							for ( i = 0, l = position.count; i < l; i += 3 ) {
	
								a = i;
								b = i + 1;
								c = i + 2;
	
								intersection = checkBufferGeometryIntersection( this, raycaster, ray, position, uv, a, b, c );
	
								if ( intersection ) {
	
									intersection.index = a; // triangle number in positions buffer semantics
									intersects.push( intersection );
	
								}
	
							}
	
						}
	
					} else if ( geometry.isGeometry ) {
	
						var fvA, fvB, fvC;
						var isFaceMaterial = ( material && material.isMultiMaterial );
						var materials = isFaceMaterial === true ? material.materials : null;
	
						var vertices = geometry.vertices;
						var faces = geometry.faces;
						var uvs;
	
						var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
						if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;
	
						for ( var f = 0, fl = faces.length; f < fl; f ++ ) {
	
							var face = faces[ f ];
							var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;
	
							if ( faceMaterial === undefined ) continue;
	
							fvA = vertices[ face.a ];
							fvB = vertices[ face.b ];
							fvC = vertices[ face.c ];
	
							if ( faceMaterial.morphTargets === true ) {
	
								var morphTargets = geometry.morphTargets;
								var morphInfluences = this.morphTargetInfluences;
	
								vA.set( 0, 0, 0 );
								vB.set( 0, 0, 0 );
								vC.set( 0, 0, 0 );
	
								for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {
	
									var influence = morphInfluences[ t ];
	
									if ( influence === 0 ) continue;
	
									var targets = morphTargets[ t ].vertices;
	
									vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
									vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
									vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );
	
								}
	
								vA.add( fvA );
								vB.add( fvB );
								vC.add( fvC );
	
								fvA = vA;
								fvB = vB;
								fvC = vC;
	
							}
	
							intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );
	
							if ( intersection ) {
	
								if ( uvs ) {
	
									var uvs_f = uvs[ f ];
									uvA.copy( uvs_f[ 0 ] );
									uvB.copy( uvs_f[ 1 ] );
									uvC.copy( uvs_f[ 2 ] );
	
									intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );
	
								}
	
								intersection.face = face;
								intersection.faceIndex = f;
								intersects.push( intersection );
	
							}
	
						}
	
					}
	
				};
	
			}() ),
	
			clone: function () {
	
				return new this.constructor( this.geometry, this.material ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
		 */
	
		function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
			Geometry.call( this );
	
			this.type = 'BoxGeometry';
	
			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};
	
			this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
			this.mergeVertices();
	
		}
	
		BoxGeometry.prototype = Object.create( Geometry.prototype );
		BoxGeometry.prototype.constructor = BoxGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
			BufferGeometry.call( this );
	
			this.type = 'BoxBufferGeometry';
	
			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};
	
			var scope = this;
	
			// segments
	
			widthSegments = Math.floor( widthSegments ) || 1;
			heightSegments = Math.floor( heightSegments ) || 1;
			depthSegments = Math.floor( depthSegments ) || 1;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var numberOfVertices = 0;
			var groupStart = 0;
	
			// build each side of the box geometry
	
			buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
			buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
			buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
			buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
			buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
			buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
			function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {
	
				var segmentWidth = width / gridX;
				var segmentHeight = height / gridY;
	
				var widthHalf = width / 2;
				var heightHalf = height / 2;
				var depthHalf = depth / 2;
	
				var gridX1 = gridX + 1;
				var gridY1 = gridY + 1;
	
				var vertexCounter = 0;
				var groupCount = 0;
	
				var ix, iy;
	
				var vector = new Vector3();
	
				// generate vertices, normals and uvs
	
				for ( iy = 0; iy < gridY1; iy ++ ) {
	
					var y = iy * segmentHeight - heightHalf;
	
					for ( ix = 0; ix < gridX1; ix ++ ) {
	
						var x = ix * segmentWidth - widthHalf;
	
						// set values to correct vector component
	
						vector[ u ] = x * udir;
						vector[ v ] = y * vdir;
						vector[ w ] = depthHalf;
	
						// now apply vector to vertex buffer
	
						vertices.push( vector.x, vector.y, vector.z );
	
						// set values to correct vector component
	
						vector[ u ] = 0;
						vector[ v ] = 0;
						vector[ w ] = depth > 0 ? 1 : - 1;
	
						// now apply vector to normal buffer
	
						normals.push( vector.x, vector.y, vector.z );
	
						// uvs
	
						uvs.push( ix / gridX );
						uvs.push( 1 - ( iy / gridY ) );
	
						// counters
	
						vertexCounter += 1;
	
					}
	
				}
	
				// indices
	
				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment
	
				for ( iy = 0; iy < gridY; iy ++ ) {
	
					for ( ix = 0; ix < gridX; ix ++ ) {
	
						var a = numberOfVertices + ix + gridX1 * iy;
						var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
						var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
						var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;
	
						// faces
	
						indices.push( a, b, d );
						indices.push( b, c, d );
	
						// increase counter
	
						groupCount += 6;
	
					}
	
				}
	
				// add a group to the geometry. this will ensure multi material support
	
				scope.addGroup( groupStart, groupCount, materialIndex );
	
				// calculate new start value for groups
	
				groupStart += groupCount;
	
				// update total number of vertices
	
				numberOfVertices += vertexCounter;
	
			}
	
		}
	
		BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
		 */
	
		function PlaneGeometry( width, height, widthSegments, heightSegments ) {
	
			Geometry.call( this );
	
			this.type = 'PlaneGeometry';
	
			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};
	
			this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
	
		}
	
		PlaneGeometry.prototype = Object.create( Geometry.prototype );
		PlaneGeometry.prototype.constructor = PlaneGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
		 */
	
		function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {
	
			BufferGeometry.call( this );
	
			this.type = 'PlaneBufferGeometry';
	
			this.parameters = {
				width: width,
				height: height,
				widthSegments: widthSegments,
				heightSegments: heightSegments
			};
	
			var width_half = width / 2;
			var height_half = height / 2;
	
			var gridX = Math.floor( widthSegments ) || 1;
			var gridY = Math.floor( heightSegments ) || 1;
	
			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;
	
			var segment_width = width / gridX;
			var segment_height = height / gridY;
	
			var ix, iy;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// generate vertices, normals and uvs
	
			for ( iy = 0; iy < gridY1; iy ++ ) {
	
				var y = iy * segment_height - height_half;
	
				for ( ix = 0; ix < gridX1; ix ++ ) {
	
					var x = ix * segment_width - width_half;
	
					vertices.push( x, - y, 0 );
	
					normals.push( 0, 0, 1 );
	
					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );
	
				}
	
			}
	
			// indices
	
			for ( iy = 0; iy < gridY; iy ++ ) {
	
				for ( ix = 0; ix < gridX; ix ++ ) {
	
					var a = ix + gridX1 * iy;
					var b = ix + gridX1 * ( iy + 1 );
					var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = ( ix + 1 ) + gridX1 * iy;
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		}
	
		PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author mikael emtinger / http://gomo.se/
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function Camera() {
	
			Object3D.call( this );
	
			this.type = 'Camera';
	
			this.matrixWorldInverse = new Matrix4();
			this.projectionMatrix = new Matrix4();
	
		}
	
		Camera.prototype = Object.create( Object3D.prototype );
		Camera.prototype.constructor = Camera;
	
		Camera.prototype.isCamera = true;
	
		Camera.prototype.getWorldDirection = function () {
	
			var quaternion = new Quaternion();
	
			return function getWorldDirection( optionalTarget ) {
	
				var result = optionalTarget || new Vector3();
	
				this.getWorldQuaternion( quaternion );
	
				return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
			};
	
		}();
	
		Camera.prototype.lookAt = function () {
	
			// This routine does not support cameras with rotated and/or translated parent(s)
	
			var m1 = new Matrix4();
	
			return function lookAt( vector ) {
	
				m1.lookAt( this.position, vector, this.up );
	
				this.quaternion.setFromRotationMatrix( m1 );
	
			};
	
		}();
	
		Camera.prototype.clone = function () {
	
			return new this.constructor().copy( this );
	
		};
	
		Camera.prototype.copy = function ( source ) {
	
			Object3D.prototype.copy.call( this, source );
	
			this.matrixWorldInverse.copy( source.matrixWorldInverse );
			this.projectionMatrix.copy( source.projectionMatrix );
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author greggman / http://games.greggman.com/
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author tschw
		 */
	
		function PerspectiveCamera( fov, aspect, near, far ) {
	
			Camera.call( this );
	
			this.type = 'PerspectiveCamera';
	
			this.fov = fov !== undefined ? fov : 50;
			this.zoom = 1;
	
			this.near = near !== undefined ? near : 0.1;
			this.far = far !== undefined ? far : 2000;
			this.focus = 10;
	
			this.aspect = aspect !== undefined ? aspect : 1;
			this.view = null;
	
			this.filmGauge = 35;	// width of the film (default in millimeters)
			this.filmOffset = 0;	// horizontal film offset (same unit as gauge)
	
			this.updateProjectionMatrix();
	
		}
	
		PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {
	
			constructor: PerspectiveCamera,
	
			isPerspectiveCamera: true,
	
			copy: function ( source ) {
	
				Camera.prototype.copy.call( this, source );
	
				this.fov = source.fov;
				this.zoom = source.zoom;
	
				this.near = source.near;
				this.far = source.far;
				this.focus = source.focus;
	
				this.aspect = source.aspect;
				this.view = source.view === null ? null : Object.assign( {}, source.view );
	
				this.filmGauge = source.filmGauge;
				this.filmOffset = source.filmOffset;
	
				return this;
	
			},
	
			/**
			 * Sets the FOV by focal length in respect to the current .filmGauge.
			 *
			 * The default film gauge is 35, so that the focal length can be specified for
			 * a 35mm (full frame) camera.
			 *
			 * Values for focal length and film gauge must have the same unit.
			 */
			setFocalLength: function ( focalLength ) {
	
				// see http://www.bobatkins.com/photography/technical/field_of_view.html
				var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
	
				this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
				this.updateProjectionMatrix();
	
			},
	
			/**
			 * Calculates the focal length from the current .fov and .filmGauge.
			 */
			getFocalLength: function () {
	
				var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );
	
				return 0.5 * this.getFilmHeight() / vExtentSlope;
	
			},
	
			getEffectiveFOV: function () {
	
				return _Math.RAD2DEG * 2 * Math.atan(
						Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );
	
			},
	
			getFilmWidth: function () {
	
				// film not completely covered in portrait format (aspect < 1)
				return this.filmGauge * Math.min( this.aspect, 1 );
	
			},
	
			getFilmHeight: function () {
	
				// film not completely covered in landscape format (aspect > 1)
				return this.filmGauge / Math.max( this.aspect, 1 );
	
			},
	
			/**
			 * Sets an offset in a larger frustum. This is useful for multi-window or
			 * multi-monitor/multi-machine setups.
			 *
			 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
			 * the monitors are in grid like this
			 *
			 *   +---+---+---+
			 *   | A | B | C |
			 *   +---+---+---+
			 *   | D | E | F |
			 *   +---+---+---+
			 *
			 * then for each monitor you would call it like this
			 *
			 *   var w = 1920;
			 *   var h = 1080;
			 *   var fullWidth = w * 3;
			 *   var fullHeight = h * 2;
			 *
			 *   --A--
			 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
			 *   --B--
			 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
			 *   --C--
			 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
			 *   --D--
			 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
			 *   --E--
			 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
			 *   --F--
			 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
			 *
			 *   Note there is no reason monitors have to be the same size or in a grid.
			 */
			setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {
	
				this.aspect = fullWidth / fullHeight;
	
				this.view = {
					fullWidth: fullWidth,
					fullHeight: fullHeight,
					offsetX: x,
					offsetY: y,
					width: width,
					height: height
				};
	
				this.updateProjectionMatrix();
	
			},
	
			clearViewOffset: function() {
	
				this.view = null;
				this.updateProjectionMatrix();
	
			},
	
			updateProjectionMatrix: function () {
	
				var near = this.near,
					top = near * Math.tan(
							_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
					height = 2 * top,
					width = this.aspect * height,
					left = - 0.5 * width,
					view = this.view;
	
				if ( view !== null ) {
	
					var fullWidth = view.fullWidth,
						fullHeight = view.fullHeight;
	
					left += view.offsetX * width / fullWidth;
					top -= view.offsetY * height / fullHeight;
					width *= view.width / fullWidth;
					height *= view.height / fullHeight;
	
				}
	
				var skew = this.filmOffset;
				if ( skew !== 0 ) left += near * skew / this.getFilmWidth();
	
				this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );
	
			},
	
			toJSON: function ( meta ) {
	
				var data = Object3D.prototype.toJSON.call( this, meta );
	
				data.object.fov = this.fov;
				data.object.zoom = this.zoom;
	
				data.object.near = this.near;
				data.object.far = this.far;
				data.object.focus = this.focus;
	
				data.object.aspect = this.aspect;
	
				if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
	
				data.object.filmGauge = this.filmGauge;
				data.object.filmOffset = this.filmOffset;
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author arose / http://github.com/arose
		 */
	
		function OrthographicCamera( left, right, top, bottom, near, far ) {
	
			Camera.call( this );
	
			this.type = 'OrthographicCamera';
	
			this.zoom = 1;
			this.view = null;
	
			this.left = left;
			this.right = right;
			this.top = top;
			this.bottom = bottom;
	
			this.near = ( near !== undefined ) ? near : 0.1;
			this.far = ( far !== undefined ) ? far : 2000;
	
			this.updateProjectionMatrix();
	
		}
	
		OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {
	
			constructor: OrthographicCamera,
	
			isOrthographicCamera: true,
	
			copy: function ( source ) {
	
				Camera.prototype.copy.call( this, source );
	
				this.left = source.left;
				this.right = source.right;
				this.top = source.top;
				this.bottom = source.bottom;
				this.near = source.near;
				this.far = source.far;
	
				this.zoom = source.zoom;
				this.view = source.view === null ? null : Object.assign( {}, source.view );
	
				return this;
	
			},
	
			setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {
	
				this.view = {
					fullWidth: fullWidth,
					fullHeight: fullHeight,
					offsetX: x,
					offsetY: y,
					width: width,
					height: height
				};
	
				this.updateProjectionMatrix();
	
			},
	
			clearViewOffset: function() {
	
				this.view = null;
				this.updateProjectionMatrix();
	
			},
	
			updateProjectionMatrix: function () {
	
				var dx = ( this.right - this.left ) / ( 2 * this.zoom );
				var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
				var cx = ( this.right + this.left ) / 2;
				var cy = ( this.top + this.bottom ) / 2;
	
				var left = cx - dx;
				var right = cx + dx;
				var top = cy + dy;
				var bottom = cy - dy;
	
				if ( this.view !== null ) {
	
					var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
					var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
					var scaleW = ( this.right - this.left ) / this.view.width;
					var scaleH = ( this.top - this.bottom ) / this.view.height;
	
					left += scaleW * ( this.view.offsetX / zoomW );
					right = left + scaleW * ( this.view.width / zoomW );
					top -= scaleH * ( this.view.offsetY / zoomH );
					bottom = top - scaleH * ( this.view.height / zoomH );
	
				}
	
				this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );
	
			},
	
			toJSON: function ( meta ) {
	
				var data = Object3D.prototype.toJSON.call( this, meta );
	
				data.object.zoom = this.zoom;
				data.object.left = this.left;
				data.object.right = this.right;
				data.object.top = this.top;
				data.object.bottom = this.bottom;
				data.object.near = this.near;
				data.object.far = this.far;
	
				if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {
	
			var mode;
	
			function setMode( value ) {
	
				mode = value;
	
			}
	
			var type, size;
	
			function setIndex( index ) {
	
				if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {
	
					type = gl.UNSIGNED_INT;
					size = 4;
	
				} else if ( index.array instanceof Uint16Array ) {
	
					type = gl.UNSIGNED_SHORT;
					size = 2;
	
				} else {
	
					type = gl.UNSIGNED_BYTE;
					size = 1;
	
				}
	
			}
	
			function render( start, count ) {
	
				gl.drawElements( mode, count, type, start * size );
	
				infoRender.calls ++;
				infoRender.vertices += count;
	
				if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;
	
			}
	
			function renderInstances( geometry, start, count ) {
	
				var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				if ( extension === null ) {
	
					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
	
				}
	
				extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );
	
				infoRender.calls ++;
				infoRender.vertices += count * geometry.maxInstancedCount;
	
				if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;
	
			}
	
			return {
	
				setMode: setMode,
				setIndex: setIndex,
				render: render,
				renderInstances: renderInstances
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLBufferRenderer( gl, extensions, infoRender ) {
	
			var mode;
	
			function setMode( value ) {
	
				mode = value;
	
			}
	
			function render( start, count ) {
	
				gl.drawArrays( mode, start, count );
	
				infoRender.calls ++;
				infoRender.vertices += count;
	
				if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;
	
			}
	
			function renderInstances( geometry ) {
	
				var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				if ( extension === null ) {
	
					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
	
				}
	
				var position = geometry.attributes.position;
	
				var count = 0;
	
				if ( position.isInterleavedBufferAttribute ) {
	
					count = position.data.count;
	
					extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );
	
				} else {
	
					count = position.count;
	
					extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );
	
				}
	
				infoRender.calls ++;
				infoRender.vertices += count * geometry.maxInstancedCount;
	
				if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;
	
			}
	
			return {
				setMode: setMode,
				render: render,
				renderInstances: renderInstances
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLLights() {
	
			var lights = {};
	
			return {
	
				get: function ( light ) {
	
					if ( lights[ light.id ] !== undefined ) {
	
						return lights[ light.id ];
	
					}
	
					var uniforms;
	
					switch ( light.type ) {
	
						case 'DirectionalLight':
							uniforms = {
								direction: new Vector3(),
								color: new Color(),
	
								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;
	
						case 'SpotLight':
							uniforms = {
								position: new Vector3(),
								direction: new Vector3(),
								color: new Color(),
								distance: 0,
								coneCos: 0,
								penumbraCos: 0,
								decay: 0,
	
								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;
	
						case 'PointLight':
							uniforms = {
								position: new Vector3(),
								color: new Color(),
								distance: 0,
								decay: 0,
	
								shadow: false,
								shadowBias: 0,
								shadowRadius: 1,
								shadowMapSize: new Vector2()
							};
							break;
	
						case 'HemisphereLight':
							uniforms = {
								direction: new Vector3(),
								skyColor: new Color(),
								groundColor: new Color()
							};
							break;
	
						case 'RectAreaLight':
							uniforms = {
								color: new Color(),
								position: new Vector3(),
								halfWidth: new Vector3(),
								halfHeight: new Vector3()
								// TODO (abelnation): set RectAreaLight shadow uniforms
							};
							break;
	
					}
	
					lights[ light.id ] = uniforms;
	
					return uniforms;
	
				}
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function addLineNumbers( string ) {
	
			var lines = string.split( '\n' );
	
			for ( var i = 0; i < lines.length; i ++ ) {
	
				lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];
	
			}
	
			return lines.join( '\n' );
	
		}
	
		function WebGLShader( gl, type, string ) {
	
			var shader = gl.createShader( type );
	
			gl.shaderSource( shader, string );
			gl.compileShader( shader );
	
			if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {
	
				console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );
	
			}
	
			if ( gl.getShaderInfoLog( shader ) !== '' ) {
	
				console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );
	
			}
	
			// --enable-privileged-webgl-extension
			// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
	
			return shader;
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		var programIdCount = 0;
	
		function getEncodingComponents( encoding ) {
	
			switch ( encoding ) {
	
				case LinearEncoding:
					return [ 'Linear','( value )' ];
				case sRGBEncoding:
					return [ 'sRGB','( value )' ];
				case RGBEEncoding:
					return [ 'RGBE','( value )' ];
				case RGBM7Encoding:
					return [ 'RGBM','( value, 7.0 )' ];
				case RGBM16Encoding:
					return [ 'RGBM','( value, 16.0 )' ];
				case RGBDEncoding:
					return [ 'RGBD','( value, 256.0 )' ];
				case GammaEncoding:
					return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
				default:
					throw new Error( 'unsupported encoding: ' + encoding );
	
			}
	
		}
	
		function getTexelDecodingFunction( functionName, encoding ) {
	
			var components = getEncodingComponents( encoding );
			return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";
	
		}
	
		function getTexelEncodingFunction( functionName, encoding ) {
	
			var components = getEncodingComponents( encoding );
			return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";
	
		}
	
		function getToneMappingFunction( functionName, toneMapping ) {
	
			var toneMappingName;
	
			switch ( toneMapping ) {
	
				case LinearToneMapping:
					toneMappingName = "Linear";
					break;
	
				case ReinhardToneMapping:
					toneMappingName = "Reinhard";
					break;
	
				case Uncharted2ToneMapping:
					toneMappingName = "Uncharted2";
					break;
	
				case CineonToneMapping:
					toneMappingName = "OptimizedCineon";
					break;
	
				default:
					throw new Error( 'unsupported toneMapping: ' + toneMapping );
	
			}
	
			return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";
	
		}
	
		function generateExtensions( extensions, parameters, rendererExtensions ) {
	
			extensions = extensions || {};
	
			var chunks = [
				( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
				( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
				( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
				( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
			];
	
			return chunks.filter( filterEmptyLine ).join( '\n' );
	
		}
	
		function generateDefines( defines ) {
	
			var chunks = [];
	
			for ( var name in defines ) {
	
				var value = defines[ name ];
	
				if ( value === false ) continue;
	
				chunks.push( '#define ' + name + ' ' + value );
	
			}
	
			return chunks.join( '\n' );
	
		}
	
		function fetchAttributeLocations( gl, program, identifiers ) {
	
			var attributes = {};
	
			var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );
	
			for ( var i = 0; i < n; i ++ ) {
	
				var info = gl.getActiveAttrib( program, i );
				var name = info.name;
	
				// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );
	
				attributes[ name ] = gl.getAttribLocation( program, name );
	
			}
	
			return attributes;
	
		}
	
		function filterEmptyLine( string ) {
	
			return string !== '';
	
		}
	
		function replaceLightNums( string, parameters ) {
	
			return string
				.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
				.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
				.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
				.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
				.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );
	
		}
	
		function parseIncludes( string ) {
	
			var pattern = /#include +<([\w\d.]+)>/g;
	
			function replace( match, include ) {
	
				var replace = ShaderChunk[ include ];
	
				if ( replace === undefined ) {
	
					throw new Error( 'Can not resolve #include <' + include + '>' );
	
				}
	
				return parseIncludes( replace );
	
			}
	
			return string.replace( pattern, replace );
	
		}
	
		function unrollLoops( string ) {
	
			var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	
			function replace( match, start, end, snippet ) {
	
				var unroll = '';
	
				for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {
	
					unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );
	
				}
	
				return unroll;
	
			}
	
			return string.replace( pattern, replace );
	
		}
	
		function WebGLProgram( renderer, code, material, parameters ) {
	
			var gl = renderer.context;
	
			var extensions = material.extensions;
			var defines = material.defines;
	
			var vertexShader = material.__webglShader.vertexShader;
			var fragmentShader = material.__webglShader.fragmentShader;
	
			var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
	
			if ( parameters.shadowMapType === PCFShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
	
			} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {
	
				shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
	
			}
	
			var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
			var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
			var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
	
			if ( parameters.envMap ) {
	
				switch ( material.envMap.mapping ) {
	
					case CubeReflectionMapping:
					case CubeRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
						break;
	
					case CubeUVReflectionMapping:
					case CubeUVRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
						break;
	
					case EquirectangularReflectionMapping:
					case EquirectangularRefractionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
						break;
	
					case SphericalReflectionMapping:
						envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
						break;
	
				}
	
				switch ( material.envMap.mapping ) {
	
					case CubeRefractionMapping:
					case EquirectangularRefractionMapping:
						envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
						break;
	
				}
	
				switch ( material.combine ) {
	
					case MultiplyOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
						break;
	
					case MixOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
						break;
	
					case AddOperation:
						envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
						break;
	
				}
	
			}
	
			var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;
	
			// console.log( 'building new program ' );
	
			//
	
			var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );
	
			var customDefines = generateDefines( defines );
	
			//
	
			var program = gl.createProgram();
	
			var prefixVertex, prefixFragment;
	
			if ( material.isRawShaderMaterial ) {
	
				prefixVertex = [
	
					customDefines,
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
				prefixFragment = [
	
					customExtensions,
					customDefines,
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
			} else {
	
				prefixVertex = [
	
		        
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					'#define SHADER_NAME ' + material.__webglShader.name,
	
					customDefines,
	
					parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
	
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					'#define MAX_BONES ' + parameters.maxBones,
					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',
	
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED' : '',
	
					parameters.skinning ? '#define USE_SKINNING' : '',
					parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
	
					parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
					parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
	
					parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
					'uniform mat4 modelMatrix;',
					'uniform mat4 modelViewMatrix;',
					'uniform mat4 projectionMatrix;',
					'uniform mat4 viewMatrix;',
					'uniform mat3 normalMatrix;',
					'uniform vec3 cameraPosition;',
	
					'attribute vec3 position;',
					'attribute vec3 normal;',
					'attribute vec2 uv;',
	
					'#ifdef USE_COLOR',
	
					'	attribute vec3 color;',
	
					'#endif',
	
					'#ifdef USE_MORPHTARGETS',
	
					'	attribute vec3 morphTarget0;',
					'	attribute vec3 morphTarget1;',
					'	attribute vec3 morphTarget2;',
					'	attribute vec3 morphTarget3;',
	
					'	#ifdef USE_MORPHNORMALS',
	
					'		attribute vec3 morphNormal0;',
					'		attribute vec3 morphNormal1;',
					'		attribute vec3 morphNormal2;',
					'		attribute vec3 morphNormal3;',
	
					'	#else',
	
					'		attribute vec3 morphTarget4;',
					'		attribute vec3 morphTarget5;',
					'		attribute vec3 morphTarget6;',
					'		attribute vec3 morphTarget7;',
	
					'	#endif',
	
					'#endif',
	
					'#ifdef USE_SKINNING',
	
					'	attribute vec4 skinIndex;',
					'	attribute vec4 skinWeight;',
	
					'#endif',
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
				prefixFragment = [
	
					customExtensions,
	
					'precision ' + parameters.precision + ' float;',
					'precision ' + parameters.precision + ' int;',
	
					'#define SHADER_NAME ' + material.__webglShader.name,
	
					customDefines,
	
					parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',
	
					'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
					( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
					( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',
	
					parameters.map ? '#define USE_MAP' : '',
					parameters.envMap ? '#define USE_ENVMAP' : '',
					parameters.envMap ? '#define ' + envMapTypeDefine : '',
					parameters.envMap ? '#define ' + envMapModeDefine : '',
					parameters.envMap ? '#define ' + envMapBlendingDefine : '',
					parameters.lightMap ? '#define USE_LIGHTMAP' : '',
					parameters.aoMap ? '#define USE_AOMAP' : '',
					parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
					parameters.bumpMap ? '#define USE_BUMPMAP' : '',
					parameters.normalMap ? '#define USE_NORMALMAP' : '',
					parameters.specularMap ? '#define USE_SPECULARMAP' : '',
					parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
					parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
					parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
					parameters.vertexColors ? '#define USE_COLOR' : '',
	
					parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',
	
					parameters.flatShading ? '#define FLAT_SHADED' : '',
	
					parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
					parameters.flipSided ? '#define FLIP_SIDED' : '',
	
					'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
					'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),
	
					parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
					parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
	
					parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',
	
					parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',
	
					parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
					parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
					parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',
	
					'uniform mat4 viewMatrix;',
					'uniform vec3 cameraPosition;',
	
					( parameters.toneMapping !== NoToneMapping ) ? "#define TONE_MAPPING" : '',
					( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
					( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',
	
					( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
					parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
					parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
					parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
					parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',
	
					parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',
	
					'\n'
	
				].filter( filterEmptyLine ).join( '\n' );
	
			}
	
			vertexShader = parseIncludes( vertexShader, parameters );
			vertexShader = replaceLightNums( vertexShader, parameters );
	
			fragmentShader = parseIncludes( fragmentShader, parameters );
			fragmentShader = replaceLightNums( fragmentShader, parameters );
	
			if ( ! material.isShaderMaterial ) {
	
				vertexShader = unrollLoops( vertexShader );
				fragmentShader = unrollLoops( fragmentShader );
	
			}
	
			var vertexGlsl = prefixVertex + vertexShader;
			var fragmentGlsl = prefixFragment + fragmentShader;
	
			// console.log( '*VERTEX*', vertexGlsl );
			// console.log( '*FRAGMENT*', fragmentGlsl );
	
			var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
			var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );
	
			gl.attachShader( program, glVertexShader );
			gl.attachShader( program, glFragmentShader );
	
			// Force a particular attribute to index 0.
	
			if ( material.index0AttributeName !== undefined ) {
	
				gl.bindAttribLocation( program, 0, material.index0AttributeName );
	
			} else if ( parameters.morphTargets === true ) {
	
				// programs with morphTargets displace position out of attribute 0
				gl.bindAttribLocation( program, 0, 'position' );
	
			}
	
			gl.linkProgram( program );
	
			var programLog = gl.getProgramInfoLog( program );
			var vertexLog = gl.getShaderInfoLog( glVertexShader );
			var fragmentLog = gl.getShaderInfoLog( glFragmentShader );
	
			var runnable = true;
			var haveDiagnostics = true;
	
			// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
			// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
	
			if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {
	
				runnable = false;
	
				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );
	
			} else if ( programLog !== '' ) {
	
				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );
	
			} else if ( vertexLog === '' || fragmentLog === '' ) {
	
				haveDiagnostics = false;
	
			}
	
			if ( haveDiagnostics ) {
	
				this.diagnostics = {
	
					runnable: runnable,
					material: material,
	
					programLog: programLog,
	
					vertexShader: {
	
						log: vertexLog,
						prefix: prefixVertex
	
					},
	
					fragmentShader: {
	
						log: fragmentLog,
						prefix: prefixFragment
	
					}
	
				};
	
			}
	
			// clean up
	
			gl.deleteShader( glVertexShader );
			gl.deleteShader( glFragmentShader );
	
			// set up caching for uniform locations
	
			var cachedUniforms;
	
			this.getUniforms = function() {
	
				if ( cachedUniforms === undefined ) {
	
					cachedUniforms =
						new WebGLUniforms( gl, program, renderer );
	
				}
	
				return cachedUniforms;
	
			};
	
			// set up caching for attribute locations
	
			var cachedAttributes;
	
			this.getAttributes = function() {
	
				if ( cachedAttributes === undefined ) {
	
					cachedAttributes = fetchAttributeLocations( gl, program );
	
				}
	
				return cachedAttributes;
	
			};
	
			// free resource
	
			this.destroy = function() {
	
				gl.deleteProgram( program );
				this.program = undefined;
	
			};
	
			// DEPRECATED
	
			Object.defineProperties( this, {
	
				uniforms: {
					get: function() {
	
						console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
						return this.getUniforms();
	
					}
				},
	
				attributes: {
					get: function() {
	
						console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
						return this.getAttributes();
	
					}
				}
	
			} );
	
	
			//
	
			this.id = programIdCount ++;
			this.code = code;
			this.usedTimes = 1;
			this.program = program;
			this.vertexShader = glVertexShader;
			this.fragmentShader = glFragmentShader;
	
			return this;
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLPrograms( renderer, capabilities ) {
	
			var programs = [];
	
			var shaderIDs = {
				MeshDepthMaterial: 'depth',
				MeshNormalMaterial: 'normal',
				MeshBasicMaterial: 'basic',
				MeshLambertMaterial: 'lambert',
				MeshPhongMaterial: 'phong',
				MeshToonMaterial: 'phong',
				MeshStandardMaterial: 'physical',
				MeshPhysicalMaterial: 'physical',
				LineBasicMaterial: 'basic',
				LineDashedMaterial: 'dashed',
				PointsMaterial: 'points'
			};
	
			var parameterNames = [
				"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
				"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
				"roughnessMap", "metalnessMap", "gradientMap",
				"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
				"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
				"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
				"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
				"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
				"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
				"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking"
			];
	
	
			function allocateBones( object ) {
	
				if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {
	
					return 1024;
	
				} else {
	
					// default for when object is not specified
					// ( for example when prebuilding shader to be used with multiple objects )
					//
					//  - leave some extra space for other uniforms
					//  - limit here is ANGLE's 254 max uniform vectors
					//    (up to 54 should be safe)
	
					var nVertexUniforms = capabilities.maxVertexUniforms;
					var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );
	
					var maxBones = nVertexMatrices;
	
					if ( object !== undefined && (object && object.isSkinnedMesh) ) {
	
						maxBones = Math.min( object.skeleton.bones.length, maxBones );
	
						if ( maxBones < object.skeleton.bones.length ) {
	
							console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );
	
						}
	
					}
	
					return maxBones;
	
				}
	
			}
	
			function getTextureEncodingFromMap( map, gammaOverrideLinear ) {
	
				var encoding;
	
				if ( ! map ) {
	
					encoding = LinearEncoding;
	
				} else if ( map.isTexture ) {
	
					encoding = map.encoding;
	
				} else if ( map.isWebGLRenderTarget ) {
	
					console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
					encoding = map.texture.encoding;
	
				}
	
				// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
				if ( encoding === LinearEncoding && gammaOverrideLinear ) {
	
					encoding = GammaEncoding;
	
				}
	
				return encoding;
	
			}
	
			this.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {
	
				var shaderID = shaderIDs[ material.type ];
	
				// heuristics to create shader parameters according to lights in the scene
				// (not to blow over maxLights budget)
	
				var maxBones = allocateBones( object );
				var precision = renderer.getPrecision();
	
				if ( material.precision !== null ) {
	
					precision = capabilities.getMaxPrecision( material.precision );
	
					if ( precision !== material.precision ) {
	
						console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );
	
					}
	
				}
	
				var currentRenderTarget = renderer.getCurrentRenderTarget();
	
				var parameters = {
	
					shaderID: shaderID,
	
					precision: precision,
					supportsVertexTextures: capabilities.vertexTextures,
					outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
					map: !! material.map,
					mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
					envMap: !! material.envMap,
					envMapMode: material.envMap && material.envMap.mapping,
					envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
					envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
					lightMap: !! material.lightMap,
					aoMap: !! material.aoMap,
					emissiveMap: !! material.emissiveMap,
					emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
					bumpMap: !! material.bumpMap,
					normalMap: !! material.normalMap,
					displacementMap: !! material.displacementMap,
					roughnessMap: !! material.roughnessMap,
					metalnessMap: !! material.metalnessMap,
					specularMap: !! material.specularMap,
					alphaMap: !! material.alphaMap,
	
					gradientMap: !! material.gradientMap,
	
					combine: material.combine,
	
					vertexColors: material.vertexColors,
	
					fog: !! fog,
					useFog: material.fog,
					fogExp: (fog && fog.isFogExp2),
	
					flatShading: material.shading === FlatShading,
	
					sizeAttenuation: material.sizeAttenuation,
					logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
	
					skinning: material.skinning,
					maxBones: maxBones,
					useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,
	
					morphTargets: material.morphTargets,
					morphNormals: material.morphNormals,
					maxMorphTargets: renderer.maxMorphTargets,
					maxMorphNormals: renderer.maxMorphNormals,
	
					numDirLights: lights.directional.length,
					numPointLights: lights.point.length,
					numSpotLights: lights.spot.length,
					numRectAreaLights: lights.rectArea.length,
					numHemiLights: lights.hemi.length,
	
					numClippingPlanes: nClipPlanes,
					numClipIntersection: nClipIntersection,
	
					shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
					shadowMapType: renderer.shadowMap.type,
	
					toneMapping: renderer.toneMapping,
					physicallyCorrectLights: renderer.physicallyCorrectLights,
	
					premultipliedAlpha: material.premultipliedAlpha,
	
					alphaTest: material.alphaTest,
					doubleSided: material.side === DoubleSide,
					flipSided: material.side === BackSide,
	
					depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false
	
				};
	
				return parameters;
	
			};
	
			this.getProgramCode = function ( material, parameters ) {
	
				var array = [];
	
				if ( parameters.shaderID ) {
	
					array.push( parameters.shaderID );
	
				} else {
	
					array.push( material.fragmentShader );
					array.push( material.vertexShader );
	
				}
	
				if ( material.defines !== undefined ) {
	
					for ( var name in material.defines ) {
	
						array.push( name );
						array.push( material.defines[ name ] );
	
					}
	
				}
	
				for ( var i = 0; i < parameterNames.length; i ++ ) {
	
					array.push( parameters[ parameterNames[ i ] ] );
	
				}
	
				return array.join();
	
			};
	
			this.acquireProgram = function ( material, parameters, code ) {
	
				var program;
	
				// Check if code has been already compiled
				for ( var p = 0, pl = programs.length; p < pl; p ++ ) {
	
					var programInfo = programs[ p ];
	
					if ( programInfo.code === code ) {
	
						program = programInfo;
						++ program.usedTimes;
	
						break;
	
					}
	
				}
	
				if ( program === undefined ) {
	
					program = new WebGLProgram( renderer, code, material, parameters );
					programs.push( program );
	
				}
	
				return program;
	
			};
	
			this.releaseProgram = function( program ) {
	
				if ( -- program.usedTimes === 0 ) {
	
					// Remove from unordered set
					var i = programs.indexOf( program );
					programs[ i ] = programs[ programs.length - 1 ];
					programs.pop();
	
					// Free WebGL resources
					program.destroy();
	
				}
	
			};
	
			// Exposed for resource monitoring & error feedback via renderer.info:
			this.programs = programs;
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLGeometries( gl, properties, info ) {
	
			var geometries = {};
	
			function onGeometryDispose( event ) {
	
				var geometry = event.target;
				var buffergeometry = geometries[ geometry.id ];
	
				if ( buffergeometry.index !== null ) {
	
					deleteAttribute( buffergeometry.index );
	
				}
	
				deleteAttributes( buffergeometry.attributes );
	
				geometry.removeEventListener( 'dispose', onGeometryDispose );
	
				delete geometries[ geometry.id ];
	
				// TODO
	
				var property = properties.get( geometry );
	
				if ( property.wireframe ) {
	
					deleteAttribute( property.wireframe );
	
				}
	
				properties.delete( geometry );
	
				var bufferproperty = properties.get( buffergeometry );
	
				if ( bufferproperty.wireframe ) {
	
					deleteAttribute( bufferproperty.wireframe );
	
				}
	
				properties.delete( buffergeometry );
	
				//
	
				info.memory.geometries --;
	
			}
	
			function getAttributeBuffer( attribute ) {
	
				if ( attribute.isInterleavedBufferAttribute ) {
	
					return properties.get( attribute.data ).__webglBuffer;
	
				}
	
				return properties.get( attribute ).__webglBuffer;
	
			}
	
			function deleteAttribute( attribute ) {
	
				var buffer = getAttributeBuffer( attribute );
	
				if ( buffer !== undefined ) {
	
					gl.deleteBuffer( buffer );
					removeAttributeBuffer( attribute );
	
				}
	
			}
	
			function deleteAttributes( attributes ) {
	
				for ( var name in attributes ) {
	
					deleteAttribute( attributes[ name ] );
	
				}
	
			}
	
			function removeAttributeBuffer( attribute ) {
	
				if ( attribute.isInterleavedBufferAttribute ) {
	
					properties.delete( attribute.data );
	
				} else {
	
					properties.delete( attribute );
	
				}
	
			}
	
			return {
	
				get: function ( object ) {
	
					var geometry = object.geometry;
	
					if ( geometries[ geometry.id ] !== undefined ) {
	
						return geometries[ geometry.id ];
	
					}
	
					geometry.addEventListener( 'dispose', onGeometryDispose );
	
					var buffergeometry;
	
					if ( geometry.isBufferGeometry ) {
	
						buffergeometry = geometry;
	
					} else if ( geometry.isGeometry ) {
	
						if ( geometry._bufferGeometry === undefined ) {
	
							geometry._bufferGeometry = new BufferGeometry().setFromObject( object );
	
						}
	
						buffergeometry = geometry._bufferGeometry;
	
					}
	
					geometries[ geometry.id ] = buffergeometry;
	
					info.memory.geometries ++;
	
					return buffergeometry;
	
				}
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLObjects( gl, properties, info ) {
	
			var geometries = new WebGLGeometries( gl, properties, info );
	
			//
	
			function update( object ) {
	
				// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.
	
				var geometry = geometries.get( object );
	
				if ( object.geometry.isGeometry ) {
	
					geometry.updateFromObject( object );
	
				}
	
				var index = geometry.index;
				var attributes = geometry.attributes;
	
				if ( index !== null ) {
	
					updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );
	
				}
	
				for ( var name in attributes ) {
	
					updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );
	
				}
	
				// morph targets
	
				var morphAttributes = geometry.morphAttributes;
	
				for ( var name in morphAttributes ) {
	
					var array = morphAttributes[ name ];
	
					for ( var i = 0, l = array.length; i < l; i ++ ) {
	
						updateAttribute( array[ i ], gl.ARRAY_BUFFER );
	
					}
	
				}
	
				return geometry;
	
			}
	
			function updateAttribute( attribute, bufferType ) {
	
				var data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;
	
				var attributeProperties = properties.get( data );
	
				if ( attributeProperties.__webglBuffer === undefined ) {
	
					createBuffer( attributeProperties, data, bufferType );
	
				} else if ( attributeProperties.version !== data.version ) {
	
					updateBuffer( attributeProperties, data, bufferType );
	
				}
	
			}
	
			function createBuffer( attributeProperties, data, bufferType ) {
	
				attributeProperties.__webglBuffer = gl.createBuffer();
				gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );
	
				var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
	
				gl.bufferData( bufferType, data.array, usage );
	
				var type = gl.FLOAT;
				var array = data.array;
	
				if ( array instanceof Float32Array ) {
	
					type = gl.FLOAT;
	
				} else if ( array instanceof Float64Array ) {
	
					console.warn( "Unsupported data buffer format: Float64Array" );
	
				} else if ( array instanceof Uint16Array ) {
	
					type = gl.UNSIGNED_SHORT;
	
				} else if ( array instanceof Int16Array ) {
	
					type = gl.SHORT;
	
				} else if ( array instanceof Uint32Array ) {
	
					type = gl.UNSIGNED_INT;
	
				} else if ( array instanceof Int32Array ) {
	
					type = gl.INT;
	
				} else if ( array instanceof Int8Array ) {
	
					type = gl.BYTE;
	
				} else if ( array instanceof Uint8Array ) {
	
					type = gl.UNSIGNED_BYTE;
	
				}
	
				attributeProperties.bytesPerElement = array.BYTES_PER_ELEMENT;
				attributeProperties.type = type;
				attributeProperties.version = data.version;
	
				data.onUploadCallback();
	
			}
	
			function updateBuffer( attributeProperties, data, bufferType ) {
	
				gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );
	
				if ( data.dynamic === false ) {
	
					gl.bufferData( bufferType, data.array, gl.STATIC_DRAW );
	
				} else if ( data.updateRange.count === - 1 ) {
	
					// Not using update ranges
	
					gl.bufferSubData( bufferType, 0, data.array );
	
				} else if ( data.updateRange.count === 0 ) {
	
					console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );
	
				} else {
	
					gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
									  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );
	
					data.updateRange.count = 0; // reset range
	
				}
	
				attributeProperties.version = data.version;
	
			}
	
			function getAttributeBuffer( attribute ) {
	
				if ( attribute.isInterleavedBufferAttribute ) {
	
					return properties.get( attribute.data ).__webglBuffer;
	
				}
	
				return properties.get( attribute ).__webglBuffer;
	
			}
	
			function getAttributeProperties( attribute ) {
	
				if ( attribute.isInterleavedBufferAttribute ) {
	
					return properties.get( attribute.data );
	
				}
	
				return properties.get( attribute );
	
			}
	
			function getWireframeAttribute( geometry ) {
	
				var property = properties.get( geometry );
	
				if ( property.wireframe !== undefined ) {
	
					return property.wireframe;
	
				}
	
				var indices = [];
	
				var index = geometry.index;
				var attributes = geometry.attributes;
	
				// console.time( 'wireframe' );
	
				if ( index !== null ) {
	
					var array = index.array;
	
					for ( var i = 0, l = array.length; i < l; i += 3 ) {
	
						var a = array[ i + 0 ];
						var b = array[ i + 1 ];
						var c = array[ i + 2 ];
	
						indices.push( a, b, b, c, c, a );
	
					}
	
				} else {
	
					var array = attributes.position.array;
	
					for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {
	
						var a = i + 0;
						var b = i + 1;
						var c = i + 2;
	
						indices.push( a, b, b, c, c, a );
	
					}
	
				}
	
				// console.timeEnd( 'wireframe' );
	
				var attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
	
				updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );
	
				property.wireframe = attribute;
	
				return attribute;
	
			}
	
			return {
	
				getAttributeBuffer: getAttributeBuffer,
				getAttributeProperties: getAttributeProperties,
				getWireframeAttribute: getWireframeAttribute,
	
				update: update
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {
	
			var _infoMemory = info.memory;
			var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );
	
			//
	
			function clampToMaxSize( image, maxSize ) {
	
				if ( image.width > maxSize || image.height > maxSize ) {
	
					// Warning: Scaling through the canvas will only work with images that use
					// premultiplied alpha.
	
					var scale = maxSize / Math.max( image.width, image.height );
	
					var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = Math.floor( image.width * scale );
					canvas.height = Math.floor( image.height * scale );
	
					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );
	
					console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
	
					return canvas;
	
				}
	
				return image;
	
			}
	
			function isPowerOfTwo( image ) {
	
				return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );
	
			}
	
			function makePowerOfTwo( image ) {
	
				if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {
	
					var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
					canvas.width = _Math.nearestPowerOfTwo( image.width );
					canvas.height = _Math.nearestPowerOfTwo( image.height );
	
					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, canvas.width, canvas.height );
	
					console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );
	
					return canvas;
	
				}
	
				return image;
	
			}
	
			function textureNeedsPowerOfTwo( texture ) {
	
				return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
					( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );
	
			}
	
			// Fallback filters for non-power-of-2 textures
	
			function filterFallback( f ) {
	
				if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {
	
					return _gl.NEAREST;
	
				}
	
				return _gl.LINEAR;
	
			}
	
			//
	
			function onTextureDispose( event ) {
	
				var texture = event.target;
	
				texture.removeEventListener( 'dispose', onTextureDispose );
	
				deallocateTexture( texture );
	
				_infoMemory.textures --;
	
	
			}
	
			function onRenderTargetDispose( event ) {
	
				var renderTarget = event.target;
	
				renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );
	
				deallocateRenderTarget( renderTarget );
	
				_infoMemory.textures --;
	
			}
	
			//
	
			function deallocateTexture( texture ) {
	
				var textureProperties = properties.get( texture );
	
				if ( texture.image && textureProperties.__image__webglTextureCube ) {
	
					// cube texture
	
					_gl.deleteTexture( textureProperties.__image__webglTextureCube );
	
				} else {
	
					// 2D texture
	
					if ( textureProperties.__webglInit === undefined ) return;
	
					_gl.deleteTexture( textureProperties.__webglTexture );
	
				}
	
				// remove all webgl properties
				properties.delete( texture );
	
			}
	
			function deallocateRenderTarget( renderTarget ) {
	
				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );
	
				if ( ! renderTarget ) return;
	
				if ( textureProperties.__webglTexture !== undefined ) {
	
					_gl.deleteTexture( textureProperties.__webglTexture );
	
				}
	
				if ( renderTarget.depthTexture ) {
	
					renderTarget.depthTexture.dispose();
	
				}
	
				if ( renderTarget.isWebGLRenderTargetCube ) {
	
					for ( var i = 0; i < 6; i ++ ) {
	
						_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
						if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );
	
					}
	
				} else {
	
					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
	
				}
	
				properties.delete( renderTarget.texture );
				properties.delete( renderTarget );
	
			}
	
			//
	
	
	
			function setTexture2D( texture, slot ) {
	
				var textureProperties = properties.get( texture );
	
				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
					var image = texture.image;
	
					if ( image === undefined ) {
	
						console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );
	
					} else if ( image.complete === false ) {
	
						console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );
	
					} else {
	
						uploadTexture( textureProperties, texture, slot );
						return;
	
					}
	
				}
	
				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
	
			}
	
			function setTextureCube( texture, slot ) {
	
				var textureProperties = properties.get( texture );
	
				if ( texture.image.length === 6 ) {
	
					if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
						if ( ! textureProperties.__image__webglTextureCube ) {
	
							texture.addEventListener( 'dispose', onTextureDispose );
	
							textureProperties.__image__webglTextureCube = _gl.createTexture();
	
							_infoMemory.textures ++;
	
						}
	
						state.activeTexture( _gl.TEXTURE0 + slot );
						state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
	
						_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
	
						var isCompressed = ( texture && texture.isCompressedTexture );
						var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );
	
						var cubeImage = [];
	
						for ( var i = 0; i < 6; i ++ ) {
	
							if ( ! isCompressed && ! isDataTexture ) {
	
								cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );
	
							} else {
	
								cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];
	
							}
	
						}
	
						var image = cubeImage[ 0 ],
						isPowerOfTwoImage = isPowerOfTwo( image ),
						glFormat = paramThreeToGL( texture.format ),
						glType = paramThreeToGL( texture.type );
	
						setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );
	
						for ( var i = 0; i < 6; i ++ ) {
	
							if ( ! isCompressed ) {
	
								if ( isDataTexture ) {
	
									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );
	
								} else {
	
									state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );
	
								}
	
							} else {
	
								var mipmap, mipmaps = cubeImage[ i ].mipmaps;
	
								for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {
	
									mipmap = mipmaps[ j ];
	
									if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {
	
										if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
											state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
										} else {
	
											console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );
	
										}
	
									} else {
	
										state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
									}
	
								}
	
							}
	
						}
	
						if ( texture.generateMipmaps && isPowerOfTwoImage ) {
	
							_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
	
						}
	
						textureProperties.__version = texture.version;
	
						if ( texture.onUpdate ) texture.onUpdate( texture );
	
					} else {
	
						state.activeTexture( _gl.TEXTURE0 + slot );
						state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );
	
					}
	
				}
	
			}
	
			function setTextureCubeDynamic( texture, slot ) {
	
				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );
	
			}
	
			function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {
	
				var extension;
	
				if ( isPowerOfTwoImage ) {
	
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );
	
					_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );
	
				} else {
	
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
					_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );
	
					if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {
	
						console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );
	
					}
	
					_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
					_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );
	
					if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {
	
						console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );
	
					}
	
				}
	
				extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
				if ( extension ) {
	
					if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
					if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;
	
					if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {
	
						_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
						properties.get( texture ).__currentAnisotropy = texture.anisotropy;
	
					}
	
				}
	
			}
	
			function uploadTexture( textureProperties, texture, slot ) {
	
				if ( textureProperties.__webglInit === undefined ) {
	
					textureProperties.__webglInit = true;
	
					texture.addEventListener( 'dispose', onTextureDispose );
	
					textureProperties.__webglTexture = _gl.createTexture();
	
					_infoMemory.textures ++;
	
				}
	
				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
	
				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
				_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
				_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );
	
				var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );
	
				if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {
	
					image = makePowerOfTwo( image );
	
				}
	
				var isPowerOfTwoImage = isPowerOfTwo( image ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );
	
				setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );
	
				var mipmap, mipmaps = texture.mipmaps;
	
				if ( texture.isDepthTexture ) {
	
					// populate depth texture with dummy data
	
					var internalFormat = _gl.DEPTH_COMPONENT;
	
					if ( texture.type === FloatType ) {
	
						if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
						internalFormat = _gl.DEPTH_COMPONENT32F;
	
					} else if ( _isWebGL2 ) {
	
						// WebGL 2.0 requires signed internalformat for glTexImage2D
						internalFormat = _gl.DEPTH_COMPONENT16;
	
					}
	
					if ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {
	
						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {
	
						        console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );
	
							texture.type = UnsignedShortType;
							glType = paramThreeToGL( texture.type );
	
						}
	
					}
	
					// Depth stencil textures need the DEPTH_STENCIL internal format
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.format === DepthStencilFormat ) {
	
						internalFormat = _gl.DEPTH_STENCIL;
	
						// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
						// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
						// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
						if ( texture.type !== UnsignedInt248Type ) {
	
						        console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );
	
							texture.type = UnsignedInt248Type;
							glType = paramThreeToGL( texture.type );
	
						}
	
					}
	
					state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );
	
				} else if ( texture.isDataTexture ) {
	
					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels
	
					if ( mipmaps.length > 0 && isPowerOfTwoImage ) {
	
						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
							mipmap = mipmaps[ i ];
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
						}
	
						texture.generateMipmaps = false;
	
					} else {
	
						state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );
	
					}
	
				} else if ( texture.isCompressedTexture ) {
	
					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
	
						if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {
	
							if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
								state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
							} else {
	
								console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );
	
							}
	
						} else {
	
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
						}
	
					}
	
				} else {
	
					// regular Texture (image, video, canvas)
	
					// use manually created mipmaps if available
					// if there are no manual mipmaps
					// set 0 level mipmap and then use GL to generate other mipmap levels
	
					if ( mipmaps.length > 0 && isPowerOfTwoImage ) {
	
						for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
							mipmap = mipmaps[ i ];
							state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );
	
						}
	
						texture.generateMipmaps = false;
	
					} else {
	
						state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );
	
					}
	
				}
	
				if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );
	
				textureProperties.__version = texture.version;
	
				if ( texture.onUpdate ) texture.onUpdate( texture );
	
			}
	
			// Render targets
	
			// Setup storage for target texture and bind it to correct framebuffer
			function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {
	
				var glFormat = paramThreeToGL( renderTarget.texture.format );
				var glType = paramThreeToGL( renderTarget.texture.type );
				state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
				_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
			}
	
			// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
			function setupRenderBufferStorage( renderbuffer, renderTarget ) {
	
				_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );
	
				if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
	
					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
				} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
					_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );
	
				} else {
	
					// FIXME: We don't support !depth !stencil
					_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );
	
				}
	
				_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );
	
			}
	
			// Setup resources for a Depth Texture for a FBO (needs an extension)
			function setupDepthTexture( framebuffer, renderTarget ) {
	
				var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
				if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');
	
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
	
				if ( !( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {
	
					throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');
	
				}
	
				// upload an empty depth texture with framebuffer size
				if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
						renderTarget.depthTexture.image.width !== renderTarget.width ||
						renderTarget.depthTexture.image.height !== renderTarget.height ) {
					renderTarget.depthTexture.image.width = renderTarget.width;
					renderTarget.depthTexture.image.height = renderTarget.height;
					renderTarget.depthTexture.needsUpdate = true;
				}
	
				setTexture2D( renderTarget.depthTexture, 0 );
	
				var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
	
				if ( renderTarget.depthTexture.format === DepthFormat ) {
	
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );
	
				} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {
	
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );
	
				} else {
	
					throw new Error('Unknown depthTexture format')
	
				}
	
			}
	
			// Setup GL resources for a non-texture depth buffer
			function setupDepthRenderbuffer( renderTarget ) {
	
				var renderTargetProperties = properties.get( renderTarget );
	
				var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
	
				if ( renderTarget.depthTexture ) {
	
					if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');
	
					setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );
	
				} else {
	
					if ( isCube ) {
	
						renderTargetProperties.__webglDepthbuffer = [];
	
						for ( var i = 0; i < 6; i ++ ) {
	
							_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
							renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
							setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );
	
						}
	
					} else {
	
						_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
						renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );
	
					}
	
				}
	
				_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );
	
			}
	
			// Set up GL resources for the render target
			function setupRenderTarget( renderTarget ) {
	
				var renderTargetProperties = properties.get( renderTarget );
				var textureProperties = properties.get( renderTarget.texture );
	
				renderTarget.addEventListener( 'dispose', onRenderTargetDispose );
	
				textureProperties.__webglTexture = _gl.createTexture();
	
				_infoMemory.textures ++;
	
				var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
				var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );
	
				// Setup framebuffer
	
				if ( isCube ) {
	
					renderTargetProperties.__webglFramebuffer = [];
	
					for ( var i = 0; i < 6; i ++ ) {
	
						renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
	
					}
	
				} else {
	
					renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
	
				}
	
				// Setup color buffer
	
				if ( isCube ) {
	
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );
	
					for ( var i = 0; i < 6; i ++ ) {
	
						setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );
	
					}
	
					if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
					state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );
	
				} else {
	
					state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
					setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );
	
					if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
					state.bindTexture( _gl.TEXTURE_2D, null );
	
				}
	
				// Setup depth and stencil buffers
	
				if ( renderTarget.depthBuffer ) {
	
					setupDepthRenderbuffer( renderTarget );
	
				}
	
			}
	
			function updateRenderTargetMipmap( renderTarget ) {
	
				var texture = renderTarget.texture;
	
				if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
						texture.minFilter !== NearestFilter &&
						texture.minFilter !== LinearFilter ) {
	
					var target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
					var webglTexture = properties.get( texture ).__webglTexture;
	
					state.bindTexture( target, webglTexture );
					_gl.generateMipmap( target );
					state.bindTexture( target, null );
	
				}
	
			}
	
			this.setTexture2D = setTexture2D;
			this.setTextureCube = setTextureCube;
			this.setTextureCubeDynamic = setTextureCubeDynamic;
			this.setupRenderTarget = setupRenderTarget;
			this.updateRenderTargetMipmap = updateRenderTargetMipmap;
	
		}
	
		/**
		 * @author fordacious / fordacious.github.io
		 */
	
		function WebGLProperties() {
	
			var properties = {};
	
			return {
	
				get: function ( object ) {
	
					var uuid = object.uuid;
					var map = properties[ uuid ];
	
					if ( map === undefined ) {
	
						map = {};
						properties[ uuid ] = map;
	
					}
	
					return map;
	
				},
	
				delete: function ( object ) {
	
					delete properties[ object.uuid ];
	
				},
	
				clear: function () {
	
					properties = {};
	
				}
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLState( gl, extensions, paramThreeToGL ) {
	
			function ColorBuffer() {
	
				var locked = false;
	
				var color = new Vector4();
				var currentColorMask = null;
				var currentColorClear = new Vector4();
	
				return {
	
					setMask: function ( colorMask ) {
	
						if ( currentColorMask !== colorMask && ! locked ) {
	
							gl.colorMask( colorMask, colorMask, colorMask, colorMask );
							currentColorMask = colorMask;
	
						}
	
					},
	
					setLocked: function ( lock ) {
	
						locked = lock;
	
					},
	
					setClear: function ( r, g, b, a, premultipliedAlpha ) {
	
						if ( premultipliedAlpha === true ) {
	
							r *= a; g *= a; b *= a;
	
						}
	
						color.set( r, g, b, a );
	
						if ( currentColorClear.equals( color ) === false ) {
	
							gl.clearColor( r, g, b, a );
							currentColorClear.copy( color );
	
						}
	
					},
	
					reset: function () {
	
						locked = false;
	
						currentColorMask = null;
						currentColorClear.set( 0, 0, 0, 1 );
	
					}
	
				};
	
			}
	
			function DepthBuffer() {
	
				var locked = false;
	
				var currentDepthMask = null;
				var currentDepthFunc = null;
				var currentDepthClear = null;
	
				return {
	
					setTest: function ( depthTest ) {
	
						if ( depthTest ) {
	
							enable( gl.DEPTH_TEST );
	
						} else {
	
							disable( gl.DEPTH_TEST );
	
						}
	
					},
	
					setMask: function ( depthMask ) {
	
						if ( currentDepthMask !== depthMask && ! locked ) {
	
							gl.depthMask( depthMask );
							currentDepthMask = depthMask;
	
						}
	
					},
	
					setFunc: function ( depthFunc ) {
	
						if ( currentDepthFunc !== depthFunc ) {
	
							if ( depthFunc ) {
	
								switch ( depthFunc ) {
	
									case NeverDepth:
	
										gl.depthFunc( gl.NEVER );
										break;
	
									case AlwaysDepth:
	
										gl.depthFunc( gl.ALWAYS );
										break;
	
									case LessDepth:
	
										gl.depthFunc( gl.LESS );
										break;
	
									case LessEqualDepth:
	
										gl.depthFunc( gl.LEQUAL );
										break;
	
									case EqualDepth:
	
										gl.depthFunc( gl.EQUAL );
										break;
	
									case GreaterEqualDepth:
	
										gl.depthFunc( gl.GEQUAL );
										break;
	
									case GreaterDepth:
	
										gl.depthFunc( gl.GREATER );
										break;
	
									case NotEqualDepth:
	
										gl.depthFunc( gl.NOTEQUAL );
										break;
	
									default:
	
										gl.depthFunc( gl.LEQUAL );
	
								}
	
							} else {
	
								gl.depthFunc( gl.LEQUAL );
	
							}
	
							currentDepthFunc = depthFunc;
	
						}
	
					},
	
					setLocked: function ( lock ) {
	
						locked = lock;
	
					},
	
					setClear: function ( depth ) {
	
						if ( currentDepthClear !== depth ) {
	
							gl.clearDepth( depth );
							currentDepthClear = depth;
	
						}
	
					},
	
					reset: function () {
	
						locked = false;
	
						currentDepthMask = null;
						currentDepthFunc = null;
						currentDepthClear = null;
	
					}
	
				};
	
			}
	
			function StencilBuffer() {
	
				var locked = false;
	
				var currentStencilMask = null;
				var currentStencilFunc = null;
				var currentStencilRef = null;
				var currentStencilFuncMask = null;
				var currentStencilFail = null;
				var currentStencilZFail = null;
				var currentStencilZPass = null;
				var currentStencilClear = null;
	
				return {
	
					setTest: function ( stencilTest ) {
	
						if ( stencilTest ) {
	
							enable( gl.STENCIL_TEST );
	
						} else {
	
							disable( gl.STENCIL_TEST );
	
						}
	
					},
	
					setMask: function ( stencilMask ) {
	
						if ( currentStencilMask !== stencilMask && ! locked ) {
	
							gl.stencilMask( stencilMask );
							currentStencilMask = stencilMask;
	
						}
	
					},
	
					setFunc: function ( stencilFunc, stencilRef, stencilMask ) {
	
						if ( currentStencilFunc !== stencilFunc ||
						     currentStencilRef 	!== stencilRef 	||
						     currentStencilFuncMask !== stencilMask ) {
	
							gl.stencilFunc( stencilFunc, stencilRef, stencilMask );
	
							currentStencilFunc = stencilFunc;
							currentStencilRef = stencilRef;
							currentStencilFuncMask = stencilMask;
	
						}
	
					},
	
					setOp: function ( stencilFail, stencilZFail, stencilZPass ) {
	
						if ( currentStencilFail	 !== stencilFail 	||
						     currentStencilZFail !== stencilZFail ||
						     currentStencilZPass !== stencilZPass ) {
	
							gl.stencilOp( stencilFail, stencilZFail, stencilZPass );
	
							currentStencilFail = stencilFail;
							currentStencilZFail = stencilZFail;
							currentStencilZPass = stencilZPass;
	
						}
	
					},
	
					setLocked: function ( lock ) {
	
						locked = lock;
	
					},
	
					setClear: function ( stencil ) {
	
						if ( currentStencilClear !== stencil ) {
	
							gl.clearStencil( stencil );
							currentStencilClear = stencil;
	
						}
	
					},
	
					reset: function () {
	
						locked = false;
	
						currentStencilMask = null;
						currentStencilFunc = null;
						currentStencilRef = null;
						currentStencilFuncMask = null;
						currentStencilFail = null;
						currentStencilZFail = null;
						currentStencilZPass = null;
						currentStencilClear = null;
	
					}
	
				};
	
			}
	
			//
	
			var colorBuffer = new ColorBuffer();
			var depthBuffer = new DepthBuffer();
			var stencilBuffer = new StencilBuffer();
	
			var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
			var newAttributes = new Uint8Array( maxVertexAttributes );
			var enabledAttributes = new Uint8Array( maxVertexAttributes );
			var attributeDivisors = new Uint8Array( maxVertexAttributes );
	
			var capabilities = {};
	
			var compressedTextureFormats = null;
	
			var currentBlending = null;
			var currentBlendEquation = null;
			var currentBlendSrc = null;
			var currentBlendDst = null;
			var currentBlendEquationAlpha = null;
			var currentBlendSrcAlpha = null;
			var currentBlendDstAlpha = null;
			var currentPremultipledAlpha = false;
	
			var currentFlipSided = null;
			var currentCullFace = null;
	
			var currentLineWidth = null;
	
			var currentPolygonOffsetFactor = null;
			var currentPolygonOffsetUnits = null;
	
			var currentScissorTest = null;
	
			var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	
			var version = parseFloat( /^WebGL\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );
			var lineWidthAvailable = parseFloat( version ) >= 1.0;
	
			var currentTextureSlot = null;
			var currentBoundTextures = {};
	
			var currentScissor = new Vector4();
			var currentViewport = new Vector4();
	
			function createTexture( type, target, count ) {
	
				var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
				var texture = gl.createTexture();
	
				gl.bindTexture( type, texture );
				gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
				gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
	
				for ( var i = 0; i < count; i ++ ) {
	
					gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );
	
				}
	
				return texture;
	
			}
	
			var emptyTextures = {};
			emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
			emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );
	
			//
	
			function init() {
	
				colorBuffer.setClear( 0, 0, 0, 1 );
				depthBuffer.setClear( 1 );
				stencilBuffer.setClear( 0 );
	
				enable( gl.DEPTH_TEST );
				setDepthFunc( LessEqualDepth );
	
				setFlipSided( false );
				setCullFace( CullFaceBack );
				enable( gl.CULL_FACE );
	
				enable( gl.BLEND );
				setBlending( NormalBlending );
	
			}
	
			function initAttributes() {
	
				for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {
	
					newAttributes[ i ] = 0;
	
				}
	
			}
	
			function enableAttribute( attribute ) {
	
				newAttributes[ attribute ] = 1;
	
				if ( enabledAttributes[ attribute ] === 0 ) {
	
					gl.enableVertexAttribArray( attribute );
					enabledAttributes[ attribute ] = 1;
	
				}
	
				if ( attributeDivisors[ attribute ] !== 0 ) {
	
					var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
					extension.vertexAttribDivisorANGLE( attribute, 0 );
					attributeDivisors[ attribute ] = 0;
	
				}
	
			}
	
			function enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {
	
				newAttributes[ attribute ] = 1;
	
				if ( enabledAttributes[ attribute ] === 0 ) {
	
					gl.enableVertexAttribArray( attribute );
					enabledAttributes[ attribute ] = 1;
	
				}
	
				if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {
	
					extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
					attributeDivisors[ attribute ] = meshPerAttribute;
	
				}
	
			}
	
			function disableUnusedAttributes() {
	
				for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {
	
					if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {
	
						gl.disableVertexAttribArray( i );
						enabledAttributes[ i ] = 0;
	
					}
	
				}
	
			}
	
			function enable( id ) {
	
				if ( capabilities[ id ] !== true ) {
	
					gl.enable( id );
					capabilities[ id ] = true;
	
				}
	
			}
	
			function disable( id ) {
	
				if ( capabilities[ id ] !== false ) {
	
					gl.disable( id );
					capabilities[ id ] = false;
	
				}
	
			}
	
			function getCompressedTextureFormats() {
	
				if ( compressedTextureFormats === null ) {
	
					compressedTextureFormats = [];
	
					if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
					     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
					     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {
	
						var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );
	
						for ( var i = 0; i < formats.length; i ++ ) {
	
							compressedTextureFormats.push( formats[ i ] );
	
						}
	
					}
	
				}
	
				return compressedTextureFormats;
	
			}
	
			function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {
	
				if ( blending !== NoBlending ) {
	
					enable( gl.BLEND );
	
				} else {
	
					disable( gl.BLEND );
	
				}
	
				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {
	
					if ( blending === AdditiveBlending ) {
	
						if ( premultipliedAlpha ) {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );
	
						} else {
	
							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.SRC_ALPHA, gl.ONE );
	
						}
	
					} else if ( blending === SubtractiveBlending ) {
	
						if ( premultipliedAlpha ) {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );
	
						} else {
	
							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );
	
						}
	
					} else if ( blending === MultiplyBlending ) {
	
						if ( premultipliedAlpha ) {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );
	
						} else {
	
							gl.blendEquation( gl.FUNC_ADD );
							gl.blendFunc( gl.ZERO, gl.SRC_COLOR );
	
						}
	
					} else {
	
						if ( premultipliedAlpha ) {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
	
						} else {
	
							gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
							gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );
	
						}
	
					}
	
					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;
	
				}
	
				if ( blending === CustomBlending ) {
	
					blendEquationAlpha = blendEquationAlpha || blendEquation;
					blendSrcAlpha = blendSrcAlpha || blendSrc;
					blendDstAlpha = blendDstAlpha || blendDst;
	
					if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {
	
						gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );
	
						currentBlendEquation = blendEquation;
						currentBlendEquationAlpha = blendEquationAlpha;
	
					}
	
					if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {
	
						gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );
	
						currentBlendSrc = blendSrc;
						currentBlendDst = blendDst;
						currentBlendSrcAlpha = blendSrcAlpha;
						currentBlendDstAlpha = blendDstAlpha;
	
					}
	
				} else {
	
					currentBlendEquation = null;
					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendEquationAlpha = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;
	
				}
	
			}
	
			// TODO Deprecate
	
			function setColorWrite( colorWrite ) {
	
				colorBuffer.setMask( colorWrite );
	
			}
	
			function setDepthTest( depthTest ) {
	
				depthBuffer.setTest( depthTest );
	
			}
	
			function setDepthWrite( depthWrite ) {
	
				depthBuffer.setMask( depthWrite );
	
			}
	
			function setDepthFunc( depthFunc ) {
	
				depthBuffer.setFunc( depthFunc );
	
			}
	
			function setStencilTest( stencilTest ) {
	
				stencilBuffer.setTest( stencilTest );
	
			}
	
			function setStencilWrite( stencilWrite ) {
	
				stencilBuffer.setMask( stencilWrite );
	
			}
	
			function setStencilFunc( stencilFunc, stencilRef, stencilMask ) {
	
				stencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );
	
			}
	
			function setStencilOp( stencilFail, stencilZFail, stencilZPass ) {
	
				stencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );
	
			}
	
			//
	
			function setFlipSided( flipSided ) {
	
				if ( currentFlipSided !== flipSided ) {
	
					if ( flipSided ) {
	
						gl.frontFace( gl.CW );
	
					} else {
	
						gl.frontFace( gl.CCW );
	
					}
	
					currentFlipSided = flipSided;
	
				}
	
			}
	
			function setCullFace( cullFace ) {
	
				if ( cullFace !== CullFaceNone ) {
	
					enable( gl.CULL_FACE );
	
					if ( cullFace !== currentCullFace ) {
	
						if ( cullFace === CullFaceBack ) {
	
							gl.cullFace( gl.BACK );
	
						} else if ( cullFace === CullFaceFront ) {
	
							gl.cullFace( gl.FRONT );
	
						} else {
	
							gl.cullFace( gl.FRONT_AND_BACK );
	
						}
	
					}
	
				} else {
	
					disable( gl.CULL_FACE );
	
				}
	
				currentCullFace = cullFace;
	
			}
	
			function setLineWidth( width ) {
	
				if ( width !== currentLineWidth ) {
	
					if ( lineWidthAvailable ) gl.lineWidth( width );
	
					currentLineWidth = width;
	
				}
	
			}
	
			function setPolygonOffset( polygonOffset, factor, units ) {
	
				if ( polygonOffset ) {
	
					enable( gl.POLYGON_OFFSET_FILL );
	
					if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {
	
						gl.polygonOffset( factor, units );
	
						currentPolygonOffsetFactor = factor;
						currentPolygonOffsetUnits = units;
	
					}
	
				} else {
	
					disable( gl.POLYGON_OFFSET_FILL );
	
				}
	
			}
	
			function getScissorTest() {
	
				return currentScissorTest;
	
			}
	
			function setScissorTest( scissorTest ) {
	
				currentScissorTest = scissorTest;
	
				if ( scissorTest ) {
	
					enable( gl.SCISSOR_TEST );
	
				} else {
	
					disable( gl.SCISSOR_TEST );
	
				}
	
			}
	
			// texture
	
			function activeTexture( webglSlot ) {
	
				if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;
	
				if ( currentTextureSlot !== webglSlot ) {
	
					gl.activeTexture( webglSlot );
					currentTextureSlot = webglSlot;
	
				}
	
			}
	
			function bindTexture( webglType, webglTexture ) {
	
				if ( currentTextureSlot === null ) {
	
					activeTexture();
	
				}
	
				var boundTexture = currentBoundTextures[ currentTextureSlot ];
	
				if ( boundTexture === undefined ) {
	
					boundTexture = { type: undefined, texture: undefined };
					currentBoundTextures[ currentTextureSlot ] = boundTexture;
	
				}
	
				if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {
	
					gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );
	
					boundTexture.type = webglType;
					boundTexture.texture = webglTexture;
	
				}
	
			}
	
			function compressedTexImage2D() {
	
				try {
	
					gl.compressedTexImage2D.apply( gl, arguments );
	
				} catch ( error ) {
	
					console.error( error );
	
				}
	
			}
	
			function texImage2D() {
	
				try {
	
					gl.texImage2D.apply( gl, arguments );
	
				} catch ( error ) {
	
					console.error( error );
	
				}
	
			}
	
			//
	
			function scissor( scissor ) {
	
				if ( currentScissor.equals( scissor ) === false ) {
	
					gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
					currentScissor.copy( scissor );
	
				}
	
			}
	
			function viewport( viewport ) {
	
				if ( currentViewport.equals( viewport ) === false ) {
	
					gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
					currentViewport.copy( viewport );
	
				}
	
			}
	
			//
	
			function reset() {
	
				for ( var i = 0; i < enabledAttributes.length; i ++ ) {
	
					if ( enabledAttributes[ i ] === 1 ) {
	
						gl.disableVertexAttribArray( i );
						enabledAttributes[ i ] = 0;
	
					}
	
				}
	
				capabilities = {};
	
				compressedTextureFormats = null;
	
				currentTextureSlot = null;
				currentBoundTextures = {};
	
				currentBlending = null;
	
				currentFlipSided = null;
				currentCullFace = null;
	
				colorBuffer.reset();
				depthBuffer.reset();
				stencilBuffer.reset();
	
			}
	
			return {
	
				buffers: {
					color: colorBuffer,
					depth: depthBuffer,
					stencil: stencilBuffer
				},
	
				init: init,
				initAttributes: initAttributes,
				enableAttribute: enableAttribute,
				enableAttributeAndDivisor: enableAttributeAndDivisor,
				disableUnusedAttributes: disableUnusedAttributes,
				enable: enable,
				disable: disable,
				getCompressedTextureFormats: getCompressedTextureFormats,
	
				setBlending: setBlending,
	
				setColorWrite: setColorWrite,
				setDepthTest: setDepthTest,
				setDepthWrite: setDepthWrite,
				setDepthFunc: setDepthFunc,
				setStencilTest: setStencilTest,
				setStencilWrite: setStencilWrite,
				setStencilFunc: setStencilFunc,
				setStencilOp: setStencilOp,
	
				setFlipSided: setFlipSided,
				setCullFace: setCullFace,
	
				setLineWidth: setLineWidth,
				setPolygonOffset: setPolygonOffset,
	
				getScissorTest: getScissorTest,
				setScissorTest: setScissorTest,
	
				activeTexture: activeTexture,
				bindTexture: bindTexture,
				compressedTexImage2D: compressedTexImage2D,
				texImage2D: texImage2D,
	
				scissor: scissor,
				viewport: viewport,
	
				reset: reset
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLCapabilities( gl, extensions, parameters ) {
	
			var maxAnisotropy;
	
			function getMaxAnisotropy() {
	
				if ( maxAnisotropy !== undefined ) return maxAnisotropy;
	
				var extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
				if ( extension !== null ) {
	
					maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );
	
				} else {
	
					maxAnisotropy = 0;
	
				}
	
				return maxAnisotropy;
	
			}
	
			function getMaxPrecision( precision ) {
	
				if ( precision === 'highp' ) {
	
					if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
					     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {
	
						return 'highp';
	
					}
	
					precision = 'mediump';
	
				}
	
				if ( precision === 'mediump' ) {
	
					if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
					     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {
	
						return 'mediump';
	
					}
	
				}
	
				return 'lowp';
	
			}
	
			var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
			var maxPrecision = getMaxPrecision( precision );
	
			if ( maxPrecision !== precision ) {
	
				console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
				precision = maxPrecision;
	
			}
	
			var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );
	
			var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
			var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
			var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
			var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );
	
			var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
			var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
			var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
			var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );
	
			var vertexTextures = maxVertexTextures > 0;
			var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
			var floatVertexTextures = vertexTextures && floatFragmentTextures;
	
			return {
	
				getMaxAnisotropy: getMaxAnisotropy,
				getMaxPrecision: getMaxPrecision,
	
				precision: precision,
				logarithmicDepthBuffer: logarithmicDepthBuffer,
	
				maxTextures: maxTextures,
				maxVertexTextures: maxVertexTextures,
				maxTextureSize: maxTextureSize,
				maxCubemapSize: maxCubemapSize,
	
				maxAttributes: maxAttributes,
				maxVertexUniforms: maxVertexUniforms,
				maxVaryings: maxVaryings,
				maxFragmentUniforms: maxFragmentUniforms,
	
				vertexTextures: vertexTextures,
				floatFragmentTextures: floatFragmentTextures,
				floatVertexTextures: floatVertexTextures
	
			};
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function WebGLExtensions( gl ) {
	
			var extensions = {};
	
			return {
	
				get: function ( name ) {
	
					if ( extensions[ name ] !== undefined ) {
	
						return extensions[ name ];
	
					}
	
					var extension;
	
					switch ( name ) {
	
						case 'WEBGL_depth_texture':
							extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
							break;
	
						case 'EXT_texture_filter_anisotropic':
							extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
							break;
	
						case 'WEBGL_compressed_texture_s3tc':
							extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
							break;
	
						case 'WEBGL_compressed_texture_pvrtc':
							extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
							break;
	
						case 'WEBGL_compressed_texture_etc1':
							extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
							break;
	
						default:
							extension = gl.getExtension( name );
	
					}
	
					if ( extension === null ) {
	
						console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );
	
					}
	
					extensions[ name ] = extension;
	
					return extension;
	
				}
	
			};
	
		}
	
		/**
		 * @author tschw
		 */
	
		function WebGLClipping() {
	
			var scope = this,
	
				globalState = null,
				numGlobalPlanes = 0,
				localClippingEnabled = false,
				renderingShadows = false,
	
				plane = new Plane(),
				viewNormalMatrix = new Matrix3(),
	
				uniform = { value: null, needsUpdate: false };
	
			this.uniform = uniform;
			this.numPlanes = 0;
			this.numIntersection = 0;
	
			this.init = function( planes, enableLocalClipping, camera ) {
	
				var enabled =
					planes.length !== 0 ||
					enableLocalClipping ||
					// enable state of previous frame - the clipping code has to
					// run another frame in order to reset the state:
					numGlobalPlanes !== 0 ||
					localClippingEnabled;
	
				localClippingEnabled = enableLocalClipping;
	
				globalState = projectPlanes( planes, camera, 0 );
				numGlobalPlanes = planes.length;
	
				return enabled;
	
			};
	
			this.beginShadows = function() {
	
				renderingShadows = true;
				projectPlanes( null );
	
			};
	
			this.endShadows = function() {
	
				renderingShadows = false;
				resetGlobalState();
	
			};
	
			this.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {
	
				if ( ! localClippingEnabled ||
						planes === null || planes.length === 0 ||
						renderingShadows && ! clipShadows ) {
					// there's no local clipping
	
					if ( renderingShadows ) {
						// there's no global clipping
	
						projectPlanes( null );
	
					} else {
	
						resetGlobalState();
					}
	
				} else {
	
					var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
						lGlobal = nGlobal * 4,
	
						dstArray = cache.clippingState || null;
	
					uniform.value = dstArray; // ensure unique state
	
					dstArray = projectPlanes( planes, camera, lGlobal, fromCache );
	
					for ( var i = 0; i !== lGlobal; ++ i ) {
	
						dstArray[ i ] = globalState[ i ];
	
					}
	
					cache.clippingState = dstArray;
					this.numIntersection = clipIntersection ? this.numPlanes : 0;
					this.numPlanes += nGlobal;
	
				}
	
	
			};
	
			function resetGlobalState() {
	
				if ( uniform.value !== globalState ) {
	
					uniform.value = globalState;
					uniform.needsUpdate = numGlobalPlanes > 0;
	
				}
	
				scope.numPlanes = numGlobalPlanes;
				scope.numIntersection = 0;
	
			}
	
			function projectPlanes( planes, camera, dstOffset, skipTransform ) {
	
				var nPlanes = planes !== null ? planes.length : 0,
					dstArray = null;
	
				if ( nPlanes !== 0 ) {
	
					dstArray = uniform.value;
	
					if ( skipTransform !== true || dstArray === null ) {
	
						var flatSize = dstOffset + nPlanes * 4,
							viewMatrix = camera.matrixWorldInverse;
	
						viewNormalMatrix.getNormalMatrix( viewMatrix );
	
						if ( dstArray === null || dstArray.length < flatSize ) {
	
							dstArray = new Float32Array( flatSize );
	
						}
	
						for ( var i = 0, i4 = dstOffset;
											i !== nPlanes; ++ i, i4 += 4 ) {
	
							plane.copy( planes[ i ] ).
									applyMatrix4( viewMatrix, viewNormalMatrix );
	
							plane.normal.toArray( dstArray, i4 );
							dstArray[ i4 + 3 ] = plane.constant;
	
						}
	
					}
	
					uniform.value = dstArray;
					uniform.needsUpdate = true;
	
				}
	
				scope.numPlanes = nPlanes;
				
				return dstArray;
	
			}
	
		}
	
		/**
		 * @author supereggbert / http://www.paulbrunt.co.uk/
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 * @author szimek / https://github.com/szimek/
		 * @author tschw
		 */
	
		function WebGLRenderer( parameters ) {
	
			console.log( 'THREE.WebGLRenderer', REVISION );
	
			parameters = parameters || {};
	
			var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
				_context = parameters.context !== undefined ? parameters.context : null,
	
				_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
				_depth = parameters.depth !== undefined ? parameters.depth : true,
				_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
				_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
				_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
				_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;
	
			var lights = [];
	
			var opaqueObjects = [];
			var opaqueObjectsLastIndex = - 1;
			var transparentObjects = [];
			var transparentObjectsLastIndex = - 1;
	
			var morphInfluences = new Float32Array( 8 );
	
			var sprites = [];
			var lensFlares = [];
	
			// public properties
	
			this.domElement = _canvas;
			this.context = null;
	
			// clearing
	
			this.autoClear = true;
			this.autoClearColor = true;
			this.autoClearDepth = true;
			this.autoClearStencil = true;
	
			// scene graph
	
			this.sortObjects = true;
	
			// user-defined clipping
	
			this.clippingPlanes = [];
			this.localClippingEnabled = false;
	
			// physically based shading
	
			this.gammaFactor = 2.0;	// for backwards compatibility
			this.gammaInput = false;
			this.gammaOutput = false;
	
			// physical lights
	
			this.physicallyCorrectLights = false;
	
			// tone mapping
	
			this.toneMapping = LinearToneMapping;
			this.toneMappingExposure = 1.0;
			this.toneMappingWhitePoint = 1.0;
	
			// morphs
	
			this.maxMorphTargets = 8;
			this.maxMorphNormals = 4;
	
			// internal properties
	
			var _this = this,
	
				// internal state cache
	
				_currentProgram = null,
				_currentRenderTarget = null,
				_currentFramebuffer = null,
				_currentMaterialId = - 1,
				_currentGeometryProgram = '',
				_currentCamera = null,
	
				_currentScissor = new Vector4(),
				_currentScissorTest = null,
	
				_currentViewport = new Vector4(),
	
				//
	
				_usedTextureUnits = 0,
	
				//
	
				_clearColor = new Color( 0x000000 ),
				_clearAlpha = 0,
	
				_width = _canvas.width,
				_height = _canvas.height,
	
				_pixelRatio = 1,
	
				_scissor = new Vector4( 0, 0, _width, _height ),
				_scissorTest = false,
	
				_viewport = new Vector4( 0, 0, _width, _height ),
	
				// frustum
	
				_frustum = new Frustum(),
	
				// clipping
	
				_clipping = new WebGLClipping(),
				_clippingEnabled = false,
				_localClippingEnabled = false,
	
				_sphere = new Sphere(),
	
				// camera matrices cache
	
				_projScreenMatrix = new Matrix4(),
	
				_vector3 = new Vector3(),
				_matrix4 = new Matrix4(),
				_matrix42 = new Matrix4(),
	
				// light arrays cache
	
				_lights = {
	
					hash: '',
	
				ambient: [ 0, 0, 0 ],
				directional: [],
				directionalShadowMap: [],
				directionalShadowMatrix: [],
				spot: [],
				spotShadowMap: [],
				spotShadowMatrix: [],
				rectArea: [],
				point: [],
				pointShadowMap: [],
				pointShadowMatrix: [],
				hemi: [],
	
					shadows: []
	
				},
	
				// info
	
				_infoRender = {
	
					calls: 0,
					vertices: 0,
					faces: 0,
					points: 0
	
				};
	
			this.info = {
	
				render: _infoRender,
				memory: {
	
					geometries: 0,
					textures: 0
	
				},
				programs: null
	
			};
	
	
			// initialize
	
			var _gl;
	
			try {
	
				var attributes = {
					alpha: _alpha,
					depth: _depth,
					stencil: _stencil,
					antialias: _antialias,
					premultipliedAlpha: _premultipliedAlpha,
					preserveDrawingBuffer: _preserveDrawingBuffer
				};
	
				_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );
	
				if ( _gl === null ) {
	
					if ( _canvas.getContext( 'webgl' ) !== null ) {
	
						throw 'Error creating WebGL context with your selected attributes.';
	
					} else {
	
						throw 'Error creating WebGL context.';
	
					}
	
				}
	
				// Some experimental-webgl implementations do not have getShaderPrecisionFormat
	
				if ( _gl.getShaderPrecisionFormat === undefined ) {
	
					_gl.getShaderPrecisionFormat = function () {
	
						return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
	
					};
	
				}
	
				_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
	
			} catch ( error ) {
	
				console.error( 'THREE.WebGLRenderer: ' + error );
	
			}
	
			var extensions = new WebGLExtensions( _gl );
	
			extensions.get( 'WEBGL_depth_texture' );
			extensions.get( 'OES_texture_float' );
			extensions.get( 'OES_texture_float_linear' );
			extensions.get( 'OES_texture_half_float' );
			extensions.get( 'OES_texture_half_float_linear' );
			extensions.get( 'OES_standard_derivatives' );
			extensions.get( 'ANGLE_instanced_arrays' );
	
			if ( extensions.get( 'OES_element_index_uint' ) ) {
	
				BufferGeometry.MaxIndex = 4294967296;
	
			}
	
			var capabilities = new WebGLCapabilities( _gl, extensions, parameters );
	
			var state = new WebGLState( _gl, extensions, paramThreeToGL );
			var properties = new WebGLProperties();
			var textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );
			var objects = new WebGLObjects( _gl, properties, this.info );
			var programCache = new WebGLPrograms( this, capabilities );
			var lightCache = new WebGLLights();
	
			this.info.programs = programCache.programs;
	
			var bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
			var indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );
	
			//
	
			var backgroundPlaneCamera, backgroundPlaneMesh;
			var backgroundBoxCamera, backgroundBoxMesh;
	
			//
	
			function getTargetPixelRatio() {
	
				return _currentRenderTarget === null ? _pixelRatio : 1;
	
			}
	
			function setDefaultGLState() {
	
				state.init();
	
				state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
				state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );
	
				state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );
	
			}
	
			function resetGLState() {
	
				_currentProgram = null;
				_currentCamera = null;
	
				_currentGeometryProgram = '';
				_currentMaterialId = - 1;
	
				state.reset();
	
			}
	
			setDefaultGLState();
	
			this.context = _gl;
			this.capabilities = capabilities;
			this.extensions = extensions;
			this.properties = properties;
			this.state = state;
	
			// shadow map
	
			var shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );
	
			this.shadowMap = shadowMap;
	
	
			// Plugins
	
			var spritePlugin = new SpritePlugin( this, sprites );
			var lensFlarePlugin = new LensFlarePlugin( this, lensFlares );
	
			// API
	
			this.getContext = function () {
	
				return _gl;
	
			};
	
			this.getContextAttributes = function () {
	
				return _gl.getContextAttributes();
	
			};
	
			this.forceContextLoss = function () {
	
				extensions.get( 'WEBGL_lose_context' ).loseContext();
	
			};
	
			this.getMaxAnisotropy = function () {
	
				return capabilities.getMaxAnisotropy();
	
			};
	
			this.getPrecision = function () {
	
				return capabilities.precision;
	
			};
	
			this.getPixelRatio = function () {
	
				return _pixelRatio;
	
			};
	
			this.setPixelRatio = function ( value ) {
	
				if ( value === undefined ) return;
	
				_pixelRatio = value;
	
				this.setSize( _viewport.z, _viewport.w, false );
	
			};
	
			this.getSize = function () {
	
				return {
					width: _width,
					height: _height
				};
	
			};
	
			this.setSize = function ( width, height, updateStyle ) {
	
				_width = width;
				_height = height;
	
				_canvas.width = width * _pixelRatio;
				_canvas.height = height * _pixelRatio;
	
				if ( updateStyle !== false ) {
	
					_canvas.style.width = width + 'px';
					_canvas.style.height = height + 'px';
	
				}
	
				this.setViewport( 0, 0, width, height );
	
			};
	
			this.setViewport = function ( x, y, width, height ) {
	
				state.viewport( _viewport.set( x, y, width, height ) );
	
			};
	
			this.setScissor = function ( x, y, width, height ) {
	
				state.scissor( _scissor.set( x, y, width, height ) );
	
			};
	
			this.setScissorTest = function ( boolean ) {
	
				state.setScissorTest( _scissorTest = boolean );
	
			};
	
			// Clearing
	
			this.getClearColor = function () {
	
				return _clearColor;
	
			};
	
			this.setClearColor = function ( color, alpha ) {
	
				_clearColor.set( color );
	
				_clearAlpha = alpha !== undefined ? alpha : 1;
	
				state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );
	
			};
	
			this.getClearAlpha = function () {
	
				return _clearAlpha;
	
			};
	
			this.setClearAlpha = function ( alpha ) {
	
				_clearAlpha = alpha;
	
				state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );
	
			};
	
			this.clear = function ( color, depth, stencil ) {
	
				var bits = 0;
	
				if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
				if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
				if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;
	
				_gl.clear( bits );
	
			};
	
			this.clearColor = function () {
	
				this.clear( true, false, false );
	
			};
	
			this.clearDepth = function () {
	
				this.clear( false, true, false );
	
			};
	
			this.clearStencil = function () {
	
				this.clear( false, false, true );
	
			};
	
			this.clearTarget = function ( renderTarget, color, depth, stencil ) {
	
				this.setRenderTarget( renderTarget );
				this.clear( color, depth, stencil );
	
			};
	
			// Reset
	
			this.resetGLState = resetGLState;
	
			this.dispose = function() {
	
				transparentObjects = [];
				transparentObjectsLastIndex = -1;
				opaqueObjects = [];
				opaqueObjectsLastIndex = -1;
	
				_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
	
			};
	
			// Events
	
			function onContextLost( event ) {
	
				event.preventDefault();
	
				resetGLState();
				setDefaultGLState();
	
				properties.clear();
	
			}
	
			function onMaterialDispose( event ) {
	
				var material = event.target;
	
				material.removeEventListener( 'dispose', onMaterialDispose );
	
				deallocateMaterial( material );
	
			}
	
			// Buffer deallocation
	
			function deallocateMaterial( material ) {
	
				releaseMaterialProgramReference( material );
	
				properties.delete( material );
	
			}
	
	
			function releaseMaterialProgramReference( material ) {
	
				var programInfo = properties.get( material ).program;
	
				material.program = undefined;
	
				if ( programInfo !== undefined ) {
	
					programCache.releaseProgram( programInfo );
	
				}
	
			}
	
			// Buffer rendering
	
			this.renderBufferImmediate = function ( object, program, material ) {
	
				state.initAttributes();
	
				var buffers = properties.get( object );
	
				if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
				if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
				if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
				if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();
	
				var attributes = program.getAttributes();
	
				if ( object.hasPositions ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );
	
					state.enableAttribute( attributes.position );
					_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
				if ( object.hasNormals ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );
	
					if ( ! material.isMeshPhongMaterial &&
						! material.isMeshStandardMaterial &&
						! material.isMeshNormalMaterial &&
						material.shading === FlatShading ) {
	
						for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {
	
							var array = object.normalArray;
	
							var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
							var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
							var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;
	
							array[ i + 0 ] = nx;
							array[ i + 1 ] = ny;
							array[ i + 2 ] = nz;
	
							array[ i + 3 ] = nx;
							array[ i + 4 ] = ny;
							array[ i + 5 ] = nz;
	
							array[ i + 6 ] = nx;
							array[ i + 7 ] = ny;
							array[ i + 8 ] = nz;
	
						}
	
					}
	
					_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );
	
					state.enableAttribute( attributes.normal );
	
					_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
				if ( object.hasUvs && material.map ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );
	
					state.enableAttribute( attributes.uv );
	
					_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );
	
				}
	
				if ( object.hasColors && material.vertexColors !== NoColors ) {
	
					_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
					_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );
	
					state.enableAttribute( attributes.color );
	
					_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );
	
				}
	
				state.disableUnusedAttributes();
	
				_gl.drawArrays( _gl.TRIANGLES, 0, object.count );
	
				object.count = 0;
	
			};
	
			this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {
	
				setMaterial( material );
	
				var program = setProgram( camera, fog, material, object );
	
				var updateBuffers = false;
				var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;
	
				if ( geometryProgram !== _currentGeometryProgram ) {
	
					_currentGeometryProgram = geometryProgram;
					updateBuffers = true;
	
				}
	
				// morph targets
	
				var morphTargetInfluences = object.morphTargetInfluences;
	
				if ( morphTargetInfluences !== undefined ) {
	
					var activeInfluences = [];
	
					for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {
	
						var influence = morphTargetInfluences[ i ];
						activeInfluences.push( [ influence, i ] );
	
					}
	
					activeInfluences.sort( absNumericalSort );
	
					if ( activeInfluences.length > 8 ) {
	
						activeInfluences.length = 8;
	
					}
	
					var morphAttributes = geometry.morphAttributes;
	
					for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {
	
						var influence = activeInfluences[ i ];
						morphInfluences[ i ] = influence[ 0 ];
	
						if ( influence[ 0 ] !== 0 ) {
	
							var index = influence[ 1 ];
	
							if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
							if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );
	
						} else {
	
							if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
							if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );
	
						}
	
					}
	
					for ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {
	
						morphInfluences[ i ] = 0.0;
	
					}
	
					program.getUniforms().setValue(
						_gl, 'morphTargetInfluences', morphInfluences );
	
					updateBuffers = true;
	
				}
	
				//
	
				var index = geometry.index;
				var position = geometry.attributes.position;
				var rangeFactor = 1;
	
				if ( material.wireframe === true ) {
	
					index = objects.getWireframeAttribute( geometry );
					rangeFactor = 2;
	
				}
	
				var renderer;
	
				if ( index !== null ) {
	
					renderer = indexedBufferRenderer;
					renderer.setIndex( index );
	
				} else {
	
					renderer = bufferRenderer;
	
				}
	
				if ( updateBuffers ) {
	
					setupVertexAttributes( material, program, geometry );
	
					if ( index !== null ) {
	
						_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );
	
					}
	
				}
	
				//
	
				var dataCount = 0;
	
				if ( index !== null ) {
	
					dataCount = index.count;
	
				} else if ( position !== undefined ) {
	
					dataCount = position.count;
	
				}
	
				var rangeStart = geometry.drawRange.start * rangeFactor;
				var rangeCount = geometry.drawRange.count * rangeFactor;
	
				var groupStart = group !== null ? group.start * rangeFactor : 0;
				var groupCount = group !== null ? group.count * rangeFactor : Infinity;
	
				var drawStart = Math.max( rangeStart, groupStart );
				var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;
	
				var drawCount = Math.max( 0, drawEnd - drawStart + 1 );
	
				if ( drawCount === 0 ) return;
	
				//
	
				if ( object.isMesh ) {
	
					if ( material.wireframe === true ) {
	
						state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
						renderer.setMode( _gl.LINES );
	
					} else {
	
						switch ( object.drawMode ) {
	
							case TrianglesDrawMode:
								renderer.setMode( _gl.TRIANGLES );
								break;
	
							case TriangleStripDrawMode:
								renderer.setMode( _gl.TRIANGLE_STRIP );
								break;
	
							case TriangleFanDrawMode:
								renderer.setMode( _gl.TRIANGLE_FAN );
								break;
	
						}
	
					}
	
	
				} else if ( object.isLine ) {
	
					var lineWidth = material.linewidth;
	
					if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material
	
					state.setLineWidth( lineWidth * getTargetPixelRatio() );
	
					if ( object.isLineSegments ) {
	
						renderer.setMode( _gl.LINES );
	
					} else {
	
						renderer.setMode( _gl.LINE_STRIP );
	
					}
	
				} else if ( object.isPoints ) {
	
					renderer.setMode( _gl.POINTS );
	
				}
	
				if ( geometry && geometry.isInstancedBufferGeometry ) {
	
					if ( geometry.maxInstancedCount > 0 ) {
	
						renderer.renderInstances( geometry, drawStart, drawCount );
	
					}
	
				} else {
	
					renderer.render( drawStart, drawCount );
	
				}
	
			};
	
			function setupVertexAttributes( material, program, geometry, startIndex ) {
	
				var extension;
	
				if ( geometry && geometry.isInstancedBufferGeometry ) {
	
					extension = extensions.get( 'ANGLE_instanced_arrays' );
	
					if ( extension === null ) {
	
						console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
						return;
	
					}
	
				}
	
				if ( startIndex === undefined ) startIndex = 0;
	
				state.initAttributes();
	
				var geometryAttributes = geometry.attributes;
	
				var programAttributes = program.getAttributes();
	
				var materialDefaultAttributeValues = material.defaultAttributeValues;
	
				for ( var name in programAttributes ) {
	
					var programAttribute = programAttributes[ name ];
	
					if ( programAttribute >= 0 ) {
	
						var geometryAttribute = geometryAttributes[ name ];
	
						if ( geometryAttribute !== undefined ) {
	
							var normalized = geometryAttribute.normalized;
							var size = geometryAttribute.itemSize;
	
							var attributeProperties = objects.getAttributeProperties( geometryAttribute );
	
							var buffer = attributeProperties.__webglBuffer;
							var type = attributeProperties.type;
							var bytesPerElement = attributeProperties.bytesPerElement;
	
							if ( geometryAttribute.isInterleavedBufferAttribute ) {
	
								var data = geometryAttribute.data;
								var stride = data.stride;
								var offset = geometryAttribute.offset;
	
								if ( data && data.isInstancedInterleavedBuffer ) {
	
									state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );
	
									if ( geometry.maxInstancedCount === undefined ) {
	
										geometry.maxInstancedCount = data.meshPerAttribute * data.count;
	
									}
	
								} else {
	
									state.enableAttribute( programAttribute );
	
								}
	
								_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
								_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );
	
							} else {
	
								if ( geometryAttribute.isInstancedBufferAttribute ) {
	
									state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );
	
									if ( geometry.maxInstancedCount === undefined ) {
	
										geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
	
									}
	
								} else {
	
									state.enableAttribute( programAttribute );
	
								}
	
								_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
								_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );
	
							}
	
						} else if ( materialDefaultAttributeValues !== undefined ) {
	
							var value = materialDefaultAttributeValues[ name ];
	
							if ( value !== undefined ) {
	
								switch ( value.length ) {
	
									case 2:
										_gl.vertexAttrib2fv( programAttribute, value );
										break;
	
									case 3:
										_gl.vertexAttrib3fv( programAttribute, value );
										break;
	
									case 4:
										_gl.vertexAttrib4fv( programAttribute, value );
										break;
	
									default:
										_gl.vertexAttrib1fv( programAttribute, value );
	
								}
	
							}
	
						}
	
					}
	
				}
	
				state.disableUnusedAttributes();
	
			}
	
			// Sorting
	
			function absNumericalSort( a, b ) {
	
				return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );
	
			}
	
			function painterSortStable( a, b ) {
	
				if ( a.object.renderOrder !== b.object.renderOrder ) {
	
					return a.object.renderOrder - b.object.renderOrder;
	
				} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {
	
					return a.material.program.id - b.material.program.id;
	
				} else if ( a.material.id !== b.material.id ) {
	
					return a.material.id - b.material.id;
	
				} else if ( a.z !== b.z ) {
	
					return a.z - b.z;
	
				} else {
	
					return a.id - b.id;
	
				}
	
			}
	
			function reversePainterSortStable( a, b ) {
	
				if ( a.object.renderOrder !== b.object.renderOrder ) {
	
					return a.object.renderOrder - b.object.renderOrder;
	
				} if ( a.z !== b.z ) {
	
					return b.z - a.z;
	
				} else {
	
					return a.id - b.id;
	
				}
	
			}
	
			// Rendering
	
			this.render = function ( scene, camera, renderTarget, forceClear ) {
	
				if ( camera !== undefined && camera.isCamera !== true ) {
	
					console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
					return;
	
				}
	
				// reset caching for this frame
	
				_currentGeometryProgram = '';
				_currentMaterialId = - 1;
				_currentCamera = null;
	
				// update scene graph
	
				if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
	
				// update camera matrices and frustum
	
				if ( camera.parent === null ) camera.updateMatrixWorld();
	
				camera.matrixWorldInverse.getInverse( camera.matrixWorld );
	
				_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );
	
				lights.length = 0;
	
				opaqueObjectsLastIndex = - 1;
				transparentObjectsLastIndex = - 1;
	
				sprites.length = 0;
				lensFlares.length = 0;
	
				_localClippingEnabled = this.localClippingEnabled;
				_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );
	
				projectObject( scene, camera );
	
				opaqueObjects.length = opaqueObjectsLastIndex + 1;
				transparentObjects.length = transparentObjectsLastIndex + 1;
	
				if ( _this.sortObjects === true ) {
	
					opaqueObjects.sort( painterSortStable );
					transparentObjects.sort( reversePainterSortStable );
	
				}
	
				//
	
				if ( _clippingEnabled ) _clipping.beginShadows();
	
				setupShadows( lights );
	
				shadowMap.render( scene, camera );
	
				setupLights( lights, camera );
	
				if ( _clippingEnabled ) _clipping.endShadows();
	
				//
	
				_infoRender.calls = 0;
				_infoRender.vertices = 0;
				_infoRender.faces = 0;
				_infoRender.points = 0;
	
				if ( renderTarget === undefined ) {
	
					renderTarget = null;
	
				}
	
				this.setRenderTarget( renderTarget );
	
				//
	
				var background = scene.background;
	
				if ( background === null ) {
	
					state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );
	
				} else if ( background && background.isColor ) {
	
					state.buffers.color.setClear( background.r, background.g, background.b, 1, _premultipliedAlpha );
					forceClear = true;
	
				}
	
				if ( this.autoClear || forceClear ) {
	
					this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );
	
				}
	
				if ( background && background.isCubeTexture ) {
	
					if ( backgroundBoxCamera === undefined ) {
	
						backgroundBoxCamera = new PerspectiveCamera();
	
						backgroundBoxMesh = new Mesh(
							new BoxBufferGeometry( 5, 5, 5 ),
							new ShaderMaterial( {
								uniforms: ShaderLib.cube.uniforms,
								vertexShader: ShaderLib.cube.vertexShader,
								fragmentShader: ShaderLib.cube.fragmentShader,
								side: BackSide,
								depthTest: false,
								depthWrite: false,
								fog: false
							} )
						);
	
					}
	
					backgroundBoxCamera.projectionMatrix.copy( camera.projectionMatrix );
	
					backgroundBoxCamera.matrixWorld.extractRotation( camera.matrixWorld );
					backgroundBoxCamera.matrixWorldInverse.getInverse( backgroundBoxCamera.matrixWorld );
	
	
					backgroundBoxMesh.material.uniforms[ "tCube" ].value = background;
					backgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundBoxCamera.matrixWorldInverse, backgroundBoxMesh.matrixWorld );
	
					objects.update( backgroundBoxMesh );
	
					_this.renderBufferDirect( backgroundBoxCamera, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );
	
				} else if ( background && background.isTexture ) {
	
					if ( backgroundPlaneCamera === undefined ) {
	
						backgroundPlaneCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	
						backgroundPlaneMesh = new Mesh(
							new PlaneBufferGeometry( 2, 2 ),
							new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
						);
	
					}
	
					backgroundPlaneMesh.material.map = background;
	
					objects.update( backgroundPlaneMesh );
	
					_this.renderBufferDirect( backgroundPlaneCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );
	
				}
	
				//
	
				if ( scene.overrideMaterial ) {
	
					var overrideMaterial = scene.overrideMaterial;
	
					renderObjects( opaqueObjects, scene, camera, overrideMaterial );
					renderObjects( transparentObjects, scene, camera, overrideMaterial );
	
				} else {
	
					// opaque pass (front-to-back order)
	
					state.setBlending( NoBlending );
					renderObjects( opaqueObjects, scene, camera );
	
					// transparent pass (back-to-front order)
	
					renderObjects( transparentObjects, scene, camera );
	
				}
	
				// custom render plugins (post pass)
	
				spritePlugin.render( scene, camera );
				lensFlarePlugin.render( scene, camera, _currentViewport );
	
				// Generate mipmap if we're using any kind of mipmap filtering
	
				if ( renderTarget ) {
	
					textures.updateRenderTargetMipmap( renderTarget );
	
				}
	
				// Ensure depth buffer writing is enabled so it can be cleared on next render
	
				state.setDepthTest( true );
				state.setDepthWrite( true );
				state.setColorWrite( true );
	
				// _gl.finish();
	
			};
	
			function pushRenderItem( object, geometry, material, z, group ) {
	
				var array, index;
	
				// allocate the next position in the appropriate array
	
				if ( material.transparent ) {
	
					array = transparentObjects;
					index = ++ transparentObjectsLastIndex;
	
				} else {
	
					array = opaqueObjects;
					index = ++ opaqueObjectsLastIndex;
	
				}
	
				// recycle existing render item or grow the array
	
				var renderItem = array[ index ];
	
				if ( renderItem !== undefined ) {
	
					renderItem.id = object.id;
					renderItem.object = object;
					renderItem.geometry = geometry;
					renderItem.material = material;
					renderItem.z = _vector3.z;
					renderItem.group = group;
	
				} else {
	
					renderItem = {
						id: object.id,
						object: object,
						geometry: geometry,
						material: material,
						z: _vector3.z,
						group: group
					};
	
					// assert( index === array.length );
					array.push( renderItem );
	
				}
	
			}
	
			// TODO Duplicated code (Frustum)
	
			function isObjectViewable( object ) {
	
				var geometry = object.geometry;
	
				if ( geometry.boundingSphere === null )
					geometry.computeBoundingSphere();
	
				_sphere.copy( geometry.boundingSphere ).
				applyMatrix4( object.matrixWorld );
	
				return isSphereViewable( _sphere );
	
			}
	
			function isSpriteViewable( sprite ) {
	
				_sphere.center.set( 0, 0, 0 );
				_sphere.radius = 0.7071067811865476;
				_sphere.applyMatrix4( sprite.matrixWorld );
	
				return isSphereViewable( _sphere );
	
			}
	
			function isSphereViewable( sphere ) {
	
				if ( ! _frustum.intersectsSphere( sphere ) ) return false;
	
				var numPlanes = _clipping.numPlanes;
	
				if ( numPlanes === 0 ) return true;
	
				var planes = _this.clippingPlanes,
	
					center = sphere.center,
					negRad = - sphere.radius,
					i = 0;
	
				do {
	
					// out when deeper than radius in the negative halfspace
					if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;
	
				} while ( ++ i !== numPlanes );
	
				return true;
	
			}
	
			function projectObject( object, camera ) {
	
				if ( object.visible === false ) return;
	
				var visible = ( object.layers.mask & camera.layers.mask ) !== 0;
	
				if ( visible ) {
	
					if ( object.isLight ) {
	
						lights.push( object );
	
					} else if ( object.isSprite ) {
	
						if ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {
	
							sprites.push( object );
	
						}
	
					} else if ( object.isLensFlare ) {
	
						lensFlares.push( object );
	
					} else if ( object.isImmediateRenderObject ) {
	
						if ( _this.sortObjects === true ) {
	
							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyMatrix4( _projScreenMatrix );
	
						}
	
						pushRenderItem( object, null, object.material, _vector3.z, null );
	
					} else if ( object.isMesh || object.isLine || object.isPoints ) {
	
						if ( object.isSkinnedMesh ) {
	
							object.skeleton.update();
	
						}
	
						if ( object.frustumCulled === false || isObjectViewable( object ) === true ) {
	
							var material = object.material;
	
							if ( material.visible === true ) {
	
								if ( _this.sortObjects === true ) {
	
									_vector3.setFromMatrixPosition( object.matrixWorld );
									_vector3.applyMatrix4( _projScreenMatrix );
	
								}
	
								var geometry = objects.update( object );
	
								if ( material.isMultiMaterial ) {
	
									var groups = geometry.groups;
									var materials = material.materials;
	
									for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
										var group = groups[ i ];
										var groupMaterial = materials[ group.materialIndex ];
	
										if ( groupMaterial.visible === true ) {
	
											pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );
	
										}
	
									}
	
								} else {
	
									pushRenderItem( object, geometry, material, _vector3.z, null );
	
								}
	
							}
	
						}
	
					}
	
				}
	
				var children = object.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					projectObject( children[ i ], camera );
	
				}
	
			}
	
			function renderObjects( renderList, scene, camera, overrideMaterial ) {
	
				for ( var i = 0, l = renderList.length; i < l; i ++ ) {
	
					var renderItem = renderList[ i ];
	
					var object = renderItem.object;
					var geometry = renderItem.geometry;
					var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
					var group = renderItem.group;
	
					object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
					object.normalMatrix.getNormalMatrix( object.modelViewMatrix );
	
					object.onBeforeRender( _this, scene, camera, geometry, material, group );
	
					if ( object.isImmediateRenderObject ) {
	
						setMaterial( material );
	
						var program = setProgram( camera, scene.fog, material, object );
	
						_currentGeometryProgram = '';
	
						object.render( function ( object ) {
	
							_this.renderBufferImmediate( object, program, material );
	
						} );
	
					} else {
	
						_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );
	
					}
	
					object.onAfterRender( _this, scene, camera, geometry, material, group );
	
	
				}
	
			}
	
			function initMaterial( material, fog, object ) {
	
				var materialProperties = properties.get( material );
	
				var parameters = programCache.getParameters(
					material, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );
	
				var code = programCache.getProgramCode( material, parameters );
	
				var program = materialProperties.program;
				var programChange = true;
	
				if ( program === undefined ) {
	
					// new material
					material.addEventListener( 'dispose', onMaterialDispose );
	
				} else if ( program.code !== code ) {
	
					// changed glsl or parameters
					releaseMaterialProgramReference( material );
	
				} else if ( parameters.shaderID !== undefined ) {
	
					// same glsl and uniform list
					return;
	
				} else {
	
					// only rebuild uniform list
					programChange = false;
	
				}
	
				if ( programChange ) {
	
					if ( parameters.shaderID ) {
	
						var shader = ShaderLib[ parameters.shaderID ];
	
						materialProperties.__webglShader = {
							name: material.type,
							uniforms: UniformsUtils.clone( shader.uniforms ),
							vertexShader: shader.vertexShader,
							fragmentShader: shader.fragmentShader
						};
	
					} else {
	
						materialProperties.__webglShader = {
							name: material.type,
							uniforms: material.uniforms,
							vertexShader: material.vertexShader,
							fragmentShader: material.fragmentShader
						};
	
					}
	
					material.__webglShader = materialProperties.__webglShader;
	
					program = programCache.acquireProgram( material, parameters, code );
	
					materialProperties.program = program;
					material.program = program;
	
				}
	
				var attributes = program.getAttributes();
	
				if ( material.morphTargets ) {
	
					material.numSupportedMorphTargets = 0;
	
					for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {
	
						if ( attributes[ 'morphTarget' + i ] >= 0 ) {
	
							material.numSupportedMorphTargets ++;
	
						}
	
					}
	
				}
	
				if ( material.morphNormals ) {
	
					material.numSupportedMorphNormals = 0;
	
					for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {
	
						if ( attributes[ 'morphNormal' + i ] >= 0 ) {
	
							material.numSupportedMorphNormals ++;
	
						}
	
					}
	
				}
	
				var uniforms = materialProperties.__webglShader.uniforms;
	
				if ( ! material.isShaderMaterial &&
					! material.isRawShaderMaterial ||
					material.clipping === true ) {
	
					materialProperties.numClippingPlanes = _clipping.numPlanes;
					materialProperties.numIntersection = _clipping.numIntersection;
					uniforms.clippingPlanes = _clipping.uniform;
	
				}
	
				materialProperties.fog = fog;
	
				// store the light setup it was created for
	
				materialProperties.lightsHash = _lights.hash;
	
				if ( material.lights ) {
	
					// wire up the material to this renderer's lighting state
	
					uniforms.ambientLightColor.value = _lights.ambient;
					uniforms.directionalLights.value = _lights.directional;
					uniforms.spotLights.value = _lights.spot;
					uniforms.rectAreaLights.value = _lights.rectArea;
					uniforms.pointLights.value = _lights.point;
					uniforms.hemisphereLights.value = _lights.hemi;
	
					uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
					uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
					uniforms.spotShadowMap.value = _lights.spotShadowMap;
					uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
					uniforms.pointShadowMap.value = _lights.pointShadowMap;
					uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
					// TODO (abelnation): add area lights shadow info to uniforms
	
				}
	
				var progUniforms = materialProperties.program.getUniforms(),
					uniformsList =
						WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );
	
				materialProperties.uniformsList = uniformsList;
	
			}
	
			function setMaterial( material ) {
	
				material.side === DoubleSide
					? state.disable( _gl.CULL_FACE )
					: state.enable( _gl.CULL_FACE );
	
				state.setFlipSided( material.side === BackSide );
	
				material.transparent === true
					? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
					: state.setBlending( NoBlending );
	
				state.setDepthFunc( material.depthFunc );
				state.setDepthTest( material.depthTest );
				state.setDepthWrite( material.depthWrite );
				state.setColorWrite( material.colorWrite );
				state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
	
			}
	
			function setProgram( camera, fog, material, object ) {
	
				_usedTextureUnits = 0;
	
				var materialProperties = properties.get( material );
	
				if ( _clippingEnabled ) {
	
					if ( _localClippingEnabled || camera !== _currentCamera ) {
	
						var useCache =
							camera === _currentCamera &&
							material.id === _currentMaterialId;
	
						// we might want to call this function with some ClippingGroup
						// object instead of the material, once it becomes feasible
						// (#8465, #8379)
						_clipping.setState(
							material.clippingPlanes, material.clipIntersection, material.clipShadows,
							camera, materialProperties, useCache );
	
					}
	
				}
	
				if ( material.needsUpdate === false ) {
	
					if ( materialProperties.program === undefined ) {
	
						material.needsUpdate = true;
	
					} else if ( material.fog && materialProperties.fog !== fog ) {
	
						material.needsUpdate = true;
	
					} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {
	
						material.needsUpdate = true;
	
					} else if ( materialProperties.numClippingPlanes !== undefined &&
						( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
						materialProperties.numIntersection  !== _clipping.numIntersection ) ) {
	
						material.needsUpdate = true;
	
					}
	
				}
	
				if ( material.needsUpdate ) {
	
					initMaterial( material, fog, object );
					material.needsUpdate = false;
	
				}
	
				var refreshProgram = false;
				var refreshMaterial = false;
				var refreshLights = false;
	
				var program = materialProperties.program,
					p_uniforms = program.getUniforms(),
					m_uniforms = materialProperties.__webglShader.uniforms;
	
				if ( program.id !== _currentProgram ) {
	
					_gl.useProgram( program.program );
					_currentProgram = program.id;
	
					refreshProgram = true;
					refreshMaterial = true;
					refreshLights = true;
	
				}
	
				if ( material.id !== _currentMaterialId ) {
	
					_currentMaterialId = material.id;
	
					refreshMaterial = true;
	
				}
	
				if ( refreshProgram || camera !== _currentCamera ) {
	
					p_uniforms.set( _gl, camera, 'projectionMatrix' );
	
					if ( capabilities.logarithmicDepthBuffer ) {
	
						p_uniforms.setValue( _gl, 'logDepthBufFC',
							2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );
	
					}
	
	
					if ( camera !== _currentCamera ) {
	
						_currentCamera = camera;
	
						// lighting uniforms depend on the camera so enforce an update
						// now, in case this material supports lights - or later, when
						// the next material that does gets activated:
	
						refreshMaterial = true;		// set to true on material change
						refreshLights = true;		// remains set until update done
	
					}
	
					// load material specific uniforms
					// (shader material also gets them for the sake of genericity)
	
					if ( material.isShaderMaterial ||
						material.isMeshPhongMaterial ||
						material.isMeshStandardMaterial ||
						material.envMap ) {
	
						var uCamPos = p_uniforms.map.cameraPosition;
	
						if ( uCamPos !== undefined ) {
	
							uCamPos.setValue( _gl,
								_vector3.setFromMatrixPosition( camera.matrixWorld ) );
	
						}
	
					}
	
					if ( material.isMeshPhongMaterial ||
						material.isMeshLambertMaterial ||
						material.isMeshBasicMaterial ||
						material.isMeshStandardMaterial ||
						material.isShaderMaterial ||
						material.skinning ) {
	
						p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );
	
					}
	
					p_uniforms.set( _gl, _this, 'toneMappingExposure' );
					p_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );
	
				}
	
				// skinning uniforms must be set even if material didn't change
				// auto-setting of texture unit for bone texture must go before other textures
				// not sure why, but otherwise weird things happen
	
				if ( material.skinning ) {
	
					p_uniforms.setOptional( _gl, object, 'bindMatrix' );
					p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );
	
					var skeleton = object.skeleton;
	
					if ( skeleton ) {
	
						if ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {
	
							p_uniforms.set( _gl, skeleton, 'boneTexture' );
							p_uniforms.set( _gl, skeleton, 'boneTextureWidth' );
							p_uniforms.set( _gl, skeleton, 'boneTextureHeight' );
	
						} else {
	
							p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );
	
						}
	
					}
	
				}
	
				if ( refreshMaterial ) {
	
					if ( material.lights ) {
	
						// the current material requires lighting info
	
						// note: all lighting uniforms are always set correctly
						// they simply reference the renderer's state for their
						// values
						//
						// use the current material's .needsUpdate flags to set
						// the GL state when required
	
						markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );
	
					}
	
					// refresh uniforms common to several materials
	
					if ( fog && material.fog ) {
	
						refreshUniformsFog( m_uniforms, fog );
	
					}
	
					if ( material.isMeshBasicMaterial ||
						material.isMeshLambertMaterial ||
						material.isMeshPhongMaterial ||
						material.isMeshStandardMaterial ||
						material.isMeshNormalMaterial ||
						material.isMeshDepthMaterial ) {
	
						refreshUniformsCommon( m_uniforms, material );
	
					}
	
					// refresh single material specific uniforms
	
					if ( material.isLineBasicMaterial ) {
	
						refreshUniformsLine( m_uniforms, material );
	
					} else if ( material.isLineDashedMaterial ) {
	
						refreshUniformsLine( m_uniforms, material );
						refreshUniformsDash( m_uniforms, material );
	
					} else if ( material.isPointsMaterial ) {
	
						refreshUniformsPoints( m_uniforms, material );
	
					} else if ( material.isMeshLambertMaterial ) {
	
						refreshUniformsLambert( m_uniforms, material );
	
					} else if ( material.isMeshToonMaterial ) {
	
						refreshUniformsToon( m_uniforms, material );
	
					} else if ( material.isMeshPhongMaterial ) {
	
						refreshUniformsPhong( m_uniforms, material );
	
					} else if ( material.isMeshPhysicalMaterial ) {
	
						refreshUniformsPhysical( m_uniforms, material );
	
					} else if ( material.isMeshStandardMaterial ) {
	
						refreshUniformsStandard( m_uniforms, material );
	
					} else if ( material.isMeshDepthMaterial ) {
	
						if ( material.displacementMap ) {
	
							m_uniforms.displacementMap.value = material.displacementMap;
							m_uniforms.displacementScale.value = material.displacementScale;
							m_uniforms.displacementBias.value = material.displacementBias;
	
						}
	
					} else if ( material.isMeshNormalMaterial ) {
	
						refreshUniformsNormal( m_uniforms, material );
	
					}
	
					// RectAreaLight Texture
					// TODO (mrdoob): Find a nicer implementation
	
					if ( m_uniforms.ltcMat !== undefined ) m_uniforms.ltcMat.value = THREE.UniformsLib.LTC_MAT_TEXTURE;
					if ( m_uniforms.ltcMag !== undefined ) m_uniforms.ltcMag.value = THREE.UniformsLib.LTC_MAG_TEXTURE;
	
					WebGLUniforms.upload(
						_gl, materialProperties.uniformsList, m_uniforms, _this );
	
				}
	
	
				// common matrices
	
				p_uniforms.set( _gl, object, 'modelViewMatrix' );
				p_uniforms.set( _gl, object, 'normalMatrix' );
				p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );
	
				return program;
	
			}
	
			// Uniforms (refresh uniforms objects)
	
			function refreshUniformsCommon( uniforms, material ) {
	
				uniforms.opacity.value = material.opacity;
	
				uniforms.diffuse.value = material.color;
	
				if ( material.emissive ) {
	
					uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );
	
				}
	
				uniforms.map.value = material.map;
				uniforms.specularMap.value = material.specularMap;
				uniforms.alphaMap.value = material.alphaMap;
	
				if ( material.lightMap ) {
	
					uniforms.lightMap.value = material.lightMap;
					uniforms.lightMapIntensity.value = material.lightMapIntensity;
	
				}
	
				if ( material.aoMap ) {
	
					uniforms.aoMap.value = material.aoMap;
					uniforms.aoMapIntensity.value = material.aoMapIntensity;
	
				}
	
				// uv repeat and offset setting priorities
				// 1. color map
				// 2. specular map
				// 3. normal map
				// 4. bump map
				// 5. alpha map
				// 6. emissive map
	
				var uvScaleMap;
	
				if ( material.map ) {
	
					uvScaleMap = material.map;
	
				} else if ( material.specularMap ) {
	
					uvScaleMap = material.specularMap;
	
				} else if ( material.displacementMap ) {
	
					uvScaleMap = material.displacementMap;
	
				} else if ( material.normalMap ) {
	
					uvScaleMap = material.normalMap;
	
				} else if ( material.bumpMap ) {
	
					uvScaleMap = material.bumpMap;
	
				} else if ( material.roughnessMap ) {
	
					uvScaleMap = material.roughnessMap;
	
				} else if ( material.metalnessMap ) {
	
					uvScaleMap = material.metalnessMap;
	
				} else if ( material.alphaMap ) {
	
					uvScaleMap = material.alphaMap;
	
				} else if ( material.emissiveMap ) {
	
					uvScaleMap = material.emissiveMap;
	
				}
	
				if ( uvScaleMap !== undefined ) {
	
					// backwards compatibility
					if ( uvScaleMap.isWebGLRenderTarget ) {
	
						uvScaleMap = uvScaleMap.texture;
	
					}
	
					var offset = uvScaleMap.offset;
					var repeat = uvScaleMap.repeat;
	
					uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
				}
	
				uniforms.envMap.value = material.envMap;
	
				// don't flip CubeTexture envMaps, flip everything else:
				//  WebGLRenderTargetCube will be flipped for backwards compatibility
				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
				uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;
	
				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;
	
			}
	
			function refreshUniformsLine( uniforms, material ) {
	
				uniforms.diffuse.value = material.color;
				uniforms.opacity.value = material.opacity;
	
			}
	
			function refreshUniformsDash( uniforms, material ) {
	
				uniforms.dashSize.value = material.dashSize;
				uniforms.totalSize.value = material.dashSize + material.gapSize;
				uniforms.scale.value = material.scale;
	
			}
	
			function refreshUniformsPoints( uniforms, material ) {
	
				uniforms.diffuse.value = material.color;
				uniforms.opacity.value = material.opacity;
				uniforms.size.value = material.size * _pixelRatio;
				uniforms.scale.value = _height * 0.5;
	
				uniforms.map.value = material.map;
	
				if ( material.map !== null ) {
	
					var offset = material.map.offset;
					var repeat = material.map.repeat;
	
					uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );
	
				}
	
			}
	
			function refreshUniformsFog( uniforms, fog ) {
	
				uniforms.fogColor.value = fog.color;
	
				if ( fog.isFog ) {
	
					uniforms.fogNear.value = fog.near;
					uniforms.fogFar.value = fog.far;
	
				} else if ( fog.isFogExp2 ) {
	
					uniforms.fogDensity.value = fog.density;
	
				}
	
			}
	
			function refreshUniformsLambert( uniforms, material ) {
	
				if ( material.emissiveMap ) {
	
					uniforms.emissiveMap.value = material.emissiveMap;
	
				}
	
			}
	
			function refreshUniformsPhong( uniforms, material ) {
	
				uniforms.specular.value = material.specular;
				uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )
	
				if ( material.emissiveMap ) {
	
					uniforms.emissiveMap.value = material.emissiveMap;
	
				}
	
				if ( material.bumpMap ) {
	
					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;
	
				}
	
				if ( material.normalMap ) {
	
					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );
	
				}
	
				if ( material.displacementMap ) {
	
					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;
	
				}
	
			}
	
			function refreshUniformsToon( uniforms, material ) {
	
				refreshUniformsPhong( uniforms, material );
	
				if ( material.gradientMap ) {
	
					uniforms.gradientMap.value = material.gradientMap;
	
				}
	
			}
	
			function refreshUniformsStandard( uniforms, material ) {
	
				uniforms.roughness.value = material.roughness;
				uniforms.metalness.value = material.metalness;
	
				if ( material.roughnessMap ) {
	
					uniforms.roughnessMap.value = material.roughnessMap;
	
				}
	
				if ( material.metalnessMap ) {
	
					uniforms.metalnessMap.value = material.metalnessMap;
	
				}
	
				if ( material.emissiveMap ) {
	
					uniforms.emissiveMap.value = material.emissiveMap;
	
				}
	
				if ( material.bumpMap ) {
	
					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;
	
				}
	
				if ( material.normalMap ) {
	
					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );
	
				}
	
				if ( material.displacementMap ) {
	
					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;
	
				}
	
				if ( material.envMap ) {
	
					//uniforms.envMap.value = material.envMap; // part of uniforms common
					uniforms.envMapIntensity.value = material.envMapIntensity;
	
				}
	
			}
	
			function refreshUniformsPhysical( uniforms, material ) {
	
				uniforms.clearCoat.value = material.clearCoat;
				uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
	
				refreshUniformsStandard( uniforms, material );
	
			}
	
			function refreshUniformsNormal( uniforms, material ) {
	
				if ( material.bumpMap ) {
	
					uniforms.bumpMap.value = material.bumpMap;
					uniforms.bumpScale.value = material.bumpScale;
	
				}
	
				if ( material.normalMap ) {
	
					uniforms.normalMap.value = material.normalMap;
					uniforms.normalScale.value.copy( material.normalScale );
	
				}
	
				if ( material.displacementMap ) {
	
					uniforms.displacementMap.value = material.displacementMap;
					uniforms.displacementScale.value = material.displacementScale;
					uniforms.displacementBias.value = material.displacementBias;
	
				}
	
			}
	
			// If uniforms are marked as clean, they don't need to be loaded to the GPU.
	
			function markUniformsLightsNeedsUpdate( uniforms, value ) {
	
				uniforms.ambientLightColor.needsUpdate = value;
	
				uniforms.directionalLights.needsUpdate = value;
				uniforms.pointLights.needsUpdate = value;
				uniforms.spotLights.needsUpdate = value;
				uniforms.rectAreaLights.needsUpdate = value;
				uniforms.hemisphereLights.needsUpdate = value;
	
			}
	
			// Lighting
	
			function setupShadows( lights ) {
	
				var lightShadowsLength = 0;
	
				for ( var i = 0, l = lights.length; i < l; i ++ ) {
	
					var light = lights[ i ];
	
					if ( light.castShadow ) {
	
						_lights.shadows[ lightShadowsLength ++ ] = light;
	
					}
	
				}
	
				_lights.shadows.length = lightShadowsLength;
	
			}
	
			function setupLights( lights, camera ) {
	
				var l, ll, light,
					r = 0, g = 0, b = 0,
					color,
					intensity,
					distance,
					shadowMap,
	
					viewMatrix = camera.matrixWorldInverse,
	
				directionalLength = 0,
				pointLength = 0,
				spotLength = 0,
				rectAreaLength = 0,
				hemiLength = 0;
	
				for ( l = 0, ll = lights.length; l < ll; l ++ ) {
	
					light = lights[ l ];
	
					color = light.color;
					intensity = light.intensity;
					distance = light.distance;
	
					shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;
	
					if ( light.isAmbientLight ) {
	
						r += color.r * intensity;
						g += color.g * intensity;
						b += color.b * intensity;
	
					} else if ( light.isDirectionalLight ) {
	
						var uniforms = lightCache.get( light );
	
						uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						_vector3.setFromMatrixPosition( light.target.matrixWorld );
						uniforms.direction.sub( _vector3 );
						uniforms.direction.transformDirection( viewMatrix );
	
						uniforms.shadow = light.castShadow;
	
						if ( light.castShadow ) {
	
							uniforms.shadowBias = light.shadow.bias;
							uniforms.shadowRadius = light.shadow.radius;
							uniforms.shadowMapSize = light.shadow.mapSize;
	
						}
	
						_lights.directionalShadowMap[ directionalLength ] = shadowMap;
						_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
						_lights.directional[ directionalLength ++ ] = uniforms;
	
					} else if ( light.isSpotLight ) {
	
						var uniforms = lightCache.get( light );
	
						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );
	
						uniforms.color.copy( color ).multiplyScalar( intensity );
						uniforms.distance = distance;
	
						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						_vector3.setFromMatrixPosition( light.target.matrixWorld );
						uniforms.direction.sub( _vector3 );
						uniforms.direction.transformDirection( viewMatrix );
	
						uniforms.coneCos = Math.cos( light.angle );
						uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
						uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;
	
						uniforms.shadow = light.castShadow;
	
						if ( light.castShadow ) {
	
							uniforms.shadowBias = light.shadow.bias;
							uniforms.shadowRadius = light.shadow.radius;
							uniforms.shadowMapSize = light.shadow.mapSize;
	
						}
	
						_lights.spotShadowMap[ spotLength ] = shadowMap;
						_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
						_lights.spot[ spotLength ++ ] = uniforms;
	
					} else if ( light.isRectAreaLight ) {
	
						var uniforms = lightCache.get( light );
	
						// (a) intensity controls irradiance of entire light
						uniforms.color
							.copy( color )
							.multiplyScalar( intensity / ( light.width * light.height ) );
	
						// (b) intensity controls the radiance per light area
						// uniforms.color.copy( color ).multiplyScalar( intensity );
	
						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );
	
						// extract local rotation of light to derive width/height half vectors
						_matrix42.identity();
						_matrix4.copy( light.matrixWorld );
						_matrix4.premultiply( viewMatrix );
						_matrix42.extractRotation( _matrix4 );
	
						uniforms.halfWidth.set( light.width * 0.5,                0.0, 0.0 );
						uniforms.halfHeight.set(              0.0, light.height * 0.5, 0.0 );
	
						uniforms.halfWidth.applyMatrix4( _matrix42 );
						uniforms.halfHeight.applyMatrix4( _matrix42 );
	
						// TODO (abelnation): RectAreaLight distance?
						// uniforms.distance = distance;
	
						_lights.rectArea[ rectAreaLength ++ ] = uniforms;
	
					} else if ( light.isPointLight ) {
	
						var uniforms = lightCache.get( light );
	
						uniforms.position.setFromMatrixPosition( light.matrixWorld );
						uniforms.position.applyMatrix4( viewMatrix );
	
						uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
						uniforms.distance = light.distance;
						uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;
	
						uniforms.shadow = light.castShadow;
	
						if ( light.castShadow ) {
	
							uniforms.shadowBias = light.shadow.bias;
							uniforms.shadowRadius = light.shadow.radius;
							uniforms.shadowMapSize = light.shadow.mapSize;
	
						}
	
						_lights.pointShadowMap[ pointLength ] = shadowMap;
	
						if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {
	
							_lights.pointShadowMatrix[ pointLength ] = new Matrix4();
	
						}
	
						// for point lights we set the shadow matrix to be a translation-only matrix
						// equal to inverse of the light's position
						_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
						_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );
	
						_lights.point[ pointLength ++ ] = uniforms;
	
					} else if ( light.isHemisphereLight ) {
	
						var uniforms = lightCache.get( light );
	
						uniforms.direction.setFromMatrixPosition( light.matrixWorld );
						uniforms.direction.transformDirection( viewMatrix );
						uniforms.direction.normalize();
	
						uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
						uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );
	
						_lights.hemi[ hemiLength ++ ] = uniforms;
	
					}
	
				}
	
				_lights.ambient[ 0 ] = r;
				_lights.ambient[ 1 ] = g;
				_lights.ambient[ 2 ] = b;
	
				_lights.directional.length = directionalLength;
				_lights.spot.length = spotLength;
				_lights.rectArea.length = rectAreaLength;
				_lights.point.length = pointLength;
				_lights.hemi.length = hemiLength;
	
				// TODO (sam-g-steel) why aren't we using join
				_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + _lights.shadows.length;
	
			}
	
			// GL state setting
	
			this.setFaceCulling = function ( cullFace, frontFaceDirection ) {
	
				state.setCullFace( cullFace );
				state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );
	
			};
	
			// Textures
	
			function allocTextureUnit() {
	
				var textureUnit = _usedTextureUnits;
	
				if ( textureUnit >= capabilities.maxTextures ) {
	
					console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );
	
				}
	
				_usedTextureUnits += 1;
	
				return textureUnit;
	
			}
	
			this.allocTextureUnit = allocTextureUnit;
	
			// this.setTexture2D = setTexture2D;
			this.setTexture2D = ( function() {
	
				var warned = false;
	
				// backwards compatibility: peel texture.texture
				return function setTexture2D( texture, slot ) {
	
					if ( texture && texture.isWebGLRenderTarget ) {
	
						if ( ! warned ) {
	
							console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
							warned = true;
	
						}
	
						texture = texture.texture;
	
					}
	
					textures.setTexture2D( texture, slot );
	
				};
	
			}() );
	
			this.setTexture = ( function() {
	
				var warned = false;
	
				return function setTexture( texture, slot ) {
	
					if ( ! warned ) {
	
						console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
						warned = true;
	
					}
	
					textures.setTexture2D( texture, slot );
	
				};
	
			}() );
	
			this.setTextureCube = ( function() {
	
				var warned = false;
	
				return function setTextureCube( texture, slot ) {
	
					// backwards compatibility: peel texture.texture
					if ( texture && texture.isWebGLRenderTargetCube ) {
	
						if ( ! warned ) {
	
							console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
							warned = true;
	
						}
	
						texture = texture.texture;
	
					}
	
					// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
					// TODO: unify these code paths
					if ( ( texture && texture.isCubeTexture ) ||
						( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {
	
						// CompressedTexture can have Array in image :/
	
						// this function alone should take care of cube textures
						textures.setTextureCube( texture, slot );
	
					} else {
	
						// assumed: texture property of THREE.WebGLRenderTargetCube
	
						textures.setTextureCubeDynamic( texture, slot );
	
					}
	
				};
	
			}() );
	
			this.getCurrentRenderTarget = function() {
	
				return _currentRenderTarget;
	
			};
	
			this.setRenderTarget = function ( renderTarget ) {
	
				_currentRenderTarget = renderTarget;
	
				if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {
	
					textures.setupRenderTarget( renderTarget );
	
				}
	
				var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
				var framebuffer;
	
				if ( renderTarget ) {
	
					var renderTargetProperties = properties.get( renderTarget );
	
					if ( isCube ) {
	
						framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];
	
					} else {
	
						framebuffer = renderTargetProperties.__webglFramebuffer;
	
					}
	
					_currentScissor.copy( renderTarget.scissor );
					_currentScissorTest = renderTarget.scissorTest;
	
					_currentViewport.copy( renderTarget.viewport );
	
				} else {
	
					framebuffer = null;
	
					_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
					_currentScissorTest = _scissorTest;
	
					_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
	
				}
	
				if ( _currentFramebuffer !== framebuffer ) {
	
					_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
					_currentFramebuffer = framebuffer;
	
				}
	
				state.scissor( _currentScissor );
				state.setScissorTest( _currentScissorTest );
	
				state.viewport( _currentViewport );
	
				if ( isCube ) {
	
					var textureProperties = properties.get( renderTarget.texture );
					_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );
	
				}
	
			};
	
			this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {
	
				if ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {
	
					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
					return;
	
				}
	
				var framebuffer = properties.get( renderTarget ).__webglFramebuffer;
	
				if ( framebuffer ) {
	
					var restore = false;
	
					if ( framebuffer !== _currentFramebuffer ) {
	
						_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
	
						restore = true;
	
					}
	
					try {
	
						var texture = renderTarget.texture;
						var textureFormat = texture.format;
						var textureType = texture.type;
	
						if ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {
	
							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
							return;
	
						}
	
						if ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
							! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
							! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {
	
							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
							return;
	
						}
	
						if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {
	
							// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
	
							if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {
	
								_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );
	
							}
	
						} else {
	
							console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );
	
						}
	
					} finally {
	
						if ( restore ) {
	
							_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );
	
						}
	
					}
	
				}
	
			};
	
			// Map three.js constants to WebGL constants
	
			function paramThreeToGL( p ) {
	
				var extension;
	
				if ( p === RepeatWrapping ) return _gl.REPEAT;
				if ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
				if ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;
	
				if ( p === NearestFilter ) return _gl.NEAREST;
				if ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
				if ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;
	
				if ( p === LinearFilter ) return _gl.LINEAR;
				if ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
				if ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;
	
				if ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;
				if ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
				if ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
				if ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;
	
				if ( p === ByteType ) return _gl.BYTE;
				if ( p === ShortType ) return _gl.SHORT;
				if ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;
				if ( p === IntType ) return _gl.INT;
				if ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;
				if ( p === FloatType ) return _gl.FLOAT;
	
				if ( p === HalfFloatType ) {
	
					extension = extensions.get( 'OES_texture_half_float' );
	
					if ( extension !== null ) return extension.HALF_FLOAT_OES;
	
				}
	
				if ( p === AlphaFormat ) return _gl.ALPHA;
				if ( p === RGBFormat ) return _gl.RGB;
				if ( p === RGBAFormat ) return _gl.RGBA;
				if ( p === LuminanceFormat ) return _gl.LUMINANCE;
				if ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
				if ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;
				if ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;
	
				if ( p === AddEquation ) return _gl.FUNC_ADD;
				if ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;
				if ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;
	
				if ( p === ZeroFactor ) return _gl.ZERO;
				if ( p === OneFactor ) return _gl.ONE;
				if ( p === SrcColorFactor ) return _gl.SRC_COLOR;
				if ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
				if ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;
				if ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
				if ( p === DstAlphaFactor ) return _gl.DST_ALPHA;
				if ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;
	
				if ( p === DstColorFactor ) return _gl.DST_COLOR;
				if ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
				if ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;
	
				if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
					p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {
	
					extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );
	
					if ( extension !== null ) {
	
						if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
						if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
						if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
	
					}
	
				}
	
				if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
					p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {
	
					extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	
					if ( extension !== null ) {
	
						if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
						if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
						if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
						if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
	
					}
	
				}
	
				if ( p === RGB_ETC1_Format ) {
	
					extension = extensions.get( 'WEBGL_compressed_texture_etc1' );
	
					if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;
	
				}
	
				if ( p === MinEquation || p === MaxEquation ) {
	
					extension = extensions.get( 'EXT_blend_minmax' );
	
					if ( extension !== null ) {
	
						if ( p === MinEquation ) return extension.MIN_EXT;
						if ( p === MaxEquation ) return extension.MAX_EXT;
	
					}
	
				}
	
				if ( p === UnsignedInt248Type ) {
	
					extension = extensions.get( 'WEBGL_depth_texture' );
	
					if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;
	
				}
	
				return 0;
	
			}
	
		}
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function FogExp2 ( color, density ) {
	
			this.name = '';
	
			this.color = new Color( color );
			this.density = ( density !== undefined ) ? density : 0.00025;
	
		}
	
		FogExp2.prototype.isFogExp2 = true;
	
		FogExp2.prototype.clone = function () {
	
			return new FogExp2( this.color.getHex(), this.density );
	
		};
	
		FogExp2.prototype.toJSON = function ( meta ) {
	
			return {
				type: 'FogExp2',
				color: this.color.getHex(),
				density: this.density
			};
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Fog ( color, near, far ) {
	
			this.name = '';
	
			this.color = new Color( color );
	
			this.near = ( near !== undefined ) ? near : 1;
			this.far = ( far !== undefined ) ? far : 1000;
	
		}
	
		Fog.prototype.isFog = true;
	
		Fog.prototype.clone = function () {
	
			return new Fog( this.color.getHex(), this.near, this.far );
	
		};
	
		Fog.prototype.toJSON = function ( meta ) {
	
			return {
				type: 'Fog',
				color: this.color.getHex(),
				near: this.near,
				far: this.far
			};
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Scene () {
	
			Object3D.call( this );
	
			this.type = 'Scene';
	
			this.background = null;
			this.fog = null;
			this.overrideMaterial = null;
	
			this.autoUpdate = true; // checked by the renderer
	
		}
	
		Scene.prototype = Object.create( Object3D.prototype );
	
		Scene.prototype.constructor = Scene;
	
		Scene.prototype.copy = function ( source, recursive ) {
	
			Object3D.prototype.copy.call( this, source, recursive );
	
			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();
			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();
	
			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
	
			return this;
	
		};
	
		Scene.prototype.toJSON = function ( meta ) {
	
			var data = Object3D.prototype.toJSON.call( this, meta );
	
			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();
	
			return data;
	
		};
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function LensFlare( texture, size, distance, blending, color ) {
	
			Object3D.call( this );
	
			this.lensFlares = [];
	
			this.positionScreen = new Vector3();
			this.customUpdateCallback = undefined;
	
			if ( texture !== undefined ) {
	
				this.add( texture, size, distance, blending, color );
	
			}
	
		}
	
		LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: LensFlare,
	
			isLensFlare: true,
	
			copy: function ( source ) {
	
				Object3D.prototype.copy.call( this, source );
	
				this.positionScreen.copy( source.positionScreen );
				this.customUpdateCallback = source.customUpdateCallback;
	
				for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {
	
					this.lensFlares.push( source.lensFlares[ i ] );
	
				}
	
				return this;
	
			},
	
			add: function ( texture, size, distance, blending, color, opacity ) {
	
				if ( size === undefined ) size = - 1;
				if ( distance === undefined ) distance = 0;
				if ( opacity === undefined ) opacity = 1;
				if ( color === undefined ) color = new Color( 0xffffff );
				if ( blending === undefined ) blending = NormalBlending;
	
				distance = Math.min( distance, Math.max( 0, distance ) );
	
				this.lensFlares.push( {
					texture: texture,	// THREE.Texture
					size: size, 		// size in pixels (-1 = use texture.width)
					distance: distance, 	// distance (0-1) from light source (0=at light source)
					x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
					scale: 1, 		// scale
					rotation: 0, 		// rotation
					opacity: opacity,	// opacity
					color: color,		// color
					blending: blending	// blending
				} );
	
			},
	
			/*
			 * Update lens flares update positions on all flares based on the screen position
			 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
			 */
	
			updateLensFlares: function () {
	
				var f, fl = this.lensFlares.length;
				var flare;
				var vecX = - this.positionScreen.x * 2;
				var vecY = - this.positionScreen.y * 2;
	
				for ( f = 0; f < fl; f ++ ) {
	
					flare = this.lensFlares[ f ];
	
					flare.x = this.positionScreen.x + vecX * flare.distance;
					flare.y = this.positionScreen.y + vecY * flare.distance;
	
					flare.wantedRotation = flare.x * Math.PI * 0.25;
					flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;
	
				}
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *	uvOffset: new THREE.Vector2(),
		 *	uvScale: new THREE.Vector2()
		 * }
		 */
	
		function SpriteMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'SpriteMaterial';
	
			this.color = new Color( 0xffffff );
			this.map = null;
	
			this.rotation = 0;
	
			this.fog = false;
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		SpriteMaterial.prototype = Object.create( Material.prototype );
		SpriteMaterial.prototype.constructor = SpriteMaterial;
	
		SpriteMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
			this.map = source.map;
	
			this.rotation = source.rotation;
	
			return this;
	
		};
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Sprite( material ) {
	
			Object3D.call( this );
	
			this.type = 'Sprite';
	
			this.material = ( material !== undefined ) ? material : new SpriteMaterial();
	
		}
	
		Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Sprite,
	
			isSprite: true,
	
			raycast: ( function () {
	
				var matrixPosition = new Vector3();
	
				return function raycast( raycaster, intersects ) {
	
					matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
					var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
					var guessSizeSq = this.scale.x * this.scale.y / 4;
	
					if ( distanceSq > guessSizeSq ) {
	
						return;
	
					}
	
					intersects.push( {
	
						distance: Math.sqrt( distanceSq ),
						point: this.position,
						face: null,
						object: this
	
					} );
	
				};
	
			}() ),
	
			clone: function () {
	
				return new this.constructor( this.material ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function LOD() {
	
			Object3D.call( this );
	
			this.type = 'LOD';
	
			Object.defineProperties( this, {
				levels: {
					enumerable: true,
					value: []
				}
			} );
	
		}
	
	
		LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: LOD,
	
			copy: function ( source ) {
	
				Object3D.prototype.copy.call( this, source, false );
	
				var levels = source.levels;
	
				for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
					var level = levels[ i ];
	
					this.addLevel( level.object.clone(), level.distance );
	
				}
	
				return this;
	
			},
	
			addLevel: function ( object, distance ) {
	
				if ( distance === undefined ) distance = 0;
	
				distance = Math.abs( distance );
	
				var levels = this.levels;
	
				for ( var l = 0; l < levels.length; l ++ ) {
	
					if ( distance < levels[ l ].distance ) {
	
						break;
	
					}
	
				}
	
				levels.splice( l, 0, { distance: distance, object: object } );
	
				this.add( object );
	
			},
	
			getObjectForDistance: function ( distance ) {
	
				var levels = this.levels;
	
				for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
					if ( distance < levels[ i ].distance ) {
	
						break;
	
					}
	
				}
	
				return levels[ i - 1 ].object;
	
			},
	
			raycast: ( function () {
	
				var matrixPosition = new Vector3();
	
				return function raycast( raycaster, intersects ) {
	
					matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
					var distance = raycaster.ray.origin.distanceTo( matrixPosition );
	
					this.getObjectForDistance( distance ).raycast( raycaster, intersects );
	
				};
	
			}() ),
	
			update: function () {
	
				var v1 = new Vector3();
				var v2 = new Vector3();
	
				return function update( camera ) {
	
					var levels = this.levels;
	
					if ( levels.length > 1 ) {
	
						v1.setFromMatrixPosition( camera.matrixWorld );
						v2.setFromMatrixPosition( this.matrixWorld );
	
						var distance = v1.distanceTo( v2 );
	
						levels[ 0 ].object.visible = true;
	
						for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
							if ( distance >= levels[ i ].distance ) {
	
								levels[ i - 1 ].object.visible = false;
								levels[ i ].object.visible = true;
	
							} else {
	
								break;
	
							}
	
						}
	
						for ( ; i < l; i ++ ) {
	
							levels[ i ].object.visible = false;
	
						}
	
					}
	
				};
	
			}(),
	
			toJSON: function ( meta ) {
	
				var data = Object3D.prototype.toJSON.call( this, meta );
	
				data.object.levels = [];
	
				var levels = this.levels;
	
				for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
					var level = levels[ i ];
	
					data.object.levels.push( {
						object: level.object.uuid,
						distance: level.distance
					} );
	
				}
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author michael guerrero / http://realitymeltdown.com
		 * @author ikerr / http://verold.com
		 */
	
		function Skeleton( bones, boneInverses, useVertexTexture ) {
	
			this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;
	
			this.identityMatrix = new Matrix4();
	
			// copy the bone array
	
			bones = bones || [];
	
			this.bones = bones.slice( 0 );
	
			// create a bone texture or an array of floats
	
			if ( this.useVertexTexture ) {
	
				// layout (1 matrix = 4 pixels)
				//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
				//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
				//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
				//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
				//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
	
	
				var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
				size = _Math.nextPowerOfTwo( Math.ceil( size ) );
				size = Math.max( size, 4 );
	
				this.boneTextureWidth = size;
				this.boneTextureHeight = size;
	
				this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
				this.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );
	
			} else {
	
				this.boneMatrices = new Float32Array( 16 * this.bones.length );
	
			}
	
			// use the supplied bone inverses or calculate the inverses
	
			if ( boneInverses === undefined ) {
	
				this.calculateInverses();
	
			} else {
	
				if ( this.bones.length === boneInverses.length ) {
	
					this.boneInverses = boneInverses.slice( 0 );
	
				} else {
	
					console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );
	
					this.boneInverses = [];
	
					for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
						this.boneInverses.push( new Matrix4() );
	
					}
	
				}
	
			}
	
		}
	
		Object.assign( Skeleton.prototype, {
	
			calculateInverses: function () {
	
				this.boneInverses = [];
	
				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
					var inverse = new Matrix4();
	
					if ( this.bones[ b ] ) {
	
						inverse.getInverse( this.bones[ b ].matrixWorld );
	
					}
	
					this.boneInverses.push( inverse );
	
				}
	
			},
	
			pose: function () {
	
				var bone;
	
				// recover the bind-time world matrices
	
				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
					bone = this.bones[ b ];
	
					if ( bone ) {
	
						bone.matrixWorld.getInverse( this.boneInverses[ b ] );
	
					}
	
				}
	
				// compute the local matrices, positions, rotations and scales
	
				for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
					bone = this.bones[ b ];
	
					if ( bone ) {
	
						if ( bone.parent && bone.parent.isBone ) {
	
							bone.matrix.getInverse( bone.parent.matrixWorld );
							bone.matrix.multiply( bone.matrixWorld );
	
						} else {
	
							bone.matrix.copy( bone.matrixWorld );
	
						}
	
						bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );
	
					}
	
				}
	
			},
	
			update: ( function () {
	
				var offsetMatrix = new Matrix4();
	
				return function update() {
	
					// flatten bone matrices to array
	
					for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {
	
						// compute the offset between the current and the original transform
	
						var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;
	
						offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
						offsetMatrix.toArray( this.boneMatrices, b * 16 );
	
					}
	
					if ( this.useVertexTexture ) {
	
						this.boneTexture.needsUpdate = true;
	
					}
	
				};
	
			} )(),
	
			clone: function () {
	
				return new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );
	
			}
	
		} );
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author ikerr / http://verold.com
		 */
	
		function Bone() {
	
			Object3D.call( this );
	
			this.type = 'Bone';
	
		}
	
		Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Bone,
	
			isBone: true
	
		} );
	
		/**
		 * @author mikael emtinger / http://gomo.se/
		 * @author alteredq / http://alteredqualia.com/
		 * @author ikerr / http://verold.com
		 */
	
		function SkinnedMesh( geometry, material, useVertexTexture ) {
	
			Mesh.call( this, geometry, material );
	
			this.type = 'SkinnedMesh';
	
			this.bindMode = "attached";
			this.bindMatrix = new Matrix4();
			this.bindMatrixInverse = new Matrix4();
	
			// init bones
	
			// TODO: remove bone creation as there is no reason (other than
			// convenience) for THREE.SkinnedMesh to do this.
	
			var bones = [];
	
			if ( this.geometry && this.geometry.bones !== undefined ) {
	
				var bone, gbone;
	
				for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {
	
					gbone = this.geometry.bones[ b ];
	
					bone = new Bone();
					bones.push( bone );
	
					bone.name = gbone.name;
					bone.position.fromArray( gbone.pos );
					bone.quaternion.fromArray( gbone.rotq );
					if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );
	
				}
	
				for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {
	
					gbone = this.geometry.bones[ b ];
	
					if ( gbone.parent !== - 1 && gbone.parent !== null &&
							bones[ gbone.parent ] !== undefined ) {
	
						bones[ gbone.parent ].add( bones[ b ] );
	
					} else {
	
						this.add( bones[ b ] );
	
					}
	
				}
	
			}
	
			this.normalizeSkinWeights();
	
			this.updateMatrixWorld( true );
			this.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );
	
		}
	
	
		SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {
	
			constructor: SkinnedMesh,
	
			isSkinnedMesh: true,
	
			bind: function( skeleton, bindMatrix ) {
	
				this.skeleton = skeleton;
	
				if ( bindMatrix === undefined ) {
	
					this.updateMatrixWorld( true );
	
					this.skeleton.calculateInverses();
	
					bindMatrix = this.matrixWorld;
	
				}
	
				this.bindMatrix.copy( bindMatrix );
				this.bindMatrixInverse.getInverse( bindMatrix );
	
			},
	
			pose: function () {
	
				this.skeleton.pose();
	
			},
	
			normalizeSkinWeights: function () {
	
				if ( this.geometry && this.geometry.isGeometry ) {
	
					for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {
	
						var sw = this.geometry.skinWeights[ i ];
	
						var scale = 1.0 / sw.lengthManhattan();
	
						if ( scale !== Infinity ) {
	
							sw.multiplyScalar( scale );
	
						} else {
	
							sw.set( 1, 0, 0, 0 ); // do something reasonable
	
						}
	
					}
	
				} else if ( this.geometry && this.geometry.isBufferGeometry ) {
	
					var vec = new Vector4();
	
					var skinWeight = this.geometry.attributes.skinWeight;
	
					for ( var i = 0; i < skinWeight.count; i ++ ) {
	
						vec.x = skinWeight.getX( i );
						vec.y = skinWeight.getY( i );
						vec.z = skinWeight.getZ( i );
						vec.w = skinWeight.getW( i );
	
						var scale = 1.0 / vec.lengthManhattan();
	
						if ( scale !== Infinity ) {
	
							vec.multiplyScalar( scale );
	
						} else {
	
							vec.set( 1, 0, 0, 0 ); // do something reasonable
	
						}
	
						skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );
	
					}
	
				}
	
			},
	
			updateMatrixWorld: function( force ) {
	
				Mesh.prototype.updateMatrixWorld.call( this, true );
	
				if ( this.bindMode === "attached" ) {
	
					this.bindMatrixInverse.getInverse( this.matrixWorld );
	
				} else if ( this.bindMode === "detached" ) {
	
					this.bindMatrixInverse.getInverse( this.bindMatrix );
	
				} else {
	
					console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );
	
				}
	
			},
	
			clone: function() {
	
				return new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  linewidth: <float>,
		 *  linecap: "round",
		 *  linejoin: "round"
		 * }
		 */
	
		function LineBasicMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'LineBasicMaterial';
	
			this.color = new Color( 0xffffff );
	
			this.linewidth = 1;
			this.linecap = 'round';
			this.linejoin = 'round';
	
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		LineBasicMaterial.prototype = Object.create( Material.prototype );
		LineBasicMaterial.prototype.constructor = LineBasicMaterial;
	
		LineBasicMaterial.prototype.isLineBasicMaterial = true;
	
		LineBasicMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.linewidth = source.linewidth;
			this.linecap = source.linecap;
			this.linejoin = source.linejoin;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Line( geometry, material, mode ) {
	
			if ( mode === 1 ) {
	
				console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
				return new LineSegments( geometry, material );
	
			}
	
			Object3D.call( this );
	
			this.type = 'Line';
	
			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );
	
		}
	
		Line.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Line,
	
			isLine: true,
	
			raycast: ( function () {
	
				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();
	
				return function raycast( raycaster, intersects ) {
	
					var precision = raycaster.linePrecision;
					var precisionSq = precision * precision;
	
					var geometry = this.geometry;
					var matrixWorld = this.matrixWorld;
	
					// Checking boundingSphere distance to ray
	
					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );
	
					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
					//
	
					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
					var vStart = new Vector3();
					var vEnd = new Vector3();
					var interSegment = new Vector3();
					var interRay = new Vector3();
					var step = (this && this.isLineSegments) ? 2 : 1;
	
					if ( geometry.isBufferGeometry ) {
	
						var index = geometry.index;
						var attributes = geometry.attributes;
						var positions = attributes.position.array;
	
						if ( index !== null ) {
	
							var indices = index.array;
	
							for ( var i = 0, l = indices.length - 1; i < l; i += step ) {
	
								var a = indices[ i ];
								var b = indices[ i + 1 ];
	
								vStart.fromArray( positions, a * 3 );
								vEnd.fromArray( positions, b * 3 );
	
								var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
								if ( distSq > precisionSq ) continue;
	
								interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
								var distance = raycaster.ray.origin.distanceTo( interRay );
	
								if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
								intersects.push( {
	
									distance: distance,
									// What do we want? intersection point on the ray or on the segment??
									// point: raycaster.ray.at( distance ),
									point: interSegment.clone().applyMatrix4( this.matrixWorld ),
									index: i,
									face: null,
									faceIndex: null,
									object: this
	
								} );
	
							}
	
						} else {
	
							for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {
	
								vStart.fromArray( positions, 3 * i );
								vEnd.fromArray( positions, 3 * i + 3 );
	
								var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
								if ( distSq > precisionSq ) continue;
	
								interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
								var distance = raycaster.ray.origin.distanceTo( interRay );
	
								if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
								intersects.push( {
	
									distance: distance,
									// What do we want? intersection point on the ray or on the segment??
									// point: raycaster.ray.at( distance ),
									point: interSegment.clone().applyMatrix4( this.matrixWorld ),
									index: i,
									face: null,
									faceIndex: null,
									object: this
	
								} );
	
							}
	
						}
	
					} else if ( geometry.isGeometry ) {
	
						var vertices = geometry.vertices;
						var nbVertices = vertices.length;
	
						for ( var i = 0; i < nbVertices - 1; i += step ) {
	
							var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );
	
							if ( distSq > precisionSq ) continue;
	
							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
							var distance = raycaster.ray.origin.distanceTo( interRay );
	
							if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
							intersects.push( {
	
								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this
	
							} );
	
						}
	
					}
	
				};
	
			}() ),
	
			clone: function () {
	
				return new this.constructor( this.geometry, this.material ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function LineSegments( geometry, material ) {
	
			Line.call( this, geometry, material );
	
			this.type = 'LineSegments';
	
		}
	
		LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {
	
			constructor: LineSegments,
	
			isLineSegments: true
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  size: <float>,
		 *  sizeAttenuation: <bool>
		 * }
		 */
	
		function PointsMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'PointsMaterial';
	
			this.color = new Color( 0xffffff );
	
			this.map = null;
	
			this.size = 1;
			this.sizeAttenuation = true;
	
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		PointsMaterial.prototype = Object.create( Material.prototype );
		PointsMaterial.prototype.constructor = PointsMaterial;
	
		PointsMaterial.prototype.isPointsMaterial = true;
	
		PointsMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.map = source.map;
	
			this.size = source.size;
			this.sizeAttenuation = source.sizeAttenuation;
	
			return this;
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Points( geometry, material ) {
	
			Object3D.call( this );
	
			this.type = 'Points';
	
			this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
			this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );
	
		}
	
		Points.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Points,
	
			isPoints: true,
	
			raycast: ( function () {
	
				var inverseMatrix = new Matrix4();
				var ray = new Ray();
				var sphere = new Sphere();
	
				return function raycast( raycaster, intersects ) {
	
					var object = this;
					var geometry = this.geometry;
					var matrixWorld = this.matrixWorld;
					var threshold = raycaster.params.Points.threshold;
	
					// Checking boundingSphere distance to ray
	
					if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
					sphere.copy( geometry.boundingSphere );
					sphere.applyMatrix4( matrixWorld );
	
					if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
					//
	
					inverseMatrix.getInverse( matrixWorld );
					ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
					var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
					var localThresholdSq = localThreshold * localThreshold;
					var position = new Vector3();
	
					function testPoint( point, index ) {
	
						var rayPointDistanceSq = ray.distanceSqToPoint( point );
	
						if ( rayPointDistanceSq < localThresholdSq ) {
	
							var intersectPoint = ray.closestPointToPoint( point );
							intersectPoint.applyMatrix4( matrixWorld );
	
							var distance = raycaster.ray.origin.distanceTo( intersectPoint );
	
							if ( distance < raycaster.near || distance > raycaster.far ) return;
	
							intersects.push( {
	
								distance: distance,
								distanceToRay: Math.sqrt( rayPointDistanceSq ),
								point: intersectPoint.clone(),
								index: index,
								face: null,
								object: object
	
							} );
	
						}
	
					}
	
					if ( geometry.isBufferGeometry ) {
	
						var index = geometry.index;
						var attributes = geometry.attributes;
						var positions = attributes.position.array;
	
						if ( index !== null ) {
	
							var indices = index.array;
	
							for ( var i = 0, il = indices.length; i < il; i ++ ) {
	
								var a = indices[ i ];
	
								position.fromArray( positions, a * 3 );
	
								testPoint( position, a );
	
							}
	
						} else {
	
							for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {
	
								position.fromArray( positions, i * 3 );
	
								testPoint( position, i );
	
							}
	
						}
	
					} else {
	
						var vertices = geometry.vertices;
	
						for ( var i = 0, l = vertices.length; i < l; i ++ ) {
	
							testPoint( vertices[ i ], i );
	
						}
	
					}
	
				};
	
			}() ),
	
			clone: function () {
	
				return new this.constructor( this.geometry, this.material ).copy( this );
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Group() {
	
			Object3D.call( this );
	
			this.type = 'Group';
	
		}
	
		Group.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Group
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
			Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
			this.generateMipmaps = false;
	
			var scope = this;
	
			function update() {
	
				requestAnimationFrame( update );
	
				if ( video.readyState >= video.HAVE_CURRENT_DATA ) {
	
					scope.needsUpdate = true;
	
				}
	
			}
	
			update();
	
		}
	
		VideoTexture.prototype = Object.create( Texture.prototype );
		VideoTexture.prototype.constructor = VideoTexture;
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
	
			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
			this.image = { width: width, height: height };
			this.mipmaps = mipmaps;
	
			// no flipping for cube textures
			// (also flipping doesn't work for compressed textures )
	
			this.flipY = false;
	
			// can't generate mipmaps for compressed textures
			// mips must be embedded in DDS files
	
			this.generateMipmaps = false;
	
		}
	
		CompressedTexture.prototype = Object.create( Texture.prototype );
		CompressedTexture.prototype.constructor = CompressedTexture;
	
		CompressedTexture.prototype.isCompressedTexture = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
			Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
			this.needsUpdate = true;
	
		}
	
		CanvasTexture.prototype = Object.create( Texture.prototype );
		CanvasTexture.prototype.constructor = CanvasTexture;
	
		/**
		 * @author Matt DesLauriers / @mattdesl
		 * @author atix / arthursilber.de
		 */
	
		function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {
	
			format = format !== undefined ? format : DepthFormat;
	
			if ( format !== DepthFormat && format !== DepthStencilFormat ) {
	
				throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )
	
			}
	
			if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
			if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;
	
			Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
			this.image = { width: width, height: height };
	
			this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
			this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
	
			this.flipY = false;
			this.generateMipmaps	= false;
	
		}
	
		DepthTexture.prototype = Object.create( Texture.prototype );
		DepthTexture.prototype.constructor = DepthTexture;
		DepthTexture.prototype.isDepthTexture = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function WireframeGeometry( geometry ) {
	
			BufferGeometry.call( this );
	
			this.type = 'WireframeGeometry';
	
			// buffer
	
			var vertices = [];
	
			// helper variables
	
			var i, j, l, o, ol;
			var edge = [ 0, 0 ], edges = {}, e;
			var key, keys = [ 'a', 'b', 'c' ];
			var vertex;
	
			// different logic for Geometry and BufferGeometry
	
			if ( geometry && geometry.isGeometry ) {
	
				// create a data structure that contains all edges without duplicates
	
				var faces = geometry.faces;
	
				for ( i = 0, l = faces.length; i < l; i ++ ) {
	
					var face = faces[ i ];
	
					for ( j = 0; j < 3; j ++ ) {
	
						edge[ 0 ] = face[ keys[ j ] ];
						edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
						edge.sort( sortFunction ); // sorting prevents duplicates
	
						key = edge.toString();
	
						if ( edges[ key ] === undefined ) {
	
							edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };
	
						}
	
					}
	
				}
	
				// generate vertices
	
				for ( key in edges ) {
	
					e = edges[ key ];
	
					vertex = geometry.vertices[ e.index1 ];
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					vertex = geometry.vertices[ e.index2 ];
					vertices.push( vertex.x, vertex.y, vertex.z );
	
				}
	
			} else if ( geometry && geometry.isBufferGeometry ) {
	
				var position, indices, groups;
				var group, start, count;
				var index1, index2;
	
				vertex = new Vector3();
	
				if ( geometry.index !== null ) {
	
					// indexed BufferGeometry
	
					position = geometry.attributes.position;
					indices = geometry.index;
					groups = geometry.groups;
	
					if ( groups.length === 0 ) {
	
						geometry.addGroup( 0, indices.count );
	
					}
	
					// create a data structure that contains all eges without duplicates
	
					for ( o = 0, ol = groups.length; o < ol; ++ o ) {
	
						group = groups[ o ];
	
						start = group.start;
						count = group.count;
	
						for ( i = start, l = ( start + count ); i < l; i += 3 ) {
	
							for ( j = 0; j < 3; j ++ ) {
	
								edge[ 0 ] = indices.getX( i + j );
								edge[ 1 ] = indices.getX( i + ( j + 1 ) % 3 );
								edge.sort( sortFunction ); // sorting prevents duplicates
	
								key = edge.toString();
	
								if ( edges[ key ] === undefined ) {
	
									edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };
	
								}
	
							}
	
						}
	
					}
	
					// generate vertices
	
					for ( key in edges ) {
	
						e = edges[ key ];
	
						vertex.fromBufferAttribute( position, e.index1 );
						vertices.push( vertex.x, vertex.y, vertex.z );
	
						vertex.fromBufferAttribute( position, e.index2 );
						vertices.push( vertex.x, vertex.y, vertex.z );
	
					}
	
				} else {
	
					// non-indexed BufferGeometry
	
					position = geometry.attributes.position;
	
					for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {
	
						for ( j = 0; j < 3; j ++ ) {
	
							// three edges per triangle, an edge is represented as (index1, index2)
							// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
	
							index1 = 3 * i + j;
							vertex.fromBufferAttribute( position, index1 );
							vertices.push( vertex.x, vertex.y, vertex.z );
	
							index2 = 3 * i + ( ( j + 1 ) % 3 );
							vertex.fromBufferAttribute( position, index2 );
							vertices.push( vertex.x, vertex.y, vertex.z );
	
						}
	
					}
	
				}
	
			}
	
			// build geometry
	
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	
			// custom array sort function
	
			function sortFunction( a, b ) {
	
				return a - b;
	
			}
	
		}
	
		WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
		WireframeGeometry.prototype.constructor = WireframeGeometry;
	
		/**
		 * @author zz85 / https://github.com/zz85
		 *
		 * Parametric Surfaces Geometry
		 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
		 */
	
		function ParametricGeometry( func, slices, stacks ) {
	
			Geometry.call( this );
	
			this.type = 'ParametricGeometry';
	
			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			};
	
			this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
			this.mergeVertices();
	
		}
	
		ParametricGeometry.prototype = Object.create( Geometry.prototype );
		ParametricGeometry.prototype.constructor = ParametricGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Parametric Surfaces Geometry
		 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
		 */
	
		function ParametricBufferGeometry( func, slices, stacks ) {
	
			BufferGeometry.call( this );
	
			this.type = 'ParametricBufferGeometry';
	
			this.parameters = {
				func: func,
				slices: slices,
				stacks: stacks
			};
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var uvs = [];
	
			var i, j;
	
			// generate vertices and uvs
	
			var sliceCount = slices + 1;
	
			for ( i = 0; i <= stacks; i ++ ) {
	
				var v = i / stacks;
	
				for ( j = 0; j <= slices; j ++ ) {
	
					var u = j / slices;
	
					var p = func( u, v );
					vertices.push( p.x, p.y, p.z );
	
					uvs.push( u, v );
	
				}
	
			}
	
			// generate indices
	
			for ( i = 0; i < stacks; i ++ ) {
	
				for ( j = 0; j < slices; j ++ ) {
	
					var a = i * sliceCount + j;
					var b = i * sliceCount + j + 1;
					var c = ( i + 1 ) * sliceCount + j + 1;
					var d = ( i + 1 ) * sliceCount + j;
	
					// faces one and two
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
			// generate normals
	
			this.computeVertexNormals();
	
		}
	
		ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
	
		/**
		 * @author clockworkgeek / https://github.com/clockworkgeek
		 * @author timothypratley / https://github.com/timothypratley
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function PolyhedronGeometry( vertices, indices, radius, detail ) {
	
			Geometry.call( this );
	
			this.type = 'PolyhedronGeometry';
	
			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
			this.mergeVertices();
	
		}
	
		PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
		PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {
	
			BufferGeometry.call( this );
	
			this.type = 'PolyhedronBufferGeometry';
	
			this.parameters = {
				vertices: vertices,
				indices: indices,
				radius: radius,
				detail: detail
			};
	
			radius = radius || 1;
			detail = detail || 0;
	
			// default buffer data
	
			var vertexBuffer = [];
			var uvBuffer = [];
	
			// the subdivision creates the vertex buffer data
	
			subdivide( detail );
	
			// all vertices should lie on a conceptual sphere with a given radius
	
			appplyRadius( radius );
	
			// finally, create the uv data
	
			generateUVs();
	
			// build non-indexed geometry
	
			this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );
			this.normalizeNormals();
	
			// helper functions
	
			function subdivide( detail ) {
	
				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();
	
				// iterate over all faces and apply a subdivison with the given detail value
	
				for ( var i = 0; i < indices.length; i += 3 ) {
	
					// get the vertices of the face
	
					getVertexByIndex( indices[ i + 0 ], a );
					getVertexByIndex( indices[ i + 1 ], b );
					getVertexByIndex( indices[ i + 2 ], c );
	
					// perform subdivision
	
					subdivideFace( a, b, c, detail );
	
				}
	
			}
	
			function subdivideFace( a, b, c, detail ) {
	
				var cols = Math.pow( 2, detail );
	
				// we use this multidimensional array as a data structure for creating the subdivision
	
				var v = [];
	
				var i, j;
	
				// construct all of the vertices for this subdivision
	
				for ( i = 0; i <= cols; i ++ ) {
	
					v[ i ] = [];
	
					var aj = a.clone().lerp( c, i / cols );
					var bj = b.clone().lerp( c, i / cols );
	
					var rows = cols - i;
	
					for ( j = 0; j <= rows; j ++ ) {
	
						if ( j === 0 && i === cols ) {
	
							v[ i ][ j ] = aj;
	
						} else {
	
							v[ i ][ j ] = aj.clone().lerp( bj, j / rows );
	
						}
	
					}
	
				}
	
				// construct all of the faces
	
				for ( i = 0; i < cols; i ++ ) {
	
					for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {
	
						var k = Math.floor( j / 2 );
	
						if ( j % 2 === 0 ) {
	
							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );
							pushVertex( v[ i ][ k ] );
	
						} else {
	
							pushVertex( v[ i ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k + 1 ] );
							pushVertex( v[ i + 1 ][ k ] );
	
						}
	
					}
	
				}
	
			}
	
			function appplyRadius( radius ) {
	
				var vertex = new Vector3();
	
				// iterate over the entire buffer and apply the radius to each vertex
	
				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {
	
					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];
	
					vertex.normalize().multiplyScalar( radius );
	
					vertexBuffer[ i + 0 ] = vertex.x;
					vertexBuffer[ i + 1 ] = vertex.y;
					vertexBuffer[ i + 2 ] = vertex.z;
	
				}
	
			}
	
			function generateUVs() {
	
				var vertex = new Vector3();
	
				for ( var i = 0; i < vertexBuffer.length; i += 3 ) {
	
					vertex.x = vertexBuffer[ i + 0 ];
					vertex.y = vertexBuffer[ i + 1 ];
					vertex.z = vertexBuffer[ i + 2 ];
	
					var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
					var v = inclination( vertex ) / Math.PI + 0.5;
					uvBuffer.push( u, 1 - v );
	
				}
	
				correctUVs();
	
				correctSeam();
	
			}
	
			function correctSeam() {
	
				// handle case when face straddles the seam, see #3269
	
				for ( var i = 0; i < uvBuffer.length; i += 6 ) {
	
					// uv data of a single face
	
					var x0 = uvBuffer[ i + 0 ];
					var x1 = uvBuffer[ i + 2 ];
					var x2 = uvBuffer[ i + 4 ];
	
					var max = Math.max( x0, x1, x2 );
					var min = Math.min( x0, x1, x2 );
	
					// 0.9 is somewhat arbitrary
	
					if ( max > 0.9 && min < 0.1 ) {
	
						if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
						if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
						if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;
	
					}
	
				}
	
			}
	
			function pushVertex( vertex ) {
	
				vertexBuffer.push( vertex.x, vertex.y, vertex.z );
	
			}
	
			function getVertexByIndex( index, vertex ) {
	
				var stride = index * 3;
	
				vertex.x = vertices[ stride + 0 ];
				vertex.y = vertices[ stride + 1 ];
				vertex.z = vertices[ stride + 2 ];
	
			}
	
			function correctUVs() {
	
				var a = new Vector3();
				var b = new Vector3();
				var c = new Vector3();
	
				var centroid = new Vector3();
	
				var uvA = new Vector2();
				var uvB = new Vector2();
				var uvC = new Vector2();
	
				for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {
	
					a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
					b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
					c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );
	
					uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
					uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
					uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );
	
					centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );
	
					var azi = azimuth( centroid );
	
					correctUV( uvA, j + 0, a, azi );
					correctUV( uvB, j + 2, b, azi );
					correctUV( uvC, j + 4, c, azi );
	
				}
	
			}
	
			function correctUV( uv, stride, vector, azimuth ) {
	
				if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {
	
					uvBuffer[ stride ] = uv.x - 1;
	
				}
	
				if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {
	
					uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;
	
				}
	
			}
	
			// Angle around the Y axis, counter-clockwise when looking from above.
	
			function azimuth( vector ) {
	
				return Math.atan2( vector.z, - vector.x );
	
			}
	
	
			// Angle above the XZ plane.
	
			function inclination( vector ) {
	
				return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );
	
			}
	
		}
	
		PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
	
		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */
	
		function TetrahedronGeometry( radius, detail ) {
	
			Geometry.call( this );
	
			this.type = 'TetrahedronGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();
	
		}
	
		TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
		TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function TetrahedronBufferGeometry( radius, detail ) {
	
			var vertices = [
				1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
			];
	
			var indices = [
				2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
			];
	
			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
			this.type = 'TetrahedronBufferGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
		}
	
		TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
	
		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */
	
		function OctahedronGeometry( radius, detail ) {
	
			Geometry.call( this );
	
			this.type = 'OctahedronGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();
	
		}
	
		OctahedronGeometry.prototype = Object.create( Geometry.prototype );
		OctahedronGeometry.prototype.constructor = OctahedronGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function OctahedronBufferGeometry( radius, detail ) {
	
			var vertices = [
				1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
			];
	
			var indices = [
				0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
			];
	
			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
			this.type = 'OctahedronBufferGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
		}
	
		OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
	
		/**
		 * @author timothypratley / https://github.com/timothypratley
		 */
	
		function IcosahedronGeometry( radius, detail ) {
	
		 	Geometry.call( this );
	
			this.type = 'IcosahedronGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();
	
		}
	
		IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
		IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function IcosahedronBufferGeometry( radius, detail ) {
	
			var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	
			var vertices = [
				- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
				 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
				 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
			];
	
			var indices = [
				 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
				 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
				 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
				 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
			];
	
			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
			this.type = 'IcosahedronBufferGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
		}
	
		IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
	
		/**
		 * @author Abe Pazos / https://hamoid.com
		 */
	
		function DodecahedronGeometry( radius, detail ) {
	
			Geometry.call( this );
	
			this.type = 'DodecahedronGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
			this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
			this.mergeVertices();
	
		}
	
		DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
		DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function DodecahedronBufferGeometry( radius, detail ) {
	
			var t = ( 1 + Math.sqrt( 5 ) ) / 2;
			var r = 1 / t;
	
			var vertices = [
	
				// (±1, ±1, ±1)
				- 1, - 1, - 1,    - 1, - 1,  1,
				- 1,  1, - 1,    - 1,  1,  1,
				  1, - 1, - 1,     1, - 1,  1,
				  1,  1, - 1,     1,  1,  1,
	
				// (0, ±1/φ, ±φ)
				 0, - r, - t,     0, - r,  t,
				 0,  r, - t,     0,  r,  t,
	
				// (±1/φ, ±φ, 0)
				- r, - t,  0,    - r,  t,  0,
				 r, - t,  0,     r,  t,  0,
	
				// (±φ, 0, ±1/φ)
				- t,  0, - r,     t,  0, - r,
				- t,  0,  r,     t,  0,  r
			];
	
			var indices = [
				 3, 11,  7,      3,  7, 15,      3, 15, 13,
				 7, 19, 17,      7, 17,  6,      7,  6, 15,
				17,  4,  8,     17,  8, 10,     17, 10,  6,
				 8,  0, 16,      8, 16,  2,      8,  2, 10,
				 0, 12,  1,      0,  1, 18,      0, 18, 16,
				 6, 10,  2,      6,  2, 13,      6, 13, 15,
				 2, 16, 18,      2, 18,  3,      2,  3, 13,
				18,  1,  9,     18,  9, 11,     18, 11,  3,
				 4, 14, 12,      4, 12,  0,      4,  0,  8,
				11,  9,  5,     11,  5, 19,     11, 19,  7,
				19,  5, 14,     19, 14,  4,     19,  4, 17,
				 1, 12, 14,      1, 14,  5,      1,  5,  9
			];
	
			PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
			this.type = 'DodecahedronBufferGeometry';
	
			this.parameters = {
				radius: radius,
				detail: detail
			};
	
		}
	
		DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
		DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
	
		/**
		 * @author oosmoxiecode / https://github.com/oosmoxiecode
		 * @author WestLangley / https://github.com/WestLangley
		 * @author zz85 / https://github.com/zz85
		 * @author miningold / https://github.com/miningold
		 * @author jonobr1 / https://github.com/jonobr1
		 *
		 * Creates a tube which extrudes along a 3d spline.
		 */
	
		function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {
	
			Geometry.call( this );
	
			this.type = 'TubeGeometry';
	
			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};
	
			if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );
	
			var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );
	
			// expose internals
	
			this.tangents = bufferGeometry.tangents;
			this.normals = bufferGeometry.normals;
			this.binormals = bufferGeometry.binormals;
	
			// create geometry
	
			this.fromBufferGeometry( bufferGeometry );
			this.mergeVertices();
	
		}
	
		TubeGeometry.prototype = Object.create( Geometry.prototype );
		TubeGeometry.prototype.constructor = TubeGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {
	
			BufferGeometry.call( this );
	
			this.type = 'TubeBufferGeometry';
	
			this.parameters = {
				path: path,
				tubularSegments: tubularSegments,
				radius: radius,
				radialSegments: radialSegments,
				closed: closed
			};
	
			tubularSegments = tubularSegments || 64;
			radius = radius || 1;
			radialSegments = radialSegments || 8;
			closed = closed || false;
	
			var frames = path.computeFrenetFrames( tubularSegments, closed );
	
			// expose internals
	
			this.tangents = frames.tangents;
			this.normals = frames.normals;
			this.binormals = frames.binormals;
	
			// helper variables
	
			var vertex = new Vector3();
			var normal = new Vector3();
			var uv = new Vector2();
	
			var i, j;
	
			// buffer
	
			var vertices = [];
			var normals = [];
			var uvs = [];
			var indices = [];
	
			// create buffer data
	
			generateBufferData();
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
			// functions
	
			function generateBufferData() {
	
				for ( i = 0; i < tubularSegments; i ++ ) {
	
					generateSegment( i );
	
				}
	
				// if the geometry is not closed, generate the last row of vertices and normals
				// at the regular position on the given path
				//
				// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
	
				generateSegment( ( closed === false ) ? tubularSegments : 0 );
	
				// uvs are generated in a separate function.
				// this makes it easy compute correct values for closed geometries
	
				generateUVs();
	
				// finally create faces
	
				generateIndices();
	
			}
	
			function generateSegment( i ) {
	
				// we use getPointAt to sample evenly distributed points from the given path
	
				var P = path.getPointAt( i / tubularSegments );
	
				// retrieve corresponding normal and binormal
	
				var N = frames.normals[ i ];
				var B = frames.binormals[ i ];
	
				// generate normals and vertices for the current segment
	
				for ( j = 0; j <= radialSegments; j ++ ) {
	
					var v = j / radialSegments * Math.PI * 2;
	
					var sin =   Math.sin( v );
					var cos = - Math.cos( v );
	
					// normal
	
					normal.x = ( cos * N.x + sin * B.x );
					normal.y = ( cos * N.y + sin * B.y );
					normal.z = ( cos * N.z + sin * B.z );
					normal.normalize();
	
					normals.push( normal.x, normal.y, normal.z );
	
					// vertex
	
					vertex.x = P.x + radius * normal.x;
					vertex.y = P.y + radius * normal.y;
					vertex.z = P.z + radius * normal.z;
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
				}
	
			}
	
			function generateIndices() {
	
				for ( j = 1; j <= tubularSegments; j ++ ) {
	
					for ( i = 1; i <= radialSegments; i ++ ) {
	
						var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
						var b = ( radialSegments + 1 ) * j + ( i - 1 );
						var c = ( radialSegments + 1 ) * j + i;
						var d = ( radialSegments + 1 ) * ( j - 1 ) + i;
	
						// faces
	
						indices.push( a, b, d );
						indices.push( b, c, d );
	
					}
	
				}
	
			}
	
			function generateUVs() {
	
				for ( i = 0; i <= tubularSegments; i ++ ) {
	
					for ( j = 0; j <= radialSegments; j ++ ) {
	
						uv.x = i / tubularSegments;
						uv.y = j / radialSegments;
	
						uvs.push( uv.x, uv.y );
	
					}
	
				}
	
			}
	
		}
	
		TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
	
		/**
		 * @author oosmoxiecode
		 */
	
		function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {
	
			Geometry.call( this );
	
			this.type = 'TorusKnotGeometry';
	
			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};
	
			if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );
	
			this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
			this.mergeVertices();
	
		}
	
		TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
		TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 * see: http://www.blackpawn.com/texts/pqtorus/
		 */
	
		function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {
	
			BufferGeometry.call( this );
	
			this.type = 'TorusKnotBufferGeometry';
	
			this.parameters = {
				radius: radius,
				tube: tube,
				tubularSegments: tubularSegments,
				radialSegments: radialSegments,
				p: p,
				q: q
			};
	
			radius = radius || 100;
			tube = tube || 40;
			tubularSegments = Math.floor( tubularSegments ) || 64;
			radialSegments = Math.floor( radialSegments ) || 8;
			p = p || 2;
			q = q || 3;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var i, j;
	
			var vertex = new Vector3();
			var normal = new Vector3();
			var uv = new Vector2();
	
			var P1 = new Vector3();
			var P2 = new Vector3();
	
			var B = new Vector3();
			var T = new Vector3();
			var N = new Vector3();
	
			// generate vertices, normals and uvs
	
			for ( i = 0; i <= tubularSegments; ++ i ) {
	
				// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
	
				var u = i / tubularSegments * p * Math.PI * 2;
	
				// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
				// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
	
				calculatePositionOnCurve( u, p, q, radius, P1 );
				calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );
	
				// calculate orthonormal basis
	
				T.subVectors( P2, P1 );
				N.addVectors( P2, P1 );
				B.crossVectors( T, N );
				N.crossVectors( B, T );
	
				// normalize B, N. T can be ignored, we don't use it
	
				B.normalize();
				N.normalize();
	
				for ( j = 0; j <= radialSegments; ++ j ) {
	
					// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
					// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
	
					var v = j / radialSegments * Math.PI * 2;
					var cx = - tube * Math.cos( v );
					var cy = tube * Math.sin( v );
	
					// now calculate the final vertex position.
					// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
	
					vertex.x = P1.x + ( cx * N.x + cy * B.x );
					vertex.y = P1.y + ( cx * N.y + cy * B.y );
					vertex.z = P1.z + ( cx * N.z + cy * B.z );
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
	
					normal.subVectors( vertex, P1 ).normalize();
	
					normals.push( normal.x, normal.y, normal.z );
	
					// uv
	
					uvs.push( i / tubularSegments );
					uvs.push( j / radialSegments );
	
				}
	
			}
	
			// generate indices
	
			for ( j = 1; j <= tubularSegments; j ++ ) {
	
				for ( i = 1; i <= radialSegments; i ++ ) {
	
					// indices
	
					var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					var b = ( radialSegments + 1 ) * j + ( i - 1 );
					var c = ( radialSegments + 1 ) * j + i;
					var d = ( radialSegments + 1 ) * ( j - 1 ) + i;
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
			// this function calculates the current position on the torus curve
	
			function calculatePositionOnCurve( u, p, q, radius, position ) {
	
				var cu = Math.cos( u );
				var su = Math.sin( u );
				var quOverP = q / p * u;
				var cs = Math.cos( quOverP );
	
				position.x = radius * ( 2 + cs ) * 0.5 * cu;
				position.y = radius * ( 2 + cs ) * su * 0.5;
				position.z = radius * Math.sin( quOverP ) * 0.5;
	
			}
	
		}
	
		TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
	
		/**
		 * @author oosmoxiecode
		 * @author mrdoob / http://mrdoob.com/
		 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
		 */
	
		function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {
	
			Geometry.call( this );
	
			this.type = 'TorusGeometry';
	
			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};
	
			this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
	
		}
	
		TorusGeometry.prototype = Object.create( Geometry.prototype );
		TorusGeometry.prototype.constructor = TorusGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {
	
			BufferGeometry.call( this );
	
			this.type = 'TorusBufferGeometry';
	
			this.parameters = {
				radius: radius,
				tube: tube,
				radialSegments: radialSegments,
				tubularSegments: tubularSegments,
				arc: arc
			};
	
			radius = radius || 100;
			tube = tube || 40;
			radialSegments = Math.floor( radialSegments ) || 8;
			tubularSegments = Math.floor( tubularSegments ) || 6;
			arc = arc || Math.PI * 2;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var center = new Vector3();
			var vertex = new Vector3();
			var normal = new Vector3();
	
			var j, i;
	
			// generate vertices, normals and uvs
	
			for ( j = 0; j <= radialSegments; j ++ ) {
	
				for ( i = 0; i <= tubularSegments; i ++ ) {
	
					var u = i / tubularSegments * arc;
					var v = j / radialSegments * Math.PI * 2;
	
					// vertex
	
					vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
					vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
					vertex.z = tube * Math.sin( v );
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// normal
	
					center.x = radius * Math.cos( u );
					center.y = radius * Math.sin( u );
					normal.subVectors( vertex, center ).normalize();
	
					normals.push( normal.x, normal.y, normal.z );
	
					// uv
	
					uvs.push( i / tubularSegments );
					uvs.push( j / radialSegments );
	
				}
	
			}
	
			// generate indices
	
			for ( j = 1; j <= radialSegments; j ++ ) {
	
				for ( i = 1; i <= tubularSegments; i ++ ) {
	
					// indices
	
					var a = ( tubularSegments + 1 ) * j + i - 1;
					var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
					var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
					var d = ( tubularSegments + 1 ) * j + i;
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		}
	
		TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 */
	
		var ShapeUtils = {
	
			// calculate area of the contour polygon
	
			area: function ( contour ) {
	
				var n = contour.length;
				var a = 0.0;
	
				for ( var p = n - 1, q = 0; q < n; p = q ++ ) {
	
					a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;
	
				}
	
				return a * 0.5;
	
			},
	
			triangulate: ( function () {
	
				/**
				 * This code is a quick port of code written in C++ which was submitted to
				 * flipcode.com by John W. Ratcliff  // July 22, 2000
				 * See original code and more information here:
				 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
				 *
				 * ported to actionscript by Zevan Rosser
				 * www.actionsnippet.com
				 *
				 * ported to javascript by Joshua Koo
				 * http://www.lab4games.net/zz85/blog
				 *
				 */
	
				function snip( contour, u, v, w, n, verts ) {
	
					var p;
					var ax, ay, bx, by;
					var cx, cy, px, py;
	
					ax = contour[ verts[ u ] ].x;
					ay = contour[ verts[ u ] ].y;
	
					bx = contour[ verts[ v ] ].x;
					by = contour[ verts[ v ] ].y;
	
					cx = contour[ verts[ w ] ].x;
					cy = contour[ verts[ w ] ].y;
	
					if ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;
	
					var aX, aY, bX, bY, cX, cY;
					var apx, apy, bpx, bpy, cpx, cpy;
					var cCROSSap, bCROSScp, aCROSSbp;
	
					aX = cx - bx;  aY = cy - by;
					bX = ax - cx;  bY = ay - cy;
					cX = bx - ax;  cY = by - ay;
	
					for ( p = 0; p < n; p ++ ) {
	
						px = contour[ verts[ p ] ].x;
						py = contour[ verts[ p ] ].y;
	
						if ( ( ( px === ax ) && ( py === ay ) ) ||
							 ( ( px === bx ) && ( py === by ) ) ||
							 ( ( px === cx ) && ( py === cy ) ) )	continue;
	
						apx = px - ax;  apy = py - ay;
						bpx = px - bx;  bpy = py - by;
						cpx = px - cx;  cpy = py - cy;
	
						// see if p is inside triangle abc
	
						aCROSSbp = aX * bpy - aY * bpx;
						cCROSSap = cX * apy - cY * apx;
						bCROSScp = bX * cpy - bY * cpx;
	
						if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;
	
					}
	
					return true;
	
				}
	
				// takes in an contour array and returns
	
				return function triangulate( contour, indices ) {
	
					var n = contour.length;
	
					if ( n < 3 ) return null;
	
					var result = [],
						verts = [],
						vertIndices = [];
	
					/* we want a counter-clockwise polygon in verts */
	
					var u, v, w;
	
					if ( ShapeUtils.area( contour ) > 0.0 ) {
	
						for ( v = 0; v < n; v ++ ) verts[ v ] = v;
	
					} else {
	
						for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;
	
					}
	
					var nv = n;
	
					/*  remove nv - 2 vertices, creating 1 triangle every time */
	
					var count = 2 * nv;   /* error detection */
	
					for ( v = nv - 1; nv > 2; ) {
	
						/* if we loop, it is probably a non-simple polygon */
	
						if ( ( count -- ) <= 0 ) {
	
							//** Triangulate: ERROR - probable bad polygon!
	
							//throw ( "Warning, unable to triangulate polygon!" );
							//return null;
							// Sometimes warning is fine, especially polygons are triangulated in reverse.
							console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );
	
							if ( indices ) return vertIndices;
							return result;
	
						}
	
						/* three consecutive vertices in current polygon, <u,v,w> */
	
						u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
						v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
						w = v + 1;  if ( nv <= w ) w = 0;     /* next     */
	
						if ( snip( contour, u, v, w, nv, verts ) ) {
	
							var a, b, c, s, t;
	
							/* true names of the vertices */
	
							a = verts[ u ];
							b = verts[ v ];
							c = verts[ w ];
	
							/* output Triangle */
	
							result.push( [ contour[ a ],
								contour[ b ],
								contour[ c ] ] );
	
	
							vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );
	
							/* remove v from the remaining polygon */
	
							for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {
	
								verts[ s ] = verts[ t ];
	
							}
	
							nv --;
	
							/* reset error detection counter */
	
							count = 2 * nv;
	
						}
	
					}
	
					if ( indices ) return vertIndices;
					return result;
	
				}
	
			} )(),
	
			triangulateShape: function ( contour, holes ) {
	
				function removeDupEndPts(points) {
	
					var l = points.length;
	
					if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {
	
						points.pop();
	
					}
	
				}
	
				removeDupEndPts( contour );
				holes.forEach( removeDupEndPts );
	
				function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {
	
					// inOtherPt needs to be collinear to the inSegment
					if ( inSegPt1.x !== inSegPt2.x ) {
	
						if ( inSegPt1.x < inSegPt2.x ) {
	
							return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );
	
						} else {
	
							return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );
	
						}
	
					} else {
	
						if ( inSegPt1.y < inSegPt2.y ) {
	
							return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );
	
						} else {
	
							return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );
	
						}
	
					}
	
				}
	
				function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {
	
					var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
					var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;
	
					var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
					var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;
	
					var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
					var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;
	
					if ( Math.abs( limit ) > Number.EPSILON ) {
	
						// not parallel
	
						var perpSeg2;
						if ( limit > 0 ) {
	
							if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
							perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
							if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];
	
						} else {
	
							if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
							perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
							if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];
	
						}
	
						// i.e. to reduce rounding errors
						// intersection at endpoint of segment#1?
						if ( perpSeg2 === 0 ) {
	
							if ( ( inExcludeAdjacentSegs ) &&
								 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
							return [ inSeg1Pt1 ];
	
						}
						if ( perpSeg2 === limit ) {
	
							if ( ( inExcludeAdjacentSegs ) &&
								 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
							return [ inSeg1Pt2 ];
	
						}
						// intersection at endpoint of segment#2?
						if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
						if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];
	
						// return real intersection point
						var factorSeg1 = perpSeg2 / limit;
						return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
									y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];
	
					} else {
	
						// parallel or collinear
						if ( ( perpSeg1 !== 0 ) ||
							 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];
	
						// they are collinear or degenerate
						var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
						var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
						// both segments are points
						if ( seg1Pt && seg2Pt ) {
	
							if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
								 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
							return [ inSeg1Pt1 ];                 						// they are the same point
	
						}
						// segment#1  is a single point
						if ( seg1Pt ) {
	
							if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
							return [ inSeg1Pt1 ];
	
						}
						// segment#2  is a single point
						if ( seg2Pt ) {
	
							if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
							return [ inSeg2Pt1 ];
	
						}
	
						// they are collinear segments, which might overlap
						var seg1min, seg1max, seg1minVal, seg1maxVal;
						var seg2min, seg2max, seg2minVal, seg2maxVal;
						if ( seg1dx !== 0 ) {
	
							// the segments are NOT on a vertical line
							if ( inSeg1Pt1.x < inSeg1Pt2.x ) {
	
								seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
								seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;
	
							} else {
	
								seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
								seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;
	
							}
							if ( inSeg2Pt1.x < inSeg2Pt2.x ) {
	
								seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
								seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;
	
							} else {
	
								seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
								seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;
	
							}
	
						} else {
	
							// the segments are on a vertical line
							if ( inSeg1Pt1.y < inSeg1Pt2.y ) {
	
								seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
								seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;
	
							} else {
	
								seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
								seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;
	
							}
							if ( inSeg2Pt1.y < inSeg2Pt2.y ) {
	
								seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
								seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;
	
							} else {
	
								seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
								seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;
	
							}
	
						}
						if ( seg1minVal <= seg2minVal ) {
	
							if ( seg1maxVal <  seg2minVal )	return [];
							if ( seg1maxVal === seg2minVal )	{
	
								if ( inExcludeAdjacentSegs )		return [];
								return [ seg2min ];
	
							}
							if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
							return	[ seg2min, seg2max ];
	
						} else {
	
							if ( seg1minVal >  seg2maxVal )	return [];
							if ( seg1minVal === seg2maxVal )	{
	
								if ( inExcludeAdjacentSegs )		return [];
								return [ seg1min ];
	
							}
							if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
							return	[ seg1min, seg2max ];
	
						}
	
					}
	
				}
	
				function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {
	
					// The order of legs is important
	
					// translation of all points, so that Vertex is at (0,0)
					var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
					var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
					var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;
	
					// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
					var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
					var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;
	
					if ( Math.abs( from2toAngle ) > Number.EPSILON ) {
	
						// angle != 180 deg.
	
						var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
						// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );
	
						if ( from2toAngle > 0 ) {
	
							// main angle < 180 deg.
							return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );
	
						} else {
	
							// main angle > 180 deg.
							return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );
	
						}
	
					} else {
	
						// angle == 180 deg.
						// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
						return	( from2otherAngle > 0 );
	
					}
	
				}
	
	
				function removeHoles( contour, holes ) {
	
					var shape = contour.concat(); // work on this shape
					var hole;
	
					function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {
	
						// Check if hole point lies within angle around shape point
						var lastShapeIdx = shape.length - 1;
	
						var prevShapeIdx = inShapeIdx - 1;
						if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;
	
						var nextShapeIdx = inShapeIdx + 1;
						if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;
	
						var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
						if ( ! insideAngle ) {
	
							// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
							return	false;
	
						}
	
						// Check if shape point lies within angle around hole point
						var lastHoleIdx = hole.length - 1;
	
						var prevHoleIdx = inHoleIdx - 1;
						if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;
	
						var nextHoleIdx = inHoleIdx + 1;
						if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;
	
						insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
						if ( ! insideAngle ) {
	
							// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
							return	false;
	
						}
	
						return	true;
	
					}
	
					function intersectsShapeEdge( inShapePt, inHolePt ) {
	
						// checks for intersections with shape edges
						var sIdx, nextIdx, intersection;
						for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {
	
							nextIdx = sIdx + 1; nextIdx %= shape.length;
							intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
							if ( intersection.length > 0 )		return	true;
	
						}
	
						return	false;
	
					}
	
					var indepHoles = [];
	
					function intersectsHoleEdge( inShapePt, inHolePt ) {
	
						// checks for intersections with hole edges
						var ihIdx, chkHole,
							hIdx, nextIdx, intersection;
						for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {
	
							chkHole = holes[ indepHoles[ ihIdx ]];
							for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {
	
								nextIdx = hIdx + 1; nextIdx %= chkHole.length;
								intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
								if ( intersection.length > 0 )		return	true;
	
							}
	
						}
						return	false;
	
					}
	
					var holeIndex, shapeIndex,
						shapePt, holePt,
						holeIdx, cutKey, failedCuts = [],
						tmpShape1, tmpShape2,
						tmpHole1, tmpHole2;
	
					for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
						indepHoles.push( h );
	
					}
	
					var minShapeIndex = 0;
					var counter = indepHoles.length * 2;
					while ( indepHoles.length > 0 ) {
	
						counter --;
						if ( counter < 0 ) {
	
							console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
							break;
	
						}
	
						// search for shape-vertex and hole-vertex,
						// which can be connected without intersections
						for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {
	
							shapePt = shape[ shapeIndex ];
							holeIndex	= - 1;
	
							// search for hole which can be reached without intersections
							for ( var h = 0; h < indepHoles.length; h ++ ) {
	
								holeIdx = indepHoles[ h ];
	
								// prevent multiple checks
								cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
								if ( failedCuts[ cutKey ] !== undefined )			continue;
	
								hole = holes[ holeIdx ];
								for ( var h2 = 0; h2 < hole.length; h2 ++ ) {
	
									holePt = hole[ h2 ];
									if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
									if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
									if ( intersectsHoleEdge( shapePt, holePt ) )		continue;
	
									holeIndex = h2;
									indepHoles.splice( h, 1 );
	
									tmpShape1 = shape.slice( 0, shapeIndex + 1 );
									tmpShape2 = shape.slice( shapeIndex );
									tmpHole1 = hole.slice( holeIndex );
									tmpHole2 = hole.slice( 0, holeIndex + 1 );
	
									shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );
	
									minShapeIndex = shapeIndex;
	
									// Debug only, to show the selected cuts
									// glob_CutLines.push( [ shapePt, holePt ] );
	
									break;
	
								}
								if ( holeIndex >= 0 )	break;		// hole-vertex found
	
								failedCuts[ cutKey ] = true;			// remember failure
	
							}
							if ( holeIndex >= 0 )	break;		// hole-vertex found
	
						}
	
					}
	
					return shape; 			/* shape with no holes */
	
				}
	
	
				var i, il, f, face,
					key, index,
					allPointsMap = {};
	
				// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.
	
				var allpoints = contour.concat();
	
				for ( var h = 0, hl = holes.length; h < hl; h ++ ) {
	
					Array.prototype.push.apply( allpoints, holes[ h ] );
	
				}
	
				//console.log( "allpoints",allpoints, allpoints.length );
	
				// prepare all points map
	
				for ( i = 0, il = allpoints.length; i < il; i ++ ) {
	
					key = allpoints[ i ].x + ":" + allpoints[ i ].y;
	
					if ( allPointsMap[ key ] !== undefined ) {
	
						console.warn( "THREE.ShapeUtils: Duplicate point", key, i );
	
					}
	
					allPointsMap[ key ] = i;
	
				}
	
				// remove holes by cutting paths to holes and adding them to the shape
				var shapeWithoutHoles = removeHoles( contour, holes );
	
				var triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
				//console.log( "triangles",triangles, triangles.length );
	
				// check all face vertices against all points map
	
				for ( i = 0, il = triangles.length; i < il; i ++ ) {
	
					face = triangles[ i ];
	
					for ( f = 0; f < 3; f ++ ) {
	
						key = face[ f ].x + ":" + face[ f ].y;
	
						index = allPointsMap[ key ];
	
						if ( index !== undefined ) {
	
							face[ f ] = index;
	
						}
	
					}
	
				}
	
				return triangles.concat();
	
			},
	
			isClockWise: function ( pts ) {
	
				return ShapeUtils.area( pts ) < 0;
	
			}
	
		};
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 * Creates extruded geometry from a path shape.
		 *
		 * parameters = {
		 *
		 *  curveSegments: <int>, // number of points on the curves
		 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
		 *  amount: <int>, // Depth to extrude the shape
		 *
		 *  bevelEnabled: <bool>, // turn on bevel
		 *  bevelThickness: <float>, // how deep into the original shape bevel goes
		 *  bevelSize: <float>, // how far from shape outline is bevel
		 *  bevelSegments: <int>, // number of bevel layers
		 *
		 *  extrudePath: <THREE.Curve> // curve to extrude shape along
		 *  frames: <Object> // containing arrays of tangents, normals, binormals
		 *
		 *  uvGenerator: <Object> // object that provides UV generator functions
		 *
		 * }
		 **/
	
		function ExtrudeGeometry( shapes, options ) {
	
			if ( typeof( shapes ) === "undefined" ) {
	
				shapes = [];
				return;
	
			}
	
			Geometry.call( this );
	
			this.type = 'ExtrudeGeometry';
	
			shapes = Array.isArray( shapes ) ? shapes : [ shapes ];
	
			this.addShapeList( shapes, options );
	
			this.computeFaceNormals();
	
			// can't really use automatic vertex normals
			// as then front and back sides get smoothed too
			// should do separate smoothing just for sides
	
			//this.computeVertexNormals();
	
			//console.log( "took", ( Date.now() - startTime ) );
	
		}
	
		ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
		ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
	
		ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {
	
			var sl = shapes.length;
	
			for ( var s = 0; s < sl; s ++ ) {
	
				var shape = shapes[ s ];
				this.addShape( shape, options );
	
			}
	
		};
	
		ExtrudeGeometry.prototype.addShape = function ( shape, options ) {
	
			var amount = options.amount !== undefined ? options.amount : 100;
	
			var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
			var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
			var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
	
			var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false
	
			var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
	
			var steps = options.steps !== undefined ? options.steps : 1;
	
			var extrudePath = options.extrudePath;
			var extrudePts, extrudeByPath = false;
	
			// Use default WorldUVGenerator if no UV generators are specified.
			var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;
	
			var splineTube, binormal, normal, position2;
			if ( extrudePath ) {
	
				extrudePts = extrudePath.getSpacedPoints( steps );
	
				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion
	
				// SETUP TNB variables
	
				// TODO1 - have a .isClosed in spline?
	
				splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );
	
				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
	
				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();
	
			}
	
			// Safeguards if bevels are not enabled
	
			if ( ! bevelEnabled ) {
	
				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
	
			}
	
			// Variables initialization
	
			var ahole, h, hl; // looping of holes
			var scope = this;
	
			var shapesOffset = this.vertices.length;
	
			var shapePoints = shape.extractPoints( curveSegments );
	
			var vertices = shapePoints.shape;
			var holes = shapePoints.holes;
	
			var reverse = ! ShapeUtils.isClockWise( vertices );
	
			if ( reverse ) {
	
				vertices = vertices.reverse();
	
				// Maybe we should also check if holes are in the opposite direction, just to be safe ...
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
	
					if ( ShapeUtils.isClockWise( ahole ) ) {
	
						holes[ h ] = ahole.reverse();
	
					}
	
				}
	
				reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!
	
			}
	
	
			var faces = ShapeUtils.triangulateShape( vertices, holes );
	
			/* Vertices */
	
			var contour = vertices; // vertices has all points but contour has only points of circumference
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
	
				vertices = vertices.concat( ahole );
	
			}
	
	
			function scalePt2( pt, vec, size ) {
	
				if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );
	
				return vec.clone().multiplyScalar( size ).add( pt );
	
			}
	
			var b, bs, t, z,
				vert, vlen = vertices.length,
				face, flen = faces.length;
	
	
			// Find directions for point movement
	
	
			function getBevelVec( inPt, inPrev, inNext ) {
	
				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.
	
				var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt
	
				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html
	
				var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
				var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;
	
				var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
	
				// check for collinear edges
				var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
				if ( Math.abs( collinear0 ) > Number.EPSILON ) {
	
					// not collinear
	
					// length of vectors for normalizing
	
					var v_prev_len = Math.sqrt( v_prev_lensq );
					var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
	
					// shift adjacent points by unit vectors to the left
	
					var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
	
					var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
	
					// scaling factor for v_prev to intersection point
	
					var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
								( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
							  ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
					// vector from inPt to intersection point
	
					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
	
					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {
	
						return	new Vector2( v_trans_x, v_trans_y );
	
					} else {
	
						shrink_by = Math.sqrt( v_trans_lensq / 2 );
	
					}
	
				} else {
	
					// handle special case of collinear edges
	
					var direction_eq = false;		// assumes: opposite
					if ( v_prev_x > Number.EPSILON ) {
	
						if ( v_next_x > Number.EPSILON ) {
	
							direction_eq = true;
	
						}
	
					} else {
	
						if ( v_prev_x < - Number.EPSILON ) {
	
							if ( v_next_x < - Number.EPSILON ) {
	
								direction_eq = true;
	
							}
	
						} else {
	
							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {
	
								direction_eq = true;
	
							}
	
						}
	
					}
	
					if ( direction_eq ) {
	
						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y =  v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );
	
					} else {
	
						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );
	
					}
	
				}
	
				return	new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );
	
			}
	
	
			var contourMovements = [];
	
			for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
				if ( j === il ) j = 0;
				if ( k === il ) k = 0;
	
				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)
	
				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );
	
			}
	
			var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
	
				oneHoleMovements = [];
	
				for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
					if ( j === il ) j = 0;
					if ( k === il ) k = 0;
	
					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );
	
				}
	
				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );
	
			}
	
	
			// Loop bevelSegments, 1 for the front, 1 for the back
	
			for ( b = 0; b < bevelSegments; b ++ ) {
	
				//for ( b = bevelSegments; b > 0; b -- ) {
	
				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );
	
				// contract shape
	
				for ( i = 0, il = contour.length; i < il; i ++ ) {
	
					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
	
					v( vert.x, vert.y,  - z );
	
				}
	
				// expand holes
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];
	
					for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
						v( vert.x, vert.y,  - z );
	
					}
	
				}
	
			}
	
			bs = bevelSize;
	
			// Back facing vertices
	
			for ( i = 0; i < vlen; i ++ ) {
	
				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
				if ( ! extrudeByPath ) {
	
					v( vert.x, vert.y, 0 );
	
				} else {
	
					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
	
					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );
	
					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );
	
					v( position2.x, position2.y, position2.z );
	
				}
	
			}
	
			// Add stepped vertices...
			// Including front facing vertices
	
			var s;
	
			for ( s = 1; s <= steps; s ++ ) {
	
				for ( i = 0; i < vlen; i ++ ) {
	
					vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
					if ( ! extrudeByPath ) {
	
						v( vert.x, vert.y, amount / steps * s );
	
					} else {
	
						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
	
						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );
	
						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );
	
						v( position2.x, position2.y, position2.z );
	
					}
	
				}
	
			}
	
	
			// Add bevel segments planes
	
			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( b = bevelSegments - 1; b >= 0; b -- ) {
	
				t = b / bevelSegments;
				z = bevelThickness * Math.cos ( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );
	
				// contract shape
	
				for ( i = 0, il = contour.length; i < il; i ++ ) {
	
					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y,  amount + z );
	
				}
	
				// expand holes
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];
	
					for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
						if ( ! extrudeByPath ) {
	
							v( vert.x, vert.y,  amount + z );
	
						} else {
	
							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );
	
						}
	
					}
	
				}
	
			}
	
			/* Faces */
	
			// Top and bottom faces
	
			buildLidFaces();
	
			// Sides faces
	
			buildSideFaces();
	
	
			/////  Internal functions
	
			function buildLidFaces() {
	
				if ( bevelEnabled ) {
	
					var layer = 0; // steps + 1
					var offset = vlen * layer;
	
					// Bottom faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );
	
					}
	
					layer = steps + bevelSegments * 2;
					offset = vlen * layer;
	
					// Top faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );
	
					}
	
				} else {
	
					// Bottom faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );
	
					}
	
					// Top faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );
	
					}
	
				}
	
			}
	
			// Create faces for the z-sides of the shape
	
			function buildSideFaces() {
	
				var layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
					sidewalls( ahole, layeroffset );
	
					//, true
					layeroffset += ahole.length;
	
				}
	
			}
	
			function sidewalls( contour, layeroffset ) {
	
				var j, k;
				i = contour.length;
	
				while ( -- i >= 0 ) {
	
					j = i;
					k = i - 1;
					if ( k < 0 ) k = contour.length - 1;
	
					//console.log('b', i,j, i-1, k,vertices.length);
	
					var s = 0, sl = steps  + bevelSegments * 2;
	
					for ( s = 0; s < sl; s ++ ) {
	
						var slen1 = vlen * s;
						var slen2 = vlen * ( s + 1 );
	
						var a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;
	
						f4( a, b, c, d, contour, s, sl, j, k );
	
					}
	
				}
	
			}
	
	
			function v( x, y, z ) {
	
				scope.vertices.push( new Vector3( x, y, z ) );
	
			}
	
			function f3( a, b, c ) {
	
				a += shapesOffset;
				b += shapesOffset;
				c += shapesOffset;
	
				scope.faces.push( new Face3( a, b, c, null, null, 0 ) );
	
				var uvs = uvgen.generateTopUV( scope, a, b, c );
	
				scope.faceVertexUvs[ 0 ].push( uvs );
	
			}
	
			function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {
	
				a += shapesOffset;
				b += shapesOffset;
				c += shapesOffset;
				d += shapesOffset;
	
				scope.faces.push( new Face3( a, b, d, null, null, 1 ) );
				scope.faces.push( new Face3( b, c, d, null, null, 1 ) );
	
				var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );
	
				scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
				scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );
	
			}
	
		};
	
		ExtrudeGeometry.WorldUVGenerator = {
	
			generateTopUV: function ( geometry, indexA, indexB, indexC ) {
	
				var vertices = geometry.vertices;
	
				var a = vertices[ indexA ];
				var b = vertices[ indexB ];
				var c = vertices[ indexC ];
	
				return [
					new Vector2( a.x, a.y ),
					new Vector2( b.x, b.y ),
					new Vector2( c.x, c.y )
				];
	
			},
	
			generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {
	
				var vertices = geometry.vertices;
	
				var a = vertices[ indexA ];
				var b = vertices[ indexB ];
				var c = vertices[ indexC ];
				var d = vertices[ indexD ];
	
				if ( Math.abs( a.y - b.y ) < 0.01 ) {
	
					return [
						new Vector2( a.x, 1 - a.z ),
						new Vector2( b.x, 1 - b.z ),
						new Vector2( c.x, 1 - c.z ),
						new Vector2( d.x, 1 - d.z )
					];
	
				} else {
	
					return [
						new Vector2( a.y, 1 - a.z ),
						new Vector2( b.y, 1 - b.z ),
						new Vector2( c.y, 1 - c.z ),
						new Vector2( d.y, 1 - d.z )
					];
	
				}
	
			}
		};
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * Text = 3D Text
		 *
		 * parameters = {
		 *  font: <THREE.Font>, // font
		 *
		 *  size: <float>, // size of the text
		 *  height: <float>, // thickness to extrude text
		 *  curveSegments: <int>, // number of points on the curves
		 *
		 *  bevelEnabled: <bool>, // turn on bevel
		 *  bevelThickness: <float>, // how deep into text bevel goes
		 *  bevelSize: <float> // how far from text outline is bevel
		 * }
		 */
	
		function TextGeometry( text, parameters ) {
	
			parameters = parameters || {};
	
			var font = parameters.font;
	
			if ( ( font && font.isFont ) === false ) {
	
				console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
				return new Geometry();
	
			}
	
			var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );
	
			// translate parameters to ExtrudeGeometry API
	
			parameters.amount = parameters.height !== undefined ? parameters.height : 50;
	
			// defaults
	
			if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
			if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
			if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;
	
			ExtrudeGeometry.call( this, shapes, parameters );
	
			this.type = 'TextGeometry';
	
		}
	
		TextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );
		TextGeometry.prototype.constructor = TextGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
			Geometry.call( this );
	
			this.type = 'SphereGeometry';
	
			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
	
		}
	
		SphereGeometry.prototype = Object.create( Geometry.prototype );
		SphereGeometry.prototype.constructor = SphereGeometry;
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'SphereBufferGeometry';
	
			this.parameters = {
				radius: radius,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				phiStart: phiStart,
				phiLength: phiLength,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			radius = radius || 50;
	
			widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
			heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );
	
			phiStart = phiStart !== undefined ? phiStart : 0;
			phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
	
			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
	
			var thetaEnd = thetaStart + thetaLength;
	
			var ix, iy;
	
			var index = 0;
			var grid = [];
	
			var vertex = new Vector3();
			var normal = new Vector3();
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// generate vertices, normals and uvs
	
			for ( iy = 0; iy <= heightSegments; iy ++ ) {
	
				var verticesRow = [];
	
				var v = iy / heightSegments;
	
				for ( ix = 0; ix <= widthSegments; ix ++ ) {
	
					var u = ix / widthSegments;
	
					// vertex
	
					vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
					vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
					vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// normal
	
					normal.set( vertex.x, vertex.y, vertex.z ).normalize();
					normals.push( normal.x, normal.y, normal.z );
	
					// uv
	
					uvs.push( u, 1 - v );
	
					verticesRow.push( index ++ );
	
				}
	
				grid.push( verticesRow );
	
			}
	
			// indices
	
			for ( iy = 0; iy < heightSegments; iy ++ ) {
	
				for ( ix = 0; ix < widthSegments; ix ++ ) {
	
					var a = grid[ iy ][ ix + 1 ];
					var b = grid[ iy ][ ix ];
					var c = grid[ iy + 1 ][ ix ];
					var d = grid[ iy + 1 ][ ix + 1 ];
	
					if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
					if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		}
	
		SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
	
		/**
		 * @author Kaleb Murphy
		 */
	
		function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	
			Geometry.call( this );
	
			this.type = 'RingGeometry';
	
			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
	
		}
	
		RingGeometry.prototype = Object.create( Geometry.prototype );
		RingGeometry.prototype.constructor = RingGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'RingBufferGeometry';
	
			this.parameters = {
				innerRadius: innerRadius,
				outerRadius: outerRadius,
				thetaSegments: thetaSegments,
				phiSegments: phiSegments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			innerRadius = innerRadius || 20;
			outerRadius = outerRadius || 50;
	
			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
			thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
			phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// some helper variables
	
			var segment;
			var radius = innerRadius;
			var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
			var vertex = new Vector3();
			var uv = new Vector2();
			var j, i;
	
			// generate vertices, normals and uvs
	
			for ( j = 0; j <= phiSegments; j ++ ) {
	
				for ( i = 0; i <= thetaSegments; i ++ ) {
	
					// values are generate from the inside of the ring to the outside
	
					segment = thetaStart + i / thetaSegments * thetaLength;
	
					// vertex
	
					vertex.x = radius * Math.cos( segment );
					vertex.y = radius * Math.sin( segment );
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// normal
	
					normals.push( 0, 0, 1 );
	
					// uv
	
					uv.x = ( vertex.x / outerRadius + 1 ) / 2;
					uv.y = ( vertex.y / outerRadius + 1 ) / 2;
	
					uvs.push( uv.x, uv.y );
	
				}
	
				// increase the radius for next row of vertices
	
				radius += radiusStep;
	
			}
	
			// indices
	
			for ( j = 0; j < phiSegments; j ++ ) {
	
				var thetaSegmentLevel = j * ( thetaSegments + 1 );
	
				for ( i = 0; i < thetaSegments; i ++ ) {
	
					segment = i + thetaSegmentLevel;
	
					var a = segment;
					var b = segment + thetaSegments + 1;
					var c = segment + thetaSegments + 2;
					var d = segment + 1;
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		}
	
		RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		RingBufferGeometry.prototype.constructor = RingBufferGeometry;
	
		/**
		 * @author astrodud / http://astrodud.isgreat.org/
		 * @author zz85 / https://github.com/zz85
		 * @author bhouston / http://clara.io
		 */
	
		// points - to create a closed torus, one must use a set of points
		//    like so: [ a, b, c, d, a ], see first is the same as last.
		// segments - the number of circumference segments to create
		// phiStart - the starting radian
		// phiLength - the radian (0 to 2PI) range of the lathed section
		//    2PI is a closed lathe, less than 2PI is a portion.
	
		function LatheGeometry( points, segments, phiStart, phiLength ) {
	
			Geometry.call( this );
	
			this.type = 'LatheGeometry';
	
			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};
	
			this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
			this.mergeVertices();
	
		}
	
		LatheGeometry.prototype = Object.create( Geometry.prototype );
		LatheGeometry.prototype.constructor = LatheGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function LatheBufferGeometry( points, segments, phiStart, phiLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'LatheBufferGeometry';
	
			this.parameters = {
				points: points,
				segments: segments,
				phiStart: phiStart,
				phiLength: phiLength
			};
	
			segments = Math.floor( segments ) || 12;
			phiStart = phiStart || 0;
			phiLength = phiLength || Math.PI * 2;
	
			// clamp phiLength so it's in range of [ 0, 2PI ]
	
			phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );
	
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var uvs = [];
	
			// helper variables
	
			var base;
			var inverseSegments = 1.0 / segments;
			var vertex = new Vector3();
			var uv = new Vector2();
			var i, j;
	
			// generate vertices and uvs
	
			for ( i = 0; i <= segments; i ++ ) {
	
				var phi = phiStart + i * inverseSegments * phiLength;
	
				var sin = Math.sin( phi );
				var cos = Math.cos( phi );
	
				for ( j = 0; j <= ( points.length - 1 ); j ++ ) {
	
					// vertex
	
					vertex.x = points[ j ].x * sin;
					vertex.y = points[ j ].y;
					vertex.z = points[ j ].x * cos;
	
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// uv
	
					uv.x = i / segments;
					uv.y = j / ( points.length - 1 );
	
					uvs.push( uv.x, uv.y );
	
	
				}
	
			}
	
			// indices
	
			for ( i = 0; i < segments; i ++ ) {
	
				for ( j = 0; j < ( points.length - 1 ); j ++ ) {
	
					base = j + i * points.length;
	
					var a = base;
					var b = base + points.length;
					var c = base + points.length + 1;
					var d = base + 1;
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
			// generate normals
	
			this.computeVertexNormals();
	
			// if the geometry is closed, we need to average the normals along the seam.
			// because the corresponding vertices are identical (but still have different UVs).
	
			if ( phiLength === Math.PI * 2 ) {
	
				var normals = this.attributes.normal.array;
				var n1 = new Vector3();
				var n2 = new Vector3();
				var n = new Vector3();
	
				// this is the buffer offset for the last line of vertices
	
				base = segments * points.length * 3;
	
				for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {
	
					// select the normal of the vertex in the first line
	
					n1.x = normals[ j + 0 ];
					n1.y = normals[ j + 1 ];
					n1.z = normals[ j + 2 ];
	
					// select the normal of the vertex in the last line
	
					n2.x = normals[ base + j + 0 ];
					n2.y = normals[ base + j + 1 ];
					n2.z = normals[ base + j + 2 ];
	
					// average normals
	
					n.addVectors( n1, n2 ).normalize();
	
					// assign the new values to both normals
	
					normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
					normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
					normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;
	
				}
	
			}
	
		}
	
		LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
	
		/**
		 * @author jonobr1 / http://jonobr1.com
		 */
	
		function ShapeGeometry( shapes, curveSegments ) {
	
			Geometry.call( this );
	
			this.type = 'ShapeGeometry';
	
			if ( typeof curveSegments === 'object' ) {
	
				console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );
	
				curveSegments = curveSegments.curveSegments;
	
			}
	
			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			};
	
			this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
			this.mergeVertices();
	
		}
	
		ShapeGeometry.prototype = Object.create( Geometry.prototype );
		ShapeGeometry.prototype.constructor = ShapeGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function ShapeBufferGeometry( shapes, curveSegments ) {
	
			BufferGeometry.call( this );
	
			this.type = 'ShapeBufferGeometry';
	
			this.parameters = {
				shapes: shapes,
				curveSegments: curveSegments
			};
	
			curveSegments = curveSegments || 12;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var groupStart = 0;
			var groupCount = 0;
	
			// allow single and array values for "shapes" parameter
	
			if ( Array.isArray( shapes ) === false ) {
	
				addShape( shapes );
	
			} else {
	
				for ( var i = 0; i < shapes.length; i ++ ) {
	
					addShape( shapes[ i ] );
	
					this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support
	
					groupStart += groupCount;
					groupCount = 0;
	
				}
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
	
			// helper functions
	
			function addShape( shape ) {
	
				var i, l, shapeHole;
	
				var indexOffset = vertices.length / 3;
				var points = shape.extractPoints( curveSegments );
	
				var shapeVertices = points.shape;
				var shapeHoles = points.holes;
	
				// check direction of vertices
	
				if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {
	
					shapeVertices = shapeVertices.reverse();
	
					// also check if holes are in the opposite direction
	
					for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {
	
						shapeHole = shapeHoles[ i ];
	
						if ( ShapeUtils.isClockWise( shapeHole ) === true ) {
	
							shapeHoles[ i ] = shapeHole.reverse();
	
						}
	
					}
	
				}
	
				var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );
	
				// join vertices of inner and outer paths to a single array
	
				for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {
	
					shapeHole = shapeHoles[ i ];
					shapeVertices = shapeVertices.concat( shapeHole );
	
				}
	
				// vertices, normals, uvs
	
				for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {
	
					var vertex = shapeVertices[ i ];
	
					vertices.push( vertex.x, vertex.y, 0 );
					normals.push( 0, 0, 1 );
					uvs.push( vertex.x, vertex.y ); // world uvs
	
				}
	
				// incides
	
				for ( i = 0, l = faces.length; i < l; i ++ ) {
	
					var face = faces[ i ];
	
					var a = face[ 0 ] + indexOffset;
					var b = face[ 1 ] + indexOffset;
					var c = face[ 2 ] + indexOffset;
	
					indices.push( a, b, c );
					groupCount += 3;
	
				}
	
			}
	
		}
	
		ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
	
		/**
		 * @author WestLangley / http://github.com/WestLangley
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function EdgesGeometry( geometry, thresholdAngle ) {
	
			BufferGeometry.call( this );
	
			this.type = 'EdgesGeometry';
	
			this.parameters = {
				thresholdAngle: thresholdAngle
			};
	
			thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;
	
			// buffer
	
			var vertices = [];
	
			// helper variables
	
			var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
			var edge = [ 0, 0 ], edges = {};
			var key, keys = [ 'a', 'b', 'c' ];
	
			// prepare source geometry
	
			var geometry2;
	
			if ( geometry.isBufferGeometry ) {
	
				geometry2 = new Geometry();
				geometry2.fromBufferGeometry( geometry );
	
			} else {
	
				geometry2 = geometry.clone();
	
			}
	
			geometry2.mergeVertices();
			geometry2.computeFaceNormals();
	
			var sourceVertices = geometry2.vertices;
			var faces = geometry2.faces;
	
			// now create a data structure where each entry represents an edge with its adjoining faces
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				for ( var j = 0; j < 3; j ++ ) {
	
					edge[ 0 ] = face[ keys[ j ] ];
					edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
					edge.sort( sortFunction );
	
					key = edge.toString();
	
					if ( edges[ key ] === undefined ) {
	
						edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };
	
					} else {
	
						edges[ key ].face2 = i;
	
					}
	
				}
	
			}
	
			// generate vertices
	
			for ( key in edges ) {
	
				var e = edges[ key ];
	
				// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
	
				if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {
	
					var vertex = sourceVertices[ e.index1 ];
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					vertex = sourceVertices[ e.index2 ];
					vertices.push( vertex.x, vertex.y, vertex.z );
	
				}
	
			}
	
			// build geometry
	
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	
			// custom array sort function
	
			function sortFunction( a, b ) {
	
				return a - b;
	
			}
	
		}
	
		EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
		EdgesGeometry.prototype.constructor = EdgesGeometry;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
			Geometry.call( this );
	
			this.type = 'CylinderGeometry';
	
			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
			this.mergeVertices();
	
		}
	
		CylinderGeometry.prototype = Object.create( Geometry.prototype );
		CylinderGeometry.prototype.constructor = CylinderGeometry;
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'CylinderBufferGeometry';
	
			this.parameters = {
				radiusTop: radiusTop,
				radiusBottom: radiusBottom,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			var scope = this;
	
			radiusTop = radiusTop !== undefined ? radiusTop : 20;
			radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
			height = height !== undefined ? height : 100;
	
			radialSegments = Math.floor( radialSegments ) || 8;
			heightSegments = Math.floor( heightSegments ) || 1;
	
			openEnded = openEnded !== undefined ? openEnded : false;
			thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
			thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var index = 0;
			var indexOffset = 0;
			var indexArray = [];
			var halfHeight = height / 2;
			var groupStart = 0;
	
			// generate geometry
	
			generateTorso();
	
			if ( openEnded === false ) {
	
				if ( radiusTop > 0 ) generateCap( true );
				if ( radiusBottom > 0 ) generateCap( false );
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
			function generateTorso() {
	
				var x, y;
				var normal = new Vector3();
				var vertex = new Vector3();
	
				var groupCount = 0;
	
				// this will be used to calculate the normal
				var slope = ( radiusBottom - radiusTop ) / height;
	
				// generate vertices, normals and uvs
	
				for ( y = 0; y <= heightSegments; y ++ ) {
	
					var indexRow = [];
	
					var v = y / heightSegments;
	
					// calculate the radius of the current row
	
					var radius = v * ( radiusBottom - radiusTop ) + radiusTop;
	
					for ( x = 0; x <= radialSegments; x ++ ) {
	
						var u = x / radialSegments;
	
						var theta = u * thetaLength + thetaStart;
	
						var sinTheta = Math.sin( theta );
						var cosTheta = Math.cos( theta );
	
						// vertex
	
						vertex.x = radius * sinTheta;
						vertex.y = - v * height + halfHeight;
						vertex.z = radius * cosTheta;
						vertices.push( vertex.x, vertex.y, vertex.z );
	
						// normal
	
						normal.set( sinTheta, slope, cosTheta ).normalize();
						normals.push( normal.x, normal.y, normal.z );
	
						// uv
	
						uvs.push( u, 1 - v );
	
						// save index of vertex in respective row
	
						indexRow.push( index ++ );
	
					}
	
					// now save vertices of the row in our index array
	
					indexArray.push( indexRow );
	
				}
	
				// generate indices
	
				for ( x = 0; x < radialSegments; x ++ ) {
	
					for ( y = 0; y < heightSegments; y ++ ) {
	
						// we use the index array to access the correct indices
	
						var a = indexArray[ y ][ x ];
						var b = indexArray[ y + 1 ][ x ];
						var c = indexArray[ y + 1 ][ x + 1 ];
						var d = indexArray[ y ][ x + 1 ];
	
						// faces
	
						indices.push( a, b, d );
						indices.push( b, c, d );
	
						// update group counter
	
						groupCount += 6;
	
					}
	
				}
	
				// add a group to the geometry. this will ensure multi material support
	
				scope.addGroup( groupStart, groupCount, 0 );
	
				// calculate new start value for groups
	
				groupStart += groupCount;
	
			}
	
			function generateCap( top ) {
	
				var x, centerIndexStart, centerIndexEnd;
	
				var uv = new Vector2();
				var vertex = new Vector3();
	
				var groupCount = 0;
	
				var radius = ( top === true ) ? radiusTop : radiusBottom;
				var sign = ( top === true ) ? 1 : - 1;
	
				// save the index of the first center vertex
				centerIndexStart = index;
	
				// first we generate the center vertex data of the cap.
				// because the geometry needs one set of uvs per face,
				// we must generate a center vertex per face/segment
	
				for ( x = 1; x <= radialSegments; x ++ ) {
	
					// vertex
	
					vertices.push( 0, halfHeight * sign, 0 );
	
					// normal
	
					normals.push( 0, sign, 0 );
	
					// uv
	
					uvs.push( 0.5, 0.5 );
	
					// increase index
	
					index ++;
	
				}
	
				// save the index of the last center vertex
	
				centerIndexEnd = index;
	
				// now we generate the surrounding vertices, normals and uvs
	
				for ( x = 0; x <= radialSegments; x ++ ) {
	
					var u = x / radialSegments;
					var theta = u * thetaLength + thetaStart;
	
					var cosTheta = Math.cos( theta );
					var sinTheta = Math.sin( theta );
	
					// vertex
	
					vertex.x = radius * sinTheta;
					vertex.y = halfHeight * sign;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// normal
	
					normals.push( 0, sign, 0 );
	
					// uv
	
					uv.x = ( cosTheta * 0.5 ) + 0.5;
					uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
					uvs.push( uv.x, uv.y );
	
					// increase index
	
					index ++;
	
				}
	
				// generate indices
	
				for ( x = 0; x < radialSegments; x ++ ) {
	
					var c = centerIndexStart + x;
					var i = centerIndexEnd + x;
	
					if ( top === true ) {
	
						// face top
	
						indices.push( i, i + 1, c );
	
					} else {
	
						// face bottom
	
						indices.push( i + 1, i, c );
	
					}
	
					groupCount += 3;
	
				}
	
				// add a group to the geometry. this will ensure multi material support
	
				scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );
	
				// calculate new start value for groups
	
				groupStart += groupCount;
	
			}
	
		}
	
		CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
	
		/**
		 * @author abelnation / http://github.com/abelnation
		 */
	
		function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
			CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );
	
			this.type = 'ConeGeometry';
	
			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
		}
	
		ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
		ConeGeometry.prototype.constructor = ConeGeometry;
	
		/**
		 * @author: abelnation / http://github.com/abelnation
		 */
	
		function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
			CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );
	
			this.type = 'ConeBufferGeometry';
	
			this.parameters = {
				radius: radius,
				height: height,
				radialSegments: radialSegments,
				heightSegments: heightSegments,
				openEnded: openEnded,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
		}
	
		ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
		ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
	
		/**
		 * @author hughes
		 */
	
		function CircleGeometry( radius, segments, thetaStart, thetaLength ) {
	
			Geometry.call( this );
	
			this.type = 'CircleGeometry';
	
			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
	
		}
	
		CircleGeometry.prototype = Object.create( Geometry.prototype );
		CircleGeometry.prototype.constructor = CircleGeometry;
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {
	
			BufferGeometry.call( this );
	
			this.type = 'CircleBufferGeometry';
	
			this.parameters = {
				radius: radius,
				segments: segments,
				thetaStart: thetaStart,
				thetaLength: thetaLength
			};
	
			radius = radius || 50;
			segments = segments !== undefined ? Math.max( 3, segments ) : 8;
	
			thetaStart = thetaStart !== undefined ? thetaStart : 0;
			thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
			// buffers
	
			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];
	
			// helper variables
	
			var i, s;
			var vertex = new Vector3();
			var uv = new Vector2();
	
			// center point
	
			vertices.push( 0, 0, 0 );
			normals.push( 0, 0, 1 );
			uvs.push( 0.5, 0.5 );
	
			for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {
	
				var segment = thetaStart + s / segments * thetaLength;
	
				// vertex
	
				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );
	
				vertices.push( vertex.x, vertex.y, vertex.z );
	
				// normal
	
				normals.push( 0, 0, 1 );
	
				// uvs
	
				uv.x = ( vertices[ i ] / radius + 1 ) / 2;
				uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;
	
				uvs.push( uv.x, uv.y );
	
			}
	
			// indices
	
			for ( i = 1; i <= segments; i ++ ) {
	
				indices.push( i, i + 1, 0 );
	
			}
	
			// build geometry
	
			this.setIndex( indices );
			this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		}
	
		CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
	
	
	
		var Geometries = Object.freeze({
			WireframeGeometry: WireframeGeometry,
			ParametricGeometry: ParametricGeometry,
			ParametricBufferGeometry: ParametricBufferGeometry,
			TetrahedronGeometry: TetrahedronGeometry,
			TetrahedronBufferGeometry: TetrahedronBufferGeometry,
			OctahedronGeometry: OctahedronGeometry,
			OctahedronBufferGeometry: OctahedronBufferGeometry,
			IcosahedronGeometry: IcosahedronGeometry,
			IcosahedronBufferGeometry: IcosahedronBufferGeometry,
			DodecahedronGeometry: DodecahedronGeometry,
			DodecahedronBufferGeometry: DodecahedronBufferGeometry,
			PolyhedronGeometry: PolyhedronGeometry,
			PolyhedronBufferGeometry: PolyhedronBufferGeometry,
			TubeGeometry: TubeGeometry,
			TubeBufferGeometry: TubeBufferGeometry,
			TorusKnotGeometry: TorusKnotGeometry,
			TorusKnotBufferGeometry: TorusKnotBufferGeometry,
			TorusGeometry: TorusGeometry,
			TorusBufferGeometry: TorusBufferGeometry,
			TextGeometry: TextGeometry,
			SphereGeometry: SphereGeometry,
			SphereBufferGeometry: SphereBufferGeometry,
			RingGeometry: RingGeometry,
			RingBufferGeometry: RingBufferGeometry,
			PlaneGeometry: PlaneGeometry,
			PlaneBufferGeometry: PlaneBufferGeometry,
			LatheGeometry: LatheGeometry,
			LatheBufferGeometry: LatheBufferGeometry,
			ShapeGeometry: ShapeGeometry,
			ShapeBufferGeometry: ShapeBufferGeometry,
			ExtrudeGeometry: ExtrudeGeometry,
			EdgesGeometry: EdgesGeometry,
			ConeGeometry: ConeGeometry,
			ConeBufferGeometry: ConeBufferGeometry,
			CylinderGeometry: CylinderGeometry,
			CylinderBufferGeometry: CylinderBufferGeometry,
			CircleGeometry: CircleGeometry,
			CircleBufferGeometry: CircleBufferGeometry,
			BoxGeometry: BoxGeometry,
			BoxBufferGeometry: BoxBufferGeometry
		});
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function ShadowMaterial() {
	
			ShaderMaterial.call( this, {
				uniforms: UniformsUtils.merge( [
					UniformsLib.lights,
					{
						opacity: { value: 1.0 }
					}
				] ),
				vertexShader: ShaderChunk[ 'shadow_vert' ],
				fragmentShader: ShaderChunk[ 'shadow_frag' ]
			} );
	
			this.lights = true;
			this.transparent = true;
	
			Object.defineProperties( this, {
				opacity: {
					enumerable: true,
					get: function () {
						return this.uniforms.opacity.value;
					},
					set: function ( value ) {
						this.uniforms.opacity.value = value;
					}
				}
			} );
	
		}
	
		ShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );
		ShadowMaterial.prototype.constructor = ShadowMaterial;
	
		ShadowMaterial.prototype.isShadowMaterial = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function RawShaderMaterial( parameters ) {
	
			ShaderMaterial.call( this, parameters );
	
			this.type = 'RawShaderMaterial';
	
		}
	
		RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
		RawShaderMaterial.prototype.constructor = RawShaderMaterial;
	
		RawShaderMaterial.prototype.isRawShaderMaterial = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function MultiMaterial( materials ) {
	
			this.uuid = _Math.generateUUID();
	
			this.type = 'MultiMaterial';
	
			this.materials = Array.isArray( materials ) ? materials : [];
	
			this.visible = true;
	
		}
	
		MultiMaterial.prototype = {
	
			constructor: MultiMaterial,
	
			isMultiMaterial: true,
	
			toJSON: function ( meta ) {
	
				var output = {
					metadata: {
						version: 4.2,
						type: 'material',
						generator: 'MaterialExporter'
					},
					uuid: this.uuid,
					type: this.type,
					materials: []
				};
	
				var materials = this.materials;
	
				for ( var i = 0, l = materials.length; i < l; i ++ ) {
	
					var material = materials[ i ].toJSON( meta );
					delete material.metadata;
	
					output.materials.push( material );
	
				}
	
				output.visible = this.visible;
	
				return output;
	
			},
	
			clone: function () {
	
				var material = new this.constructor();
	
				for ( var i = 0; i < this.materials.length; i ++ ) {
	
					material.materials.push( this.materials[ i ].clone() );
	
				}
	
				material.visible = this.visible;
	
				return material;
	
			}
	
		};
	
		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  roughness: <float>,
		 *  metalness: <float>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  roughnessMap: new THREE.Texture( <Image> ),
		 *
		 *  metalnessMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
		 *  envMapIntensity: <float>
		 *
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function MeshStandardMaterial( parameters ) {
	
			Material.call( this );
	
			this.defines = { 'STANDARD': '' };
	
			this.type = 'MeshStandardMaterial';
	
			this.color = new Color( 0xffffff ); // diffuse
			this.roughness = 0.5;
			this.metalness = 0.5;
	
			this.map = null;
	
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
	
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
	
			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
	
			this.bumpMap = null;
			this.bumpScale = 1;
	
			this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );
	
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
	
			this.roughnessMap = null;
	
			this.metalnessMap = null;
	
			this.alphaMap = null;
	
			this.envMap = null;
			this.envMapIntensity = 1.0;
	
			this.refractionRatio = 0.98;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
	
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
	
			this.setValues( parameters );
	
		}
	
		MeshStandardMaterial.prototype = Object.create( Material.prototype );
		MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
	
		MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
	
		MeshStandardMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.defines = { 'STANDARD': '' };
	
			this.color.copy( source.color );
			this.roughness = source.roughness;
			this.metalness = source.metalness;
	
			this.map = source.map;
	
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
	
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
	
			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
	
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
	
			this.normalMap = source.normalMap;
			this.normalScale.copy( source.normalScale );
	
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
	
			this.roughnessMap = source.roughnessMap;
	
			this.metalnessMap = source.metalnessMap;
	
			this.alphaMap = source.alphaMap;
	
			this.envMap = source.envMap;
			this.envMapIntensity = source.envMapIntensity;
	
			this.refractionRatio = source.refractionRatio;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			return this;
	
		};
	
		/**
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  reflectivity: <float>
		 * }
		 */
	
		function MeshPhysicalMaterial( parameters ) {
	
			MeshStandardMaterial.call( this );
	
			this.defines = { 'PHYSICAL': '' };
	
			this.type = 'MeshPhysicalMaterial';
	
			this.reflectivity = 0.5; // maps to F0 = 0.04
	
			this.clearCoat = 0.0;
			this.clearCoatRoughness = 0.0;
	
			this.setValues( parameters );
	
		}
	
		MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
		MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
	
		MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
	
		MeshPhysicalMaterial.prototype.copy = function ( source ) {
	
			MeshStandardMaterial.prototype.copy.call( this, source );
	
			this.defines = { 'PHYSICAL': '' };
	
			this.reflectivity = source.reflectivity;
	
			this.clearCoat = source.clearCoat;
			this.clearCoatRoughness = source.clearCoatRoughness;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  specular: <hex>,
		 *  shininess: <float>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function MeshPhongMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'MeshPhongMaterial';
	
			this.color = new Color( 0xffffff ); // diffuse
			this.specular = new Color( 0x111111 );
			this.shininess = 30;
	
			this.map = null;
	
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
	
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
	
			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
	
			this.bumpMap = null;
			this.bumpScale = 1;
	
			this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );
	
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
	
			this.specularMap = null;
	
			this.alphaMap = null;
	
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
	
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
	
			this.setValues( parameters );
	
		}
	
		MeshPhongMaterial.prototype = Object.create( Material.prototype );
		MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
	
		MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
	
		MeshPhongMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
			this.specular.copy( source.specular );
			this.shininess = source.shininess;
	
			this.map = source.map;
	
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
	
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
	
			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
	
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
	
			this.normalMap = source.normalMap;
			this.normalScale.copy( source.normalScale );
	
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
	
			this.specularMap = source.specularMap;
	
			this.alphaMap = source.alphaMap;
	
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			return this;
	
		};
	
		/**
		 * @author takahirox / http://github.com/takahirox
		 *
		 * parameters = {
		 *  gradientMap: new THREE.Texture( <Image> )
		 * }
		 */
	
		function MeshToonMaterial( parameters ) {
	
			MeshPhongMaterial.call( this );
	
			this.defines = { 'TOON': '' };
	
			this.type = 'MeshToonMaterial';
	
			this.gradientMap = null;
	
			this.setValues( parameters );
	
		}
	
		MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
		MeshToonMaterial.prototype.constructor = MeshToonMaterial;
	
		MeshToonMaterial.prototype.isMeshToonMaterial = true;
	
		MeshToonMaterial.prototype.copy = function ( source ) {
	
			MeshPhongMaterial.prototype.copy.call( this, source );
	
			this.gradientMap = source.gradientMap;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * parameters = {
		 *  opacity: <float>,
		 *
		 *  bumpMap: new THREE.Texture( <Image> ),
		 *  bumpScale: <float>,
		 *
		 *  normalMap: new THREE.Texture( <Image> ),
		 *  normalScale: <Vector2>,
		 *
		 *  displacementMap: new THREE.Texture( <Image> ),
		 *  displacementScale: <float>,
		 *  displacementBias: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function MeshNormalMaterial( parameters ) {
	
			Material.call( this, parameters );
	
			this.type = 'MeshNormalMaterial';
	
			this.bumpMap = null;
			this.bumpScale = 1;
	
			this.normalMap = null;
			this.normalScale = new Vector2( 1, 1 );
	
			this.displacementMap = null;
			this.displacementScale = 1;
			this.displacementBias = 0;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
	
			this.fog = false;
			this.lights = false;
	
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
	
			this.setValues( parameters );
	
		}
	
		MeshNormalMaterial.prototype = Object.create( Material.prototype );
		MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
	
		MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
	
		MeshNormalMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.bumpMap = source.bumpMap;
			this.bumpScale = source.bumpScale;
	
			this.normalMap = source.normalMap;
			this.normalScale.copy( source.normalScale );
	
			this.displacementMap = source.displacementMap;
			this.displacementScale = source.displacementScale;
			this.displacementBias = source.displacementBias;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  map: new THREE.Texture( <Image> ),
		 *
		 *  lightMap: new THREE.Texture( <Image> ),
		 *  lightMapIntensity: <float>
		 *
		 *  aoMap: new THREE.Texture( <Image> ),
		 *  aoMapIntensity: <float>
		 *
		 *  emissive: <hex>,
		 *  emissiveIntensity: <float>
		 *  emissiveMap: new THREE.Texture( <Image> ),
		 *
		 *  specularMap: new THREE.Texture( <Image> ),
		 *
		 *  alphaMap: new THREE.Texture( <Image> ),
		 *
		 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
		 *  combine: THREE.Multiply,
		 *  reflectivity: <float>,
		 *  refractionRatio: <float>,
		 *
		 *  wireframe: <boolean>,
		 *  wireframeLinewidth: <float>,
		 *
		 *  skinning: <bool>,
		 *  morphTargets: <bool>,
		 *  morphNormals: <bool>
		 * }
		 */
	
		function MeshLambertMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'MeshLambertMaterial';
	
			this.color = new Color( 0xffffff ); // diffuse
	
			this.map = null;
	
			this.lightMap = null;
			this.lightMapIntensity = 1.0;
	
			this.aoMap = null;
			this.aoMapIntensity = 1.0;
	
			this.emissive = new Color( 0x000000 );
			this.emissiveIntensity = 1.0;
			this.emissiveMap = null;
	
			this.specularMap = null;
	
			this.alphaMap = null;
	
			this.envMap = null;
			this.combine = MultiplyOperation;
			this.reflectivity = 1;
			this.refractionRatio = 0.98;
	
			this.wireframe = false;
			this.wireframeLinewidth = 1;
			this.wireframeLinecap = 'round';
			this.wireframeLinejoin = 'round';
	
			this.skinning = false;
			this.morphTargets = false;
			this.morphNormals = false;
	
			this.setValues( parameters );
	
		}
	
		MeshLambertMaterial.prototype = Object.create( Material.prototype );
		MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
	
		MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
	
		MeshLambertMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.map = source.map;
	
			this.lightMap = source.lightMap;
			this.lightMapIntensity = source.lightMapIntensity;
	
			this.aoMap = source.aoMap;
			this.aoMapIntensity = source.aoMapIntensity;
	
			this.emissive.copy( source.emissive );
			this.emissiveMap = source.emissiveMap;
			this.emissiveIntensity = source.emissiveIntensity;
	
			this.specularMap = source.specularMap;
	
			this.alphaMap = source.alphaMap;
	
			this.envMap = source.envMap;
			this.combine = source.combine;
			this.reflectivity = source.reflectivity;
			this.refractionRatio = source.refractionRatio;
	
			this.wireframe = source.wireframe;
			this.wireframeLinewidth = source.wireframeLinewidth;
			this.wireframeLinecap = source.wireframeLinecap;
			this.wireframeLinejoin = source.wireframeLinejoin;
	
			this.skinning = source.skinning;
			this.morphTargets = source.morphTargets;
			this.morphNormals = source.morphNormals;
	
			return this;
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 *
		 * parameters = {
		 *  color: <hex>,
		 *  opacity: <float>,
		 *
		 *  linewidth: <float>,
		 *
		 *  scale: <float>,
		 *  dashSize: <float>,
		 *  gapSize: <float>
		 * }
		 */
	
		function LineDashedMaterial( parameters ) {
	
			Material.call( this );
	
			this.type = 'LineDashedMaterial';
	
			this.color = new Color( 0xffffff );
	
			this.linewidth = 1;
	
			this.scale = 1;
			this.dashSize = 3;
			this.gapSize = 1;
	
			this.lights = false;
	
			this.setValues( parameters );
	
		}
	
		LineDashedMaterial.prototype = Object.create( Material.prototype );
		LineDashedMaterial.prototype.constructor = LineDashedMaterial;
	
		LineDashedMaterial.prototype.isLineDashedMaterial = true;
	
		LineDashedMaterial.prototype.copy = function ( source ) {
	
			Material.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
	
			this.linewidth = source.linewidth;
	
			this.scale = source.scale;
			this.dashSize = source.dashSize;
			this.gapSize = source.gapSize;
	
			return this;
	
		};
	
	
	
		var Materials = Object.freeze({
			ShadowMaterial: ShadowMaterial,
			SpriteMaterial: SpriteMaterial,
			RawShaderMaterial: RawShaderMaterial,
			ShaderMaterial: ShaderMaterial,
			PointsMaterial: PointsMaterial,
			MultiMaterial: MultiMaterial,
			MeshPhysicalMaterial: MeshPhysicalMaterial,
			MeshStandardMaterial: MeshStandardMaterial,
			MeshPhongMaterial: MeshPhongMaterial,
			MeshToonMaterial: MeshToonMaterial,
			MeshNormalMaterial: MeshNormalMaterial,
			MeshLambertMaterial: MeshLambertMaterial,
			MeshDepthMaterial: MeshDepthMaterial,
			MeshBasicMaterial: MeshBasicMaterial,
			LineDashedMaterial: LineDashedMaterial,
			LineBasicMaterial: LineBasicMaterial,
			Material: Material
		});
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		var Cache = {
	
			enabled: false,
	
			files: {},
	
			add: function ( key, file ) {
	
				if ( this.enabled === false ) return;
	
				// console.log( 'THREE.Cache', 'Adding key:', key );
	
				this.files[ key ] = file;
	
			},
	
			get: function ( key ) {
	
				if ( this.enabled === false ) return;
	
				// console.log( 'THREE.Cache', 'Checking key:', key );
	
				return this.files[ key ];
	
			},
	
			remove: function ( key ) {
	
				delete this.files[ key ];
	
			},
	
			clear: function () {
	
				this.files = {};
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function LoadingManager( onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var isLoading = false, itemsLoaded = 0, itemsTotal = 0;
	
			this.onStart = undefined;
			this.onLoad = onLoad;
			this.onProgress = onProgress;
			this.onError = onError;
	
			this.itemStart = function ( url ) {
	
				itemsTotal ++;
	
				if ( isLoading === false ) {
	
					if ( scope.onStart !== undefined ) {
	
						scope.onStart( url, itemsLoaded, itemsTotal );
	
					}
	
				}
	
				isLoading = true;
	
			};
	
			this.itemEnd = function ( url ) {
	
				itemsLoaded ++;
	
				if ( scope.onProgress !== undefined ) {
	
					scope.onProgress( url, itemsLoaded, itemsTotal );
	
				}
	
				if ( itemsLoaded === itemsTotal ) {
	
					isLoading = false;
	
					if ( scope.onLoad !== undefined ) {
	
						scope.onLoad();
	
					}
	
				}
	
			};
	
			this.itemError = function ( url ) {
	
				if ( scope.onError !== undefined ) {
	
					scope.onError( url );
	
				}
	
			};
	
		}
	
		var DefaultLoadingManager = new LoadingManager();
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function FileLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( FileLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				if ( url === undefined ) url = '';
	
				if ( this.path !== undefined ) url = this.path + url;
	
				var scope = this;
	
				var cached = Cache.get( url );
	
				if ( cached !== undefined ) {
	
					scope.manager.itemStart( url );
	
					setTimeout( function () {
	
						if ( onLoad ) onLoad( cached );
	
						scope.manager.itemEnd( url );
	
					}, 0 );
	
					return cached;
	
				}
	
				// Check for data: URI
				var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
				var dataUriRegexResult = url.match( dataUriRegex );
	
				// Safari can not handle Data URIs through XMLHttpRequest so process manually
				if ( dataUriRegexResult ) {
	
					var mimeType = dataUriRegexResult[ 1 ];
					var isBase64 = !! dataUriRegexResult[ 2 ];
					var data = dataUriRegexResult[ 3 ];
	
					data = window.decodeURIComponent( data );
	
					if ( isBase64 ) data = window.atob( data );
	
					try {
	
						var response;
						var responseType = ( this.responseType || '' ).toLowerCase();
	
						switch ( responseType ) {
	
							case 'arraybuffer':
							case 'blob':
	
							 	response = new ArrayBuffer( data.length );
	
								var view = new Uint8Array( response );
	
								for ( var i = 0; i < data.length; i ++ ) {
	
									view[ i ] = data.charCodeAt( i );
	
								}
	
								if ( responseType === 'blob' ) {
	
									response = new Blob( [ response ], { type: mimeType } );
	
								}
	
								break;
	
							case 'document':
	
								var parser = new DOMParser();
								response = parser.parseFromString( data, mimeType );
	
								break;
	
							case 'json':
	
								response = JSON.parse( data );
	
								break;
	
							default: // 'text' or other
	
								response = data;
	
								break;
	
						}
	
						// Wait for next browser tick
						window.setTimeout( function () {
	
							if ( onLoad ) onLoad( response );
	
							scope.manager.itemEnd( url );
	
						}, 0 );
	
					} catch ( error ) {
	
						// Wait for next browser tick
						window.setTimeout( function () {
	
							if ( onError ) onError( error );
	
							scope.manager.itemError( url );
	
						}, 0 );
	
					}
	
				} else {
	
					var request = new XMLHttpRequest();
					request.open( 'GET', url, true );
	
					request.addEventListener( 'load', function ( event ) {
	
						var response = event.target.response;
	
						Cache.add( url, response );
	
						if ( this.status === 200 ) {
	
							if ( onLoad ) onLoad( response );
	
							scope.manager.itemEnd( url );
	
						} else if ( this.status === 0 ) {
	
							// Some browsers return HTTP Status 0 when using non-http protocol
							// e.g. 'file://' or 'data://'. Handle as success.
	
							console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );
	
							if ( onLoad ) onLoad( response );
	
							scope.manager.itemEnd( url );
	
						} else {
	
							if ( onError ) onError( event );
	
							scope.manager.itemError( url );
	
						}
	
					}, false );
	
					if ( onProgress !== undefined ) {
	
						request.addEventListener( 'progress', function ( event ) {
	
							onProgress( event );
	
						}, false );
	
					}
	
					request.addEventListener( 'error', function ( event ) {
	
						if ( onError ) onError( event );
	
						scope.manager.itemError( url );
	
					}, false );
	
					if ( this.responseType !== undefined ) request.responseType = this.responseType;
					if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;
	
					if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );
	
					request.send( null );
	
				}
	
				scope.manager.itemStart( url );
	
				return request;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			},
	
			setResponseType: function ( value ) {
	
				this.responseType = value;
				return this;
	
			},
	
			setWithCredentials: function ( value ) {
	
				this.withCredentials = value;
				return this;
	
			},
	
			setMimeType: function ( value ) {
	
				this.mimeType = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 *
		 * Abstract Base class to block based textures loader (dds, pvr, ...)
		 */
	
		function CompressedTextureLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
			// override in sub classes
			this._parser = null;
	
		}
	
		Object.assign( CompressedTextureLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var images = [];
	
				var texture = new CompressedTexture();
				texture.image = images;
	
				var loader = new FileLoader( this.manager );
				loader.setPath( this.path );
				loader.setResponseType( 'arraybuffer' );
	
				function loadTexture( i ) {
	
					loader.load( url[ i ], function ( buffer ) {
	
						var texDatas = scope._parser( buffer, true );
	
						images[ i ] = {
							width: texDatas.width,
							height: texDatas.height,
							format: texDatas.format,
							mipmaps: texDatas.mipmaps
						};
	
						loaded += 1;
	
						if ( loaded === 6 ) {
	
							if ( texDatas.mipmapCount === 1 )
								texture.minFilter = LinearFilter;
	
							texture.format = texDatas.format;
							texture.needsUpdate = true;
	
							if ( onLoad ) onLoad( texture );
	
						}
	
					}, onProgress, onError );
	
				}
	
				if ( Array.isArray( url ) ) {
	
					var loaded = 0;
	
					for ( var i = 0, il = url.length; i < il; ++ i ) {
	
						loadTexture( i );
	
					}
	
				} else {
	
					// compressed cubemap texture stored in a single DDS file
	
					loader.load( url, function ( buffer ) {
	
						var texDatas = scope._parser( buffer, true );
	
						if ( texDatas.isCubemap ) {
	
							var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
	
							for ( var f = 0; f < faces; f ++ ) {
	
								images[ f ] = { mipmaps : [] };
	
								for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {
	
									images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
									images[ f ].format = texDatas.format;
									images[ f ].width = texDatas.width;
									images[ f ].height = texDatas.height;
	
								}
	
							}
	
						} else {
	
							texture.image.width = texDatas.width;
							texture.image.height = texDatas.height;
							texture.mipmaps = texDatas.mipmaps;
	
						}
	
						if ( texDatas.mipmapCount === 1 ) {
	
							texture.minFilter = LinearFilter;
	
						}
	
						texture.format = texDatas.format;
						texture.needsUpdate = true;
	
						if ( onLoad ) onLoad( texture );
	
					}, onProgress, onError );
	
				}
	
				return texture;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author Nikos M. / https://github.com/foo123/
		 *
		 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
		 */
	
		function DataTextureLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
			// override in sub classes
			this._parser = null;
	
		}
	
		Object.assign( DataTextureLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var texture = new DataTexture();
	
				var loader = new FileLoader( this.manager );
				loader.setResponseType( 'arraybuffer' );
	
				loader.load( url, function ( buffer ) {
	
					var texData = scope._parser( buffer );
	
					if ( ! texData ) return;
	
					if ( undefined !== texData.image ) {
	
						texture.image = texData.image;
	
					} else if ( undefined !== texData.data ) {
	
						texture.image.width = texData.width;
						texture.image.height = texData.height;
						texture.image.data = texData.data;
	
					}
	
					texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
					texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;
	
					texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
					texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;
	
					texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;
	
					if ( undefined !== texData.format ) {
	
						texture.format = texData.format;
	
					}
					if ( undefined !== texData.type ) {
	
						texture.type = texData.type;
	
					}
	
					if ( undefined !== texData.mipmaps ) {
	
						texture.mipmaps = texData.mipmaps;
	
					}
	
					if ( 1 === texData.mipmapCount ) {
	
						texture.minFilter = LinearFilter;
	
					}
	
					texture.needsUpdate = true;
	
					if ( onLoad ) onLoad( texture, texData );
	
				}, onProgress, onError );
	
	
				return texture;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function ImageLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( ImageLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				if ( url === undefined ) url = '';
	
				if ( this.path !== undefined ) url = this.path + url;
	
				var scope = this;
	
				var cached = Cache.get( url );
	
				if ( cached !== undefined ) {
	
					scope.manager.itemStart( url );
	
					setTimeout( function () {
	
						if ( onLoad ) onLoad( cached );
	
						scope.manager.itemEnd( url );
	
					}, 0 );
	
					return cached;
	
				}
	
				var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
	
				image.addEventListener( 'load', function () {
	
					Cache.add( url, this );
	
					if ( onLoad ) onLoad( this );
	
					scope.manager.itemEnd( url );
	
				}, false );
	
				/*
				image.addEventListener( 'progress', function ( event ) {
	
					if ( onProgress ) onProgress( event );
	
				}, false );
				*/
	
				image.addEventListener( 'error', function ( event ) {
	
					if ( onError ) onError( event );
	
					scope.manager.itemError( url );
	
				}, false );
	
				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;
	
				scope.manager.itemStart( url );
	
				image.src = url;
	
				return image;
	
			},
	
			setCrossOrigin: function ( value ) {
	
				this.crossOrigin = value;
				return this;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function CubeTextureLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( CubeTextureLoader.prototype, {
	
			load: function ( urls, onLoad, onProgress, onError ) {
	
				var texture = new CubeTexture();
	
				var loader = new ImageLoader( this.manager );
				loader.setCrossOrigin( this.crossOrigin );
				loader.setPath( this.path );
	
				var loaded = 0;
	
				function loadTexture( i ) {
	
					loader.load( urls[ i ], function ( image ) {
	
						texture.images[ i ] = image;
	
						loaded ++;
	
						if ( loaded === 6 ) {
	
							texture.needsUpdate = true;
	
							if ( onLoad ) onLoad( texture );
	
						}
	
					}, undefined, onError );
	
				}
	
				for ( var i = 0; i < urls.length; ++ i ) {
	
					loadTexture( i );
	
				}
	
				return texture;
	
			},
	
			setCrossOrigin: function ( value ) {
	
				this.crossOrigin = value;
				return this;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function TextureLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( TextureLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var texture = new Texture();
	
				var loader = new ImageLoader( this.manager );
				loader.setCrossOrigin( this.crossOrigin );
				loader.setPath( this.path );
				loader.load( url, function ( image ) {
	
					// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
					var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;
	
					texture.format = isJPEG ? RGBFormat : RGBAFormat;
					texture.image = image;
					texture.needsUpdate = true;
	
					if ( onLoad !== undefined ) {
	
						onLoad( texture );
	
					}
	
				}, onProgress, onError );
	
				return texture;
	
			},
	
			setCrossOrigin: function ( value ) {
	
				this.crossOrigin = value;
				return this;
	
			},
	
			setPath: function ( value ) {
	
				this.path = value;
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Light( color, intensity ) {
	
			Object3D.call( this );
	
			this.type = 'Light';
	
			this.color = new Color( color );
			this.intensity = intensity !== undefined ? intensity : 1;
	
			this.receiveShadow = undefined;
	
		}
	
		Light.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Light,
	
			isLight: true,
	
			copy: function ( source ) {
	
				Object3D.prototype.copy.call( this, source );
	
				this.color.copy( source.color );
				this.intensity = source.intensity;
	
				return this;
	
			},
	
			toJSON: function ( meta ) {
	
				var data = Object3D.prototype.toJSON.call( this, meta );
	
				data.object.color = this.color.getHex();
				data.object.intensity = this.intensity;
	
				if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();
	
				if ( this.distance !== undefined ) data.object.distance = this.distance;
				if ( this.angle !== undefined ) data.object.angle = this.angle;
				if ( this.decay !== undefined ) data.object.decay = this.decay;
				if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;
	
				if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();
	
				return data;
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function HemisphereLight( skyColor, groundColor, intensity ) {
	
			Light.call( this, skyColor, intensity );
	
			this.type = 'HemisphereLight';
	
			this.castShadow = undefined;
	
			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();
	
			this.groundColor = new Color( groundColor );
	
		}
	
		HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: HemisphereLight,
	
			isHemisphereLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.groundColor.copy( source.groundColor );
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function LightShadow( camera ) {
	
			this.camera = camera;
	
			this.bias = 0;
			this.radius = 1;
	
			this.mapSize = new Vector2( 512, 512 );
	
			this.map = null;
			this.matrix = new Matrix4();
	
		}
	
		Object.assign( LightShadow.prototype, {
	
			copy: function ( source ) {
	
				this.camera = source.camera.clone();
	
				this.bias = source.bias;
				this.radius = source.radius;
	
				this.mapSize.copy( source.mapSize );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			toJSON: function () {
	
				var object = {};
	
				if ( this.bias !== 0 ) object.bias = this.bias;
				if ( this.radius !== 1 ) object.radius = this.radius;
				if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();
	
				object.camera = this.camera.toJSON( false ).object;
				delete object.camera.matrix;
	
				return object;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function SpotLightShadow() {
	
			LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );
	
		}
	
		SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {
	
			constructor: SpotLightShadow,
	
			isSpotLightShadow: true,
	
			update: function ( light ) {
	
				var fov = _Math.RAD2DEG * 2 * light.angle;
				var aspect = this.mapSize.width / this.mapSize.height;
				var far = light.distance || 500;
	
				var camera = this.camera;
	
				if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {
	
					camera.fov = fov;
					camera.aspect = aspect;
					camera.far = far;
					camera.updateProjectionMatrix();
	
				}
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function SpotLight( color, intensity, distance, angle, penumbra, decay ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'SpotLight';
	
			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();
	
			this.target = new Object3D();
	
			Object.defineProperty( this, 'power', {
				get: function () {
					// intensity = power per solid angle.
					// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					return this.intensity * Math.PI;
				},
				set: function ( power ) {
					// intensity = power per solid angle.
					// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					this.intensity = power / Math.PI;
				}
			} );
	
			this.distance = ( distance !== undefined ) ? distance : 0;
			this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
			this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
			this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
			this.shadow = new SpotLightShadow();
	
		}
	
		SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: SpotLight,
	
			isSpotLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.distance = source.distance;
				this.angle = source.angle;
				this.penumbra = source.penumbra;
				this.decay = source.decay;
	
				this.target = source.target.clone();
	
				this.shadow = source.shadow.clone();
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
	
		function PointLight( color, intensity, distance, decay ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'PointLight';
	
			Object.defineProperty( this, 'power', {
				get: function () {
					// intensity = power per solid angle.
					// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					return this.intensity * 4 * Math.PI;
	
				},
				set: function ( power ) {
					// intensity = power per solid angle.
					// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
					this.intensity = power / ( 4 * Math.PI );
				}
			} );
	
			this.distance = ( distance !== undefined ) ? distance : 0;
			this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
			this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );
	
		}
	
		PointLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: PointLight,
	
			isPointLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.distance = source.distance;
				this.decay = source.decay;
	
				this.shadow = source.shadow.clone();
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function DirectionalLightShadow( ) {
	
			LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );
	
		}
	
		DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {
	
			constructor: DirectionalLightShadow
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function DirectionalLight( color, intensity ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'DirectionalLight';
	
			this.position.copy( Object3D.DefaultUp );
			this.updateMatrix();
	
			this.target = new Object3D();
	
			this.shadow = new DirectionalLightShadow();
	
		}
	
		DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: DirectionalLight,
	
			isDirectionalLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.target = source.target.clone();
	
				this.shadow = source.shadow.clone();
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function AmbientLight( color, intensity ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'AmbientLight';
	
			this.castShadow = undefined;
	
		}
	
		AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: AmbientLight,
	
			isAmbientLight: true
	
		} );
	
		/**
		 * @author tschw
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */
	
		var AnimationUtils = {
	
			// same as Array.prototype.slice, but also works on typed arrays
			arraySlice: function( array, from, to ) {
	
				if ( AnimationUtils.isTypedArray( array ) ) {
	
					return new array.constructor( array.subarray( from, to ) );
	
				}
	
				return array.slice( from, to );
	
			},
	
			// converts an array to a specific type
			convertArray: function( array, type, forceClone ) {
	
				if ( ! array || // let 'undefined' and 'null' pass
						! forceClone && array.constructor === type ) return array;
	
				if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {
	
					return new type( array ); // create typed array
	
				}
	
				return Array.prototype.slice.call( array ); // create Array
	
			},
	
			isTypedArray: function( object ) {
	
				return ArrayBuffer.isView( object ) &&
						! ( object instanceof DataView );
	
			},
	
			// returns an array by which times and values can be sorted
			getKeyframeOrder: function( times ) {
	
				function compareTime( i, j ) {
	
					return times[ i ] - times[ j ];
	
				}
	
				var n = times.length;
				var result = new Array( n );
				for ( var i = 0; i !== n; ++ i ) result[ i ] = i;
	
				result.sort( compareTime );
	
				return result;
	
			},
	
			// uses the array previously returned by 'getKeyframeOrder' to sort data
			sortedArray: function( values, stride, order ) {
	
				var nValues = values.length;
				var result = new values.constructor( nValues );
	
				for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {
	
					var srcOffset = order[ i ] * stride;
	
					for ( var j = 0; j !== stride; ++ j ) {
	
						result[ dstOffset ++ ] = values[ srcOffset + j ];
	
					}
	
				}
	
				return result;
	
			},
	
			// function for parsing AOS keyframe formats
			flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {
	
				var i = 1, key = jsonKeys[ 0 ];
	
				while ( key !== undefined && key[ valuePropertyName ] === undefined ) {
	
					key = jsonKeys[ i ++ ];
	
				}
	
				if ( key === undefined ) return; // no data
	
				var value = key[ valuePropertyName ];
				if ( value === undefined ) return; // no data
	
				if ( Array.isArray( value ) ) {
	
					do {
	
						value = key[ valuePropertyName ];
	
						if ( value !== undefined ) {
	
							times.push( key.time );
							values.push.apply( values, value ); // push all elements
	
						}
	
						key = jsonKeys[ i ++ ];
	
					} while ( key !== undefined );
	
				} else if ( value.toArray !== undefined ) {
					// ...assume THREE.Math-ish
	
					do {
	
						value = key[ valuePropertyName ];
	
						if ( value !== undefined ) {
	
							times.push( key.time );
							value.toArray( values, values.length );
	
						}
	
						key = jsonKeys[ i ++ ];
	
					} while ( key !== undefined );
	
				} else {
					// otherwise push as-is
	
					do {
	
						value = key[ valuePropertyName ];
	
						if ( value !== undefined ) {
	
							times.push( key.time );
							values.push( value );
	
						}
	
						key = jsonKeys[ i ++ ];
	
					} while ( key !== undefined );
	
				}
	
			}
	
		};
	
		/**
		 * Abstract base class of interpolants over parametric samples.
		 *
		 * The parameter domain is one dimensional, typically the time or a path
		 * along a curve defined by the data.
		 *
		 * The sample values can have any dimensionality and derived classes may
		 * apply special interpretations to the data.
		 *
		 * This class provides the interval seek in a Template Method, deferring
		 * the actual interpolation to derived classes.
		 *
		 * Time complexity is O(1) for linear access crossing at most two points
		 * and O(log N) for random access, where N is the number of positions.
		 *
		 * References:
		 *
		 * 		http://www.oodesign.com/template-method-pattern.html
		 *
		 * @author tschw
		 */
	
		function Interpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			this.parameterPositions = parameterPositions;
			this._cachedIndex = 0;
	
			this.resultBuffer = resultBuffer !== undefined ?
					resultBuffer : new sampleValues.constructor( sampleSize );
			this.sampleValues = sampleValues;
			this.valueSize = sampleSize;
	
		}
	
		Interpolant.prototype = {
	
			constructor: Interpolant,
	
			evaluate: function( t ) {
	
				var pp = this.parameterPositions,
					i1 = this._cachedIndex,
	
					t1 = pp[   i1   ],
					t0 = pp[ i1 - 1 ];
	
				validate_interval: {
	
					seek: {
	
						var right;
	
						linear_scan: {
		//- See http://jsperf.com/comparison-to-undefined/3
		//- slower code:
		//-
		//- 				if ( t >= t1 || t1 === undefined ) {
							forward_scan: if ( ! ( t < t1 ) ) {
	
								for ( var giveUpAt = i1 + 2; ;) {
	
									if ( t1 === undefined ) {
	
										if ( t < t0 ) break forward_scan;
	
										// after end
	
										i1 = pp.length;
										this._cachedIndex = i1;
										return this.afterEnd_( i1 - 1, t, t0 );
	
									}
	
									if ( i1 === giveUpAt ) break; // this loop
	
									t0 = t1;
									t1 = pp[ ++ i1 ];
	
									if ( t < t1 ) {
	
										// we have arrived at the sought interval
										break seek;
	
									}
	
								}
	
								// prepare binary search on the right side of the index
								right = pp.length;
								break linear_scan;
	
							}
	
		//- slower code:
		//-					if ( t < t0 || t0 === undefined ) {
							if ( ! ( t >= t0 ) ) {
	
								// looping?
	
								var t1global = pp[ 1 ];
	
								if ( t < t1global ) {
	
									i1 = 2; // + 1, using the scan for the details
									t0 = t1global;
	
								}
	
								// linear reverse scan
	
								for ( var giveUpAt = i1 - 2; ;) {
	
									if ( t0 === undefined ) {
	
										// before start
	
										this._cachedIndex = 0;
										return this.beforeStart_( 0, t, t1 );
	
									}
	
									if ( i1 === giveUpAt ) break; // this loop
	
									t1 = t0;
									t0 = pp[ -- i1 - 1 ];
	
									if ( t >= t0 ) {
	
										// we have arrived at the sought interval
										break seek;
	
									}
	
								}
	
								// prepare binary search on the left side of the index
								right = i1;
								i1 = 0;
								break linear_scan;
	
							}
	
							// the interval is valid
	
							break validate_interval;
	
						} // linear scan
	
						// binary search
	
						while ( i1 < right ) {
	
							var mid = ( i1 + right ) >>> 1;
	
							if ( t < pp[ mid ] ) {
	
								right = mid;
	
							} else {
	
								i1 = mid + 1;
	
							}
	
						}
	
						t1 = pp[   i1   ];
						t0 = pp[ i1 - 1 ];
	
						// check boundary cases, again
	
						if ( t0 === undefined ) {
	
							this._cachedIndex = 0;
							return this.beforeStart_( 0, t, t1 );
	
						}
	
						if ( t1 === undefined ) {
	
							i1 = pp.length;
							this._cachedIndex = i1;
							return this.afterEnd_( i1 - 1, t0, t );
	
						}
	
					} // seek
	
					this._cachedIndex = i1;
	
					this.intervalChanged_( i1, t0, t1 );
	
				} // validate_interval
	
				return this.interpolate_( i1, t0, t, t1 );
	
			},
	
			settings: null, // optional, subclass-specific settings structure
			// Note: The indirection allows central control of many interpolants.
	
			// --- Protected interface
	
			DefaultSettings_: {},
	
			getSettings_: function() {
	
				return this.settings || this.DefaultSettings_;
	
			},
	
			copySampleValue_: function( index ) {
	
				// copies a sample value to the result buffer
	
				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
					offset = index * stride;
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					result[ i ] = values[ offset + i ];
	
				}
	
				return result;
	
			},
	
			// Template methods for derived classes:
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				throw new Error( "call to abstract method" );
				// implementations shall return this.resultBuffer
	
			},
	
			intervalChanged_: function( i1, t0, t1 ) {
	
				// empty
	
			}
	
		};
	
		Object.assign( Interpolant.prototype, {
	
			beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
				Interpolant.prototype.copySampleValue_,
	
			afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
				Interpolant.prototype.copySampleValue_
	
		} );
	
		/**
		 * Fast and simple cubic spline interpolant.
		 *
		 * It was derived from a Hermitian construction setting the first derivative
		 * at each sample position to the linear slope between neighboring positions
		 * over their parameter interval.
		 *
		 * @author tschw
		 */
	
		function CubicInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
			this._weightPrev = -0;
			this._offsetPrev = -0;
			this._weightNext = -0;
			this._offsetNext = -0;
	
		}
	
		CubicInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {
	
			constructor: CubicInterpolant,
	
			DefaultSettings_: {
	
				endingStart: 	ZeroCurvatureEnding,
				endingEnd:		ZeroCurvatureEnding
	
			},
	
			intervalChanged_: function( i1, t0, t1 ) {
	
				var pp = this.parameterPositions,
					iPrev = i1 - 2,
					iNext = i1 + 1,
	
					tPrev = pp[ iPrev ],
					tNext = pp[ iNext ];
	
				if ( tPrev === undefined ) {
	
					switch ( this.getSettings_().endingStart ) {
	
						case ZeroSlopeEnding:
	
							// f'(t0) = 0
							iPrev = i1;
							tPrev = 2 * t0 - t1;
	
							break;
	
						case WrapAroundEnding:
	
							// use the other end of the curve
							iPrev = pp.length - 2;
							tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];
	
							break;
	
						default: // ZeroCurvatureEnding
	
							// f''(t0) = 0 a.k.a. Natural Spline
							iPrev = i1;
							tPrev = t1;
	
					}
	
				}
	
				if ( tNext === undefined ) {
	
					switch ( this.getSettings_().endingEnd ) {
	
						case ZeroSlopeEnding:
	
							// f'(tN) = 0
							iNext = i1;
							tNext = 2 * t1 - t0;
	
							break;
	
						case WrapAroundEnding:
	
							// use the other end of the curve
							iNext = 1;
							tNext = t1 + pp[ 1 ] - pp[ 0 ];
	
							break;
	
						default: // ZeroCurvatureEnding
	
							// f''(tN) = 0, a.k.a. Natural Spline
							iNext = i1 - 1;
							tNext = t0;
	
					}
	
				}
	
				var halfDt = ( t1 - t0 ) * 0.5,
					stride = this.valueSize;
	
				this._weightPrev = halfDt / ( t0 - tPrev );
				this._weightNext = halfDt / ( tNext - t1 );
				this._offsetPrev = iPrev * stride;
				this._offsetNext = iNext * stride;
	
			},
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
	
					o1 = i1 * stride,		o0 = o1 - stride,
					oP = this._offsetPrev, 	oN = this._offsetNext,
					wP = this._weightPrev,	wN = this._weightNext,
	
					p = ( t - t0 ) / ( t1 - t0 ),
					pp = p * p,
					ppp = pp * p;
	
				// evaluate polynomials
	
				var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
				var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
				var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
				var sN =       wN   * ppp   -           wN      * pp;
	
				// combine data linearly
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					result[ i ] =
							sP * values[ oP + i ] +
							s0 * values[ o0 + i ] +
							s1 * values[ o1 + i ] +
							sN * values[ oN + i ];
	
				}
	
				return result;
	
			}
	
		} );
	
		/**
		 * @author tschw
		 */
	
		function LinearInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
		}
	
		LinearInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {
	
			constructor: LinearInterpolant,
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
	
					offset1 = i1 * stride,
					offset0 = offset1 - stride,
	
					weight1 = ( t - t0 ) / ( t1 - t0 ),
					weight0 = 1 - weight1;
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					result[ i ] =
							values[ offset0 + i ] * weight0 +
							values[ offset1 + i ] * weight1;
	
				}
	
				return result;
	
			}
	
		} );
	
		/**
		 *
		 * Interpolant that evaluates to the sample value at the position preceeding
		 * the parameter.
		 *
		 * @author tschw
		 */
	
		function DiscreteInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
		}
	
		DiscreteInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {
	
			constructor: DiscreteInterpolant,
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				return this.copySampleValue_( i1 - 1 );
	
			}
	
		} );
	
		var KeyframeTrackPrototype;
	
		KeyframeTrackPrototype = {
	
			TimeBufferType: Float32Array,
			ValueBufferType: Float32Array,
	
			DefaultInterpolation: InterpolateLinear,
	
			InterpolantFactoryMethodDiscrete: function ( result ) {
	
				return new DiscreteInterpolant(
						this.times, this.values, this.getValueSize(), result );
	
			},
	
			InterpolantFactoryMethodLinear: function ( result ) {
	
				return new LinearInterpolant(
						this.times, this.values, this.getValueSize(), result );
	
			},
	
			InterpolantFactoryMethodSmooth: function ( result ) {
	
				return new CubicInterpolant(
						this.times, this.values, this.getValueSize(), result );
	
			},
	
			setInterpolation: function ( interpolation ) {
	
				var factoryMethod;
	
				switch ( interpolation ) {
	
					case InterpolateDiscrete:
	
						factoryMethod = this.InterpolantFactoryMethodDiscrete;
	
						break;
	
					case InterpolateLinear:
	
						factoryMethod = this.InterpolantFactoryMethodLinear;
	
						break;
	
					case InterpolateSmooth:
	
						factoryMethod = this.InterpolantFactoryMethodSmooth;
	
						break;
	
				}
	
				if ( factoryMethod === undefined ) {
	
					var message = "unsupported interpolation for " +
							this.ValueTypeName + " keyframe track named " + this.name;
	
					if ( this.createInterpolant === undefined ) {
	
						// fall back to default, unless the default itself is messed up
						if ( interpolation !== this.DefaultInterpolation ) {
	
							this.setInterpolation( this.DefaultInterpolation );
	
						} else {
	
							throw new Error( message ); // fatal, in this case
	
						}
	
					}
	
					console.warn( message );
					return;
	
				}
	
				this.createInterpolant = factoryMethod;
	
			},
	
			getInterpolation: function () {
	
				switch ( this.createInterpolant ) {
	
					case this.InterpolantFactoryMethodDiscrete:
	
						return InterpolateDiscrete;
	
					case this.InterpolantFactoryMethodLinear:
	
						return InterpolateLinear;
	
					case this.InterpolantFactoryMethodSmooth:
	
						return InterpolateSmooth;
	
				}
	
			},
	
			getValueSize: function () {
	
				return this.values.length / this.times.length;
	
			},
	
			// move all keyframes either forwards or backwards in time
			shift: function ( timeOffset ) {
	
				if ( timeOffset !== 0.0 ) {
	
					var times = this.times;
	
					for ( var i = 0, n = times.length; i !== n; ++ i ) {
	
						times[ i ] += timeOffset;
	
					}
	
				}
	
				return this;
	
			},
	
			// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
			scale: function ( timeScale ) {
	
				if ( timeScale !== 1.0 ) {
	
					var times = this.times;
	
					for ( var i = 0, n = times.length; i !== n; ++ i ) {
	
						times[ i ] *= timeScale;
	
					}
	
				}
	
				return this;
	
			},
	
			// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
			// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
			trim: function ( startTime, endTime ) {
	
				var times = this.times,
					nKeys = times.length,
					from = 0,
					to = nKeys - 1;
	
				while ( from !== nKeys && times[ from ] < startTime ) ++ from;
				while ( to !== - 1 && times[ to ] > endTime ) -- to;
	
				++ to; // inclusive -> exclusive bound
	
				if ( from !== 0 || to !== nKeys ) {
	
					// empty tracks are forbidden, so keep at least one keyframe
					if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;
	
					var stride = this.getValueSize();
					this.times = AnimationUtils.arraySlice( times, from, to );
					this.values = AnimationUtils.
							arraySlice( this.values, from * stride, to * stride );
	
				}
	
				return this;
	
			},
	
			// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
			validate: function () {
	
				var valid = true;
	
				var valueSize = this.getValueSize();
				if ( valueSize - Math.floor( valueSize ) !== 0 ) {
	
					console.error( "invalid value size in track", this );
					valid = false;
	
				}
	
				var times = this.times,
					values = this.values,
	
					nKeys = times.length;
	
				if ( nKeys === 0 ) {
	
					console.error( "track is empty", this );
					valid = false;
	
				}
	
				var prevTime = null;
	
				for ( var i = 0; i !== nKeys; i ++ ) {
	
					var currTime = times[ i ];
	
					if ( typeof currTime === 'number' && isNaN( currTime ) ) {
	
						console.error( "time is not a valid number", this, i, currTime );
						valid = false;
						break;
	
					}
	
					if ( prevTime !== null && prevTime > currTime ) {
	
						console.error( "out of order keys", this, i, currTime, prevTime );
						valid = false;
						break;
	
					}
	
					prevTime = currTime;
	
				}
	
				if ( values !== undefined ) {
	
					if ( AnimationUtils.isTypedArray( values ) ) {
	
						for ( var i = 0, n = values.length; i !== n; ++ i ) {
	
							var value = values[ i ];
	
							if ( isNaN( value ) ) {
	
								console.error( "value is not a valid number", this, i, value );
								valid = false;
								break;
	
							}
	
						}
	
					}
	
				}
	
				return valid;
	
			},
	
			// removes equivalent sequential keys as common in morph target sequences
			// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
			optimize: function () {
	
				var times = this.times,
					values = this.values,
					stride = this.getValueSize(),
	
					smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
	
					writeIndex = 1,
					lastIndex = times.length - 1;
	
				for ( var i = 1; i < lastIndex; ++ i ) {
	
					var keep = false;
	
					var time = times[ i ];
					var timeNext = times[ i + 1 ];
	
					// remove adjacent keyframes scheduled at the same time
	
					if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {
	
						if ( ! smoothInterpolation ) {
	
							// remove unnecessary keyframes same as their neighbors
	
							var offset = i * stride,
								offsetP = offset - stride,
								offsetN = offset + stride;
	
							for ( var j = 0; j !== stride; ++ j ) {
	
								var value = values[ offset + j ];
	
								if ( value !== values[ offsetP + j ] ||
										value !== values[ offsetN + j ] ) {
	
									keep = true;
									break;
	
								}
	
							}
	
						} else keep = true;
	
					}
	
					// in-place compaction
	
					if ( keep ) {
	
						if ( i !== writeIndex ) {
	
							times[ writeIndex ] = times[ i ];
	
							var readOffset = i * stride,
								writeOffset = writeIndex * stride;
	
							for ( var j = 0; j !== stride; ++ j )
	
								values[ writeOffset + j ] = values[ readOffset + j ];
	
						}
	
						++ writeIndex;
	
					}
	
				}
	
				// flush last keyframe (compaction looks ahead)
	
				if ( lastIndex > 0 ) {
	
					times[ writeIndex ] = times[ lastIndex ];
	
					for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )
	
						values[ writeOffset + j ] = values[ readOffset + j ];
	
					++ writeIndex;
	
				}
	
				if ( writeIndex !== times.length ) {
	
					this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
					this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );
	
				}
	
				return this;
	
			}
	
		};
	
		function KeyframeTrackConstructor( name, times, values, interpolation ) {
	
			if( name === undefined ) throw new Error( "track name is undefined" );
	
			if( times === undefined || times.length === 0 ) {
	
				throw new Error( "no keyframes in track named " + name );
	
			}
	
			this.name = name;
	
			this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
			this.values = AnimationUtils.convertArray( values, this.ValueBufferType );
	
			this.setInterpolation( interpolation || this.DefaultInterpolation );
	
			this.validate();
			this.optimize();
	
		}
	
		/**
		 *
		 * A Track of vectored keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function VectorKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		VectorKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: VectorKeyframeTrack,
	
			ValueTypeName: 'vector'
	
			// ValueBufferType is inherited
	
			// DefaultInterpolation is inherited
	
		} );
	
		/**
		 * Spherical linear unit quaternion interpolant.
		 *
		 * @author tschw
		 */
	
		function QuaternionLinearInterpolant(
				parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
			Interpolant.call(
					this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
		}
	
		QuaternionLinearInterpolant.prototype =
				Object.assign( Object.create( Interpolant.prototype ), {
	
			constructor: QuaternionLinearInterpolant,
	
			interpolate_: function( i1, t0, t, t1 ) {
	
				var result = this.resultBuffer,
					values = this.sampleValues,
					stride = this.valueSize,
	
					offset = i1 * stride,
	
					alpha = ( t - t0 ) / ( t1 - t0 );
	
				for ( var end = offset + stride; offset !== end; offset += 4 ) {
	
					Quaternion.slerpFlat( result, 0,
							values, offset - stride, values, offset, alpha );
	
				}
	
				return result;
	
			}
	
		} );
	
		/**
		 *
		 * A Track of quaternion keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function QuaternionKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		QuaternionKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: QuaternionKeyframeTrack,
	
			ValueTypeName: 'quaternion',
	
			// ValueBufferType is inherited
	
			DefaultInterpolation: InterpolateLinear,
	
			InterpolantFactoryMethodLinear: function( result ) {
	
				return new QuaternionLinearInterpolant(
						this.times, this.values, this.getValueSize(), result );
	
			},
	
			InterpolantFactoryMethodSmooth: undefined // not yet implemented
	
		} );
	
		/**
		 *
		 * A Track of numeric keyframe values.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function NumberKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		NumberKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: NumberKeyframeTrack,
	
			ValueTypeName: 'number'
	
			// ValueBufferType is inherited
	
			// DefaultInterpolation is inherited
	
		} );
	
		/**
		 *
		 * A Track that interpolates Strings
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function StringKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		StringKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: StringKeyframeTrack,
	
			ValueTypeName: 'string',
			ValueBufferType: Array,
	
			DefaultInterpolation: InterpolateDiscrete,
	
			InterpolantFactoryMethodLinear: undefined,
	
			InterpolantFactoryMethodSmooth: undefined
	
		} );
	
		/**
		 *
		 * A Track of Boolean keyframe values.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function BooleanKeyframeTrack( name, times, values ) {
	
			KeyframeTrackConstructor.call( this, name, times, values );
	
		}
	
		BooleanKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: BooleanKeyframeTrack,
	
			ValueTypeName: 'bool',
			ValueBufferType: Array,
	
			DefaultInterpolation: InterpolateDiscrete,
	
			InterpolantFactoryMethodLinear: undefined,
			InterpolantFactoryMethodSmooth: undefined
	
			// Note: Actually this track could have a optimized / compressed
			// representation of a single value and a custom interpolant that
			// computes "firstValue ^ isOdd( index )".
	
		} );
	
		/**
		 *
		 * A Track of keyframe values that represent color.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function ColorKeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.call( this, name, times, values, interpolation );
	
		}
	
		ColorKeyframeTrack.prototype =
				Object.assign( Object.create( KeyframeTrackPrototype ), {
	
			constructor: ColorKeyframeTrack,
	
			ValueTypeName: 'color'
	
			// ValueBufferType is inherited
	
			// DefaultInterpolation is inherited
	
	
			// Note: Very basic implementation and nothing special yet.
			// However, this is the place for color space parameterization.
	
		} );
	
		/**
		 *
		 * A timed sequence of keyframes for a specific property.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function KeyframeTrack( name, times, values, interpolation ) {
	
			KeyframeTrackConstructor.apply( this, arguments );
	
		}
	
		KeyframeTrack.prototype = KeyframeTrackPrototype;
		KeyframeTrackPrototype.constructor = KeyframeTrack;
	
		// Static methods:
	
		Object.assign( KeyframeTrack, {
	
			// Serialization (in static context, because of constructor invocation
			// and automatic invocation of .toJSON):
	
			parse: function( json ) {
	
				if( json.type === undefined ) {
	
					throw new Error( "track type undefined, can not parse" );
	
				}
	
				var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );
	
				if ( json.times === undefined ) {
	
					var times = [], values = [];
	
					AnimationUtils.flattenJSON( json.keys, times, values, 'value' );
	
					json.times = times;
					json.values = values;
	
				}
	
				// derived classes can define a static parse method
				if ( trackType.parse !== undefined ) {
	
					return trackType.parse( json );
	
				} else {
	
					// by default, we asssume a constructor compatible with the base
					return new trackType(
							json.name, json.times, json.values, json.interpolation );
	
				}
	
			},
	
			toJSON: function( track ) {
	
				var trackType = track.constructor;
	
				var json;
	
				// derived classes can define a static toJSON method
				if ( trackType.toJSON !== undefined ) {
	
					json = trackType.toJSON( track );
	
				} else {
	
					// by default, we assume the data can be serialized as-is
					json = {
	
						'name': track.name,
						'times': AnimationUtils.convertArray( track.times, Array ),
						'values': AnimationUtils.convertArray( track.values, Array )
	
					};
	
					var interpolation = track.getInterpolation();
	
					if ( interpolation !== track.DefaultInterpolation ) {
	
						json.interpolation = interpolation;
	
					}
	
				}
	
				json.type = track.ValueTypeName; // mandatory
	
				return json;
	
			},
	
			_getTrackTypeForValueTypeName: function( typeName ) {
	
				switch( typeName.toLowerCase() ) {
	
					case "scalar":
					case "double":
					case "float":
					case "number":
					case "integer":
	
						return NumberKeyframeTrack;
	
					case "vector":
					case "vector2":
					case "vector3":
					case "vector4":
	
						return VectorKeyframeTrack;
	
					case "color":
	
						return ColorKeyframeTrack;
	
					case "quaternion":
	
						return QuaternionKeyframeTrack;
	
					case "bool":
					case "boolean":
	
						return BooleanKeyframeTrack;
	
					case "string":
	
						return StringKeyframeTrack;
	
				}
	
				throw new Error( "Unsupported typeName: " + typeName );
	
			}
	
		} );
	
		/**
		 *
		 * Reusable set of Tracks that represent an animation.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 */
	
		function AnimationClip( name, duration, tracks ) {
	
			this.name = name;
			this.tracks = tracks;
			this.duration = ( duration !== undefined ) ? duration : -1;
	
			this.uuid = _Math.generateUUID();
	
			// this means it should figure out its duration by scanning the tracks
			if ( this.duration < 0 ) {
	
				this.resetDuration();
	
			}
	
			this.optimize();
	
		}
	
		AnimationClip.prototype = {
	
			constructor: AnimationClip,
	
			resetDuration: function() {
	
				var tracks = this.tracks,
					duration = 0;
	
				for ( var i = 0, n = tracks.length; i !== n; ++ i ) {
	
					var track = this.tracks[ i ];
	
					duration = Math.max( duration, track.times[ track.times.length - 1 ] );
	
				}
	
				this.duration = duration;
	
			},
	
			trim: function() {
	
				for ( var i = 0; i < this.tracks.length; i ++ ) {
	
					this.tracks[ i ].trim( 0, this.duration );
	
				}
	
				return this;
	
			},
	
			optimize: function() {
	
				for ( var i = 0; i < this.tracks.length; i ++ ) {
	
					this.tracks[ i ].optimize();
	
				}
	
				return this;
	
			}
	
		};
	
		// Static methods:
	
		Object.assign( AnimationClip, {
	
			parse: function( json ) {
	
				var tracks = [],
					jsonTracks = json.tracks,
					frameTime = 1.0 / ( json.fps || 1.0 );
	
				for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {
	
					tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );
	
				}
	
				return new AnimationClip( json.name, json.duration, tracks );
	
			},
	
	
			toJSON: function( clip ) {
	
				var tracks = [],
					clipTracks = clip.tracks;
	
				var json = {
	
					'name': clip.name,
					'duration': clip.duration,
					'tracks': tracks
	
				};
	
				for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {
	
					tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );
	
				}
	
				return json;
	
			},
	
	
			CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {
	
				var numMorphTargets = morphTargetSequence.length;
				var tracks = [];
	
				for ( var i = 0; i < numMorphTargets; i ++ ) {
	
					var times = [];
					var values = [];
	
					times.push(
							( i + numMorphTargets - 1 ) % numMorphTargets,
							i,
							( i + 1 ) % numMorphTargets );
	
					values.push( 0, 1, 0 );
	
					var order = AnimationUtils.getKeyframeOrder( times );
					times = AnimationUtils.sortedArray( times, 1, order );
					values = AnimationUtils.sortedArray( values, 1, order );
	
					// if there is a key at the first frame, duplicate it as the
					// last frame as well for perfect loop.
					if ( ! noLoop && times[ 0 ] === 0 ) {
	
						times.push( numMorphTargets );
						values.push( values[ 0 ] );
	
					}
	
					tracks.push(
							new NumberKeyframeTrack(
								'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
								times, values
							).scale( 1.0 / fps ) );
				}
	
				return new AnimationClip( name, -1, tracks );
	
			},
	
			findByName: function( objectOrClipArray, name ) {
	
				var clipArray = objectOrClipArray;
	
				if ( ! Array.isArray( objectOrClipArray ) ) {
	
					var o = objectOrClipArray;
					clipArray = o.geometry && o.geometry.animations || o.animations;
	
				}
	
				for ( var i = 0; i < clipArray.length; i ++ ) {
	
					if ( clipArray[ i ].name === name ) {
	
						return clipArray[ i ];
	
					}
				}
	
				return null;
	
			},
	
			CreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {
	
				var animationToMorphTargets = {};
	
				// tested with https://regex101.com/ on trick sequences
				// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
				var pattern = /^([\w-]*?)([\d]+)$/;
	
				// sort morph target names into animation groups based
				// patterns like Walk_001, Walk_002, Run_001, Run_002
				for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {
	
					var morphTarget = morphTargets[ i ];
					var parts = morphTarget.name.match( pattern );
	
					if ( parts && parts.length > 1 ) {
	
						var name = parts[ 1 ];
	
						var animationMorphTargets = animationToMorphTargets[ name ];
						if ( ! animationMorphTargets ) {
	
							animationToMorphTargets[ name ] = animationMorphTargets = [];
	
						}
	
						animationMorphTargets.push( morphTarget );
	
					}
	
				}
	
				var clips = [];
	
				for ( var name in animationToMorphTargets ) {
	
					clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );
	
				}
	
				return clips;
	
			},
	
			// parse the animation.hierarchy format
			parseAnimation: function( animation, bones ) {
	
				if ( ! animation ) {
	
					console.error( "  no animation in JSONLoader data" );
					return null;
	
				}
	
				var addNonemptyTrack = function(
						trackType, trackName, animationKeys, propertyName, destTracks ) {
	
					// only return track if there are actually keys.
					if ( animationKeys.length !== 0 ) {
	
						var times = [];
						var values = [];
	
						AnimationUtils.flattenJSON(
								animationKeys, times, values, propertyName );
	
						// empty keys are filtered out, so check again
						if ( times.length !== 0 ) {
	
							destTracks.push( new trackType( trackName, times, values ) );
	
						}
	
					}
	
				};
	
				var tracks = [];
	
				var clipName = animation.name || 'default';
				// automatic length determination in AnimationClip.
				var duration = animation.length || -1;
				var fps = animation.fps || 30;
	
				var hierarchyTracks = animation.hierarchy || [];
	
				for ( var h = 0; h < hierarchyTracks.length; h ++ ) {
	
					var animationKeys = hierarchyTracks[ h ].keys;
	
					// skip empty tracks
					if ( ! animationKeys || animationKeys.length === 0 ) continue;
	
					// process morph targets in a way exactly compatible
					// with AnimationHandler.init( animation )
					if ( animationKeys[0].morphTargets ) {
	
						// figure out all morph targets used in this track
						var morphTargetNames = {};
						for ( var k = 0; k < animationKeys.length; k ++ ) {
	
							if ( animationKeys[k].morphTargets ) {
	
								for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {
	
									morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
								}
	
							}
	
						}
	
						// create a track for each morph target with all zero
						// morphTargetInfluences except for the keys in which
						// the morphTarget is named.
						for ( var morphTargetName in morphTargetNames ) {
	
							var times = [];
							var values = [];
	
							for ( var m = 0; m !== animationKeys[k].morphTargets.length; ++ m ) {
	
								var animationKey = animationKeys[k];
	
								times.push( animationKey.time );
								values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );
	
							}
	
							tracks.push( new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values ) );
	
						}
	
						duration = morphTargetNames.length * ( fps || 1.0 );
	
					} else {
						// ...assume skeletal animation
	
						var boneName = '.bones[' + bones[ h ].name + ']';
	
						addNonemptyTrack(
								VectorKeyframeTrack, boneName + '.position',
								animationKeys, 'pos', tracks );
	
						addNonemptyTrack(
								QuaternionKeyframeTrack, boneName + '.quaternion',
								animationKeys, 'rot', tracks );
	
						addNonemptyTrack(
								VectorKeyframeTrack, boneName + '.scale',
								animationKeys, 'scl', tracks );
	
					}
	
				}
	
				if ( tracks.length === 0 ) {
	
					return null;
	
				}
	
				var clip = new AnimationClip( clipName, duration, tracks );
	
				return clip;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function MaterialLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
			this.textures = {};
	
		}
	
		Object.assign( MaterialLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var loader = new FileLoader( scope.manager );
				loader.load( url, function ( text ) {
	
					onLoad( scope.parse( JSON.parse( text ) ) );
	
				}, onProgress, onError );
	
			},
	
			setTextures: function ( value ) {
	
				this.textures = value;
	
			},
	
			parse: function ( json ) {
	
				var textures = this.textures;
	
				function getTexture( name ) {
	
					if ( textures[ name ] === undefined ) {
	
						console.warn( 'THREE.MaterialLoader: Undefined texture', name );
	
					}
	
					return textures[ name ];
	
				}
	
				var material = new Materials[ json.type ]();
	
				if ( json.uuid !== undefined ) material.uuid = json.uuid;
				if ( json.name !== undefined ) material.name = json.name;
				if ( json.color !== undefined ) material.color.setHex( json.color );
				if ( json.roughness !== undefined ) material.roughness = json.roughness;
				if ( json.metalness !== undefined ) material.metalness = json.metalness;
				if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
				if ( json.specular !== undefined ) material.specular.setHex( json.specular );
				if ( json.shininess !== undefined ) material.shininess = json.shininess;
				if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
				if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
				if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
				if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
				if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
				if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
				if ( json.fog !== undefined ) material.fog = json.fog;
				if ( json.shading !== undefined ) material.shading = json.shading;
				if ( json.blending !== undefined ) material.blending = json.blending;
				if ( json.side !== undefined ) material.side = json.side;
				if ( json.opacity !== undefined ) material.opacity = json.opacity;
				if ( json.transparent !== undefined ) material.transparent = json.transparent;
				if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
				if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
				if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
				if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
				if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
				if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
				if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
				if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
				if ( json.skinning !== undefined ) material.skinning = json.skinning;
				if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
	
				// for PointsMaterial
	
				if ( json.size !== undefined ) material.size = json.size;
				if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;
	
				// maps
	
				if ( json.map !== undefined ) material.map = getTexture( json.map );
	
				if ( json.alphaMap !== undefined ) {
	
					material.alphaMap = getTexture( json.alphaMap );
					material.transparent = true;
	
				}
	
				if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
				if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;
	
				if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
				if ( json.normalScale !== undefined ) {
	
					var normalScale = json.normalScale;
	
					if ( Array.isArray( normalScale ) === false ) {
	
						// Blender exporter used to export a scalar. See #7459
	
						normalScale = [ normalScale, normalScale ];
	
					}
	
					material.normalScale = new Vector2().fromArray( normalScale );
	
				}
	
				if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
				if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
				if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;
	
				if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
				if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );
	
				if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
				if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;
	
				if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );
	
				if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
	
				if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
	
				if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
				if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;
	
				if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
				if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;
	
				if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );
	
				// MultiMaterial
	
				if ( json.materials !== undefined ) {
	
					for ( var i = 0, l = json.materials.length; i < l; i ++ ) {
	
						material.materials.push( this.parse( json.materials[ i ] ) );
	
					}
	
				}
	
				return material;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function BufferGeometryLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( BufferGeometryLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var loader = new FileLoader( scope.manager );
				loader.load( url, function ( text ) {
	
					onLoad( scope.parse( JSON.parse( text ) ) );
	
				}, onProgress, onError );
	
			},
	
			parse: function ( json ) {
	
				var geometry = new BufferGeometry();
	
				var index = json.data.index;
	
				var TYPED_ARRAYS = {
					'Int8Array': Int8Array,
					'Uint8Array': Uint8Array,
					'Uint8ClampedArray': Uint8ClampedArray,
					'Int16Array': Int16Array,
					'Uint16Array': Uint16Array,
					'Int32Array': Int32Array,
					'Uint32Array': Uint32Array,
					'Float32Array': Float32Array,
					'Float64Array': Float64Array
				};
	
				if ( index !== undefined ) {
	
					var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
					geometry.setIndex( new BufferAttribute( typedArray, 1 ) );
	
				}
	
				var attributes = json.data.attributes;
	
				for ( var key in attributes ) {
	
					var attribute = attributes[ key ];
					var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );
	
					geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );
	
				}
	
				var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
	
				if ( groups !== undefined ) {
	
					for ( var i = 0, n = groups.length; i !== n; ++ i ) {
	
						var group = groups[ i ];
	
						geometry.addGroup( group.start, group.count, group.materialIndex );
	
					}
	
				}
	
				var boundingSphere = json.data.boundingSphere;
	
				if ( boundingSphere !== undefined ) {
	
					var center = new Vector3();
	
					if ( boundingSphere.center !== undefined ) {
	
						center.fromArray( boundingSphere.center );
	
					}
	
					geometry.boundingSphere = new Sphere( center, boundingSphere.radius );
	
				}
	
				return geometry;
	
			}
	
		} );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Loader() {
	
			this.onLoadStart = function () {};
			this.onLoadProgress = function () {};
			this.onLoadComplete = function () {};
	
		}
	
		Loader.prototype = {
	
			constructor: Loader,
	
			crossOrigin: undefined,
	
			extractUrlBase: function ( url ) {
	
				var parts = url.split( '/' );
	
				if ( parts.length === 1 ) return './';
	
				parts.pop();
	
				return parts.join( '/' ) + '/';
	
			},
	
			initMaterials: function ( materials, texturePath, crossOrigin ) {
	
				var array = [];
	
				for ( var i = 0; i < materials.length; ++ i ) {
	
					array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );
	
				}
	
				return array;
	
			},
	
			createMaterial: ( function () {
	
				var BlendingMode = {
					NoBlending: NoBlending,
					NormalBlending: NormalBlending,
					AdditiveBlending: AdditiveBlending,
					SubtractiveBlending: SubtractiveBlending,
					MultiplyBlending: MultiplyBlending,
					CustomBlending: CustomBlending
				};
	
				var color, textureLoader, materialLoader;
	
				return function createMaterial( m, texturePath, crossOrigin ) {
	
					if ( color === undefined ) color = new Color();
					if ( textureLoader === undefined ) textureLoader = new TextureLoader();
					if ( materialLoader === undefined ) materialLoader = new MaterialLoader();
	
					// convert from old material format
	
					var textures = {};
	
					function loadTexture( path, repeat, offset, wrap, anisotropy ) {
	
						var fullPath = texturePath + path;
						var loader = Loader.Handlers.get( fullPath );
	
						var texture;
	
						if ( loader !== null ) {
	
							texture = loader.load( fullPath );
	
						} else {
	
							textureLoader.setCrossOrigin( crossOrigin );
							texture = textureLoader.load( fullPath );
	
						}
	
						if ( repeat !== undefined ) {
	
							texture.repeat.fromArray( repeat );
	
							if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
							if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;
	
						}
	
						if ( offset !== undefined ) {
	
							texture.offset.fromArray( offset );
	
						}
	
						if ( wrap !== undefined ) {
	
							if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
							if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;
	
							if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
							if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;
	
						}
	
						if ( anisotropy !== undefined ) {
	
							texture.anisotropy = anisotropy;
	
						}
	
						var uuid = _Math.generateUUID();
	
						textures[ uuid ] = texture;
	
						return uuid;
	
					}
	
					//
	
					var json = {
						uuid: _Math.generateUUID(),
						type: 'MeshLambertMaterial'
					};
	
					for ( var name in m ) {
	
						var value = m[ name ];
	
						switch ( name ) {
	
							case 'DbgColor':
							case 'DbgIndex':
							case 'opticalDensity':
							case 'illumination':
								break;
							case 'DbgName':
								json.name = value;
								break;
							case 'blending':
								json.blending = BlendingMode[ value ];
								break;
							case 'colorAmbient':
							case 'mapAmbient':
								console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
								break;
							case 'colorDiffuse':
								json.color = color.fromArray( value ).getHex();
								break;
							case 'colorSpecular':
								json.specular = color.fromArray( value ).getHex();
								break;
							case 'colorEmissive':
								json.emissive = color.fromArray( value ).getHex();
								break;
							case 'specularCoef':
								json.shininess = value;
								break;
							case 'shading':
								if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
								if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
								if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
								break;
							case 'mapDiffuse':
								json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
								break;
							case 'mapDiffuseRepeat':
							case 'mapDiffuseOffset':
							case 'mapDiffuseWrap':
							case 'mapDiffuseAnisotropy':
								break;
							case 'mapEmissive':
								json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
								break;
							case 'mapEmissiveRepeat':
							case 'mapEmissiveOffset':
							case 'mapEmissiveWrap':
							case 'mapEmissiveAnisotropy':
								break;
							case 'mapLight':
								json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
								break;
							case 'mapLightRepeat':
							case 'mapLightOffset':
							case 'mapLightWrap':
							case 'mapLightAnisotropy':
								break;
							case 'mapAO':
								json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
								break;
							case 'mapAORepeat':
							case 'mapAOOffset':
							case 'mapAOWrap':
							case 'mapAOAnisotropy':
								break;
							case 'mapBump':
								json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
								break;
							case 'mapBumpScale':
								json.bumpScale = value;
								break;
							case 'mapBumpRepeat':
							case 'mapBumpOffset':
							case 'mapBumpWrap':
							case 'mapBumpAnisotropy':
								break;
							case 'mapNormal':
								json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
								break;
							case 'mapNormalFactor':
								json.normalScale = [ value, value ];
								break;
							case 'mapNormalRepeat':
							case 'mapNormalOffset':
							case 'mapNormalWrap':
							case 'mapNormalAnisotropy':
								break;
							case 'mapSpecular':
								json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
								break;
							case 'mapSpecularRepeat':
							case 'mapSpecularOffset':
							case 'mapSpecularWrap':
							case 'mapSpecularAnisotropy':
								break;
							case 'mapMetalness':
								json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
								break;
							case 'mapMetalnessRepeat':
							case 'mapMetalnessOffset':
							case 'mapMetalnessWrap':
							case 'mapMetalnessAnisotropy':
								break;
							case 'mapRoughness':
								json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
								break;
							case 'mapRoughnessRepeat':
							case 'mapRoughnessOffset':
							case 'mapRoughnessWrap':
							case 'mapRoughnessAnisotropy':
								break;
							case 'mapAlpha':
								json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
								break;
							case 'mapAlphaRepeat':
							case 'mapAlphaOffset':
							case 'mapAlphaWrap':
							case 'mapAlphaAnisotropy':
								break;
							case 'flipSided':
								json.side = BackSide;
								break;
							case 'doubleSided':
								json.side = DoubleSide;
								break;
							case 'transparency':
								console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
								json.opacity = value;
								break;
							case 'depthTest':
							case 'depthWrite':
							case 'colorWrite':
							case 'opacity':
							case 'reflectivity':
							case 'transparent':
							case 'visible':
							case 'wireframe':
								json[ name ] = value;
								break;
							case 'vertexColors':
								if ( value === true ) json.vertexColors = VertexColors;
								if ( value === 'face' ) json.vertexColors = FaceColors;
								break;
							default:
								console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
								break;
	
						}
	
					}
	
					if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
					if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;
	
					if ( json.opacity < 1 ) json.transparent = true;
	
					materialLoader.setTextures( textures );
	
					return materialLoader.parse( json );
	
				};
	
			} )()
	
		};
	
		Loader.Handlers = {
	
			handlers: [],
	
			add: function ( regex, loader ) {
	
				this.handlers.push( regex, loader );
	
			},
	
			get: function ( file ) {
	
				var handlers = this.handlers;
	
				for ( var i = 0, l = handlers.length; i < l; i += 2 ) {
	
					var regex = handlers[ i ];
					var loader = handlers[ i + 1 ];
	
					if ( regex.test( file ) ) {
	
						return loader;
	
					}
	
				}
	
				return null;
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function JSONLoader( manager ) {
	
			if ( typeof manager === 'boolean' ) {
	
				console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
				manager = undefined;
	
			}
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
			this.withCredentials = false;
	
		}
	
		Object.assign( JSONLoader.prototype, {
	
			load: function( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );
	
				var loader = new FileLoader( this.manager );
				loader.setWithCredentials( this.withCredentials );
				loader.load( url, function ( text ) {
	
					var json = JSON.parse( text );
					var metadata = json.metadata;
	
					if ( metadata !== undefined ) {
	
						var type = metadata.type;
	
						if ( type !== undefined ) {
	
							if ( type.toLowerCase() === 'object' ) {
	
								console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
								return;
	
							}
	
							if ( type.toLowerCase() === 'scene' ) {
	
								console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
								return;
	
							}
	
						}
	
					}
	
					var object = scope.parse( json, texturePath );
					onLoad( object.geometry, object.materials );
	
				}, onProgress, onError );
	
			},
	
			setTexturePath: function ( value ) {
	
				this.texturePath = value;
	
			},
	
			parse: function ( json, texturePath ) {
	
				var geometry = new Geometry(),
				scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;
	
				parseModel( scale );
	
				parseSkin();
				parseMorphing( scale );
				parseAnimations();
	
				geometry.computeFaceNormals();
				geometry.computeBoundingSphere();
	
				function parseModel( scale ) {
	
					function isBitSet( value, position ) {
	
						return value & ( 1 << position );
	
					}
	
					var i, j, fi,
	
					offset, zLength,
	
				colorIndex, normalIndex, uvIndex, materialIndex,
	
					type,
					isQuad,
					hasMaterial,
					hasFaceVertexUv,
					hasFaceNormal, hasFaceVertexNormal,
					hasFaceColor, hasFaceVertexColor,
	
				vertex, face, faceA, faceB, hex, normal,
	
					uvLayer, uv, u, v,
	
					faces = json.faces,
					vertices = json.vertices,
					normals = json.normals,
					colors = json.colors,
	
					nUvLayers = 0;
	
					if ( json.uvs !== undefined ) {
	
						// disregard empty arrays
	
						for ( i = 0; i < json.uvs.length; i ++ ) {
	
							if ( json.uvs[ i ].length ) nUvLayers ++;
	
						}
	
						for ( i = 0; i < nUvLayers; i ++ ) {
	
							geometry.faceVertexUvs[ i ] = [];
	
						}
	
					}
	
					offset = 0;
					zLength = vertices.length;
	
					while ( offset < zLength ) {
	
						vertex = new Vector3();
	
						vertex.x = vertices[ offset ++ ] * scale;
						vertex.y = vertices[ offset ++ ] * scale;
						vertex.z = vertices[ offset ++ ] * scale;
	
						geometry.vertices.push( vertex );
	
					}
	
					offset = 0;
					zLength = faces.length;
	
					while ( offset < zLength ) {
	
						type = faces[ offset ++ ];
	
	
						isQuad              = isBitSet( type, 0 );
						hasMaterial         = isBitSet( type, 1 );
						hasFaceVertexUv     = isBitSet( type, 3 );
						hasFaceNormal       = isBitSet( type, 4 );
						hasFaceVertexNormal = isBitSet( type, 5 );
						hasFaceColor	     = isBitSet( type, 6 );
						hasFaceVertexColor  = isBitSet( type, 7 );
	
						// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);
	
						if ( isQuad ) {
	
							faceA = new Face3();
							faceA.a = faces[ offset ];
							faceA.b = faces[ offset + 1 ];
							faceA.c = faces[ offset + 3 ];
	
							faceB = new Face3();
							faceB.a = faces[ offset + 1 ];
							faceB.b = faces[ offset + 2 ];
							faceB.c = faces[ offset + 3 ];
	
							offset += 4;
	
							if ( hasMaterial ) {
	
								materialIndex = faces[ offset ++ ];
								faceA.materialIndex = materialIndex;
								faceB.materialIndex = materialIndex;
	
							}
	
							// to get face <=> uv index correspondence
	
							fi = geometry.faces.length;
	
							if ( hasFaceVertexUv ) {
	
								for ( i = 0; i < nUvLayers; i ++ ) {
	
									uvLayer = json.uvs[ i ];
	
									geometry.faceVertexUvs[ i ][ fi ] = [];
									geometry.faceVertexUvs[ i ][ fi + 1 ] = [];
	
									for ( j = 0; j < 4; j ++ ) {
	
										uvIndex = faces[ offset ++ ];
	
										u = uvLayer[ uvIndex * 2 ];
										v = uvLayer[ uvIndex * 2 + 1 ];
	
										uv = new Vector2( u, v );
	
										if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
										if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );
	
									}
	
								}
	
							}
	
							if ( hasFaceNormal ) {
	
								normalIndex = faces[ offset ++ ] * 3;
	
								faceA.normal.set(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
	
								faceB.normal.copy( faceA.normal );
	
							}
	
							if ( hasFaceVertexNormal ) {
	
								for ( i = 0; i < 4; i ++ ) {
	
									normalIndex = faces[ offset ++ ] * 3;
	
									normal = new Vector3(
										normals[ normalIndex ++ ],
										normals[ normalIndex ++ ],
										normals[ normalIndex ]
									);
	
	
									if ( i !== 2 ) faceA.vertexNormals.push( normal );
									if ( i !== 0 ) faceB.vertexNormals.push( normal );
	
								}
	
							}
	
	
							if ( hasFaceColor ) {
	
								colorIndex = faces[ offset ++ ];
								hex = colors[ colorIndex ];
	
								faceA.color.setHex( hex );
								faceB.color.setHex( hex );
	
							}
	
	
							if ( hasFaceVertexColor ) {
	
								for ( i = 0; i < 4; i ++ ) {
	
									colorIndex = faces[ offset ++ ];
									hex = colors[ colorIndex ];
	
									if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
									if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );
	
								}
	
							}
	
							geometry.faces.push( faceA );
							geometry.faces.push( faceB );
	
						} else {
	
							face = new Face3();
							face.a = faces[ offset ++ ];
							face.b = faces[ offset ++ ];
							face.c = faces[ offset ++ ];
	
							if ( hasMaterial ) {
	
								materialIndex = faces[ offset ++ ];
								face.materialIndex = materialIndex;
	
							}
	
							// to get face <=> uv index correspondence
	
							fi = geometry.faces.length;
	
							if ( hasFaceVertexUv ) {
	
								for ( i = 0; i < nUvLayers; i ++ ) {
	
									uvLayer = json.uvs[ i ];
	
									geometry.faceVertexUvs[ i ][ fi ] = [];
	
									for ( j = 0; j < 3; j ++ ) {
	
										uvIndex = faces[ offset ++ ];
	
										u = uvLayer[ uvIndex * 2 ];
										v = uvLayer[ uvIndex * 2 + 1 ];
	
										uv = new Vector2( u, v );
	
										geometry.faceVertexUvs[ i ][ fi ].push( uv );
	
									}
	
								}
	
							}
	
							if ( hasFaceNormal ) {
	
								normalIndex = faces[ offset ++ ] * 3;
	
								face.normal.set(
									normals[ normalIndex ++ ],
									normals[ normalIndex ++ ],
									normals[ normalIndex ]
								);
	
							}
	
							if ( hasFaceVertexNormal ) {
	
								for ( i = 0; i < 3; i ++ ) {
	
									normalIndex = faces[ offset ++ ] * 3;
	
									normal = new Vector3(
										normals[ normalIndex ++ ],
										normals[ normalIndex ++ ],
										normals[ normalIndex ]
									);
	
									face.vertexNormals.push( normal );
	
								}
	
							}
	
	
							if ( hasFaceColor ) {
	
								colorIndex = faces[ offset ++ ];
								face.color.setHex( colors[ colorIndex ] );
	
							}
	
	
							if ( hasFaceVertexColor ) {
	
								for ( i = 0; i < 3; i ++ ) {
	
									colorIndex = faces[ offset ++ ];
									face.vertexColors.push( new Color( colors[ colorIndex ] ) );
	
								}
	
							}
	
							geometry.faces.push( face );
	
						}
	
					}
	
				}
	
				function parseSkin() {
	
					var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;
	
					if ( json.skinWeights ) {
	
						for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {
	
							var x =                               json.skinWeights[ i ];
							var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
							var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
							var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;
	
							geometry.skinWeights.push( new Vector4( x, y, z, w ) );
	
						}
	
					}
	
					if ( json.skinIndices ) {
	
						for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {
	
							var a =                               json.skinIndices[ i ];
							var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
							var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
							var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;
	
							geometry.skinIndices.push( new Vector4( a, b, c, d ) );
	
						}
	
					}
	
					geometry.bones = json.bones;
	
					if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {
	
						console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
							geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );
	
					}
	
				}
	
				function parseMorphing( scale ) {
	
					if ( json.morphTargets !== undefined ) {
	
						for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {
	
							geometry.morphTargets[ i ] = {};
							geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
							geometry.morphTargets[ i ].vertices = [];
	
							var dstVertices = geometry.morphTargets[ i ].vertices;
							var srcVertices = json.morphTargets[ i ].vertices;
	
							for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {
	
								var vertex = new Vector3();
								vertex.x = srcVertices[ v ] * scale;
								vertex.y = srcVertices[ v + 1 ] * scale;
								vertex.z = srcVertices[ v + 2 ] * scale;
	
								dstVertices.push( vertex );
	
							}
	
						}
	
					}
	
					if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {
	
						console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );
	
						var faces = geometry.faces;
						var morphColors = json.morphColors[ 0 ].colors;
	
						for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
							faces[ i ].color.fromArray( morphColors, i * 3 );
	
						}
	
					}
	
				}
	
				function parseAnimations() {
	
					var outputAnimations = [];
	
					// parse old style Bone/Hierarchy animations
					var animations = [];
	
					if ( json.animation !== undefined ) {
	
						animations.push( json.animation );
	
					}
	
					if ( json.animations !== undefined ) {
	
						if ( json.animations.length ) {
	
							animations = animations.concat( json.animations );
	
						} else {
	
							animations.push( json.animations );
	
						}
	
					}
	
					for ( var i = 0; i < animations.length; i ++ ) {
	
						var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
						if ( clip ) outputAnimations.push( clip );
	
					}
	
					// parse implicit morph animations
					if ( geometry.morphTargets ) {
	
						// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
						var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
						outputAnimations = outputAnimations.concat( morphAnimationClips );
	
					}
	
					if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;
	
				}
	
				if ( json.materials === undefined || json.materials.length === 0 ) {
	
					return { geometry: geometry };
	
				} else {
	
					var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );
	
					return { geometry: geometry, materials: materials };
	
				}
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function ObjectLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
			this.texturePath = '';
	
		}
	
		Object.assign( ObjectLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				if ( this.texturePath === '' ) {
	
					this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );
	
				}
	
				var scope = this;
	
				var loader = new FileLoader( scope.manager );
				loader.load( url, function ( text ) {
	
					var json = null;
	
					try {
	
						json = JSON.parse( text );
	
					} catch ( error ) {
	
						if ( onError !== undefined ) onError( error );
	
						console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );
	
						return;
	
					}
	
					var metadata = json.metadata;
	
					if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {
	
						console.error( 'THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.' );
						return;
	
					}
	
					scope.parse( json, onLoad );
	
				}, onProgress, onError );
	
			},
	
			setTexturePath: function ( value ) {
	
				this.texturePath = value;
	
			},
	
			setCrossOrigin: function ( value ) {
	
				this.crossOrigin = value;
	
			},
	
			parse: function ( json, onLoad ) {
	
				var geometries = this.parseGeometries( json.geometries );
	
				var images = this.parseImages( json.images, function () {
	
					if ( onLoad !== undefined ) onLoad( object );
	
				} );
	
				var textures = this.parseTextures( json.textures, images );
				var materials = this.parseMaterials( json.materials, textures );
	
				var object = this.parseObject( json.object, geometries, materials );
	
				if ( json.animations ) {
	
					object.animations = this.parseAnimations( json.animations );
	
				}
	
				if ( json.images === undefined || json.images.length === 0 ) {
	
					if ( onLoad !== undefined ) onLoad( object );
	
				}
	
				return object;
	
			},
	
			parseGeometries: function ( json ) {
	
				var geometries = {};
	
				if ( json !== undefined ) {
	
					var geometryLoader = new JSONLoader();
					var bufferGeometryLoader = new BufferGeometryLoader();
	
					for ( var i = 0, l = json.length; i < l; i ++ ) {
	
						var geometry;
						var data = json[ i ];
	
						switch ( data.type ) {
	
							case 'PlaneGeometry':
							case 'PlaneBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.width,
									data.height,
									data.widthSegments,
									data.heightSegments
								);
	
								break;
	
							case 'BoxGeometry':
							case 'BoxBufferGeometry':
							case 'CubeGeometry': // backwards compatible
	
								geometry = new Geometries[ data.type ](
									data.width,
									data.height,
									data.depth,
									data.widthSegments,
									data.heightSegments,
									data.depthSegments
								);
	
								break;
	
							case 'CircleGeometry':
							case 'CircleBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.segments,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'CylinderGeometry':
							case 'CylinderBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radiusTop,
									data.radiusBottom,
									data.height,
									data.radialSegments,
									data.heightSegments,
									data.openEnded,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'ConeGeometry':
							case 'ConeBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.height,
									data.radialSegments,
									data.heightSegments,
									data.openEnded,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'SphereGeometry':
							case 'SphereBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.widthSegments,
									data.heightSegments,
									data.phiStart,
									data.phiLength,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'DodecahedronGeometry':
							case 'IcosahedronGeometry':
							case 'OctahedronGeometry':
							case 'TetrahedronGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.detail
								);
	
								break;
	
							case 'RingGeometry':
							case 'RingBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.innerRadius,
									data.outerRadius,
									data.thetaSegments,
									data.phiSegments,
									data.thetaStart,
									data.thetaLength
								);
	
								break;
	
							case 'TorusGeometry':
							case 'TorusBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.tube,
									data.radialSegments,
									data.tubularSegments,
									data.arc
								);
	
								break;
	
							case 'TorusKnotGeometry':
							case 'TorusKnotBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.radius,
									data.tube,
									data.tubularSegments,
									data.radialSegments,
									data.p,
									data.q
								);
	
								break;
	
							case 'LatheGeometry':
							case 'LatheBufferGeometry':
	
								geometry = new Geometries[ data.type ](
									data.points,
									data.segments,
									data.phiStart,
									data.phiLength
								);
	
								break;
	
							case 'BufferGeometry':
	
								geometry = bufferGeometryLoader.parse( data );
	
								break;
	
							case 'Geometry':
	
								geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;
	
								break;
	
							default:
	
								console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );
	
								continue;
	
						}
	
						geometry.uuid = data.uuid;
	
						if ( data.name !== undefined ) geometry.name = data.name;
	
						geometries[ data.uuid ] = geometry;
	
					}
	
				}
	
				return geometries;
	
			},
	
			parseMaterials: function ( json, textures ) {
	
				var materials = {};
	
				if ( json !== undefined ) {
	
					var loader = new MaterialLoader();
					loader.setTextures( textures );
	
					for ( var i = 0, l = json.length; i < l; i ++ ) {
	
						var material = loader.parse( json[ i ] );
						materials[ material.uuid ] = material;
	
					}
	
				}
	
				return materials;
	
			},
	
			parseAnimations: function ( json ) {
	
				var animations = [];
	
				for ( var i = 0; i < json.length; i ++ ) {
	
					var clip = AnimationClip.parse( json[ i ] );
	
					animations.push( clip );
	
				}
	
				return animations;
	
			},
	
			parseImages: function ( json, onLoad ) {
	
				var scope = this;
				var images = {};
	
				function loadImage( url ) {
	
					scope.manager.itemStart( url );
	
					return loader.load( url, function () {
	
						scope.manager.itemEnd( url );
	
					}, undefined, function () {
	
						scope.manager.itemError( url );
	
					} );
	
				}
	
				if ( json !== undefined && json.length > 0 ) {
	
					var manager = new LoadingManager( onLoad );
	
					var loader = new ImageLoader( manager );
					loader.setCrossOrigin( this.crossOrigin );
	
					for ( var i = 0, l = json.length; i < l; i ++ ) {
	
						var image = json[ i ];
						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;
	
						images[ image.uuid ] = loadImage( path );
	
					}
	
				}
	
				return images;
	
			},
	
			parseTextures: function ( json, images ) {
	
				var TextureMapping = {
					UVMapping: UVMapping,
					CubeReflectionMapping: CubeReflectionMapping,
					CubeRefractionMapping: CubeRefractionMapping,
					EquirectangularReflectionMapping: EquirectangularReflectionMapping,
					EquirectangularRefractionMapping: EquirectangularRefractionMapping,
					SphericalReflectionMapping: SphericalReflectionMapping,
					CubeUVReflectionMapping: CubeUVReflectionMapping,
					CubeUVRefractionMapping: CubeUVRefractionMapping
				};
	
				var TextureWrapping = {
					RepeatWrapping: RepeatWrapping,
					ClampToEdgeWrapping: ClampToEdgeWrapping,
					MirroredRepeatWrapping: MirroredRepeatWrapping
				};
	
				var TextureFilter = {
					NearestFilter: NearestFilter,
					NearestMipMapNearestFilter: NearestMipMapNearestFilter,
					NearestMipMapLinearFilter: NearestMipMapLinearFilter,
					LinearFilter: LinearFilter,
					LinearMipMapNearestFilter: LinearMipMapNearestFilter,
					LinearMipMapLinearFilter: LinearMipMapLinearFilter
				};
	
				function parseConstant( value, type ) {
	
					if ( typeof( value ) === 'number' ) return value;
	
					console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );
	
					return type[ value ];
	
				}
	
				var textures = {};
	
				if ( json !== undefined ) {
	
					for ( var i = 0, l = json.length; i < l; i ++ ) {
	
						var data = json[ i ];
	
						if ( data.image === undefined ) {
	
							console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );
	
						}
	
						if ( images[ data.image ] === undefined ) {
	
							console.warn( 'THREE.ObjectLoader: Undefined image', data.image );
	
						}
	
						var texture = new Texture( images[ data.image ] );
						texture.needsUpdate = true;
	
						texture.uuid = data.uuid;
	
						if ( data.name !== undefined ) texture.name = data.name;
	
						if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );
	
						if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
						if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
						if ( data.wrap !== undefined ) {
	
							texture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );
							texture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );
	
						}
	
						if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );
						if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );
						if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
	
						if ( data.flipY !== undefined ) texture.flipY = data.flipY;
	
						textures[ data.uuid ] = texture;
	
					}
	
				}
	
				return textures;
	
			},
	
			parseObject: function () {
	
				var matrix = new Matrix4();
	
				return function parseObject( data, geometries, materials ) {
	
					var object;
	
					function getGeometry( name ) {
	
						if ( geometries[ name ] === undefined ) {
	
							console.warn( 'THREE.ObjectLoader: Undefined geometry', name );
	
						}
	
						return geometries[ name ];
	
					}
	
					function getMaterial( name ) {
	
						if ( name === undefined ) return undefined;
	
						if ( materials[ name ] === undefined ) {
	
							console.warn( 'THREE.ObjectLoader: Undefined material', name );
	
						}
	
						return materials[ name ];
	
					}
	
					switch ( data.type ) {
	
						case 'Scene':
	
							object = new Scene();
	
							if ( data.background !== undefined ) {
	
								if ( Number.isInteger( data.background ) ) {
	
									object.background = new Color( data.background );
	
								}
	
							}
	
							if ( data.fog !== undefined ) {
	
								if ( data.fog.type === 'Fog' ) {
	
									object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );
	
								} else if ( data.fog.type === 'FogExp2' ) {
	
									object.fog = new FogExp2( data.fog.color, data.fog.density );
	
								}
	
							}
	
							break;
	
						case 'PerspectiveCamera':
	
							object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );
	
							if ( data.focus !== undefined ) object.focus = data.focus;
							if ( data.zoom !== undefined ) object.zoom = data.zoom;
							if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
							if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
							if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );
	
							break;
	
						case 'OrthographicCamera':
	
							object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );
	
							break;
	
						case 'AmbientLight':
	
							object = new AmbientLight( data.color, data.intensity );
	
							break;
	
						case 'DirectionalLight':
	
							object = new DirectionalLight( data.color, data.intensity );
	
							break;
	
						case 'PointLight':
	
							object = new PointLight( data.color, data.intensity, data.distance, data.decay );
	
							break;
	
						case 'SpotLight':
	
							object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );
	
							break;
	
						case 'HemisphereLight':
	
							object = new HemisphereLight( data.color, data.groundColor, data.intensity );
	
							break;
	
						case 'Mesh':
	
							var geometry = getGeometry( data.geometry );
							var material = getMaterial( data.material );
	
							if ( geometry.bones && geometry.bones.length > 0 ) {
	
								object = new SkinnedMesh( geometry, material );
	
							} else {
	
								object = new Mesh( geometry, material );
	
							}
	
							break;
	
						case 'LOD':
	
							object = new LOD();
	
							break;
	
						case 'Line':
	
							object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );
	
							break;
	
						case 'LineSegments':
	
							object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );
	
							break;
	
						case 'PointCloud':
						case 'Points':
	
							object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );
	
							break;
	
						case 'Sprite':
	
							object = new Sprite( getMaterial( data.material ) );
	
							break;
	
						case 'Group':
	
							object = new Group();
	
							break;
	
						case 'SkinnedMesh':
	
							console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh type. Instantiates Object3D instead.' );
	
						default:
	
							object = new Object3D();
	
					}
	
					object.uuid = data.uuid;
	
					if ( data.name !== undefined ) object.name = data.name;
					if ( data.matrix !== undefined ) {
	
						matrix.fromArray( data.matrix );
						matrix.decompose( object.position, object.quaternion, object.scale );
	
					} else {
	
						if ( data.position !== undefined ) object.position.fromArray( data.position );
						if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
						if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
						if ( data.scale !== undefined ) object.scale.fromArray( data.scale );
	
					}
	
					if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
					if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;
	
					if ( data.shadow ) {
	
						if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
						if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
						if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
						if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );
	
					}
	
					if ( data.visible !== undefined ) object.visible = data.visible;
					if ( data.userData !== undefined ) object.userData = data.userData;
	
					if ( data.children !== undefined ) {
	
						for ( var child in data.children ) {
	
							object.add( this.parseObject( data.children[ child ], geometries, materials ) );
	
						}
	
					}
	
					if ( data.type === 'LOD' ) {
	
						var levels = data.levels;
	
						for ( var l = 0; l < levels.length; l ++ ) {
	
							var level = levels[ l ];
							var child = object.getObjectByProperty( 'uuid', level.object );
	
							if ( child !== undefined ) {
	
								object.addLevel( child, level.distance );
	
							}
	
						}
	
					}
	
					return object;
	
				};
	
			}()
	
		} );
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 * Bezier Curves formulas obtained from
		 * http://en.wikipedia.org/wiki/Bézier_curve
		 */
	
		function CatmullRom( t, p0, p1, p2, p3 ) {
	
			var v0 = ( p2 - p0 ) * 0.5;
			var v1 = ( p3 - p1 ) * 0.5;
			var t2 = t * t;
			var t3 = t * t2;
			return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
		}
	
		//
	
		function QuadraticBezierP0( t, p ) {
	
			var k = 1 - t;
			return k * k * p;
	
		}
	
		function QuadraticBezierP1( t, p ) {
	
			return 2 * ( 1 - t ) * t * p;
	
		}
	
		function QuadraticBezierP2( t, p ) {
	
			return t * t * p;
	
		}
	
		function QuadraticBezier( t, p0, p1, p2 ) {
	
			return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
				QuadraticBezierP2( t, p2 );
	
		}
	
		//
	
		function CubicBezierP0( t, p ) {
	
			var k = 1 - t;
			return k * k * k * p;
	
		}
	
		function CubicBezierP1( t, p ) {
	
			var k = 1 - t;
			return 3 * k * k * t * p;
	
		}
	
		function CubicBezierP2( t, p ) {
	
			return 3 * ( 1 - t ) * t * t * p;
	
		}
	
		function CubicBezierP3( t, p ) {
	
			return t * t * t * p;
	
		}
	
		function CubicBezier( t, p0, p1, p2, p3 ) {
	
			return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
				CubicBezierP3( t, p3 );
	
		}
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Extensible curve object
		 *
		 * Some common of Curve methods
		 * .getPoint(t), getTangent(t)
		 * .getPointAt(u), getTangentAt(u)
		 * .getPoints(), .getSpacedPoints()
		 * .getLength()
		 * .updateArcLengths()
		 *
		 * This following classes subclasses THREE.Curve:
		 *
		 * -- 2d classes --
		 * THREE.LineCurve
		 * THREE.QuadraticBezierCurve
		 * THREE.CubicBezierCurve
		 * THREE.SplineCurve
		 * THREE.ArcCurve
		 * THREE.EllipseCurve
		 *
		 * -- 3d classes --
		 * THREE.LineCurve3
		 * THREE.QuadraticBezierCurve3
		 * THREE.CubicBezierCurve3
		 * THREE.CatmullRomCurve3
		 *
		 * A series of curves can be represented as a THREE.CurvePath
		 *
		 **/
	
		/**************************************************************
		 *	Abstract Curve base class
		 **************************************************************/
	
		function Curve() {}
	
		Curve.prototype = {
	
			constructor: Curve,
	
			// Virtual base class method to overwrite and implement in subclasses
			//	- t [0 .. 1]
	
			getPoint: function ( t ) {
	
				console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
				return null;
	
			},
	
			// Get point at relative position in curve according to arc length
			// - u [0 .. 1]
	
			getPointAt: function ( u ) {
	
				var t = this.getUtoTmapping( u );
				return this.getPoint( t );
	
			},
	
			// Get sequence of points using getPoint( t )
	
			getPoints: function ( divisions ) {
	
				if ( isNaN( divisions ) ) divisions = 5;
	
				var points = [];
	
				for ( var d = 0; d <= divisions; d ++ ) {
	
					points.push( this.getPoint( d / divisions ) );
	
				}
	
				return points;
	
			},
	
			// Get sequence of points using getPointAt( u )
	
			getSpacedPoints: function ( divisions ) {
	
				if ( isNaN( divisions ) ) divisions = 5;
	
				var points = [];
	
				for ( var d = 0; d <= divisions; d ++ ) {
	
					points.push( this.getPointAt( d / divisions ) );
	
				}
	
				return points;
	
			},
	
			// Get total curve arc length
	
			getLength: function () {
	
				var lengths = this.getLengths();
				return lengths[ lengths.length - 1 ];
	
			},
	
			// Get list of cumulative segment lengths
	
			getLengths: function ( divisions ) {
	
				if ( isNaN( divisions ) ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;
	
				if ( this.cacheArcLengths
					&& ( this.cacheArcLengths.length === divisions + 1 )
					&& ! this.needsUpdate ) {
	
					//console.log( "cached", this.cacheArcLengths );
					return this.cacheArcLengths;
	
				}
	
				this.needsUpdate = false;
	
				var cache = [];
				var current, last = this.getPoint( 0 );
				var p, sum = 0;
	
				cache.push( 0 );
	
				for ( p = 1; p <= divisions; p ++ ) {
	
					current = this.getPoint ( p / divisions );
					sum += current.distanceTo( last );
					cache.push( sum );
					last = current;
	
				}
	
				this.cacheArcLengths = cache;
	
				return cache; // { sums: cache, sum:sum }; Sum is in the last element.
	
			},
	
			updateArcLengths: function() {
	
				this.needsUpdate = true;
				this.getLengths();
	
			},
	
			// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
	
			getUtoTmapping: function ( u, distance ) {
	
				var arcLengths = this.getLengths();
	
				var i = 0, il = arcLengths.length;
	
				var targetArcLength; // The targeted u distance value to get
	
				if ( distance ) {
	
					targetArcLength = distance;
	
				} else {
	
					targetArcLength = u * arcLengths[ il - 1 ];
	
				}
	
				//var time = Date.now();
	
				// binary search for the index with largest value smaller than target u distance
	
				var low = 0, high = il - 1, comparison;
	
				while ( low <= high ) {
	
					i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
	
					comparison = arcLengths[ i ] - targetArcLength;
	
					if ( comparison < 0 ) {
	
						low = i + 1;
	
					} else if ( comparison > 0 ) {
	
						high = i - 1;
	
					} else {
	
						high = i;
						break;
	
						// DONE
	
					}
	
				}
	
				i = high;
	
				//console.log('b' , i, low, high, Date.now()- time);
	
				if ( arcLengths[ i ] === targetArcLength ) {
	
					var t = i / ( il - 1 );
					return t;
	
				}
	
				// we could get finer grain at lengths, or use simple interpolation between two points
	
				var lengthBefore = arcLengths[ i ];
				var lengthAfter = arcLengths[ i + 1 ];
	
				var segmentLength = lengthAfter - lengthBefore;
	
				// determine where we are between the 'before' and 'after' points
	
				var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;
	
				// add that fractional amount to t
	
				var t = ( i + segmentFraction ) / ( il - 1 );
	
				return t;
	
			},
	
			// Returns a unit vector tangent at t
			// In case any sub curve does not implement its tangent derivation,
			// 2 points a small delta apart will be used to find its gradient
			// which seems to give a reasonable approximation
	
			getTangent: function( t ) {
	
				var delta = 0.0001;
				var t1 = t - delta;
				var t2 = t + delta;
	
				// Capping in case of danger
	
				if ( t1 < 0 ) t1 = 0;
				if ( t2 > 1 ) t2 = 1;
	
				var pt1 = this.getPoint( t1 );
				var pt2 = this.getPoint( t2 );
	
				var vec = pt2.clone().sub( pt1 );
				return vec.normalize();
	
			},
	
			getTangentAt: function ( u ) {
	
				var t = this.getUtoTmapping( u );
				return this.getTangent( t );
	
			},
	
			computeFrenetFrames: function ( segments, closed ) {
	
				// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	
				var normal = new Vector3();
	
				var tangents = [];
				var normals = [];
				var binormals = [];
	
				var vec = new Vector3();
				var mat = new Matrix4();
	
				var i, u, theta;
	
				// compute the tangent vectors for each segment on the curve
	
				for ( i = 0; i <= segments; i ++ ) {
	
					u = i / segments;
	
					tangents[ i ] = this.getTangentAt( u );
					tangents[ i ].normalize();
	
				}
	
				// select an initial normal vector perpendicular to the first tangent vector,
				// and in the direction of the minimum tangent xyz component
	
				normals[ 0 ] = new Vector3();
				binormals[ 0 ] = new Vector3();
				var min = Number.MAX_VALUE;
				var tx = Math.abs( tangents[ 0 ].x );
				var ty = Math.abs( tangents[ 0 ].y );
				var tz = Math.abs( tangents[ 0 ].z );
	
				if ( tx <= min ) {
	
					min = tx;
					normal.set( 1, 0, 0 );
	
				}
	
				if ( ty <= min ) {
	
					min = ty;
					normal.set( 0, 1, 0 );
	
				}
	
				if ( tz <= min ) {
	
					normal.set( 0, 0, 1 );
	
				}
	
				vec.crossVectors( tangents[ 0 ], normal ).normalize();
	
				normals[ 0 ].crossVectors( tangents[ 0 ], vec );
				binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	
	
				// compute the slowly-varying normal and binormal vectors for each segment on the curve
	
				for ( i = 1; i <= segments; i ++ ) {
	
					normals[ i ] = normals[ i - 1 ].clone();
	
					binormals[ i ] = binormals[ i - 1 ].clone();
	
					vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );
	
					if ( vec.length() > Number.EPSILON ) {
	
						vec.normalize();
	
						theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors
	
						normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );
	
					}
	
					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
				}
	
				// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
	
				if ( closed === true ) {
	
					theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
					theta /= segments;
	
					if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {
	
						theta = - theta;
	
					}
	
					for ( i = 1; i <= segments; i ++ ) {
	
						// twist a little...
						normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
						binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
					}
	
				}
	
				return {
					tangents: tangents,
					normals: normals,
					binormals: binormals
				};
	
			}
	
		};
	
		function LineCurve( v1, v2 ) {
	
			this.v1 = v1;
			this.v2 = v2;
	
		}
	
		LineCurve.prototype = Object.create( Curve.prototype );
		LineCurve.prototype.constructor = LineCurve;
	
		LineCurve.prototype.isLineCurve = true;
	
		LineCurve.prototype.getPoint = function ( t ) {
	
			if ( t === 1 ) {
	
				return this.v2.clone();
	
			}
	
			var point = this.v2.clone().sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );
	
			return point;
	
		};
	
		// Line curve is linear, so we can overwrite default getPointAt
	
		LineCurve.prototype.getPointAt = function ( u ) {
	
			return this.getPoint( u );
	
		};
	
		LineCurve.prototype.getTangent = function ( t ) {
	
			var tangent = this.v2.clone().sub( this.v1 );
	
			return tangent.normalize();
	
		};
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 *
		 **/
	
		/**************************************************************
		 *	Curved Path - a curve path is simply a array of connected
		 *  curves, but retains the api of a curve
		 **************************************************************/
	
		function CurvePath() {
	
			this.curves = [];
	
			this.autoClose = false; // Automatically closes the path
	
		}
	
		CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {
	
			constructor: CurvePath,
	
			add: function ( curve ) {
	
				this.curves.push( curve );
	
			},
	
			closePath: function () {
	
				// Add a line curve if start and end of lines are not connected
				var startPoint = this.curves[ 0 ].getPoint( 0 );
				var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );
	
				if ( ! startPoint.equals( endPoint ) ) {
	
					this.curves.push( new LineCurve( endPoint, startPoint ) );
	
				}
	
			},
	
			// To get accurate point with reference to
			// entire path distance at time t,
			// following has to be done:
	
			// 1. Length of each sub path have to be known
			// 2. Locate and identify type of curve
			// 3. Get t for the curve
			// 4. Return curve.getPointAt(t')
	
			getPoint: function ( t ) {
	
				var d = t * this.getLength();
				var curveLengths = this.getCurveLengths();
				var i = 0;
	
				// To think about boundaries points.
	
				while ( i < curveLengths.length ) {
	
					if ( curveLengths[ i ] >= d ) {
	
						var diff = curveLengths[ i ] - d;
						var curve = this.curves[ i ];
	
						var segmentLength = curve.getLength();
						var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
	
						return curve.getPointAt( u );
	
					}
	
					i ++;
	
				}
	
				return null;
	
				// loop where sum != 0, sum > d , sum+1 <d
	
			},
	
			// We cannot use the default THREE.Curve getPoint() with getLength() because in
			// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
			// getPoint() depends on getLength
	
			getLength: function () {
	
				var lens = this.getCurveLengths();
				return lens[ lens.length - 1 ];
	
			},
	
			// cacheLengths must be recalculated.
			updateArcLengths: function () {
	
				this.needsUpdate = true;
				this.cacheLengths = null;
				this.getLengths();
	
			},
	
			// Compute lengths and cache them
			// We cannot overwrite getLengths() because UtoT mapping uses it.
	
			getCurveLengths: function () {
	
				// We use cache values if curves and cache array are same length
	
				if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {
	
					return this.cacheLengths;
	
				}
	
				// Get length of sub-curve
				// Push sums into cached array
	
				var lengths = [], sums = 0;
	
				for ( var i = 0, l = this.curves.length; i < l; i ++ ) {
	
					sums += this.curves[ i ].getLength();
					lengths.push( sums );
	
				}
	
				this.cacheLengths = lengths;
	
				return lengths;
	
			},
	
			getSpacedPoints: function ( divisions ) {
	
				if ( isNaN( divisions ) ) divisions = 40;
	
				var points = [];
	
				for ( var i = 0; i <= divisions; i ++ ) {
	
					points.push( this.getPoint( i / divisions ) );
	
				}
	
				if ( this.autoClose ) {
	
					points.push( points[ 0 ] );
	
				}
	
				return points;
	
			},
	
			getPoints: function ( divisions ) {
	
				divisions = divisions || 12;
	
				var points = [], last;
	
				for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {
	
					var curve = curves[ i ];
					var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
						: (curve && curve.isLineCurve) ? 1
						: (curve && curve.isSplineCurve) ? divisions * curve.points.length
						: divisions;
	
					var pts = curve.getPoints( resolution );
	
					for ( var j = 0; j < pts.length; j++ ) {
	
						var point = pts[ j ];
	
						if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates
	
						points.push( point );
						last = point;
	
					}
	
				}
	
				if ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {
	
					points.push( points[ 0 ] );
	
				}
	
				return points;
	
			},
	
			/**************************************************************
			 *	Create Geometries Helpers
			 **************************************************************/
	
			/// Generate geometry from path points (for Line or Points objects)
	
			createPointsGeometry: function ( divisions ) {
	
				var pts = this.getPoints( divisions );
				return this.createGeometry( pts );
	
			},
	
			// Generate geometry from equidistant sampling along the path
	
			createSpacedPointsGeometry: function ( divisions ) {
	
				var pts = this.getSpacedPoints( divisions );
				return this.createGeometry( pts );
	
			},
	
			createGeometry: function ( points ) {
	
				var geometry = new Geometry();
	
				for ( var i = 0, l = points.length; i < l; i ++ ) {
	
					var point = points[ i ];
					geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );
	
				}
	
				return geometry;
	
			}
	
		} );
	
		function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
			this.aX = aX;
			this.aY = aY;
	
			this.xRadius = xRadius;
			this.yRadius = yRadius;
	
			this.aStartAngle = aStartAngle;
			this.aEndAngle = aEndAngle;
	
			this.aClockwise = aClockwise;
	
			this.aRotation = aRotation || 0;
	
		}
	
		EllipseCurve.prototype = Object.create( Curve.prototype );
		EllipseCurve.prototype.constructor = EllipseCurve;
	
		EllipseCurve.prototype.isEllipseCurve = true;
	
		EllipseCurve.prototype.getPoint = function ( t ) {
	
			var twoPi = Math.PI * 2;
			var deltaAngle = this.aEndAngle - this.aStartAngle;
			var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;
	
			// ensures that deltaAngle is 0 .. 2 PI
			while ( deltaAngle < 0 ) deltaAngle += twoPi;
			while ( deltaAngle > twoPi ) deltaAngle -= twoPi;
	
			if ( deltaAngle < Number.EPSILON ) {
	
				if ( samePoints ) {
	
					deltaAngle = 0;
	
				} else {
	
					deltaAngle = twoPi;
	
				}
	
			}
	
			if ( this.aClockwise === true && ! samePoints ) {
	
				if ( deltaAngle === twoPi ) {
	
					deltaAngle = - twoPi;
	
				} else {
	
					deltaAngle = deltaAngle - twoPi;
	
				}
	
			}
	
			var angle = this.aStartAngle + t * deltaAngle;
			var x = this.aX + this.xRadius * Math.cos( angle );
			var y = this.aY + this.yRadius * Math.sin( angle );
	
			if ( this.aRotation !== 0 ) {
	
				var cos = Math.cos( this.aRotation );
				var sin = Math.sin( this.aRotation );
	
				var tx = x - this.aX;
				var ty = y - this.aY;
	
				// Rotate the point about the center of the ellipse.
				x = tx * cos - ty * sin + this.aX;
				y = tx * sin + ty * cos + this.aY;
	
			}
	
			return new Vector2( x, y );
	
		};
	
		function SplineCurve( points /* array of Vector2 */ ) {
	
			this.points = ( points === undefined ) ? [] : points;
	
		}
	
		SplineCurve.prototype = Object.create( Curve.prototype );
		SplineCurve.prototype.constructor = SplineCurve;
	
		SplineCurve.prototype.isSplineCurve = true;
	
		SplineCurve.prototype.getPoint = function ( t ) {
	
			var points = this.points;
			var point = ( points.length - 1 ) * t;
	
			var intPoint = Math.floor( point );
			var weight = point - intPoint;
	
			var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
			var point1 = points[ intPoint ];
			var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
			var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];
	
			return new Vector2(
				CatmullRom( weight, point0.x, point1.x, point2.x, point3.x ),
				CatmullRom( weight, point0.y, point1.y, point2.y, point3.y )
			);
	
		};
	
		function CubicBezierCurve( v0, v1, v2, v3 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
	
		}
	
		CubicBezierCurve.prototype = Object.create( Curve.prototype );
		CubicBezierCurve.prototype.constructor = CubicBezierCurve;
	
		CubicBezierCurve.prototype.getPoint = function ( t ) {
	
			var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
	
			return new Vector2(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
			);
	
		};
	
		function QuadraticBezierCurve( v0, v1, v2 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
	
		}
	
		QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
		QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
	
		QuadraticBezierCurve.prototype.getPoint = function ( t ) {
	
			var v0 = this.v0, v1 = this.v1, v2 = this.v2;
	
			return new Vector2(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y )
			);
	
		};
	
		var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {
	
			fromPoints: function ( vectors ) {
	
				this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );
	
				for ( var i = 1, l = vectors.length; i < l; i ++ ) {
	
					this.lineTo( vectors[ i ].x, vectors[ i ].y );
	
				}
	
			},
	
			moveTo: function ( x, y ) {
	
				this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?
	
			},
	
			lineTo: function ( x, y ) {
	
				var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
				this.curves.push( curve );
	
				this.currentPoint.set( x, y );
	
			},
	
			quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
	
				var curve = new QuadraticBezierCurve(
					this.currentPoint.clone(),
					new Vector2( aCPx, aCPy ),
					new Vector2( aX, aY )
				);
	
				this.curves.push( curve );
	
				this.currentPoint.set( aX, aY );
	
			},
	
			bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
	
				var curve = new CubicBezierCurve(
					this.currentPoint.clone(),
					new Vector2( aCP1x, aCP1y ),
					new Vector2( aCP2x, aCP2y ),
					new Vector2( aX, aY )
				);
	
				this.curves.push( curve );
	
				this.currentPoint.set( aX, aY );
	
			},
	
			splineThru: function ( pts /*Array of Vector*/ ) {
	
				var npts = [ this.currentPoint.clone() ].concat( pts );
	
				var curve = new SplineCurve( npts );
				this.curves.push( curve );
	
				this.currentPoint.copy( pts[ pts.length - 1 ] );
	
			},
	
			arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
				var x0 = this.currentPoint.x;
				var y0 = this.currentPoint.y;
	
				this.absarc( aX + x0, aY + y0, aRadius,
					aStartAngle, aEndAngle, aClockwise );
	
			},
	
			absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
				this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
			},
	
			ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
				var x0 = this.currentPoint.x;
				var y0 = this.currentPoint.y;
	
				this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	
			},
	
			absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
				var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	
				if ( this.curves.length > 0 ) {
	
					// if a previous curve is present, attempt to join
					var firstPoint = curve.getPoint( 0 );
	
					if ( ! firstPoint.equals( this.currentPoint ) ) {
	
						this.lineTo( firstPoint.x, firstPoint.y );
	
					}
	
				}
	
				this.curves.push( curve );
	
				var lastPoint = curve.getPoint( 1 );
				this.currentPoint.copy( lastPoint );
	
			}
	
		} );
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Creates free form 2d path using series of points, lines or curves.
		 **/
	
		function Path( points ) {
	
			CurvePath.call( this );
			this.currentPoint = new Vector2();
	
			if ( points ) {
	
				this.fromPoints( points );
	
			}
	
		}
	
		Path.prototype = PathPrototype;
		PathPrototype.constructor = Path;
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * Defines a 2d shape plane using paths.
		 **/
	
		// STEP 1 Create a path.
		// STEP 2 Turn path into shape.
		// STEP 3 ExtrudeGeometry takes in Shape/Shapes
		// STEP 3a - Extract points from each shape, turn to vertices
		// STEP 3b - Triangulate each shape, add faces.
	
		function Shape() {
	
			Path.apply( this, arguments );
	
			this.holes = [];
	
		}
	
		Shape.prototype = Object.assign( Object.create( PathPrototype ), {
	
			constructor: Shape,
	
			getPointsHoles: function ( divisions ) {
	
				var holesPts = [];
	
				for ( var i = 0, l = this.holes.length; i < l; i ++ ) {
	
					holesPts[ i ] = this.holes[ i ].getPoints( divisions );
	
				}
	
				return holesPts;
	
			},
	
			// Get points of shape and holes (keypoints based on segments parameter)
	
			extractAllPoints: function ( divisions ) {
	
				return {
	
					shape: this.getPoints( divisions ),
					holes: this.getPointsHoles( divisions )
	
				};
	
			},
	
			extractPoints: function ( divisions ) {
	
				return this.extractAllPoints( divisions );
	
			}
	
		} );
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
		 **/
	
		function ShapePath() {
	
			this.subPaths = [];
			this.currentPath = null;
	
		}
	
		ShapePath.prototype = {
	
			moveTo: function ( x, y ) {
	
				this.currentPath = new Path();
				this.subPaths.push( this.currentPath );
				this.currentPath.moveTo( x, y );
	
			},
	
			lineTo: function ( x, y ) {
	
				this.currentPath.lineTo( x, y );
	
			},
	
			quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
	
				this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );
	
			},
	
			bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
	
				this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );
	
			},
	
			splineThru: function ( pts ) {
	
				this.currentPath.splineThru( pts );
	
			},
	
			toShapes: function ( isCCW, noHoles ) {
	
				function toShapesNoHoles( inSubpaths ) {
	
					var shapes = [];
	
					for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {
	
						var tmpPath = inSubpaths[ i ];
	
						var tmpShape = new Shape();
						tmpShape.curves = tmpPath.curves;
	
						shapes.push( tmpShape );
	
					}
	
					return shapes;
	
				}
	
				function isPointInsidePolygon( inPt, inPolygon ) {
	
					var polyLen = inPolygon.length;
	
					// inPt on polygon contour => immediate success    or
					// toggling of inside/outside at every single! intersection point of an edge
					//  with the horizontal line through inPt, left of inPt
					//  not counting lowerY endpoints of edges and whole edges on that line
					var inside = false;
					for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
	
						var edgeLowPt  = inPolygon[ p ];
						var edgeHighPt = inPolygon[ q ];
	
						var edgeDx = edgeHighPt.x - edgeLowPt.x;
						var edgeDy = edgeHighPt.y - edgeLowPt.y;
	
						if ( Math.abs( edgeDy ) > Number.EPSILON ) {
	
							// not parallel
							if ( edgeDy < 0 ) {
	
								edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
								edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
	
							}
							if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;
	
							if ( inPt.y === edgeLowPt.y ) {
	
								if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
								// continue;				// no intersection or edgeLowPt => doesn't count !!!
	
							} else {
	
								var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
								if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
								if ( perpEdge < 0 ) 				continue;
								inside = ! inside;		// true intersection left of inPt
	
							}
	
						} else {
	
							// parallel or collinear
							if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
							// edge lies on the same horizontal line as inPt
							if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
								 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
							// continue;
	
						}
	
					}
	
					return	inside;
	
				}
	
				var isClockWise = ShapeUtils.isClockWise;
	
				var subPaths = this.subPaths;
				if ( subPaths.length === 0 ) return [];
	
				if ( noHoles === true )	return	toShapesNoHoles( subPaths );
	
	
				var solid, tmpPath, tmpShape, shapes = [];
	
				if ( subPaths.length === 1 ) {
	
					tmpPath = subPaths[ 0 ];
					tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;
					shapes.push( tmpShape );
					return shapes;
	
				}
	
				var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
				holesFirst = isCCW ? ! holesFirst : holesFirst;
	
				// console.log("Holes first", holesFirst);
	
				var betterShapeHoles = [];
				var newShapes = [];
				var newShapeHoles = [];
				var mainIdx = 0;
				var tmpPoints;
	
				newShapes[ mainIdx ] = undefined;
				newShapeHoles[ mainIdx ] = [];
	
				for ( var i = 0, l = subPaths.length; i < l; i ++ ) {
	
					tmpPath = subPaths[ i ];
					tmpPoints = tmpPath.getPoints();
					solid = isClockWise( tmpPoints );
					solid = isCCW ? ! solid : solid;
	
					if ( solid ) {
	
						if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;
	
						newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
						newShapes[ mainIdx ].s.curves = tmpPath.curves;
	
						if ( holesFirst )	mainIdx ++;
						newShapeHoles[ mainIdx ] = [];
	
						//console.log('cw', i);
	
					} else {
	
						newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );
	
						//console.log('ccw', i);
	
					}
	
				}
	
				// only Holes? -> probably all Shapes with wrong orientation
				if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );
	
	
				if ( newShapes.length > 1 ) {
	
					var ambiguous = false;
					var toChange = [];
	
					for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
						betterShapeHoles[ sIdx ] = [];
	
					}
	
					for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
						var sho = newShapeHoles[ sIdx ];
	
						for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
	
							var ho = sho[ hIdx ];
							var hole_unassigned = true;
	
							for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
	
								if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {
	
									if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
									if ( hole_unassigned ) {
	
										hole_unassigned = false;
										betterShapeHoles[ s2Idx ].push( ho );
	
									} else {
	
										ambiguous = true;
	
									}
	
								}
	
							}
							if ( hole_unassigned ) {
	
								betterShapeHoles[ sIdx ].push( ho );
	
							}
	
						}
	
					}
					// console.log("ambiguous: ", ambiguous);
					if ( toChange.length > 0 ) {
	
						// console.log("to change: ", toChange);
						if ( ! ambiguous )	newShapeHoles = betterShapeHoles;
	
					}
	
				}
	
				var tmpHoles;
	
				for ( var i = 0, il = newShapes.length; i < il; i ++ ) {
	
					tmpShape = newShapes[ i ].s;
					shapes.push( tmpShape );
					tmpHoles = newShapeHoles[ i ];
	
					for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
	
						tmpShape.holes.push( tmpHoles[ j ].h );
	
					}
	
				}
	
				//console.log("shape", shapes);
	
				return shapes;
	
			}
	
		};
	
		/**
		 * @author zz85 / http://www.lab4games.net/zz85/blog
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Font( data ) {
	
			this.data = data;
	
		}
	
		Object.assign( Font.prototype, {
	
			isFont: true,
	
			generateShapes: function ( text, size, divisions ) {
	
				function createPaths( text ) {
	
					var chars = String( text ).split( '' );
					var scale = size / data.resolution;
					var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;
	
					var offsetX = 0, offsetY = 0;
	
					var paths = [];
	
					for ( var i = 0; i < chars.length; i ++ ) {
	
						var char = chars[ i ];
	
						if ( char === '\n' ) {
	
							offsetX = 0;
							offsetY -= line_height;
	
						} else {
	
							var ret = createPath( char, scale, offsetX, offsetY );
							offsetX += ret.offsetX;
							paths.push( ret.path );
	
						}
	
					}
	
					return paths;
	
				}
	
				function createPath( c, scale, offsetX, offsetY ) {
	
					var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];
	
					if ( ! glyph ) return;
	
					var path = new ShapePath();
	
					var pts = [];
					var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;
	
					if ( glyph.o ) {
	
						var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
	
						for ( var i = 0, l = outline.length; i < l; ) {
	
							var action = outline[ i ++ ];
	
							switch ( action ) {
	
								case 'm': // moveTo
	
									x = outline[ i ++ ] * scale + offsetX;
									y = outline[ i ++ ] * scale + offsetY;
	
									path.moveTo( x, y );
	
									break;
	
								case 'l': // lineTo
	
									x = outline[ i ++ ] * scale + offsetX;
									y = outline[ i ++ ] * scale + offsetY;
	
									path.lineTo( x, y );
	
									break;
	
								case 'q': // quadraticCurveTo
	
									cpx  = outline[ i ++ ] * scale + offsetX;
									cpy  = outline[ i ++ ] * scale + offsetY;
									cpx1 = outline[ i ++ ] * scale + offsetX;
									cpy1 = outline[ i ++ ] * scale + offsetY;
	
									path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );
	
									laste = pts[ pts.length - 1 ];
	
									if ( laste ) {
	
										cpx0 = laste.x;
										cpy0 = laste.y;
	
										for ( var i2 = 1; i2 <= divisions; i2 ++ ) {
	
											var t = i2 / divisions;
											QuadraticBezier( t, cpx0, cpx1, cpx );
											QuadraticBezier( t, cpy0, cpy1, cpy );
	
										}
	
									}
	
									break;
	
								case 'b': // bezierCurveTo
	
									cpx  = outline[ i ++ ] * scale + offsetX;
									cpy  = outline[ i ++ ] * scale + offsetY;
									cpx1 = outline[ i ++ ] * scale + offsetX;
									cpy1 = outline[ i ++ ] * scale + offsetY;
									cpx2 = outline[ i ++ ] * scale + offsetX;
									cpy2 = outline[ i ++ ] * scale + offsetY;
	
									path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );
	
									laste = pts[ pts.length - 1 ];
	
									if ( laste ) {
	
										cpx0 = laste.x;
										cpy0 = laste.y;
	
										for ( var i2 = 1; i2 <= divisions; i2 ++ ) {
	
											var t = i2 / divisions;
											CubicBezier( t, cpx0, cpx1, cpx2, cpx );
											CubicBezier( t, cpy0, cpy1, cpy2, cpy );
	
										}
	
									}
	
									break;
	
							}
	
						}
	
					}
	
					return { offsetX: glyph.ha * scale, path: path };
	
				}
	
				//
	
				if ( size === undefined ) size = 100;
				if ( divisions === undefined ) divisions = 4;
	
				var data = this.data;
	
				var paths = createPaths( text );
				var shapes = [];
	
				for ( var p = 0, pl = paths.length; p < pl; p ++ ) {
	
					Array.prototype.push.apply( shapes, paths[ p ].toShapes() );
	
				}
	
				return shapes;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function FontLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( FontLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var scope = this;
	
				var loader = new FileLoader( this.manager );
				loader.load( url, function ( text ) {
	
					var json;
	
					try {
	
						json = JSON.parse( text );
	
					} catch ( e ) {
	
						console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
						json = JSON.parse( text.substring( 65, text.length - 2 ) );
	
					}
	
					var font = scope.parse( json );
	
					if ( onLoad ) onLoad( font );
	
				}, onProgress, onError );
	
			},
	
			parse: function ( json ) {
	
				return new Font( json );
	
			}
	
		} );
	
		var context;
	
		var AudioContext = {
	
			getContext: function () {
	
				if ( context === undefined ) {
	
					context = new ( window.AudioContext || window.webkitAudioContext )();
	
				}
	
				return context;
	
			},
	
			setContext: function ( value ) {
	
				context = value;
	
			}
	
		};
	
		/**
		 * @author Reece Aaron Lecrivain / http://reecenotes.com/
		 */
	
		function AudioLoader( manager ) {
	
			this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		}
	
		Object.assign( AudioLoader.prototype, {
	
			load: function ( url, onLoad, onProgress, onError ) {
	
				var loader = new FileLoader( this.manager );
				loader.setResponseType( 'arraybuffer' );
				loader.load( url, function ( buffer ) {
	
					var context = AudioContext.getContext();
	
					context.decodeAudioData( buffer, function ( audioBuffer ) {
	
						onLoad( audioBuffer );
	
					} );
	
				}, onProgress, onError );
	
			}
	
		} );
	
		/**
		 * @author abelnation / http://github.com/abelnation
		 */
	
		function RectAreaLight ( color, intensity, width, height ) {
	
			Light.call( this, color, intensity );
	
			this.type = 'RectAreaLight';
	
			this.position.set( 0, 1, 0 );
			this.updateMatrix();
	
			this.width = ( width !== undefined ) ? width : 10;
			this.height = ( height !== undefined ) ? height : 10;
	
			// TODO (abelnation): distance/decay
	
			// TODO (abelnation): update method for RectAreaLight to update transform to lookat target
	
			// TODO (abelnation): shadows
			// this.shadow = new THREE.RectAreaLightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );
	
		}
	
		// TODO (abelnation): RectAreaLight update when light shape is changed
		RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
			constructor: RectAreaLight,
	
			isRectAreaLight: true,
	
			copy: function ( source ) {
	
				Light.prototype.copy.call( this, source );
	
				this.width = source.width;
				this.height = source.height;
	
				// this.shadow = source.shadow.clone();
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function StereoCamera() {
	
			this.type = 'StereoCamera';
	
			this.aspect = 1;
	
			this.eyeSep = 0.064;
	
			this.cameraL = new PerspectiveCamera();
			this.cameraL.layers.enable( 1 );
			this.cameraL.matrixAutoUpdate = false;
	
			this.cameraR = new PerspectiveCamera();
			this.cameraR.layers.enable( 2 );
			this.cameraR.matrixAutoUpdate = false;
	
		}
	
		Object.assign( StereoCamera.prototype, {
	
			update: ( function () {
	
				var instance, focus, fov, aspect, near, far, zoom;
	
				var eyeRight = new Matrix4();
				var eyeLeft = new Matrix4();
	
				return function update( camera ) {
	
					var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
														aspect !== camera.aspect * this.aspect || near !== camera.near ||
														far !== camera.far || zoom !== camera.zoom;
	
					if ( needsUpdate ) {
	
						instance = this;
						focus = camera.focus;
						fov = camera.fov;
						aspect = camera.aspect * this.aspect;
						near = camera.near;
						far = camera.far;
						zoom = camera.zoom;
	
						// Off-axis stereoscopic effect based on
						// http://paulbourke.net/stereographics/stereorender/
	
						var projectionMatrix = camera.projectionMatrix.clone();
						var eyeSep = this.eyeSep / 2;
						var eyeSepOnProjection = eyeSep * near / focus;
						var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
						var xmin, xmax;
	
						// translate xOffset
	
						eyeLeft.elements[ 12 ] = - eyeSep;
						eyeRight.elements[ 12 ] = eyeSep;
	
						// for left eye
	
						xmin = - ymax * aspect + eyeSepOnProjection;
						xmax = ymax * aspect + eyeSepOnProjection;
	
						projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
						projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
	
						this.cameraL.projectionMatrix.copy( projectionMatrix );
	
						// for right eye
	
						xmin = - ymax * aspect - eyeSepOnProjection;
						xmax = ymax * aspect - eyeSepOnProjection;
	
						projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
						projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
	
						this.cameraR.projectionMatrix.copy( projectionMatrix );
	
					}
	
					this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
					this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );
	
				};
	
			} )()
	
		} );
	
		/**
		 * Camera for rendering cube maps
		 *	- renders scene into axis-aligned cube
		 *
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function CubeCamera( near, far, cubeResolution ) {
	
			Object3D.call( this );
	
			this.type = 'CubeCamera';
	
			var fov = 90, aspect = 1;
	
			var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
			cameraPX.up.set( 0, - 1, 0 );
			cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
			this.add( cameraPX );
	
			var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
			cameraNX.up.set( 0, - 1, 0 );
			cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
			this.add( cameraNX );
	
			var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
			cameraPY.up.set( 0, 0, 1 );
			cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
			this.add( cameraPY );
	
			var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
			cameraNY.up.set( 0, 0, - 1 );
			cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
			this.add( cameraNY );
	
			var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraPZ.up.set( 0, - 1, 0 );
			cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
			this.add( cameraPZ );
	
			var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
			cameraNZ.up.set( 0, - 1, 0 );
			cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
			this.add( cameraNZ );
	
			var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };
	
			this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
	
			this.updateCubeMap = function ( renderer, scene ) {
	
				if ( this.parent === null ) this.updateMatrixWorld();
	
				var renderTarget = this.renderTarget;
				var generateMipmaps = renderTarget.texture.generateMipmaps;
	
				renderTarget.texture.generateMipmaps = false;
	
				renderTarget.activeCubeFace = 0;
				renderer.render( scene, cameraPX, renderTarget );
	
				renderTarget.activeCubeFace = 1;
				renderer.render( scene, cameraNX, renderTarget );
	
				renderTarget.activeCubeFace = 2;
				renderer.render( scene, cameraPY, renderTarget );
	
				renderTarget.activeCubeFace = 3;
				renderer.render( scene, cameraNY, renderTarget );
	
				renderTarget.activeCubeFace = 4;
				renderer.render( scene, cameraPZ, renderTarget );
	
				renderTarget.texture.generateMipmaps = generateMipmaps;
	
				renderTarget.activeCubeFace = 5;
				renderer.render( scene, cameraNZ, renderTarget );
	
				renderer.setRenderTarget( null );
	
			};
	
		}
	
		CubeCamera.prototype = Object.create( Object3D.prototype );
		CubeCamera.prototype.constructor = CubeCamera;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function AudioListener() {
	
			Object3D.call( this );
	
			this.type = 'AudioListener';
	
			this.context = AudioContext.getContext();
	
			this.gain = this.context.createGain();
			this.gain.connect( this.context.destination );
	
			this.filter = null;
	
		}
	
		AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: AudioListener,
	
			getInput: function () {
	
				return this.gain;
	
			},
	
			removeFilter: function ( ) {
	
				if ( this.filter !== null ) {
	
					this.gain.disconnect( this.filter );
					this.filter.disconnect( this.context.destination );
					this.gain.connect( this.context.destination );
					this.filter = null;
	
				}
	
			},
	
			getFilter: function () {
	
				return this.filter;
	
			},
	
			setFilter: function ( value ) {
	
				if ( this.filter !== null ) {
	
					this.gain.disconnect( this.filter );
					this.filter.disconnect( this.context.destination );
	
				} else {
	
					this.gain.disconnect( this.context.destination );
	
				}
	
				this.filter = value;
				this.gain.connect( this.filter );
				this.filter.connect( this.context.destination );
	
			},
	
			getMasterVolume: function () {
	
				return this.gain.gain.value;
	
			},
	
			setMasterVolume: function ( value ) {
	
				this.gain.gain.value = value;
	
			},
	
			updateMatrixWorld: ( function () {
	
				var position = new Vector3();
				var quaternion = new Quaternion();
				var scale = new Vector3();
	
				var orientation = new Vector3();
	
				return function updateMatrixWorld( force ) {
	
					Object3D.prototype.updateMatrixWorld.call( this, force );
	
					var listener = this.context.listener;
					var up = this.up;
	
					this.matrixWorld.decompose( position, quaternion, scale );
	
					orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
					if ( listener.positionX ) {
	
						listener.positionX.setValueAtTime( position.x, this.context.currentTime );
						listener.positionY.setValueAtTime( position.y, this.context.currentTime );
						listener.positionZ.setValueAtTime( position.z, this.context.currentTime );
						listener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );
						listener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );
						listener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );
						listener.upX.setValueAtTime( up.x, this.context.currentTime );
						listener.upY.setValueAtTime( up.y, this.context.currentTime );
						listener.upZ.setValueAtTime( up.z, this.context.currentTime );
	
					} else {
	
						listener.setPosition( position.x, position.y, position.z );
						listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );
	
					}
	
				};
	
			} )()
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Reece Aaron Lecrivain / http://reecenotes.com/
		 */
	
		function Audio( listener ) {
	
			Object3D.call( this );
	
			this.type = 'Audio';
	
			this.context = listener.context;
	
			this.gain = this.context.createGain();
			this.gain.connect( listener.getInput() );
	
			this.autoplay = false;
	
			this.buffer = null;
			this.loop = false;
			this.startTime = 0;
			this.playbackRate = 1;
			this.isPlaying = false;
			this.hasPlaybackControl = true;
			this.sourceType = 'empty';
	
			this.filters = [];
	
		}
	
		Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
			constructor: Audio,
	
			getOutput: function () {
	
				return this.gain;
	
			},
	
			setNodeSource: function ( audioNode ) {
	
				this.hasPlaybackControl = false;
				this.sourceType = 'audioNode';
				this.source = audioNode;
				this.connect();
	
				return this;
	
			},
	
			setBuffer: function ( audioBuffer ) {
	
				this.buffer = audioBuffer;
				this.sourceType = 'buffer';
	
				if ( this.autoplay ) this.play();
	
				return this;
	
			},
	
			play: function () {
	
				if ( this.isPlaying === true ) {
	
					console.warn( 'THREE.Audio: Audio is already playing.' );
					return;
	
				}
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				var source = this.context.createBufferSource();
	
				source.buffer = this.buffer;
				source.loop = this.loop;
				source.onended = this.onEnded.bind( this );
				source.playbackRate.setValueAtTime( this.playbackRate, this.startTime );
				source.start( 0, this.startTime );
	
				this.isPlaying = true;
	
				this.source = source;
	
				return this.connect();
	
			},
	
			pause: function () {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				this.source.stop();
				this.startTime = this.context.currentTime;
				this.isPlaying = false;
	
				return this;
	
			},
	
			stop: function () {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				this.source.stop();
				this.startTime = 0;
				this.isPlaying = false;
	
				return this;
	
			},
	
			connect: function () {
	
				if ( this.filters.length > 0 ) {
	
					this.source.connect( this.filters[ 0 ] );
	
					for ( var i = 1, l = this.filters.length; i < l; i ++ ) {
	
						this.filters[ i - 1 ].connect( this.filters[ i ] );
	
					}
	
					this.filters[ this.filters.length - 1 ].connect( this.getOutput() );
	
				} else {
	
					this.source.connect( this.getOutput() );
	
				}
	
				return this;
	
			},
	
			disconnect: function () {
	
				if ( this.filters.length > 0 ) {
	
					this.source.disconnect( this.filters[ 0 ] );
	
					for ( var i = 1, l = this.filters.length; i < l; i ++ ) {
	
						this.filters[ i - 1 ].disconnect( this.filters[ i ] );
	
					}
	
					this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );
	
				} else {
	
					this.source.disconnect( this.getOutput() );
	
				}
	
				return this;
	
			},
	
			getFilters: function () {
	
				return this.filters;
	
			},
	
			setFilters: function ( value ) {
	
				if ( ! value ) value = [];
	
				if ( this.isPlaying === true ) {
	
					this.disconnect();
					this.filters = value;
					this.connect();
	
				} else {
	
					this.filters = value;
	
				}
	
				return this;
	
			},
	
			getFilter: function () {
	
				return this.getFilters()[ 0 ];
	
			},
	
			setFilter: function ( filter ) {
	
				return this.setFilters( filter ? [ filter ] : [] );
	
			},
	
			setPlaybackRate: function ( value ) {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				this.playbackRate = value;
	
				if ( this.isPlaying === true ) {
	
					this.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );
	
				}
	
				return this;
	
			},
	
			getPlaybackRate: function () {
	
				return this.playbackRate;
	
			},
	
			onEnded: function () {
	
				this.isPlaying = false;
	
			},
	
			getLoop: function () {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return false;
	
				}
	
				return this.loop;
	
			},
	
			setLoop: function ( value ) {
	
				if ( this.hasPlaybackControl === false ) {
	
					console.warn( 'THREE.Audio: this Audio has no playback control.' );
					return;
	
				}
	
				this.loop = value;
	
				if ( this.isPlaying === true ) {
	
					this.source.loop = this.loop;
	
				}
	
				return this;
	
			},
	
			getVolume: function () {
	
				return this.gain.gain.value;
	
			},
	
	
			setVolume: function ( value ) {
	
				this.gain.gain.value = value;
	
				return this;
	
			}
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function PositionalAudio( listener ) {
	
			Audio.call( this, listener );
	
			this.panner = this.context.createPanner();
			this.panner.connect( this.gain );
	
		}
	
		PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {
	
			constructor: PositionalAudio,
	
			getOutput: function () {
	
				return this.panner;
	
			},
	
			getRefDistance: function () {
	
				return this.panner.refDistance;
	
			},
	
			setRefDistance: function ( value ) {
	
				this.panner.refDistance = value;
	
			},
	
			getRolloffFactor: function () {
	
				return this.panner.rolloffFactor;
	
			},
	
			setRolloffFactor: function ( value ) {
	
				this.panner.rolloffFactor = value;
	
			},
	
			getDistanceModel: function () {
	
				return this.panner.distanceModel;
	
			},
	
			setDistanceModel: function ( value ) {
	
				this.panner.distanceModel = value;
	
			},
	
			getMaxDistance: function () {
	
				return this.panner.maxDistance;
	
			},
	
			setMaxDistance: function ( value ) {
	
				this.panner.maxDistance = value;
	
			},
	
			updateMatrixWorld: ( function () {
	
				var position = new Vector3();
	
				return function updateMatrixWorld( force ) {
	
					Object3D.prototype.updateMatrixWorld.call( this, force );
	
					position.setFromMatrixPosition( this.matrixWorld );
	
					this.panner.setPosition( position.x, position.y, position.z );
	
				};
	
			} )()
	
	
		} );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function AudioAnalyser( audio, fftSize ) {
	
			this.analyser = audio.context.createAnalyser();
			this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
	
			this.data = new Uint8Array( this.analyser.frequencyBinCount );
	
			audio.getOutput().connect( this.analyser );
	
		}
	
		Object.assign( AudioAnalyser.prototype, {
	
			getFrequencyData: function () {
	
				this.analyser.getByteFrequencyData( this.data );
	
				return this.data;
	
			},
	
			getAverageFrequency: function () {
	
				var value = 0, data = this.getFrequencyData();
	
				for ( var i = 0; i < data.length; i ++ ) {
	
					value += data[ i ];
	
				}
	
				return value / data.length;
	
			}
	
		} );
	
		/**
		 *
		 * Buffered scene graph property that allows weighted accumulation.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function PropertyMixer( binding, typeName, valueSize ) {
	
			this.binding = binding;
			this.valueSize = valueSize;
	
			var bufferType = Float64Array,
				mixFunction;
	
			switch ( typeName ) {
	
				case 'quaternion':
					mixFunction = this._slerp;
					break;
	
				case 'string':
				case 'bool':
					bufferType = Array;
					mixFunction = this._select;
					break;
	
				default:
					mixFunction = this._lerp;
	
			}
	
			this.buffer = new bufferType( valueSize * 4 );
			// layout: [ incoming | accu0 | accu1 | orig ]
			//
			// interpolators can use .buffer as their .result
			// the data then goes to 'incoming'
			//
			// 'accu0' and 'accu1' are used frame-interleaved for
			// the cumulative result and are compared to detect
			// changes
			//
			// 'orig' stores the original state of the property
	
			this._mixBufferRegion = mixFunction;
	
			this.cumulativeWeight = 0;
	
			this.useCount = 0;
			this.referenceCount = 0;
	
		}
	
		PropertyMixer.prototype = {
	
			constructor: PropertyMixer,
	
			// accumulate data in the 'incoming' region into 'accu<i>'
			accumulate: function( accuIndex, weight ) {
	
				// note: happily accumulating nothing when weight = 0, the caller knows
				// the weight and shouldn't have made the call in the first place
	
				var buffer = this.buffer,
					stride = this.valueSize,
					offset = accuIndex * stride + stride,
	
					currentWeight = this.cumulativeWeight;
	
				if ( currentWeight === 0 ) {
	
					// accuN := incoming * weight
	
					for ( var i = 0; i !== stride; ++ i ) {
	
						buffer[ offset + i ] = buffer[ i ];
	
					}
	
					currentWeight = weight;
	
				} else {
	
					// accuN := accuN + incoming * weight
	
					currentWeight += weight;
					var mix = weight / currentWeight;
					this._mixBufferRegion( buffer, offset, 0, mix, stride );
	
				}
	
				this.cumulativeWeight = currentWeight;
	
			},
	
			// apply the state of 'accu<i>' to the binding when accus differ
			apply: function( accuIndex ) {
	
				var stride = this.valueSize,
					buffer = this.buffer,
					offset = accuIndex * stride + stride,
	
					weight = this.cumulativeWeight,
	
					binding = this.binding;
	
				this.cumulativeWeight = 0;
	
				if ( weight < 1 ) {
	
					// accuN := accuN + original * ( 1 - cumulativeWeight )
	
					var originalValueOffset = stride * 3;
	
					this._mixBufferRegion(
							buffer, offset, originalValueOffset, 1 - weight, stride );
	
				}
	
				for ( var i = stride, e = stride + stride; i !== e; ++ i ) {
	
					if ( buffer[ i ] !== buffer[ i + stride ] ) {
	
						// value has changed -> update scene graph
	
						binding.setValue( buffer, offset );
						break;
	
					}
	
				}
	
			},
	
			// remember the state of the bound property and copy it to both accus
			saveOriginalState: function() {
	
				var binding = this.binding;
	
				var buffer = this.buffer,
					stride = this.valueSize,
	
					originalValueOffset = stride * 3;
	
				binding.getValue( buffer, originalValueOffset );
	
				// accu[0..1] := orig -- initially detect changes against the original
				for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {
	
					buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];
	
				}
	
				this.cumulativeWeight = 0;
	
			},
	
			// apply the state previously taken via 'saveOriginalState' to the binding
			restoreOriginalState: function() {
	
				var originalValueOffset = this.valueSize * 3;
				this.binding.setValue( this.buffer, originalValueOffset );
	
			},
	
	
			// mix functions
	
			_select: function( buffer, dstOffset, srcOffset, t, stride ) {
	
				if ( t >= 0.5 ) {
	
					for ( var i = 0; i !== stride; ++ i ) {
	
						buffer[ dstOffset + i ] = buffer[ srcOffset + i ];
	
					}
	
				}
	
			},
	
			_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {
	
				Quaternion.slerpFlat( buffer, dstOffset,
						buffer, dstOffset, buffer, srcOffset, t );
	
			},
	
			_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {
	
				var s = 1 - t;
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					var j = dstOffset + i;
	
					buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;
	
				}
	
			}
	
		};
	
		/**
		 *
		 * A reference to a real property in the scene graph.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function PropertyBinding( rootNode, path, parsedPath ) {
	
			this.path = path;
			this.parsedPath = parsedPath ||
					PropertyBinding.parseTrackName( path );
	
			this.node = PropertyBinding.findNode(
					rootNode, this.parsedPath.nodeName ) || rootNode;
	
			this.rootNode = rootNode;
	
		}
	
		PropertyBinding.prototype = {
	
			constructor: PropertyBinding,
	
			getValue: function getValue_unbound( targetArray, offset ) {
	
				this.bind();
				this.getValue( targetArray, offset );
	
				// Note: This class uses a State pattern on a per-method basis:
				// 'bind' sets 'this.getValue' / 'setValue' and shadows the
				// prototype version of these methods with one that represents
				// the bound state. When the property is not found, the methods
				// become no-ops.
	
			},
	
			setValue: function getValue_unbound( sourceArray, offset ) {
	
				this.bind();
				this.setValue( sourceArray, offset );
	
			},
	
			// create getter / setter pair for a property in the scene graph
			bind: function() {
	
				var targetObject = this.node,
					parsedPath = this.parsedPath,
	
					objectName = parsedPath.objectName,
					propertyName = parsedPath.propertyName,
					propertyIndex = parsedPath.propertyIndex;
	
				if ( ! targetObject ) {
	
					targetObject = PropertyBinding.findNode(
							this.rootNode, parsedPath.nodeName ) || this.rootNode;
	
					this.node = targetObject;
	
				}
	
				// set fail state so we can just 'return' on error
				this.getValue = this._getValue_unavailable;
				this.setValue = this._setValue_unavailable;
	
		 		// ensure there is a value node
				if ( ! targetObject ) {
	
					console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
					return;
	
				}
	
				if ( objectName ) {
	
					var objectIndex = parsedPath.objectIndex;
	
					// special cases were we need to reach deeper into the hierarchy to get the face materials....
					switch ( objectName ) {
	
						case 'materials':
	
							if ( ! targetObject.material ) {
	
								console.error( '  can not bind to material as node does not have a material', this );
								return;
	
							}
	
							if ( ! targetObject.material.materials ) {
	
								console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
								return;
	
							}
	
							targetObject = targetObject.material.materials;
	
							break;
	
						case 'bones':
	
							if ( ! targetObject.skeleton ) {
	
								console.error( '  can not bind to bones as node does not have a skeleton', this );
								return;
	
							}
	
							// potential future optimization: skip this if propertyIndex is already an integer
							// and convert the integer string to a true integer.
	
							targetObject = targetObject.skeleton.bones;
	
							// support resolving morphTarget names into indices.
							for ( var i = 0; i < targetObject.length; i ++ ) {
	
								if ( targetObject[ i ].name === objectIndex ) {
	
									objectIndex = i;
									break;
	
								}
	
							}
	
							break;
	
						default:
	
							if ( targetObject[ objectName ] === undefined ) {
	
								console.error( '  can not bind to objectName of node, undefined', this );
								return;
	
							}
	
							targetObject = targetObject[ objectName ];
	
					}
	
	
					if ( objectIndex !== undefined ) {
	
						if ( targetObject[ objectIndex ] === undefined ) {
	
							console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
							return;
	
						}
	
						targetObject = targetObject[ objectIndex ];
	
					}
	
				}
	
				// resolve property
				var nodeProperty = targetObject[ propertyName ];
	
				if ( nodeProperty === undefined ) {
	
					var nodeName = parsedPath.nodeName;
	
					console.error( "  trying to update property for track: " + nodeName +
							'.' + propertyName + " but it wasn't found.", targetObject );
					return;
	
				}
	
				// determine versioning scheme
				var versioning = this.Versioning.None;
	
				if ( targetObject.needsUpdate !== undefined ) { // material
	
					versioning = this.Versioning.NeedsUpdate;
					this.targetObject = targetObject;
	
				} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform
	
					versioning = this.Versioning.MatrixWorldNeedsUpdate;
					this.targetObject = targetObject;
	
				}
	
				// determine how the property gets bound
				var bindingType = this.BindingType.Direct;
	
				if ( propertyIndex !== undefined ) {
					// access a sub element of the property array (only primitives are supported right now)
	
					if ( propertyName === "morphTargetInfluences" ) {
						// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
	
						// support resolving morphTarget names into indices.
						if ( ! targetObject.geometry ) {
	
							console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
							return;
	
						}
	
						if ( ! targetObject.geometry.morphTargets ) {
	
							console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
							return;
	
						}
	
						for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {
	
							if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {
	
								propertyIndex = i;
								break;
	
							}
	
						}
	
					}
	
					bindingType = this.BindingType.ArrayElement;
	
					this.resolvedProperty = nodeProperty;
					this.propertyIndex = propertyIndex;
	
				} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
					// must use copy for Object3D.Euler/Quaternion
	
					bindingType = this.BindingType.HasFromToArray;
	
					this.resolvedProperty = nodeProperty;
	
				} else if ( nodeProperty.length !== undefined ) {
	
					bindingType = this.BindingType.EntireArray;
	
					this.resolvedProperty = nodeProperty;
	
				} else {
	
					this.propertyName = propertyName;
	
				}
	
				// select getter / setter
				this.getValue = this.GetterByBindingType[ bindingType ];
				this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];
	
			},
	
			unbind: function() {
	
				this.node = null;
	
				// back to the prototype version of getValue / setValue
				// note: avoiding to mutate the shape of 'this' via 'delete'
				this.getValue = this._getValue_unbound;
				this.setValue = this._setValue_unbound;
	
			}
	
		};
	
		Object.assign( PropertyBinding.prototype, { // prototype, continued
	
			// these are used to "bind" a nonexistent property
			_getValue_unavailable: function() {},
			_setValue_unavailable: function() {},
	
			// initial state of these methods that calls 'bind'
			_getValue_unbound: PropertyBinding.prototype.getValue,
			_setValue_unbound: PropertyBinding.prototype.setValue,
	
			BindingType: {
				Direct: 0,
				EntireArray: 1,
				ArrayElement: 2,
				HasFromToArray: 3
			},
	
			Versioning: {
				None: 0,
				NeedsUpdate: 1,
				MatrixWorldNeedsUpdate: 2
			},
	
			GetterByBindingType: [
	
				function getValue_direct( buffer, offset ) {
	
					buffer[ offset ] = this.node[ this.propertyName ];
	
				},
	
				function getValue_array( buffer, offset ) {
	
					var source = this.resolvedProperty;
	
					for ( var i = 0, n = source.length; i !== n; ++ i ) {
	
						buffer[ offset ++ ] = source[ i ];
	
					}
	
				},
	
				function getValue_arrayElement( buffer, offset ) {
	
					buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];
	
				},
	
				function getValue_toArray( buffer, offset ) {
	
					this.resolvedProperty.toArray( buffer, offset );
	
				}
	
			],
	
			SetterByBindingTypeAndVersioning: [
	
				[
					// Direct
	
					function setValue_direct( buffer, offset ) {
	
						this.node[ this.propertyName ] = buffer[ offset ];
	
					},
	
					function setValue_direct_setNeedsUpdate( buffer, offset ) {
	
						this.node[ this.propertyName ] = buffer[ offset ];
						this.targetObject.needsUpdate = true;
	
					},
	
					function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
						this.node[ this.propertyName ] = buffer[ offset ];
						this.targetObject.matrixWorldNeedsUpdate = true;
	
					}
	
				], [
	
					// EntireArray
	
					function setValue_array( buffer, offset ) {
	
						var dest = this.resolvedProperty;
	
						for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
							dest[ i ] = buffer[ offset ++ ];
	
						}
	
					},
	
					function setValue_array_setNeedsUpdate( buffer, offset ) {
	
						var dest = this.resolvedProperty;
	
						for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
							dest[ i ] = buffer[ offset ++ ];
	
						}
	
						this.targetObject.needsUpdate = true;
	
					},
	
					function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
						var dest = this.resolvedProperty;
	
						for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
							dest[ i ] = buffer[ offset ++ ];
	
						}
	
						this.targetObject.matrixWorldNeedsUpdate = true;
	
					}
	
				], [
	
					// ArrayElement
	
					function setValue_arrayElement( buffer, offset ) {
	
						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
	
					},
	
					function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {
	
						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
						this.targetObject.needsUpdate = true;
	
					},
	
					function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
						this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
						this.targetObject.matrixWorldNeedsUpdate = true;
	
					}
	
				], [
	
					// HasToFromArray
	
					function setValue_fromArray( buffer, offset ) {
	
						this.resolvedProperty.fromArray( buffer, offset );
	
					},
	
					function setValue_fromArray_setNeedsUpdate( buffer, offset ) {
	
						this.resolvedProperty.fromArray( buffer, offset );
						this.targetObject.needsUpdate = true;
	
					},
	
					function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
						this.resolvedProperty.fromArray( buffer, offset );
						this.targetObject.matrixWorldNeedsUpdate = true;
	
					}
	
				]
	
			]
	
		} );
	
		PropertyBinding.Composite =
				function( targetGroup, path, optionalParsedPath ) {
	
			var parsedPath = optionalParsedPath ||
					PropertyBinding.parseTrackName( path );
	
			this._targetGroup = targetGroup;
			this._bindings = targetGroup.subscribe_( path, parsedPath );
	
		};
	
		PropertyBinding.Composite.prototype = {
	
			constructor: PropertyBinding.Composite,
	
			getValue: function( array, offset ) {
	
				this.bind(); // bind all binding
	
				var firstValidIndex = this._targetGroup.nCachedObjects_,
					binding = this._bindings[ firstValidIndex ];
	
				// and only call .getValue on the first
				if ( binding !== undefined ) binding.getValue( array, offset );
	
			},
	
			setValue: function( array, offset ) {
	
				var bindings = this._bindings;
	
				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {
	
					bindings[ i ].setValue( array, offset );
	
				}
	
			},
	
			bind: function() {
	
				var bindings = this._bindings;
	
				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {
	
					bindings[ i ].bind();
	
				}
	
			},
	
			unbind: function() {
	
				var bindings = this._bindings;
	
				for ( var i = this._targetGroup.nCachedObjects_,
						n = bindings.length; i !== n; ++ i ) {
	
					bindings[ i ].unbind();
	
				}
	
			}
	
		};
	
		PropertyBinding.create = function( root, path, parsedPath ) {
	
			if ( ! ( root && root.isAnimationObjectGroup ) ) {
	
				return new PropertyBinding( root, path, parsedPath );
	
			} else {
	
				return new PropertyBinding.Composite( root, path, parsedPath );
	
			}
	
		};
	
		PropertyBinding.parseTrackName = function( trackName ) {
	
			// matches strings in the form of:
			//    nodeName.property
			//    nodeName.property[accessor]
			//    nodeName.material.property[accessor]
			//    uuid.property[accessor]
			//    uuid.objectName[objectIndex].propertyName[propertyIndex]
			//    parentName/nodeName.property
			//    parentName/parentName/nodeName.property[index]
			//    .bone[Armature.DEF_cog].position
			//    scene:helium_balloon_model:helium_balloon_model.position
			// created and tested via https://regex101.com/#javascript
	
			var re = /^((?:[\w-]+[\/:])*)([\w-]+)?(?:\.([\w-]+)(?:\[(.+)\])?)?\.([\w-]+)(?:\[(.+)\])?$/;
			var matches = re.exec( trackName );
	
			if ( ! matches ) {
	
				throw new Error( "cannot parse trackName at all: " + trackName );
	
			}
	
			var results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[ 2 ], 	// allowed to be null, specified root node.
				objectName: matches[ 3 ],
				objectIndex: matches[ 4 ],
				propertyName: matches[ 5 ],
				propertyIndex: matches[ 6 ]	// allowed to be null, specifies that the whole property is set.
			};
	
			if ( results.propertyName === null || results.propertyName.length === 0 ) {
	
				throw new Error( "can not parse propertyName from trackName: " + trackName );
	
			}
	
			return results;
	
		};
	
		PropertyBinding.findNode = function( root, nodeName ) {
	
			if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {
	
				return root;
	
			}
	
			// search into skeleton bones.
			if ( root.skeleton ) {
	
				var searchSkeleton = function( skeleton ) {
	
					for( var i = 0; i < skeleton.bones.length; i ++ ) {
	
						var bone = skeleton.bones[ i ];
	
						if ( bone.name === nodeName ) {
	
							return bone;
	
						}
					}
	
					return null;
	
				};
	
				var bone = searchSkeleton( root.skeleton );
	
				if ( bone ) {
	
					return bone;
	
				}
			}
	
			// search into node subtree.
			if ( root.children ) {
	
				var searchNodeSubtree = function( children ) {
	
					for( var i = 0; i < children.length; i ++ ) {
	
						var childNode = children[ i ];
	
						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {
	
							return childNode;
	
						}
	
						var result = searchNodeSubtree( childNode.children );
	
						if ( result ) return result;
	
					}
	
					return null;
	
				};
	
				var subTreeNode = searchNodeSubtree( root.children );
	
				if ( subTreeNode ) {
	
					return subTreeNode;
	
				}
	
			}
	
			return null;
	
		};
	
		/**
		 *
		 * A group of objects that receives a shared animation state.
		 *
		 * Usage:
		 *
		 * 	-	Add objects you would otherwise pass as 'root' to the
		 * 		constructor or the .clipAction method of AnimationMixer.
		 *
		 * 	-	Instead pass this object as 'root'.
		 *
		 * 	-	You can also add and remove objects later when the mixer
		 * 		is running.
		 *
		 * Note:
		 *
		 *  	Objects of this class appear as one object to the mixer,
		 *  	so cache control of the individual objects must be done
		 *  	on the group.
		 *
		 * Limitation:
		 *
		 * 	- 	The animated properties must be compatible among the
		 * 		all objects in the group.
		 *
		 *  -	A single property can either be controlled through a
		 *  	target group or directly, but not both.
		 *
		 * @author tschw
		 */
	
		function AnimationObjectGroup( var_args ) {
	
			this.uuid = _Math.generateUUID();
	
			// cached objects followed by the active ones
			this._objects = Array.prototype.slice.call( arguments );
	
			this.nCachedObjects_ = 0;			// threshold
			// note: read by PropertyBinding.Composite
	
			var indices = {};
			this._indicesByUUID = indices;		// for bookkeeping
	
			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
				indices[ arguments[ i ].uuid ] = i;
	
			}
	
			this._paths = [];					// inside: string
			this._parsedPaths = [];				// inside: { we don't care, here }
			this._bindings = []; 				// inside: Array< PropertyBinding >
			this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays
	
			var scope = this;
	
			this.stats = {
	
				objects: {
					get total() { return scope._objects.length; },
					get inUse() { return this.total - scope.nCachedObjects_;  }
				},
	
				get bindingsPerObject() { return scope._bindings.length; }
	
			};
	
		}
	
		AnimationObjectGroup.prototype = {
	
			constructor: AnimationObjectGroup,
	
			isAnimationObjectGroup: true,
	
			add: function( var_args ) {
	
				var objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					nBindings = bindings.length;
	
				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ],
						knownObject = undefined;
	
					if ( index === undefined ) {
	
						// unknown object -> add it to the ACTIVE region
	
						index = nObjects ++;
						indicesByUUID[ uuid ] = index;
						objects.push( object );
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							bindings[ j ].push(
									new PropertyBinding(
										object, paths[ j ], parsedPaths[ j ] ) );
	
						}
	
					} else if ( index < nCachedObjects ) {
	
						knownObject = objects[ index ];
	
						// move existing object to the ACTIVE region
	
						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ];
	
						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;
	
						indicesByUUID[ uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = object;
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								binding = bindingsForPath[ index ];
	
							bindingsForPath[ index ] = lastCached;
	
							if ( binding === undefined ) {
	
								// since we do not bother to create new bindings
								// for objects that are cached, the binding may
								// or may not exist
	
								binding = new PropertyBinding(
										object, paths[ j ], parsedPaths[ j ] );
	
							}
	
							bindingsForPath[ firstActiveIndex ] = binding;
	
						}
	
					} else if ( objects[ index ] !== knownObject) {
	
						console.error( "Different objects with the same UUID " +
								"detected. Clean the caches or recreate your " +
								"infrastructure when reloading scenes..." );
	
					} // else the object is already where we want it to be
	
				} // for arguments
	
				this.nCachedObjects_ = nCachedObjects;
	
			},
	
			remove: function( var_args ) {
	
				var objects = this._objects,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;
	
				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];
	
					if ( index !== undefined && index >= nCachedObjects ) {
	
						// move existing object into the CACHED region
	
						var lastCachedIndex = nCachedObjects ++,
							firstActiveObject = objects[ lastCachedIndex ];
	
						indicesByUUID[ firstActiveObject.uuid ] = index;
						objects[ index ] = firstActiveObject;
	
						indicesByUUID[ uuid ] = lastCachedIndex;
						objects[ lastCachedIndex ] = object;
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							var bindingsForPath = bindings[ j ],
								firstActive = bindingsForPath[ lastCachedIndex ],
								binding = bindingsForPath[ index ];
	
							bindingsForPath[ index ] = firstActive;
							bindingsForPath[ lastCachedIndex ] = binding;
	
						}
	
					}
	
				} // for arguments
	
				this.nCachedObjects_ = nCachedObjects;
	
			},
	
			// remove & forget
			uncache: function( var_args ) {
	
				var objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					indicesByUUID = this._indicesByUUID,
					bindings = this._bindings,
					nBindings = bindings.length;
	
				for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
					var object = arguments[ i ],
						uuid = object.uuid,
						index = indicesByUUID[ uuid ];
	
					if ( index !== undefined ) {
	
						delete indicesByUUID[ uuid ];
	
						if ( index < nCachedObjects ) {
	
							// object is cached, shrink the CACHED region
	
							var firstActiveIndex = -- nCachedObjects,
								lastCachedObject = objects[ firstActiveIndex ],
								lastIndex = -- nObjects,
								lastObject = objects[ lastIndex ];
	
							// last cached object takes this object's place
							indicesByUUID[ lastCachedObject.uuid ] = index;
							objects[ index ] = lastCachedObject;
	
							// last object goes to the activated slot and pop
							indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
							objects[ firstActiveIndex ] = lastObject;
							objects.pop();
	
							// accounting is done, now do the same for all bindings
	
							for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
								var bindingsForPath = bindings[ j ],
									lastCached = bindingsForPath[ firstActiveIndex ],
									last = bindingsForPath[ lastIndex ];
	
								bindingsForPath[ index ] = lastCached;
								bindingsForPath[ firstActiveIndex ] = last;
								bindingsForPath.pop();
	
							}
	
						} else {
	
							// object is active, just swap with the last and pop
	
							var lastIndex = -- nObjects,
								lastObject = objects[ lastIndex ];
	
							indicesByUUID[ lastObject.uuid ] = index;
							objects[ index ] = lastObject;
							objects.pop();
	
							// accounting is done, now do the same for all bindings
	
							for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
								var bindingsForPath = bindings[ j ];
	
								bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
								bindingsForPath.pop();
	
							}
	
						} // cached or active
	
					} // if object is known
	
				} // for arguments
	
				this.nCachedObjects_ = nCachedObjects;
	
			},
	
			// Internal interface used by befriended PropertyBinding.Composite:
	
			subscribe_: function( path, parsedPath ) {
				// returns an array of bindings for the given path that is changed
				// according to the contained objects in the group
	
				var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[ path ],
					bindings = this._bindings;
	
				if ( index !== undefined ) return bindings[ index ];
	
				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					objects = this._objects,
					nObjects = objects.length,
					nCachedObjects = this.nCachedObjects_,
					bindingsForPath = new Array( nObjects );
	
				index = bindings.length;
	
				indicesByPath[ path ] = index;
	
				paths.push( path );
				parsedPaths.push( parsedPath );
				bindings.push( bindingsForPath );
	
				for ( var i = nCachedObjects,
						n = objects.length; i !== n; ++ i ) {
	
					var object = objects[ i ];
	
					bindingsForPath[ i ] =
							new PropertyBinding( object, path, parsedPath );
	
				}
	
				return bindingsForPath;
	
			},
	
			unsubscribe_: function( path ) {
				// tells the group to forget about a property path and no longer
				// update the array previously obtained with 'subscribe_'
	
				var indicesByPath = this._bindingsIndicesByPath,
					index = indicesByPath[ path ];
	
				if ( index !== undefined ) {
	
					var paths = this._paths,
						parsedPaths = this._parsedPaths,
						bindings = this._bindings,
						lastBindingsIndex = bindings.length - 1,
						lastBindings = bindings[ lastBindingsIndex ],
						lastBindingsPath = path[ lastBindingsIndex ];
	
					indicesByPath[ lastBindingsPath ] = index;
	
					bindings[ index ] = lastBindings;
					bindings.pop();
	
					parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
					parsedPaths.pop();
	
					paths[ index ] = paths[ lastBindingsIndex ];
					paths.pop();
	
				}
	
			}
	
		};
	
		/**
		 *
		 * Action provided by AnimationMixer for scheduling clip playback on specific
		 * objects.
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 *
		 */
	
		function AnimationAction( mixer, clip, localRoot ) {
	
			this._mixer = mixer;
			this._clip = clip;
			this._localRoot = localRoot || null;
	
			var tracks = clip.tracks,
				nTracks = tracks.length,
				interpolants = new Array( nTracks );
	
			var interpolantSettings = {
					endingStart: 	ZeroCurvatureEnding,
					endingEnd:		ZeroCurvatureEnding
			};
	
			for ( var i = 0; i !== nTracks; ++ i ) {
	
				var interpolant = tracks[ i ].createInterpolant( null );
				interpolants[ i ] = interpolant;
				interpolant.settings = interpolantSettings;
	
			}
	
			this._interpolantSettings = interpolantSettings;
	
			this._interpolants = interpolants;	// bound by the mixer
	
			// inside: PropertyMixer (managed by the mixer)
			this._propertyBindings = new Array( nTracks );
	
			this._cacheIndex = null;			// for the memory manager
			this._byClipCacheIndex = null;		// for the memory manager
	
			this._timeScaleInterpolant = null;
			this._weightInterpolant = null;
	
			this.loop = LoopRepeat;
			this._loopCount = -1;
	
			// global mixer time when the action is to be started
			// it's set back to 'null' upon start of the action
			this._startTime = null;
	
			// scaled local time of the action
			// gets clamped or wrapped to 0..clip.duration according to loop
			this.time = 0;
	
			this.timeScale = 1;
			this._effectiveTimeScale = 1;
	
			this.weight = 1;
			this._effectiveWeight = 1;
	
			this.repetitions = Infinity; 		// no. of repetitions when looping
	
			this.paused = false;				// false -> zero effective time scale
			this.enabled = true;				// true -> zero effective weight
	
			this.clampWhenFinished 	= false;	// keep feeding the last frame?
	
			this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
			this.zeroSlopeAtEnd		= true;		// clips for start, loop and end
	
		}
	
		AnimationAction.prototype = {
	
			constructor: AnimationAction,
	
			// State & Scheduling
	
			play: function() {
	
				this._mixer._activateAction( this );
	
				return this;
	
			},
	
			stop: function() {
	
				this._mixer._deactivateAction( this );
	
				return this.reset();
	
			},
	
			reset: function() {
	
				this.paused = false;
				this.enabled = true;
	
				this.time = 0;			// restart clip
				this._loopCount = -1;	// forget previous loops
				this._startTime = null;	// forget scheduling
	
				return this.stopFading().stopWarping();
	
			},
	
			isRunning: function() {
	
				return this.enabled && ! this.paused && this.timeScale !== 0 &&
						this._startTime === null && this._mixer._isActiveAction( this );
	
			},
	
			// return true when play has been called
			isScheduled: function() {
	
				return this._mixer._isActiveAction( this );
	
			},
	
			startAt: function( time ) {
	
				this._startTime = time;
	
				return this;
	
			},
	
			setLoop: function( mode, repetitions ) {
	
				this.loop = mode;
				this.repetitions = repetitions;
	
				return this;
	
			},
	
			// Weight
	
			// set the weight stopping any scheduled fading
			// although .enabled = false yields an effective weight of zero, this
			// method does *not* change .enabled, because it would be confusing
			setEffectiveWeight: function( weight ) {
	
				this.weight = weight;
	
				// note: same logic as when updated at runtime
				this._effectiveWeight = this.enabled ? weight : 0;
	
				return this.stopFading();
	
			},
	
			// return the weight considering fading and .enabled
			getEffectiveWeight: function() {
	
				return this._effectiveWeight;
	
			},
	
			fadeIn: function( duration ) {
	
				return this._scheduleFading( duration, 0, 1 );
	
			},
	
			fadeOut: function( duration ) {
	
				return this._scheduleFading( duration, 1, 0 );
	
			},
	
			crossFadeFrom: function( fadeOutAction, duration, warp ) {
	
				fadeOutAction.fadeOut( duration );
				this.fadeIn( duration );
	
				if( warp ) {
	
					var fadeInDuration = this._clip.duration,
						fadeOutDuration = fadeOutAction._clip.duration,
	
						startEndRatio = fadeOutDuration / fadeInDuration,
						endStartRatio = fadeInDuration / fadeOutDuration;
	
					fadeOutAction.warp( 1.0, startEndRatio, duration );
					this.warp( endStartRatio, 1.0, duration );
	
				}
	
				return this;
	
			},
	
			crossFadeTo: function( fadeInAction, duration, warp ) {
	
				return fadeInAction.crossFadeFrom( this, duration, warp );
	
			},
	
			stopFading: function() {
	
				var weightInterpolant = this._weightInterpolant;
	
				if ( weightInterpolant !== null ) {
	
					this._weightInterpolant = null;
					this._mixer._takeBackControlInterpolant( weightInterpolant );
	
				}
	
				return this;
	
			},
	
			// Time Scale Control
	
			// set the weight stopping any scheduled warping
			// although .paused = true yields an effective time scale of zero, this
			// method does *not* change .paused, because it would be confusing
			setEffectiveTimeScale: function( timeScale ) {
	
				this.timeScale = timeScale;
				this._effectiveTimeScale = this.paused ? 0 :timeScale;
	
				return this.stopWarping();
	
			},
	
			// return the time scale considering warping and .paused
			getEffectiveTimeScale: function() {
	
				return this._effectiveTimeScale;
	
			},
	
			setDuration: function( duration ) {
	
				this.timeScale = this._clip.duration / duration;
	
				return this.stopWarping();
	
			},
	
			syncWith: function( action ) {
	
				this.time = action.time;
				this.timeScale = action.timeScale;
	
				return this.stopWarping();
	
			},
	
			halt: function( duration ) {
	
				return this.warp( this._effectiveTimeScale, 0, duration );
	
			},
	
			warp: function( startTimeScale, endTimeScale, duration ) {
	
				var mixer = this._mixer, now = mixer.time,
					interpolant = this._timeScaleInterpolant,
	
					timeScale = this.timeScale;
	
				if ( interpolant === null ) {
	
					interpolant = mixer._lendControlInterpolant();
					this._timeScaleInterpolant = interpolant;
	
				}
	
				var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;
	
				times[ 0 ] = now;
				times[ 1 ] = now + duration;
	
				values[ 0 ] = startTimeScale / timeScale;
				values[ 1 ] = endTimeScale / timeScale;
	
				return this;
	
			},
	
			stopWarping: function() {
	
				var timeScaleInterpolant = this._timeScaleInterpolant;
	
				if ( timeScaleInterpolant !== null ) {
	
					this._timeScaleInterpolant = null;
					this._mixer._takeBackControlInterpolant( timeScaleInterpolant );
	
				}
	
				return this;
	
			},
	
			// Object Accessors
	
			getMixer: function() {
	
				return this._mixer;
	
			},
	
			getClip: function() {
	
				return this._clip;
	
			},
	
			getRoot: function() {
	
				return this._localRoot || this._mixer._root;
	
			},
	
			// Interna
	
			_update: function( time, deltaTime, timeDirection, accuIndex ) {
				// called by the mixer
	
				var startTime = this._startTime;
	
				if ( startTime !== null ) {
	
					// check for scheduled start of action
	
					var timeRunning = ( time - startTime ) * timeDirection;
					if ( timeRunning < 0 || timeDirection === 0 ) {
	
						return; // yet to come / don't decide when delta = 0
	
					}
	
					// start
	
					this._startTime = null; // unschedule
					deltaTime = timeDirection * timeRunning;
	
				}
	
				// apply time scale and advance time
	
				deltaTime *= this._updateTimeScale( time );
				var clipTime = this._updateTime( deltaTime );
	
				// note: _updateTime may disable the action resulting in
				// an effective weight of 0
	
				var weight = this._updateWeight( time );
	
				if ( weight > 0 ) {
	
					var interpolants = this._interpolants;
					var propertyMixers = this._propertyBindings;
	
					for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {
	
						interpolants[ j ].evaluate( clipTime );
						propertyMixers[ j ].accumulate( accuIndex, weight );
	
					}
	
				}
	
			},
	
			_updateWeight: function( time ) {
	
				var weight = 0;
	
				if ( this.enabled ) {
	
					weight = this.weight;
					var interpolant = this._weightInterpolant;
	
					if ( interpolant !== null ) {
	
						var interpolantValue = interpolant.evaluate( time )[ 0 ];
	
						weight *= interpolantValue;
	
						if ( time > interpolant.parameterPositions[ 1 ] ) {
	
							this.stopFading();
	
							if ( interpolantValue === 0 ) {
	
								// faded out, disable
								this.enabled = false;
	
							}
	
						}
	
					}
	
				}
	
				this._effectiveWeight = weight;
				return weight;
	
			},
	
			_updateTimeScale: function( time ) {
	
				var timeScale = 0;
	
				if ( ! this.paused ) {
	
					timeScale = this.timeScale;
	
					var interpolant = this._timeScaleInterpolant;
	
					if ( interpolant !== null ) {
	
						var interpolantValue = interpolant.evaluate( time )[ 0 ];
	
						timeScale *= interpolantValue;
	
						if ( time > interpolant.parameterPositions[ 1 ] ) {
	
							this.stopWarping();
	
							if ( timeScale === 0 ) {
	
								// motion has halted, pause
								this.paused = true;
	
							} else {
	
								// warp done - apply final time scale
								this.timeScale = timeScale;
	
							}
	
						}
	
					}
	
				}
	
				this._effectiveTimeScale = timeScale;
				return timeScale;
	
			},
	
			_updateTime: function( deltaTime ) {
	
				var time = this.time + deltaTime;
	
				if ( deltaTime === 0 ) return time;
	
				var duration = this._clip.duration,
	
					loop = this.loop,
					loopCount = this._loopCount;
	
				if ( loop === LoopOnce ) {
	
					if ( loopCount === -1 ) {
						// just started
	
						this._loopCount = 0;
						this._setEndings( true, true, false );
	
					}
	
					handle_stop: {
	
						if ( time >= duration ) {
	
							time = duration;
	
						} else if ( time < 0 ) {
	
							time = 0;
	
						} else break handle_stop;
	
						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;
	
						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime < 0 ? -1 : 1
						} );
	
					}
	
				} else { // repetitive Repeat or PingPong
	
					var pingPong = ( loop === LoopPingPong );
	
					if ( loopCount === -1 ) {
						// just started
	
						if ( deltaTime >= 0 ) {
	
							loopCount = 0;
	
							this._setEndings(
									true, this.repetitions === 0, pingPong );
	
						} else {
	
							// when looping in reverse direction, the initial
							// transition through zero counts as a repetition,
							// so leave loopCount at -1
	
							this._setEndings(
									this.repetitions === 0, true, pingPong );
	
						}
	
					}
	
					if ( time >= duration || time < 0 ) {
						// wrap around
	
						var loopDelta = Math.floor( time / duration ); // signed
						time -= duration * loopDelta;
	
						loopCount += Math.abs( loopDelta );
	
						var pending = this.repetitions - loopCount;
	
						if ( pending < 0 ) {
							// have to stop (switch state, clamp time, fire event)
	
							if ( this.clampWhenFinished ) this.paused = true;
							else this.enabled = false;
	
							time = deltaTime > 0 ? duration : 0;
	
							this._mixer.dispatchEvent( {
								type: 'finished', action: this,
								direction: deltaTime > 0 ? 1 : -1
							} );
	
						} else {
							// keep running
	
							if ( pending === 0 ) {
								// entering the last round
	
								var atStart = deltaTime < 0;
								this._setEndings( atStart, ! atStart, pingPong );
	
							} else {
	
								this._setEndings( false, false, pingPong );
	
							}
	
							this._loopCount = loopCount;
	
							this._mixer.dispatchEvent( {
								type: 'loop', action: this, loopDelta: loopDelta
							} );
	
						}
	
					}
	
					if ( pingPong && ( loopCount & 1 ) === 1 ) {
						// invert time for the "pong round"
	
						this.time = time;
						return duration - time;
	
					}
	
				}
	
				this.time = time;
				return time;
	
			},
	
			_setEndings: function( atStart, atEnd, pingPong ) {
	
				var settings = this._interpolantSettings;
	
				if ( pingPong ) {
	
					settings.endingStart 	= ZeroSlopeEnding;
					settings.endingEnd		= ZeroSlopeEnding;
	
				} else {
	
					// assuming for LoopOnce atStart == atEnd == true
	
					if ( atStart ) {
	
						settings.endingStart = this.zeroSlopeAtStart ?
								ZeroSlopeEnding : ZeroCurvatureEnding;
	
					} else {
	
						settings.endingStart = WrapAroundEnding;
	
					}
	
					if ( atEnd ) {
	
						settings.endingEnd = this.zeroSlopeAtEnd ?
								ZeroSlopeEnding : ZeroCurvatureEnding;
	
					} else {
	
						settings.endingEnd 	 = WrapAroundEnding;
	
					}
	
				}
	
			},
	
			_scheduleFading: function( duration, weightNow, weightThen ) {
	
				var mixer = this._mixer, now = mixer.time,
					interpolant = this._weightInterpolant;
	
				if ( interpolant === null ) {
	
					interpolant = mixer._lendControlInterpolant();
					this._weightInterpolant = interpolant;
	
				}
	
				var times = interpolant.parameterPositions,
					values = interpolant.sampleValues;
	
				times[ 0 ] = now; 				values[ 0 ] = weightNow;
				times[ 1 ] = now + duration;	values[ 1 ] = weightThen;
	
				return this;
	
			}
	
		};
	
		/**
		 *
		 * Player for AnimationClips.
		 *
		 *
		 * @author Ben Houston / http://clara.io/
		 * @author David Sarno / http://lighthaus.us/
		 * @author tschw
		 */
	
		function AnimationMixer( root ) {
	
			this._root = root;
			this._initMemoryManager();
			this._accuIndex = 0;
	
			this.time = 0;
	
			this.timeScale = 1.0;
	
		}
	
		AnimationMixer.prototype = {
	
			constructor: AnimationMixer,
	
			// return an action for a clip optionally using a custom root target
			// object (this method allocates a lot of dynamic memory in case a
			// previously unknown clip/root combination is specified)
			clipAction: function ( clip, optionalRoot ) {
	
				var root = optionalRoot || this._root,
					rootUuid = root.uuid,
	
					clipObject = typeof clip === 'string' ?
							AnimationClip.findByName( root, clip ) : clip,
	
					clipUuid = clipObject !== null ? clipObject.uuid : clip,
	
					actionsForClip = this._actionsByClip[ clipUuid ],
					prototypeAction = null;
	
				if ( actionsForClip !== undefined ) {
	
					var existingAction =
							actionsForClip.actionByRoot[ rootUuid ];
	
					if ( existingAction !== undefined ) {
	
						return existingAction;
	
					}
	
					// we know the clip, so we don't have to parse all
					// the bindings again but can just copy
					prototypeAction = actionsForClip.knownActions[ 0 ];
	
					// also, take the clip from the prototype action
					if ( clipObject === null )
						clipObject = prototypeAction._clip;
	
				}
	
				// clip must be known when specified via string
				if ( clipObject === null ) return null;
	
				// allocate all resources required to run it
				var newAction = new AnimationAction( this, clipObject, optionalRoot );
	
				this._bindAction( newAction, prototypeAction );
	
				// and make the action known to the memory manager
				this._addInactiveAction( newAction, clipUuid, rootUuid );
	
				return newAction;
	
			},
	
			// get an existing action
			existingAction: function ( clip, optionalRoot ) {
	
				var root = optionalRoot || this._root,
					rootUuid = root.uuid,
	
					clipObject = typeof clip === 'string' ?
							AnimationClip.findByName( root, clip ) : clip,
	
					clipUuid = clipObject ? clipObject.uuid : clip,
	
					actionsForClip = this._actionsByClip[ clipUuid ];
	
				if ( actionsForClip !== undefined ) {
	
					return actionsForClip.actionByRoot[ rootUuid ] || null;
	
				}
	
				return null;
	
			},
	
			// deactivates all previously scheduled actions
			stopAllAction: function () {
	
				var actions = this._actions,
					nActions = this._nActiveActions,
					bindings = this._bindings,
					nBindings = this._nActiveBindings;
	
				this._nActiveActions = 0;
				this._nActiveBindings = 0;
	
				for ( var i = 0; i !== nActions; ++ i ) {
	
					actions[ i ].reset();
	
				}
	
				for ( var i = 0; i !== nBindings; ++ i ) {
	
					bindings[ i ].useCount = 0;
	
				}
	
				return this;
	
			},
	
			// advance the time and update apply the animation
			update: function ( deltaTime ) {
	
				deltaTime *= this.timeScale;
	
				var actions = this._actions,
					nActions = this._nActiveActions,
	
					time = this.time += deltaTime,
					timeDirection = Math.sign( deltaTime ),
	
					accuIndex = this._accuIndex ^= 1;
	
				// run active actions
	
				for ( var i = 0; i !== nActions; ++ i ) {
	
					var action = actions[ i ];
	
					if ( action.enabled ) {
	
						action._update( time, deltaTime, timeDirection, accuIndex );
	
					}
	
				}
	
				// update scene graph
	
				var bindings = this._bindings,
					nBindings = this._nActiveBindings;
	
				for ( var i = 0; i !== nBindings; ++ i ) {
	
					bindings[ i ].apply( accuIndex );
	
				}
	
				return this;
	
			},
	
			// return this mixer's root target object
			getRoot: function () {
	
				return this._root;
	
			},
	
			// free all resources specific to a particular clip
			uncacheClip: function ( clip ) {
	
				var actions = this._actions,
					clipUuid = clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ];
	
				if ( actionsForClip !== undefined ) {
	
					// note: just calling _removeInactiveAction would mess up the
					// iteration state and also require updating the state we can
					// just throw away
	
					var actionsToRemove = actionsForClip.knownActions;
	
					for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {
	
						var action = actionsToRemove[ i ];
	
						this._deactivateAction( action );
	
						var cacheIndex = action._cacheIndex,
							lastInactiveAction = actions[ actions.length - 1 ];
	
						action._cacheIndex = null;
						action._byClipCacheIndex = null;
	
						lastInactiveAction._cacheIndex = cacheIndex;
						actions[ cacheIndex ] = lastInactiveAction;
						actions.pop();
	
						this._removeInactiveBindingsForAction( action );
	
					}
	
					delete actionsByClip[ clipUuid ];
	
				}
	
			},
	
			// free all resources specific to a particular root target object
			uncacheRoot: function ( root ) {
	
				var rootUuid = root.uuid,
					actionsByClip = this._actionsByClip;
	
				for ( var clipUuid in actionsByClip ) {
	
					var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
						action = actionByRoot[ rootUuid ];
	
					if ( action !== undefined ) {
	
						this._deactivateAction( action );
						this._removeInactiveAction( action );
	
					}
	
				}
	
				var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ];
	
				if ( bindingByName !== undefined ) {
	
					for ( var trackName in bindingByName ) {
	
						var binding = bindingByName[ trackName ];
						binding.restoreOriginalState();
						this._removeInactiveBinding( binding );
	
					}
	
				}
	
			},
	
			// remove a targeted clip from the cache
			uncacheAction: function ( clip, optionalRoot ) {
	
				var action = this.existingAction( clip, optionalRoot );
	
				if ( action !== null ) {
	
					this._deactivateAction( action );
					this._removeInactiveAction( action );
	
				}
	
			}
	
		};
	
		// Implementation details:
	
		Object.assign( AnimationMixer.prototype, {
	
			_bindAction: function ( action, prototypeAction ) {
	
				var root = action._localRoot || this._root,
					tracks = action._clip.tracks,
					nTracks = tracks.length,
					bindings = action._propertyBindings,
					interpolants = action._interpolants,
					rootUuid = root.uuid,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingsByName = bindingsByRoot[ rootUuid ];
	
				if ( bindingsByName === undefined ) {
	
					bindingsByName = {};
					bindingsByRoot[ rootUuid ] = bindingsByName;
	
				}
	
				for ( var i = 0; i !== nTracks; ++ i ) {
	
					var track = tracks[ i ],
						trackName = track.name,
						binding = bindingsByName[ trackName ];
	
					if ( binding !== undefined ) {
	
						bindings[ i ] = binding;
	
					} else {
	
						binding = bindings[ i ];
	
						if ( binding !== undefined ) {
	
							// existing binding, make sure the cache knows
	
							if ( binding._cacheIndex === null ) {
	
								++ binding.referenceCount;
								this._addInactiveBinding( binding, rootUuid, trackName );
	
							}
	
							continue;
	
						}
	
						var path = prototypeAction && prototypeAction.
								_propertyBindings[ i ].binding.parsedPath;
	
						binding = new PropertyMixer(
								PropertyBinding.create( root, trackName, path ),
								track.ValueTypeName, track.getValueSize() );
	
						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );
	
						bindings[ i ] = binding;
	
					}
	
					interpolants[ i ].resultBuffer = binding.buffer;
	
				}
	
			},
	
			_activateAction: function ( action ) {
	
				if ( ! this._isActiveAction( action ) ) {
	
					if ( action._cacheIndex === null ) {
	
						// this action has been forgotten by the cache, but the user
						// appears to be still using it -> rebind
	
						var rootUuid = ( action._localRoot || this._root ).uuid,
							clipUuid = action._clip.uuid,
							actionsForClip = this._actionsByClip[ clipUuid ];
	
						this._bindAction( action,
								actionsForClip && actionsForClip.knownActions[ 0 ] );
	
						this._addInactiveAction( action, clipUuid, rootUuid );
	
					}
	
					var bindings = action._propertyBindings;
	
					// increment reference counts / sort out state
					for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
						var binding = bindings[ i ];
	
						if ( binding.useCount ++ === 0 ) {
	
							this._lendBinding( binding );
							binding.saveOriginalState();
	
						}
	
					}
	
					this._lendAction( action );
	
				}
	
			},
	
			_deactivateAction: function ( action ) {
	
				if ( this._isActiveAction( action ) ) {
	
					var bindings = action._propertyBindings;
	
					// decrement reference counts / sort out state
					for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
						var binding = bindings[ i ];
	
						if ( -- binding.useCount === 0 ) {
	
							binding.restoreOriginalState();
							this._takeBackBinding( binding );
	
						}
	
					}
	
					this._takeBackAction( action );
	
				}
	
			},
	
			// Memory manager
	
			_initMemoryManager: function () {
	
				this._actions = []; // 'nActiveActions' followed by inactive ones
				this._nActiveActions = 0;
	
				this._actionsByClip = {};
				// inside:
				// {
				// 		knownActions: Array< AnimationAction >	- used as prototypes
				// 		actionByRoot: AnimationAction			- lookup
				// }
	
	
				this._bindings = []; // 'nActiveBindings' followed by inactive ones
				this._nActiveBindings = 0;
	
				this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
	
	
				this._controlInterpolants = []; // same game as above
				this._nActiveControlInterpolants = 0;
	
				var scope = this;
	
				this.stats = {
	
					actions: {
						get total() { return scope._actions.length; },
						get inUse() { return scope._nActiveActions; }
					},
					bindings: {
						get total() { return scope._bindings.length; },
						get inUse() { return scope._nActiveBindings; }
					},
					controlInterpolants: {
						get total() { return scope._controlInterpolants.length; },
						get inUse() { return scope._nActiveControlInterpolants; }
					}
	
				};
	
			},
	
			// Memory management for AnimationAction objects
	
			_isActiveAction: function ( action ) {
	
				var index = action._cacheIndex;
				return index !== null && index < this._nActiveActions;
	
			},
	
			_addInactiveAction: function ( action, clipUuid, rootUuid ) {
	
				var actions = this._actions,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ];
	
				if ( actionsForClip === undefined ) {
	
					actionsForClip = {
	
						knownActions: [ action ],
						actionByRoot: {}
	
					};
	
					action._byClipCacheIndex = 0;
	
					actionsByClip[ clipUuid ] = actionsForClip;
	
				} else {
	
					var knownActions = actionsForClip.knownActions;
	
					action._byClipCacheIndex = knownActions.length;
					knownActions.push( action );
	
				}
	
				action._cacheIndex = actions.length;
				actions.push( action );
	
				actionsForClip.actionByRoot[ rootUuid ] = action;
	
			},
	
			_removeInactiveAction: function ( action ) {
	
				var actions = this._actions,
					lastInactiveAction = actions[ actions.length - 1 ],
					cacheIndex = action._cacheIndex;
	
				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();
	
				action._cacheIndex = null;
	
	
				var clipUuid = action._clip.uuid,
					actionsByClip = this._actionsByClip,
					actionsForClip = actionsByClip[ clipUuid ],
					knownActionsForClip = actionsForClip.knownActions,
	
					lastKnownAction =
						knownActionsForClip[ knownActionsForClip.length - 1 ],
	
					byClipCacheIndex = action._byClipCacheIndex;
	
				lastKnownAction._byClipCacheIndex = byClipCacheIndex;
				knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
				knownActionsForClip.pop();
	
				action._byClipCacheIndex = null;
	
	
				var actionByRoot = actionsForClip.actionByRoot,
					rootUuid = ( actions._localRoot || this._root ).uuid;
	
				delete actionByRoot[ rootUuid ];
	
				if ( knownActionsForClip.length === 0 ) {
	
					delete actionsByClip[ clipUuid ];
	
				}
	
				this._removeInactiveBindingsForAction( action );
	
			},
	
			_removeInactiveBindingsForAction: function ( action ) {
	
				var bindings = action._propertyBindings;
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
					var binding = bindings[ i ];
	
					if ( -- binding.referenceCount === 0 ) {
	
						this._removeInactiveBinding( binding );
	
					}
	
				}
	
			},
	
			_lendAction: function ( action ) {
	
				// [ active actions |  inactive actions  ]
				// [  active actions >| inactive actions ]
				//                 s        a
				//                  <-swap->
				//                 a        s
	
				var actions = this._actions,
					prevIndex = action._cacheIndex,
	
					lastActiveIndex = this._nActiveActions ++,
	
					firstInactiveAction = actions[ lastActiveIndex ];
	
				action._cacheIndex = lastActiveIndex;
				actions[ lastActiveIndex ] = action;
	
				firstInactiveAction._cacheIndex = prevIndex;
				actions[ prevIndex ] = firstInactiveAction;
	
			},
	
			_takeBackAction: function ( action ) {
	
				// [  active actions  | inactive actions ]
				// [ active actions |< inactive actions  ]
				//        a        s
				//         <-swap->
				//        s        a
	
				var actions = this._actions,
					prevIndex = action._cacheIndex,
	
					firstInactiveIndex = -- this._nActiveActions,
	
					lastActiveAction = actions[ firstInactiveIndex ];
	
				action._cacheIndex = firstInactiveIndex;
				actions[ firstInactiveIndex ] = action;
	
				lastActiveAction._cacheIndex = prevIndex;
				actions[ prevIndex ] = lastActiveAction;
	
			},
	
			// Memory management for PropertyMixer objects
	
			_addInactiveBinding: function ( binding, rootUuid, trackName ) {
	
				var bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ],
	
					bindings = this._bindings;
	
				if ( bindingByName === undefined ) {
	
					bindingByName = {};
					bindingsByRoot[ rootUuid ] = bindingByName;
	
				}
	
				bindingByName[ trackName ] = binding;
	
				binding._cacheIndex = bindings.length;
				bindings.push( binding );
	
			},
	
			_removeInactiveBinding: function ( binding ) {
	
				var bindings = this._bindings,
					propBinding = binding.binding,
					rootUuid = propBinding.rootNode.uuid,
					trackName = propBinding.path,
					bindingsByRoot = this._bindingsByRootAndName,
					bindingByName = bindingsByRoot[ rootUuid ],
	
					lastInactiveBinding = bindings[ bindings.length - 1 ],
					cacheIndex = binding._cacheIndex;
	
				lastInactiveBinding._cacheIndex = cacheIndex;
				bindings[ cacheIndex ] = lastInactiveBinding;
				bindings.pop();
	
				delete bindingByName[ trackName ];
	
				remove_empty_map: {
	
					for ( var _ in bindingByName ) break remove_empty_map;
	
					delete bindingsByRoot[ rootUuid ];
	
				}
	
			},
	
			_lendBinding: function ( binding ) {
	
				var bindings = this._bindings,
					prevIndex = binding._cacheIndex,
	
					lastActiveIndex = this._nActiveBindings ++,
	
					firstInactiveBinding = bindings[ lastActiveIndex ];
	
				binding._cacheIndex = lastActiveIndex;
				bindings[ lastActiveIndex ] = binding;
	
				firstInactiveBinding._cacheIndex = prevIndex;
				bindings[ prevIndex ] = firstInactiveBinding;
	
			},
	
			_takeBackBinding: function ( binding ) {
	
				var bindings = this._bindings,
					prevIndex = binding._cacheIndex,
	
					firstInactiveIndex = -- this._nActiveBindings,
	
					lastActiveBinding = bindings[ firstInactiveIndex ];
	
				binding._cacheIndex = firstInactiveIndex;
				bindings[ firstInactiveIndex ] = binding;
	
				lastActiveBinding._cacheIndex = prevIndex;
				bindings[ prevIndex ] = lastActiveBinding;
	
			},
	
	
			// Memory management of Interpolants for weight and time scale
	
			_lendControlInterpolant: function () {
	
				var interpolants = this._controlInterpolants,
					lastActiveIndex = this._nActiveControlInterpolants ++,
					interpolant = interpolants[ lastActiveIndex ];
	
				if ( interpolant === undefined ) {
	
					interpolant = new LinearInterpolant(
							new Float32Array( 2 ), new Float32Array( 2 ),
								1, this._controlInterpolantsResultBuffer );
	
					interpolant.__cacheIndex = lastActiveIndex;
					interpolants[ lastActiveIndex ] = interpolant;
	
				}
	
				return interpolant;
	
			},
	
			_takeBackControlInterpolant: function ( interpolant ) {
	
				var interpolants = this._controlInterpolants,
					prevIndex = interpolant.__cacheIndex,
	
					firstInactiveIndex = -- this._nActiveControlInterpolants,
	
					lastActiveInterpolant = interpolants[ firstInactiveIndex ];
	
				interpolant.__cacheIndex = firstInactiveIndex;
				interpolants[ firstInactiveIndex ] = interpolant;
	
				lastActiveInterpolant.__cacheIndex = prevIndex;
				interpolants[ prevIndex ] = lastActiveInterpolant;
	
			},
	
			_controlInterpolantsResultBuffer: new Float32Array( 1 )
	
		} );
	
		Object.assign( AnimationMixer.prototype, EventDispatcher.prototype );
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Uniform( value ) {
	
			if ( typeof value === 'string' ) {
	
				console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
				value = arguments[ 1 ];
	
			}
	
			this.value = value;
	
		}
	
		Uniform.prototype.clone = function () {
	
			return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );
	
		};
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InstancedBufferGeometry() {
	
			BufferGeometry.call( this );
	
			this.type = 'InstancedBufferGeometry';
			this.maxInstancedCount = undefined;
	
		}
	
		InstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
		InstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;
	
		InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;
	
		InstancedBufferGeometry.prototype.addGroup = function ( start, count, materialIndex ) {
	
			this.groups.push( {
	
				start: start,
				count: count,
				materialIndex: materialIndex
	
			} );
	
		};
	
		InstancedBufferGeometry.prototype.copy = function ( source ) {
	
			var index = source.index;
	
			if ( index !== null ) {
	
				this.setIndex( index.clone() );
	
			}
	
			var attributes = source.attributes;
	
			for ( var name in attributes ) {
	
				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );
	
			}
	
			var groups = source.groups;
	
			for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
				var group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );
	
			}
	
			return this;
	
		};
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {
	
			this.uuid = _Math.generateUUID();
	
			this.data = interleavedBuffer;
			this.itemSize = itemSize;
			this.offset = offset;
	
			this.normalized = normalized === true;
	
		}
	
	
		InterleavedBufferAttribute.prototype = {
	
			constructor: InterleavedBufferAttribute,
	
			isInterleavedBufferAttribute: true,
	
			get count() {
	
				return this.data.count;
	
			},
	
			get array() {
	
				return this.data.array;
	
			},
	
			setX: function ( index, x ) {
	
				this.data.array[ index * this.data.stride + this.offset ] = x;
	
				return this;
	
			},
	
			setY: function ( index, y ) {
	
				this.data.array[ index * this.data.stride + this.offset + 1 ] = y;
	
				return this;
	
			},
	
			setZ: function ( index, z ) {
	
				this.data.array[ index * this.data.stride + this.offset + 2 ] = z;
	
				return this;
	
			},
	
			setW: function ( index, w ) {
	
				this.data.array[ index * this.data.stride + this.offset + 3 ] = w;
	
				return this;
	
			},
	
			getX: function ( index ) {
	
				return this.data.array[ index * this.data.stride + this.offset ];
	
			},
	
			getY: function ( index ) {
	
				return this.data.array[ index * this.data.stride + this.offset + 1 ];
	
			},
	
			getZ: function ( index ) {
	
				return this.data.array[ index * this.data.stride + this.offset + 2 ];
	
			},
	
			getW: function ( index ) {
	
				return this.data.array[ index * this.data.stride + this.offset + 3 ];
	
			},
	
			setXY: function ( index, x, y ) {
	
				index = index * this.data.stride + this.offset;
	
				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
	
				return this;
	
			},
	
			setXYZ: function ( index, x, y, z ) {
	
				index = index * this.data.stride + this.offset;
	
				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
				this.data.array[ index + 2 ] = z;
	
				return this;
	
			},
	
			setXYZW: function ( index, x, y, z, w ) {
	
				index = index * this.data.stride + this.offset;
	
				this.data.array[ index + 0 ] = x;
				this.data.array[ index + 1 ] = y;
				this.data.array[ index + 2 ] = z;
				this.data.array[ index + 3 ] = w;
	
				return this;
	
			}
	
		};
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InterleavedBuffer( array, stride ) {
	
			this.uuid = _Math.generateUUID();
	
			this.array = array;
			this.stride = stride;
			this.count = array !== undefined ? array.length / stride : 0;
	
			this.dynamic = false;
			this.updateRange = { offset: 0, count: - 1 };
	
			this.onUploadCallback = function () {};
	
			this.version = 0;
	
		}
	
		InterleavedBuffer.prototype = {
	
			constructor: InterleavedBuffer,
	
			isInterleavedBuffer: true,
	
			set needsUpdate( value ) {
	
				if ( value === true ) this.version ++;
	
			},
	
			setArray: function ( array ) {
	
				if ( Array.isArray( array ) ) {
	
					throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
	
				}
	
				this.count = array !== undefined ? array.length / this.stride : 0;
				this.array = array;
	
			},
	
			setDynamic: function ( value ) {
	
				this.dynamic = value;
	
				return this;
	
			},
	
			copy: function ( source ) {
	
				this.array = new source.array.constructor( source.array );
				this.count = source.count;
				this.stride = source.stride;
				this.dynamic = source.dynamic;
	
				return this;
	
			},
	
			copyAt: function ( index1, attribute, index2 ) {
	
				index1 *= this.stride;
				index2 *= attribute.stride;
	
				for ( var i = 0, l = this.stride; i < l; i ++ ) {
	
					this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
				}
	
				return this;
	
			},
	
			set: function ( value, offset ) {
	
				if ( offset === undefined ) offset = 0;
	
				this.array.set( value, offset );
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			onUpload: function ( callback ) {
	
				this.onUploadCallback = callback;
	
				return this;
	
			}
	
		};
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {
	
			InterleavedBuffer.call( this, array, stride );
	
			this.meshPerAttribute = meshPerAttribute || 1;
	
		}
	
		InstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );
		InstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;
	
		InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;
	
		InstancedInterleavedBuffer.prototype.copy = function ( source ) {
	
			InterleavedBuffer.prototype.copy.call( this, source );
	
			this.meshPerAttribute = source.meshPerAttribute;
	
			return this;
	
		};
	
		/**
		 * @author benaadams / https://twitter.com/ben_a_adams
		 */
	
		function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {
	
			BufferAttribute.call( this, array, itemSize );
	
			this.meshPerAttribute = meshPerAttribute || 1;
	
		}
	
		InstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
		InstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;
	
		InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;
	
		InstancedBufferAttribute.prototype.copy = function ( source ) {
	
			BufferAttribute.prototype.copy.call( this, source );
	
			this.meshPerAttribute = source.meshPerAttribute;
	
			return this;
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author bhouston / http://clara.io/
		 * @author stephomi / http://stephaneginier.com/
		 */
	
		function Raycaster( origin, direction, near, far ) {
	
			this.ray = new Ray( origin, direction );
			// direction is assumed to be normalized (for accurate distance calculations)
	
			this.near = near || 0;
			this.far = far || Infinity;
	
			this.params = {
				Mesh: {},
				Line: {},
				LOD: {},
				Points: { threshold: 1 },
				Sprite: {}
			};
	
			Object.defineProperties( this.params, {
				PointCloud: {
					get: function () {
						console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
						return this.Points;
					}
				}
			} );
	
		}
	
		function ascSort( a, b ) {
	
			return a.distance - b.distance;
	
		}
	
		function intersectObject( object, raycaster, intersects, recursive ) {
	
			if ( object.visible === false ) return;
	
			object.raycast( raycaster, intersects );
	
			if ( recursive === true ) {
	
				var children = object.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					intersectObject( children[ i ], raycaster, intersects, true );
	
				}
	
			}
	
		}
	
		//
	
		Raycaster.prototype = {
	
			constructor: Raycaster,
	
			linePrecision: 1,
	
			set: function ( origin, direction ) {
	
				// direction is assumed to be normalized (for accurate distance calculations)
	
				this.ray.set( origin, direction );
	
			},
	
			setFromCamera: function ( coords, camera ) {
	
				if ( (camera && camera.isPerspectiveCamera) ) {
	
					this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
					this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
	
				} else if ( (camera && camera.isOrthographicCamera) ) {
	
					this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
					this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
	
				} else {
	
					console.error( 'THREE.Raycaster: Unsupported camera type.' );
	
				}
	
			},
	
			intersectObject: function ( object, recursive ) {
	
				var intersects = [];
	
				intersectObject( object, this, intersects, recursive );
	
				intersects.sort( ascSort );
	
				return intersects;
	
			},
	
			intersectObjects: function ( objects, recursive ) {
	
				var intersects = [];
	
				if ( Array.isArray( objects ) === false ) {
	
					console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
					return intersects;
	
				}
	
				for ( var i = 0, l = objects.length; i < l; i ++ ) {
	
					intersectObject( objects[ i ], this, intersects, recursive );
	
				}
	
				intersects.sort( ascSort );
	
				return intersects;
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function Clock( autoStart ) {
	
			this.autoStart = ( autoStart !== undefined ) ? autoStart : true;
	
			this.startTime = 0;
			this.oldTime = 0;
			this.elapsedTime = 0;
	
			this.running = false;
	
		}
	
		Clock.prototype = {
	
			constructor: Clock,
	
			start: function () {
	
				this.startTime = ( performance || Date ).now();
	
				this.oldTime = this.startTime;
				this.elapsedTime = 0;
				this.running = true;
	
			},
	
			stop: function () {
	
				this.getElapsedTime();
				this.running = false;
	
			},
	
			getElapsedTime: function () {
	
				this.getDelta();
				return this.elapsedTime;
	
			},
	
			getDelta: function () {
	
				var diff = 0;
	
				if ( this.autoStart && ! this.running ) {
	
					this.start();
	
				}
	
				if ( this.running ) {
	
					var newTime = ( performance || Date ).now();
	
					diff = ( newTime - this.oldTime ) / 1000;
					this.oldTime = newTime;
	
					this.elapsedTime += diff;
	
				}
	
				return diff;
	
			}
	
		};
	
		/**
		 * @author bhouston / http://clara.io
		 * @author WestLangley / http://github.com/WestLangley
		 *
		 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
		 *
		 * The poles (phi) are at the positive and negative y axis.
		 * The equator starts at positive z.
		 */
	
		function Spherical( radius, phi, theta ) {
	
			this.radius = ( radius !== undefined ) ? radius : 1.0;
			this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
			this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere
	
			return this;
	
		}
	
		Spherical.prototype = {
	
			constructor: Spherical,
	
			set: function ( radius, phi, theta ) {
	
				this.radius = radius;
				this.phi = phi;
				this.theta = theta;
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( other ) {
	
				this.radius = other.radius;
				this.phi = other.phi;
				this.theta = other.theta;
	
				return this;
	
			},
	
			// restrict phi to be betwee EPS and PI-EPS
			makeSafe: function() {
	
				var EPS = 0.000001;
				this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );
	
				return this;
	
			},
	
			setFromVector3: function( vec3 ) {
	
				this.radius = vec3.length();
	
				if ( this.radius === 0 ) {
	
					this.theta = 0;
					this.phi = 0;
	
				} else {
	
					this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
					this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle
	
				}
	
				return this;
	
			}
	
		};
	
		/**
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
		 *
		 */
	
		function Cylindrical( radius, theta, y ) {
	
			this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
			this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
			this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane
	
			return this;
	
		}
	
		Cylindrical.prototype = {
	
			constructor: Cylindrical,
	
			set: function ( radius, theta, y ) {
	
				this.radius = radius;
				this.theta = theta;
				this.y = y;
	
				return this;
	
			},
	
			clone: function () {
	
				return new this.constructor().copy( this );
	
			},
	
			copy: function ( other ) {
	
				this.radius = other.radius;
				this.theta = other.theta;
				this.y = other.y;
	
				return this;
	
			},
	
			setFromVector3: function( vec3 ) {
	
				this.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );
				this.theta = Math.atan2( vec3.x, vec3.z );
				this.y = vec3.y;
	
				return this;
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function MorphBlendMesh( geometry, material ) {
	
			Mesh.call( this, geometry, material );
	
			this.animationsMap = {};
			this.animationsList = [];
	
			// prepare default animation
			// (all frames played together in 1 second)
	
			var numFrames = this.geometry.morphTargets.length;
	
			var name = "__default";
	
			var startFrame = 0;
			var endFrame = numFrames - 1;
	
			var fps = numFrames / 1;
	
			this.createAnimation( name, startFrame, endFrame, fps );
			this.setAnimationWeight( name, 1 );
	
		}
	
		MorphBlendMesh.prototype = Object.create( Mesh.prototype );
		MorphBlendMesh.prototype.constructor = MorphBlendMesh;
	
		MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {
	
			var animation = {
	
				start: start,
				end: end,
	
				length: end - start + 1,
	
				fps: fps,
				duration: ( end - start ) / fps,
	
				lastFrame: 0,
				currentFrame: 0,
	
				active: false,
	
				time: 0,
				direction: 1,
				weight: 1,
	
				directionBackwards: false,
				mirroredLoop: false
	
			};
	
			this.animationsMap[ name ] = animation;
			this.animationsList.push( animation );
	
		};
	
		MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {
	
			var pattern = /([a-z]+)_?(\d+)/i;
	
			var firstAnimation, frameRanges = {};
	
			var geometry = this.geometry;
	
			for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {
	
				var morph = geometry.morphTargets[ i ];
				var chunks = morph.name.match( pattern );
	
				if ( chunks && chunks.length > 1 ) {
	
					var name = chunks[ 1 ];
	
					if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };
	
					var range = frameRanges[ name ];
	
					if ( i < range.start ) range.start = i;
					if ( i > range.end ) range.end = i;
	
					if ( ! firstAnimation ) firstAnimation = name;
	
				}
	
			}
	
			for ( var name in frameRanges ) {
	
				var range = frameRanges[ name ];
				this.createAnimation( name, range.start, range.end, fps );
	
			}
	
			this.firstAnimation = firstAnimation;
	
		};
	
		MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.direction = 1;
				animation.directionBackwards = false;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.direction = - 1;
				animation.directionBackwards = true;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.fps = fps;
				animation.duration = ( animation.end - animation.start ) / animation.fps;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.duration = duration;
				animation.fps = ( animation.end - animation.start ) / animation.duration;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.weight = weight;
	
			}
	
		};
	
		MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.time = time;
	
			}
	
		};
	
		MorphBlendMesh.prototype.getAnimationTime = function ( name ) {
	
			var time = 0;
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				time = animation.time;
	
			}
	
			return time;
	
		};
	
		MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {
	
			var duration = - 1;
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				duration = animation.duration;
	
			}
	
			return duration;
	
		};
	
		MorphBlendMesh.prototype.playAnimation = function ( name ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.time = 0;
				animation.active = true;
	
			} else {
	
				console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );
	
			}
	
		};
	
		MorphBlendMesh.prototype.stopAnimation = function ( name ) {
	
			var animation = this.animationsMap[ name ];
	
			if ( animation ) {
	
				animation.active = false;
	
			}
	
		};
	
		MorphBlendMesh.prototype.update = function ( delta ) {
	
			for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {
	
				var animation = this.animationsList[ i ];
	
				if ( ! animation.active ) continue;
	
				var frameTime = animation.duration / animation.length;
	
				animation.time += animation.direction * delta;
	
				if ( animation.mirroredLoop ) {
	
					if ( animation.time > animation.duration || animation.time < 0 ) {
	
						animation.direction *= - 1;
	
						if ( animation.time > animation.duration ) {
	
							animation.time = animation.duration;
							animation.directionBackwards = true;
	
						}
	
						if ( animation.time < 0 ) {
	
							animation.time = 0;
							animation.directionBackwards = false;
	
						}
	
					}
	
				} else {
	
					animation.time = animation.time % animation.duration;
	
					if ( animation.time < 0 ) animation.time += animation.duration;
	
				}
	
				var keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
				var weight = animation.weight;
	
				if ( keyframe !== animation.currentFrame ) {
	
					this.morphTargetInfluences[ animation.lastFrame ] = 0;
					this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;
	
					this.morphTargetInfluences[ keyframe ] = 0;
	
					animation.lastFrame = animation.currentFrame;
					animation.currentFrame = keyframe;
	
				}
	
				var mix = ( animation.time % frameTime ) / frameTime;
	
				if ( animation.directionBackwards ) mix = 1 - mix;
	
				if ( animation.currentFrame !== animation.lastFrame ) {
	
					this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
					this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;
	
				} else {
	
					this.morphTargetInfluences[ animation.currentFrame ] = weight;
	
				}
	
			}
	
		};
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		function ImmediateRenderObject( material ) {
	
			Object3D.call( this );
	
			this.material = material;
			this.render = function ( renderCallback ) {};
	
		}
	
		ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
		ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
	
		ImmediateRenderObject.prototype.isImmediateRenderObject = true;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function VertexNormalsHelper( object, size, hex, linewidth ) {
	
			this.object = object;
	
			this.size = ( size !== undefined ) ? size : 1;
	
			var color = ( hex !== undefined ) ? hex : 0xff0000;
	
			var width = ( linewidth !== undefined ) ? linewidth : 1;
	
			//
	
			var nNormals = 0;
	
			var objGeometry = this.object.geometry;
	
			if ( objGeometry && objGeometry.isGeometry ) {
	
				nNormals = objGeometry.faces.length * 3;
	
			} else if ( objGeometry && objGeometry.isBufferGeometry ) {
	
				nNormals = objGeometry.attributes.normal.count;
	
			}
	
			//
	
			var geometry = new BufferGeometry();
	
			var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );
	
			geometry.addAttribute( 'position', positions );
	
			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );
	
			//
	
			this.matrixAutoUpdate = false;
	
			this.update();
	
		}
	
		VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
		VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
	
		VertexNormalsHelper.prototype.update = ( function () {
	
			var v1 = new Vector3();
			var v2 = new Vector3();
			var normalMatrix = new Matrix3();
	
			return function update() {
	
				var keys = [ 'a', 'b', 'c' ];
	
				this.object.updateMatrixWorld( true );
	
				normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
				var matrixWorld = this.object.matrixWorld;
	
				var position = this.geometry.attributes.position;
	
				//
	
				var objGeometry = this.object.geometry;
	
				if ( objGeometry && objGeometry.isGeometry ) {
	
					var vertices = objGeometry.vertices;
	
					var faces = objGeometry.faces;
	
					var idx = 0;
	
					for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
						var face = faces[ i ];
	
						for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
							var vertex = vertices[ face[ keys[ j ] ] ];
	
							var normal = face.vertexNormals[ j ];
	
							v1.copy( vertex ).applyMatrix4( matrixWorld );
	
							v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
							position.setXYZ( idx, v1.x, v1.y, v1.z );
	
							idx = idx + 1;
	
							position.setXYZ( idx, v2.x, v2.y, v2.z );
	
							idx = idx + 1;
	
						}
	
					}
	
				} else if ( objGeometry && objGeometry.isBufferGeometry ) {
	
					var objPos = objGeometry.attributes.position;
	
					var objNorm = objGeometry.attributes.normal;
	
					var idx = 0;
	
					// for simplicity, ignore index and drawcalls, and render every normal
	
					for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {
	
						v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );
	
						v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );
	
						v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
						position.setXYZ( idx, v1.x, v1.y, v1.z );
	
						idx = idx + 1;
	
						position.setXYZ( idx, v2.x, v2.y, v2.z );
	
						idx = idx + 1;
	
					}
	
				}
	
				position.needsUpdate = true;
	
				return this;
	
			};
	
		}() );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function SpotLightHelper( light ) {
	
			Object3D.call( this );
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
	
			var geometry = new BufferGeometry();
	
			var positions = [
				0, 0, 0,   0,   0,   1,
				0, 0, 0,   1,   0,   1,
				0, 0, 0, - 1,   0,   1,
				0, 0, 0,   0,   1,   1,
				0, 0, 0,   0, - 1,   1
			];
	
			for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {
	
				var p1 = ( i / l ) * Math.PI * 2;
				var p2 = ( j / l ) * Math.PI * 2;
	
				positions.push(
					Math.cos( p1 ), Math.sin( p1 ), 1,
					Math.cos( p2 ), Math.sin( p2 ), 1
				);
	
			}
	
			geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
	
			var material = new LineBasicMaterial( { fog: false } );
	
			this.cone = new LineSegments( geometry, material );
			this.add( this.cone );
	
			this.update();
	
		}
	
		SpotLightHelper.prototype = Object.create( Object3D.prototype );
		SpotLightHelper.prototype.constructor = SpotLightHelper;
	
		SpotLightHelper.prototype.dispose = function () {
	
			this.cone.geometry.dispose();
			this.cone.material.dispose();
	
		};
	
		SpotLightHelper.prototype.update = function () {
	
			var vector = new Vector3();
			var vector2 = new Vector3();
	
			return function update() {
	
				var coneLength = this.light.distance ? this.light.distance : 1000;
				var coneWidth = coneLength * Math.tan( this.light.angle );
	
				this.cone.scale.set( coneWidth, coneWidth, coneLength );
	
				vector.setFromMatrixPosition( this.light.matrixWorld );
				vector2.setFromMatrixPosition( this.light.target.matrixWorld );
	
				this.cone.lookAt( vector2.sub( vector ) );
	
				this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
			};
	
		}();
	
		/**
		 * @author Sean Griffin / http://twitter.com/sgrif
		 * @author Michael Guerrero / http://realitymeltdown.com
		 * @author mrdoob / http://mrdoob.com/
		 * @author ikerr / http://verold.com
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function SkeletonHelper( object ) {
	
			this.bones = this.getBoneList( object );
	
			var geometry = new BufferGeometry();
	
			var vertices = [];
			var colors = [];
	
			var color1 = new Color( 0, 0, 1 );
			var color2 = new Color( 0, 1, 0 );
	
			for ( var i = 0; i < this.bones.length; i ++ ) {
	
				var bone = this.bones[ i ];
	
				if ( bone.parent && bone.parent.isBone ) {
	
					vertices.push( 0, 0, 0 );
					vertices.push( 0, 0, 0 );
					colors.push( color1.r, color1.g, color1.b );
					colors.push( color2.r, color2.g, color2.b );
	
				}
	
			}
	
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
			var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );
	
			LineSegments.call( this, geometry, material );
	
			this.root = object;
	
			this.matrix = object.matrixWorld;
			this.matrixAutoUpdate = false;
	
			this.update();
	
		}
	
	
		SkeletonHelper.prototype = Object.create( LineSegments.prototype );
		SkeletonHelper.prototype.constructor = SkeletonHelper;
	
		SkeletonHelper.prototype.getBoneList = function( object ) {
	
			var boneList = [];
	
			if ( object && object.isBone ) {
	
				boneList.push( object );
	
			}
	
			for ( var i = 0; i < object.children.length; i ++ ) {
	
				boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );
	
			}
	
			return boneList;
	
		};
	
		SkeletonHelper.prototype.update = function () {
	
			var vector = new Vector3();
	
			var boneMatrix = new Matrix4();
			var matrixWorldInv = new Matrix4();
	
			return function update() {
	
				var geometry = this.geometry;
				var position = geometry.getAttribute( 'position' );
	
				matrixWorldInv.getInverse( this.root.matrixWorld );
	
				for ( var i = 0, j = 0; i < this.bones.length; i ++ ) {
	
					var bone = this.bones[ i ];
	
					if ( bone.parent && bone.parent.isBone ) {
	
						boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
						vector.setFromMatrixPosition( boneMatrix );
						position.setXYZ( j, vector.x, vector.y, vector.z );
	
						boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
						vector.setFromMatrixPosition( boneMatrix );
						position.setXYZ( j + 1, vector.x, vector.y, vector.z );
	
						j += 2;
	
					}
	
				}
	
				geometry.getAttribute( 'position' ).needsUpdate = true;
	
			};
	
		}();
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function PointLightHelper( light, sphereSize ) {
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
			var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
			material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
			Mesh.call( this, geometry, material );
	
			this.matrix = this.light.matrixWorld;
			this.matrixAutoUpdate = false;
	
			/*
			var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
			var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
	
			this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
			this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
	
			var d = light.distance;
	
			if ( d === 0.0 ) {
	
				this.lightDistance.visible = false;
	
			} else {
	
				this.lightDistance.scale.set( d, d, d );
	
			}
	
			this.add( this.lightDistance );
			*/
	
		}
	
		PointLightHelper.prototype = Object.create( Mesh.prototype );
		PointLightHelper.prototype.constructor = PointLightHelper;
	
		PointLightHelper.prototype.dispose = function () {
	
			this.geometry.dispose();
			this.material.dispose();
	
		};
	
		PointLightHelper.prototype.update = function () {
	
			this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
			/*
			var d = this.light.distance;
	
			if ( d === 0.0 ) {
	
				this.lightDistance.visible = false;
	
			} else {
	
				this.lightDistance.visible = true;
				this.lightDistance.scale.set( d, d, d );
	
			}
			*/
	
		};
	
		/**
		 * @author abelnation / http://github.com/abelnation
		 * @author Mugen87 / http://github.com/Mugen87
		 */
	
		function RectAreaLightHelper( light ) {
	
			Object3D.call( this );
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			var materialFront = new MeshBasicMaterial( {
				color: light.color,
				fog: false
			} );
	
			var materialBack = new MeshBasicMaterial( {
				color: light.color,
				fog: false,
				wireframe: true
			} );
	
			var geometry = new BufferGeometry();
	
			geometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 6 * 3 ), 3 ) );
	
			// shows the "front" of the light, e.g. where light comes from
	
			this.add( new Mesh( geometry, materialFront ) );
	
			// shows the "back" of the light, which does not emit light
	
			this.add( new Mesh( geometry, materialBack ) );
	
			this.update();
	
		}
	
		RectAreaLightHelper.prototype = Object.create( Object3D.prototype );
		RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;
	
		RectAreaLightHelper.prototype.dispose = function () {
	
			this.children[ 0 ].geometry.dispose();
			this.children[ 0 ].material.dispose();
			this.children[ 1 ].geometry.dispose();
			this.children[ 1 ].material.dispose();
	
		};
	
		RectAreaLightHelper.prototype.update = function () {
	
			var vector1 = new Vector3();
			var vector2 = new Vector3();
	
			return function update() {
	
				var mesh1 = this.children[ 0 ];
				var mesh2 = this.children[ 1 ];
	
				if ( this.light.target ) {
	
					vector1.setFromMatrixPosition( this.light.matrixWorld );
					vector2.setFromMatrixPosition( this.light.target.matrixWorld );
	
					var lookVec = vector2.clone().sub( vector1 );
					mesh1.lookAt( lookVec );
					mesh2.lookAt( lookVec );
	
				}
	
				// update materials
	
				mesh1.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
				mesh2.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
				// calculate new dimensions of the helper
	
				var hx = this.light.width * 0.5;
				var hy = this.light.height * 0.5;
	
				// because the buffer attribute is shared over both geometries, we only have to update once
	
				var position = mesh1.geometry.getAttribute( 'position' );
				var array = position.array;
	
				// first face
	
				array[  0 ] =   hx; array[  1 ] = - hy; array[  2 ] = 0;
				array[  3 ] =   hx; array[  4 ] =   hy; array[  5 ] = 0;
				array[  6 ] = - hx; array[  7 ] =   hy; array[  8 ] = 0;
	
				// second face
	
				array[  9 ] = - hx; array[ 10 ] =   hy; array[ 11 ] = 0;
				array[ 12 ] = - hx; array[ 13 ] = - hy; array[ 14 ] = 0;
				array[ 15 ] =   hx; array[ 16 ] = - hy; array[ 17 ] = 0;
	
				position.needsUpdate = true;
	
			};
	
		}();
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 */
	
		function HemisphereLightHelper( light, size ) {
	
			Object3D.call( this );
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
	
			var geometry = new OctahedronBufferGeometry( size );
			geometry.rotateY( Math.PI * 0.5 );
	
			var material = new MeshBasicMaterial( { vertexColors: VertexColors, wireframe: true } );
	
			var position = geometry.getAttribute( 'position' );
			var colors = new Float32Array( position.count * 3 );
	
			geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );
	
			this.add( new Mesh( geometry, material ) );
	
			this.update();
	
		}
	
		HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
		HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
	
		HemisphereLightHelper.prototype.dispose = function () {
	
			this.children[ 0 ].geometry.dispose();
			this.children[ 0 ].material.dispose();
	
		};
	
		HemisphereLightHelper.prototype.update = function () {
	
			var vector = new Vector3();
	
			var color1 = new Color();
			var color2 = new Color();
	
			return function update() {
	
				var mesh = this.children[ 0 ];
	
				var colors = mesh.geometry.getAttribute( 'color' );
	
				color1.copy( this.light.color ).multiplyScalar( this.light.intensity );
				color2.copy( this.light.groundColor ).multiplyScalar( this.light.intensity );
	
				for ( var i = 0, l = colors.count; i < l; i ++ ) {
	
					var color = ( i < ( l / 2 ) ) ? color1 : color2;
	
					colors.setXYZ( i, color.r, color.g, color.b );
	
				}
	
				mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
	
				colors.needsUpdate = true;
	
			};
	
		}();
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function GridHelper( size, divisions, color1, color2 ) {
	
			size = size || 10;
			divisions = divisions || 10;
			color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
			color2 = new Color( color2 !== undefined ? color2 : 0x888888 );
	
			var center = divisions / 2;
			var step = size / divisions;
			var halfSize = size / 2;
	
			var vertices = [], colors = [];
	
			for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {
	
				vertices.push( - halfSize, 0, k, halfSize, 0, k );
				vertices.push( k, 0, - halfSize, k, 0, halfSize );
	
				var color = i === center ? color1 : color2;
	
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
				color.toArray( colors, j ); j += 3;
	
			}
	
			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
			var material = new LineBasicMaterial( { vertexColors: VertexColors } );
	
			LineSegments.call( this, geometry, material );
	
		}
	
		GridHelper.prototype = Object.create( LineSegments.prototype );
		GridHelper.prototype.constructor = GridHelper;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author Mugen87 / http://github.com/Mugen87
		 * @author Hectate / http://www.github.com/Hectate
		 */
	
		function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {
	
			radius = radius || 10;
			radials = radials || 16;
			circles = circles || 8;
			divisions = divisions || 64;
			color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
			color2 = new Color( color2 !== undefined ? color2 : 0x888888 );
	
			var vertices = [];
			var colors = [];
	
			var x, z;
			var v, i, j, r, color;
	
			// create the radials
	
			for ( i = 0; i <= radials; i ++ ) {
	
				v = ( i / radials ) * ( Math.PI * 2 );
	
				x = Math.sin( v ) * radius;
				z = Math.cos( v ) * radius;
	
				vertices.push( 0, 0, 0 );
				vertices.push( x, 0, z );
	
				color = ( i & 1 ) ? color1 : color2;
	
				colors.push( color.r, color.g, color.b );
				colors.push( color.r, color.g, color.b );
	
			}
	
			// create the circles
	
			for ( i = 0; i <= circles; i ++ ) {
	
				color = ( i & 1 ) ? color1 : color2;
	
				r = radius - ( radius / circles * i );
	
				for ( j = 0; j < divisions; j ++ ) {
	
					// first vertex
	
					v = ( j / divisions ) * ( Math.PI * 2 );
	
					x = Math.sin( v ) * r;
					z = Math.cos( v ) * r;
	
					vertices.push( x, 0, z );
					colors.push( color.r, color.g, color.b );
	
					// second vertex
	
					v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );
	
					x = Math.sin( v ) * r;
					z = Math.cos( v ) * r;
	
					vertices.push( x, 0, z );
					colors.push( color.r, color.g, color.b );
	
				}
	
			}
	
			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
			var material = new LineBasicMaterial( { vertexColors: VertexColors } );
	
			LineSegments.call( this, geometry, material );
	
		}
	
		PolarGridHelper.prototype = Object.create( LineSegments.prototype );
		PolarGridHelper.prototype.constructor = PolarGridHelper;
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		*/
	
		function FaceNormalsHelper( object, size, hex, linewidth ) {
	
			// FaceNormalsHelper only supports THREE.Geometry
	
			this.object = object;
	
			this.size = ( size !== undefined ) ? size : 1;
	
			var color = ( hex !== undefined ) ? hex : 0xffff00;
	
			var width = ( linewidth !== undefined ) ? linewidth : 1;
	
			//
	
			var nNormals = 0;
	
			var objGeometry = this.object.geometry;
	
			if ( objGeometry && objGeometry.isGeometry ) {
	
				nNormals = objGeometry.faces.length;
	
			} else {
	
				console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );
	
			}
	
			//
	
			var geometry = new BufferGeometry();
	
			var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );
	
			geometry.addAttribute( 'position', positions );
	
			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );
	
			//
	
			this.matrixAutoUpdate = false;
			this.update();
	
		}
	
		FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
		FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
	
		FaceNormalsHelper.prototype.update = ( function () {
	
			var v1 = new Vector3();
			var v2 = new Vector3();
			var normalMatrix = new Matrix3();
	
			return function update() {
	
				this.object.updateMatrixWorld( true );
	
				normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
				var matrixWorld = this.object.matrixWorld;
	
				var position = this.geometry.attributes.position;
	
				//
	
				var objGeometry = this.object.geometry;
	
				var vertices = objGeometry.vertices;
	
				var faces = objGeometry.faces;
	
				var idx = 0;
	
				for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
					var face = faces[ i ];
	
					var normal = face.normal;
	
					v1.copy( vertices[ face.a ] )
						.add( vertices[ face.b ] )
						.add( vertices[ face.c ] )
						.divideScalar( 3 )
						.applyMatrix4( matrixWorld );
	
					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
					position.setXYZ( idx, v1.x, v1.y, v1.z );
	
					idx = idx + 1;
	
					position.setXYZ( idx, v2.x, v2.y, v2.z );
	
					idx = idx + 1;
	
				}
	
				position.needsUpdate = true;
	
				return this;
	
			};
	
		}() );
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author mrdoob / http://mrdoob.com/
		 * @author WestLangley / http://github.com/WestLangley
		 */
	
		function DirectionalLightHelper( light, size ) {
	
			Object3D.call( this );
	
			this.light = light;
			this.light.updateMatrixWorld();
	
			this.matrix = light.matrixWorld;
			this.matrixAutoUpdate = false;
	
			if ( size === undefined ) size = 1;
	
			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( [
				- size,   size, 0,
				  size,   size, 0,
				  size, - size, 0,
				- size, - size, 0,
				- size,   size, 0
			], 3 ) );
	
			var material = new LineBasicMaterial( { fog: false } );
	
			this.add( new Line( geometry, material ) );
	
			geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );
	
			this.add( new Line( geometry, material ));
	
			this.update();
	
		}
	
		DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
		DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
	
		DirectionalLightHelper.prototype.dispose = function () {
	
			var lightPlane = this.children[ 0 ];
			var targetLine = this.children[ 1 ];
	
			lightPlane.geometry.dispose();
			lightPlane.material.dispose();
			targetLine.geometry.dispose();
			targetLine.material.dispose();
	
		};
	
		DirectionalLightHelper.prototype.update = function () {
	
			var v1 = new Vector3();
			var v2 = new Vector3();
			var v3 = new Vector3();
	
			return function update() {
	
				v1.setFromMatrixPosition( this.light.matrixWorld );
				v2.setFromMatrixPosition( this.light.target.matrixWorld );
				v3.subVectors( v2, v1 );
	
				var lightPlane = this.children[ 0 ];
				var targetLine = this.children[ 1 ];
	
				lightPlane.lookAt( v3 );
				lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
				targetLine.lookAt( v3 );
				targetLine.scale.z = v3.length();
	
			};
	
		}();
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 * @author Mugen87 / https://github.com/Mugen87
		 *
		 *	- shows frustum, line of sight and up of the camera
		 *	- suitable for fast updates
		 * 	- based on frustum visualization in lightgl.js shadowmap example
		 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
		 */
	
		function CameraHelper( camera ) {
	
			var geometry = new BufferGeometry();
			var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );
	
			var vertices = [];
			var colors = [];
	
			var pointMap = {};
	
			// colors
	
			var colorFrustum = new Color( 0xffaa00 );
			var colorCone = new Color( 0xff0000 );
			var colorUp = new Color( 0x00aaff );
			var colorTarget = new Color( 0xffffff );
			var colorCross = new Color( 0x333333 );
	
			// near
	
			addLine( "n1", "n2", colorFrustum );
			addLine( "n2", "n4", colorFrustum );
			addLine( "n4", "n3", colorFrustum );
			addLine( "n3", "n1", colorFrustum );
	
			// far
	
			addLine( "f1", "f2", colorFrustum );
			addLine( "f2", "f4", colorFrustum );
			addLine( "f4", "f3", colorFrustum );
			addLine( "f3", "f1", colorFrustum );
	
			// sides
	
			addLine( "n1", "f1", colorFrustum );
			addLine( "n2", "f2", colorFrustum );
			addLine( "n3", "f3", colorFrustum );
			addLine( "n4", "f4", colorFrustum );
	
			// cone
	
			addLine( "p", "n1", colorCone );
			addLine( "p", "n2", colorCone );
			addLine( "p", "n3", colorCone );
			addLine( "p", "n4", colorCone );
	
			// up
	
			addLine( "u1", "u2", colorUp );
			addLine( "u2", "u3", colorUp );
			addLine( "u3", "u1", colorUp );
	
			// target
	
			addLine( "c", "t", colorTarget );
			addLine( "p", "c", colorCross );
	
			// cross
	
			addLine( "cn1", "cn2", colorCross );
			addLine( "cn3", "cn4", colorCross );
	
			addLine( "cf1", "cf2", colorCross );
			addLine( "cf3", "cf4", colorCross );
	
			function addLine( a, b, color ) {
	
				addPoint( a, color );
				addPoint( b, color );
	
			}
	
			function addPoint( id, color ) {
	
				vertices.push( 0, 0, 0 );
				colors.push( color.r, color.g, color.b );
	
				if ( pointMap[ id ] === undefined ) {
	
					pointMap[ id ] = [];
	
				}
	
				pointMap[ id ].push( ( vertices.length / 3 ) - 1 );
	
			}
	
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
			LineSegments.call( this, geometry, material );
	
			this.camera = camera;
			if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();
	
			this.matrix = camera.matrixWorld;
			this.matrixAutoUpdate = false;
	
			this.pointMap = pointMap;
	
			this.update();
	
		}
	
		CameraHelper.prototype = Object.create( LineSegments.prototype );
		CameraHelper.prototype.constructor = CameraHelper;
	
		CameraHelper.prototype.update = function () {
	
			var geometry, pointMap;
	
			var vector = new Vector3();
			var camera = new Camera();
	
			function setPoint( point, x, y, z ) {
	
				vector.set( x, y, z ).unproject( camera );
	
				var points = pointMap[ point ];
	
				if ( points !== undefined ) {
	
					var position = geometry.getAttribute( 'position' );
	
					for ( var i = 0, l = points.length; i < l; i ++ ) {
	
						position.setXYZ( points[ i ], vector.x, vector.y, vector.z );
	
					}
	
				}
	
			}
	
			return function update() {
	
				geometry = this.geometry;
				pointMap = this.pointMap;
	
				var w = 1, h = 1;
	
				// we need just camera projection matrix
				// world matrix must be identity
	
				camera.projectionMatrix.copy( this.camera.projectionMatrix );
	
				// center / target
	
				setPoint( "c", 0, 0, - 1 );
				setPoint( "t", 0, 0,  1 );
	
				// near
	
				setPoint( "n1", - w, - h, - 1 );
				setPoint( "n2",   w, - h, - 1 );
				setPoint( "n3", - w,   h, - 1 );
				setPoint( "n4",   w,   h, - 1 );
	
				// far
	
				setPoint( "f1", - w, - h, 1 );
				setPoint( "f2",   w, - h, 1 );
				setPoint( "f3", - w,   h, 1 );
				setPoint( "f4",   w,   h, 1 );
	
				// up
	
				setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
				setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
				setPoint( "u3",         0, h * 2,   - 1 );
	
				// cross
	
				setPoint( "cf1", - w,   0, 1 );
				setPoint( "cf2",   w,   0, 1 );
				setPoint( "cf3",   0, - h, 1 );
				setPoint( "cf4",   0,   h, 1 );
	
				setPoint( "cn1", - w,   0, - 1 );
				setPoint( "cn2",   w,   0, - 1 );
				setPoint( "cn3",   0, - h, - 1 );
				setPoint( "cn4",   0,   h, - 1 );
	
				geometry.getAttribute( 'position' ).needsUpdate = true;
	
			};
	
		}();
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function BoxHelper( object, color ) {
	
			if ( color === undefined ) color = 0xffff00;
	
			var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
			var positions = new Float32Array( 8 * 3 );
	
			var geometry = new BufferGeometry();
			geometry.setIndex( new BufferAttribute( indices, 1 ) );
			geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );
	
			LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );
	
			if ( object !== undefined ) {
	
				this.update( object );
	
			}
	
		}
	
		BoxHelper.prototype = Object.create( LineSegments.prototype );
		BoxHelper.prototype.constructor = BoxHelper;
	
		BoxHelper.prototype.update = ( function () {
	
			var box = new Box3();
	
			return function update( object ) {
	
				if ( object && object.isBox3 ) {
	
					box.copy( object );
	
				} else {
	
					box.setFromObject( object );
	
				}
	
				if ( box.isEmpty() ) return;
	
				var min = box.min;
				var max = box.max;
	
				/*
				  5____4
				1/___0/|
				| 6__|_7
				2/___3/
	
				0: max.x, max.y, max.z
				1: min.x, max.y, max.z
				2: min.x, min.y, max.z
				3: max.x, min.y, max.z
				4: max.x, max.y, min.z
				5: min.x, max.y, min.z
				6: min.x, min.y, min.z
				7: max.x, min.y, min.z
				*/
	
				var position = this.geometry.attributes.position;
				var array = position.array;
	
				array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
				array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
				array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
				array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
				array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
				array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
				array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
				array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;
	
				position.needsUpdate = true;
	
				this.geometry.computeBoundingSphere();
	
			};
	
		} )();
	
		/**
		 * @author WestLangley / http://github.com/WestLangley
		 * @author zz85 / http://github.com/zz85
		 * @author bhouston / http://clara.io
		 *
		 * Creates an arrow for visualizing directions
		 *
		 * Parameters:
		 *  dir - Vector3
		 *  origin - Vector3
		 *  length - Number
		 *  color - color in hex value
		 *  headLength - Number
		 *  headWidth - Number
		 */
	
		var lineGeometry;
		var coneGeometry;
	
		function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {
	
			// dir is assumed to be normalized
	
			Object3D.call( this );
	
			if ( color === undefined ) color = 0xffff00;
			if ( length === undefined ) length = 1;
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
			if ( lineGeometry === undefined ) {
	
				lineGeometry = new BufferGeometry();
				lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );
	
				coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
				coneGeometry.translate( 0, - 0.5, 0 );
	
			}
	
			this.position.copy( origin );
	
			this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
			this.line.matrixAutoUpdate = false;
			this.add( this.line );
	
			this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
			this.cone.matrixAutoUpdate = false;
			this.add( this.cone );
	
			this.setDirection( dir );
			this.setLength( length, headLength, headWidth );
	
		}
	
		ArrowHelper.prototype = Object.create( Object3D.prototype );
		ArrowHelper.prototype.constructor = ArrowHelper;
	
		ArrowHelper.prototype.setDirection = ( function () {
	
			var axis = new Vector3();
			var radians;
	
			return function setDirection( dir ) {
	
				// dir is assumed to be normalized
	
				if ( dir.y > 0.99999 ) {
	
					this.quaternion.set( 0, 0, 0, 1 );
	
				} else if ( dir.y < - 0.99999 ) {
	
					this.quaternion.set( 1, 0, 0, 0 );
	
				} else {
	
					axis.set( dir.z, 0, - dir.x ).normalize();
	
					radians = Math.acos( dir.y );
	
					this.quaternion.setFromAxisAngle( axis, radians );
	
				}
	
			};
	
		}() );
	
		ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {
	
			if ( headLength === undefined ) headLength = 0.2 * length;
			if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
			this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
			this.line.updateMatrix();
	
			this.cone.scale.set( headWidth, headLength, headWidth );
			this.cone.position.y = length;
			this.cone.updateMatrix();
	
		};
	
		ArrowHelper.prototype.setColor = function ( color ) {
	
			this.line.material.color.copy( color );
			this.cone.material.color.copy( color );
	
		};
	
		/**
		 * @author sroucheray / http://sroucheray.org/
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function AxisHelper( size ) {
	
			size = size || 1;
	
			var vertices = [
				0, 0, 0,  size, 0, 0,
				0, 0, 0,  0, size, 0,
				0, 0, 0,  0, 0, size
			];
	
			var colors = [
				1, 0, 0,  1, 0.6, 0,
				0, 1, 0,  0.6, 1, 0,
				0, 0, 1,  0, 0.6, 1
			];
	
			var geometry = new BufferGeometry();
			geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
			var material = new LineBasicMaterial( { vertexColors: VertexColors } );
	
			LineSegments.call( this, geometry, material );
	
		}
	
		AxisHelper.prototype = Object.create( LineSegments.prototype );
		AxisHelper.prototype.constructor = AxisHelper;
	
		/**
		 * @author zz85 https://github.com/zz85
		 *
		 * Centripetal CatmullRom Curve - which is useful for avoiding
		 * cusps and self-intersections in non-uniform catmull rom curves.
		 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
		 *
		 * curve.type accepts centripetal(default), chordal and catmullrom
		 * curve.tension is used for catmullrom which defaults to 0.5
		 */
	
	
		/*
		Based on an optimized c++ solution in
		 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
		 - http://ideone.com/NoEbVM
	
		This CubicPoly class could be used for reusing some variables and calculations,
		but for three.js curve use, it could be possible inlined and flatten into a single function call
		which can be placed in CurveUtils.
		*/
	
		function CubicPoly() {
	
			var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
	
			/*
			 * Compute coefficients for a cubic polynomial
			 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
			 * such that
			 *   p(0) = x0, p(1) = x1
			 *  and
			 *   p'(0) = t0, p'(1) = t1.
			 */
			function init( x0, x1, t0, t1 ) {
	
				c0 = x0;
				c1 = t0;
				c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
				c3 = 2 * x0 - 2 * x1 + t0 + t1;
	
			}
	
			return {
	
				initCatmullRom: function ( x0, x1, x2, x3, tension ) {
	
					init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );
	
				},
	
				initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {
	
					// compute tangents when parameterized in [t1,t2]
					var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
					var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;
	
					// rescale tangents for parametrization in [0,1]
					t1 *= dt1;
					t2 *= dt1;
	
					init( x1, x2, t1, t2 );
	
				},
	
				calc: function ( t ) {
	
					var t2 = t * t;
					var t3 = t2 * t;
					return c0 + c1 * t + c2 * t2 + c3 * t3;
	
				}
	
			};
	
		}
	
		//
	
		var tmp = new Vector3();
		var px = new CubicPoly();
		var py = new CubicPoly();
		var pz = new CubicPoly();
	
		function CatmullRomCurve3( p /* array of Vector3 */ ) {
	
			this.points = p || [];
			this.closed = false;
	
		}
	
		CatmullRomCurve3.prototype = Object.create( Curve.prototype );
		CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
	
		CatmullRomCurve3.prototype.getPoint = function ( t ) {
	
			var points = this.points;
			var l = points.length;
	
			if ( l < 2 ) console.log( 'duh, you need at least 2 points' );
	
			var point = ( l - ( this.closed ? 0 : 1 ) ) * t;
			var intPoint = Math.floor( point );
			var weight = point - intPoint;
	
			if ( this.closed ) {
	
				intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;
	
			} else if ( weight === 0 && intPoint === l - 1 ) {
	
				intPoint = l - 2;
				weight = 1;
	
			}
	
			var p0, p1, p2, p3; // 4 points
	
			if ( this.closed || intPoint > 0 ) {
	
				p0 = points[ ( intPoint - 1 ) % l ];
	
			} else {
	
				// extrapolate first point
				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
				p0 = tmp;
	
			}
	
			p1 = points[ intPoint % l ];
			p2 = points[ ( intPoint + 1 ) % l ];
	
			if ( this.closed || intPoint + 2 < l ) {
	
				p3 = points[ ( intPoint + 2 ) % l ];
	
			} else {
	
				// extrapolate last point
				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
				p3 = tmp;
	
			}
	
			if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {
	
				// init Centripetal / Chordal Catmull-Rom
				var pow = this.type === 'chordal' ? 0.5 : 0.25;
				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );
	
				// safety check for repeated points
				if ( dt1 < 1e-4 ) dt1 = 1.0;
				if ( dt0 < 1e-4 ) dt0 = dt1;
				if ( dt2 < 1e-4 ) dt2 = dt1;
	
				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );
	
			} else if ( this.type === 'catmullrom' ) {
	
				var tension = this.tension !== undefined ? this.tension : 0.5;
				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );
	
			}
	
			return new Vector3( px.calc( weight ), py.calc( weight ), pz.calc( weight ) );
	
		};
	
		function CubicBezierCurve3( v0, v1, v2, v3 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
			this.v3 = v3;
	
		}
	
		CubicBezierCurve3.prototype = Object.create( Curve.prototype );
		CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
	
		CubicBezierCurve3.prototype.getPoint = function ( t ) {
	
			var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
	
			return new Vector3(
				CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
				CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
				CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
			);
	
		};
	
		function QuadraticBezierCurve3( v0, v1, v2 ) {
	
			this.v0 = v0;
			this.v1 = v1;
			this.v2 = v2;
	
		}
	
		QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
		QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
	
		QuadraticBezierCurve3.prototype.getPoint = function ( t ) {
	
			var v0 = this.v0, v1 = this.v1, v2 = this.v2;
	
			return new Vector3(
				QuadraticBezier( t, v0.x, v1.x, v2.x ),
				QuadraticBezier( t, v0.y, v1.y, v2.y ),
				QuadraticBezier( t, v0.z, v1.z, v2.z )
			);
	
		};
	
		function LineCurve3( v1, v2 ) {
	
			this.v1 = v1;
			this.v2 = v2;
	
		}
	
		LineCurve3.prototype = Object.create( Curve.prototype );
		LineCurve3.prototype.constructor = LineCurve3;
	
		LineCurve3.prototype.getPoint = function ( t ) {
	
			if ( t === 1 ) {
	
				return this.v2.clone();
	
			}
	
			var vector = new Vector3();
	
			vector.subVectors( this.v2, this.v1 ); // diff
			vector.multiplyScalar( t );
			vector.add( this.v1 );
	
			return vector;
	
		};
	
		function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
			EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
		}
	
		ArcCurve.prototype = Object.create( EllipseCurve.prototype );
		ArcCurve.prototype.constructor = ArcCurve;
	
		/**
		 * @author alteredq / http://alteredqualia.com/
		 */
	
		var SceneUtils = {
	
			createMultiMaterialObject: function ( geometry, materials ) {
	
				var group = new Group();
	
				for ( var i = 0, l = materials.length; i < l; i ++ ) {
	
					group.add( new Mesh( geometry, materials[ i ] ) );
	
				}
	
				return group;
	
			},
	
			detach: function ( child, parent, scene ) {
	
				child.applyMatrix( parent.matrixWorld );
				parent.remove( child );
				scene.add( child );
	
			},
	
			attach: function ( child, scene, parent ) {
	
				var matrixWorldInverse = new Matrix4();
				matrixWorldInverse.getInverse( parent.matrixWorld );
				child.applyMatrix( matrixWorldInverse );
	
				scene.remove( child );
				parent.add( child );
	
			}
	
		};
	
		/**
		 * @author mrdoob / http://mrdoob.com/
		 */
	
		function Face4( a, b, c, d, normal, color, materialIndex ) {
	
			console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
			return new Face3( a, b, c, normal, color, materialIndex );
	
		}
	
		var LineStrip = 0;
	
		var LinePieces = 1;
	
		function MeshFaceMaterial( materials ) {
	
			console.warn( 'THREE.MeshFaceMaterial has been renamed to THREE.MultiMaterial.' );
			return new MultiMaterial( materials );
	
		}
	
		function PointCloud( geometry, material ) {
	
			console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
			return new Points( geometry, material );
	
		}
	
		function Particle( material ) {
	
			console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
			return new Sprite( material );
	
		}
	
		function ParticleSystem( geometry, material ) {
	
			console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
			return new Points( geometry, material );
	
		}
	
		function PointCloudMaterial( parameters ) {
	
			console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
	
		}
	
		function ParticleBasicMaterial( parameters ) {
	
			console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
	
		}
	
		function ParticleSystemMaterial( parameters ) {
	
			console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
			return new PointsMaterial( parameters );
	
		}
	
		function Vertex( x, y, z ) {
	
			console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
			return new Vector3( x, y, z );
	
		}
	
		//
	
		function DynamicBufferAttribute( array, itemSize ) {
	
			console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
			return new BufferAttribute( array, itemSize ).setDynamic( true );
	
		}
	
		function Int8Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
			return new Int8BufferAttribute( array, itemSize );
	
		}
	
		function Uint8Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
			return new Uint8BufferAttribute( array, itemSize );
	
		}
	
		function Uint8ClampedAttribute( array, itemSize ) {
	
			console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
			return new Uint8ClampedBufferAttribute( array, itemSize );
	
		}
	
		function Int16Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
			return new Int16BufferAttribute( array, itemSize );
	
		}
	
		function Uint16Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
			return new Uint16BufferAttribute( array, itemSize );
	
		}
	
		function Int32Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
			return new Int32BufferAttribute( array, itemSize );
	
		}
	
		function Uint32Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
			return new Uint32BufferAttribute( array, itemSize );
	
		}
	
		function Float32Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
			return new Float32BufferAttribute( array, itemSize );
	
		}
	
		function Float64Attribute( array, itemSize ) {
	
			console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
			return new Float64BufferAttribute( array, itemSize );
	
		}
	
		//
	
		Curve.create = function ( construct, getPoint ) {
	
			console.log( 'THREE.Curve.create() has been deprecated' );
	
			construct.prototype = Object.create( Curve.prototype );
			construct.prototype.constructor = construct;
			construct.prototype.getPoint = getPoint;
	
			return construct;
	
		};
	
		//
	
		function ClosedSplineCurve3( points ) {
	
			console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );
	
			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';
			this.closed = true;
	
		}
	
		ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );
	
		//
	
		function SplineCurve3( points ) {
	
			console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );
	
			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';
	
		}
	
		SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );
	
		//
	
		function Spline( points ) {
	
			console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );
	
			CatmullRomCurve3.call( this, points );
			this.type = 'catmullrom';
	
		}
	
		Spline.prototype = Object.create( CatmullRomCurve3.prototype );
	
		Object.assign( Spline.prototype, {
	
			initFromArray: function ( a ) {
	
				console.error( 'THREE.Spline: .initFromArray() has been removed.' );
	
			},
			getControlPointsArray: function ( optionalTarget ) {
	
				console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );
	
			},
			reparametrizeByArcLength: function ( samplingCoef ) {
	
				console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );
	
			}
	
		} );
	
		//
		function BoundingBoxHelper( object, color ) {
	
			console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
			return new BoxHelper( object, color );
	
		}
	
		function EdgesHelper( object, hex ) {
	
			console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
			return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
	
		}
	
		GridHelper.prototype.setColors = function () {
	
			console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );
	
		};
	
		function WireframeHelper( object, hex ) {
	
			console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
			return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
	
		}
	
		//
	
		function XHRLoader( manager ) {
	
			console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
			return new FileLoader( manager );
	
		}
	
		function BinaryTextureLoader( manager ) {
	
			console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
			return new DataTextureLoader( manager );
	
		}
	
		//
	
		Object.assign( Box2.prototype, {
	
			center: function ( optionalTarget ) {
	
				console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );
	
			},
			empty: function () {
	
				console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();
	
			},
			isIntersectionBox: function ( box ) {
	
				console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
	
			},
			size: function ( optionalTarget ) {
	
				console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
				return this.getSize( optionalTarget );
	
			}
		} );
	
		Object.assign( Box3.prototype, {
	
			center: function ( optionalTarget ) {
	
				console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
				return this.getCenter( optionalTarget );
	
			},
			empty: function () {
	
				console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
				return this.isEmpty();
	
			},
			isIntersectionBox: function ( box ) {
	
				console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
	
			},
			isIntersectionSphere: function ( sphere ) {
	
				console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );
	
			},
			size: function ( optionalTarget ) {
	
				console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
				return this.getSize( optionalTarget );
	
			}
		} );
	
		Line3.prototype.center = function ( optionalTarget ) {
	
			console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );
	
		};
	
		_Math.random16 = function () {
	
			console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
			return Math.random();
	
		};
	
		Object.assign( Matrix3.prototype, {
	
			flattenToArrayOffset: function ( array, offset ) {
	
				console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
				return this.toArray( array, offset );
	
			},
			multiplyVector3: function ( vector ) {
	
				console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
				return vector.applyMatrix3( this );
	
			},
			multiplyVector3Array: function ( a ) {
	
				console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
				return this.applyToVector3Array( a );
	
			},
			applyToBuffer: function( buffer, offset, length ) {
	
				console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
				return this.applyToBufferAttribute( buffer );
	
			},
			applyToVector3Array: function( array, offset, length ) {
	
				console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );
	
			}
	
		} );
	
		Object.assign( Matrix4.prototype, {
	
			extractPosition: function ( m ) {
	
				console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
				return this.copyPosition( m );
	
			},
			flattenToArrayOffset: function ( array, offset ) {
	
				console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
				return this.toArray( array, offset );
	
			},
			getPosition: function () {
	
				var v1;
	
				return function getPosition() {
	
					if ( v1 === undefined ) v1 = new Vector3();
					console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
					return v1.setFromMatrixColumn( this, 3 );
	
				};
	
			}(),
			setRotationFromQuaternion: function ( q ) {
	
				console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
				return this.makeRotationFromQuaternion( q );
	
			},
			multiplyVector3: function ( vector ) {
	
				console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
	
			},
			multiplyVector4: function ( vector ) {
	
				console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
	
			},
			multiplyVector3Array: function ( a ) {
	
				console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
				return this.applyToVector3Array( a );
	
			},
			rotateAxis: function ( v ) {
	
				console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
				v.transformDirection( this );
	
			},
			crossVector: function ( vector ) {
	
				console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
				return vector.applyMatrix4( this );
	
			},
			translate: function () {
	
				console.error( 'THREE.Matrix4: .translate() has been removed.' );
	
			},
			rotateX: function () {
	
				console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
	
			},
			rotateY: function () {
	
				console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
	
			},
			rotateZ: function () {
	
				console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
	
			},
			rotateByAxis: function () {
	
				console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
	
			},
			applyToBuffer: function( buffer, offset, length ) {
	
				console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
				return this.applyToBufferAttribute( buffer );
	
			},
			applyToVector3Array: function( array, offset, length ) {
	
				console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );
	
			},
			makeFrustum: function( left, right, bottom, top, near, far ) {
	
				console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
				return this.makePerspective( left, right, top, bottom, near, far );
	
			}
	
		} );
	
		Plane.prototype.isIntersectionLine = function ( line ) {
	
			console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
			return this.intersectsLine( line );
	
		};
	
		Quaternion.prototype.multiplyVector3 = function ( vector ) {
	
			console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
			return vector.applyQuaternion( this );
	
		};
	
		Object.assign( Ray.prototype, {
	
			isIntersectionBox: function ( box ) {
	
				console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
				return this.intersectsBox( box );
	
			},
			isIntersectionPlane: function ( plane ) {
	
				console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
				return this.intersectsPlane( plane );
	
			},
			isIntersectionSphere: function ( sphere ) {
	
				console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
				return this.intersectsSphere( sphere );
	
			}
	
		} );
	
		Object.assign( Shape.prototype, {
	
			extrude: function ( options ) {
	
				console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
				return new ExtrudeGeometry( this, options );
	
			},
			makeGeometry: function ( options ) {
	
				console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
				return new ShapeGeometry( this, options );
	
			}
	
		} );
	
		Object.assign( Vector2.prototype, {
	
			fromAttribute: function ( attribute, index, offset ) {
	
				console.error( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
				return this.fromBufferAttribute( attribute, index, offset );
	
			}
	
		} );
	
		Object.assign( Vector3.prototype, {
	
			setEulerFromRotationMatrix: function () {
	
				console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
	
			},
			setEulerFromQuaternion: function () {
	
				console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
	
			},
			getPositionFromMatrix: function ( m ) {
	
				console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
				return this.setFromMatrixPosition( m );
	
			},
			getScaleFromMatrix: function ( m ) {
	
				console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
				return this.setFromMatrixScale( m );
	
			},
			getColumnFromMatrix: function ( index, matrix ) {
	
				console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
				return this.setFromMatrixColumn( matrix, index );
	
			},
			applyProjection: function ( m ) {
	
				console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
				return this.applyMatrix4( m );
	
			},
			fromAttribute: function ( attribute, index, offset ) {
	
				console.error( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
				return this.fromBufferAttribute( attribute, index, offset );
	
			}
	
		} );
	
		Object.assign( Vector4.prototype, {
	
			fromAttribute: function ( attribute, index, offset ) {
	
				console.error( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
				return this.fromBufferAttribute( attribute, index, offset );
	
			}
	
		} );
	
		//
	
		Geometry.prototype.computeTangents = function () {
	
			console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );
	
		};
	
		Object.assign( Object3D.prototype, {
	
			getChildByName: function ( name ) {
	
				console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
				return this.getObjectByName( name );
	
			},
			renderDepth: function () {
	
				console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
	
			},
			translate: function ( distance, axis ) {
	
				console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
				return this.translateOnAxis( axis, distance );
	
			}
	
		} );
	
		Object.defineProperties( Object3D.prototype, {
	
			eulerOrder: {
				get: function () {
	
					console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
					return this.rotation.order;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
					this.rotation.order = value;
	
				}
			},
			useQuaternion: {
				get: function () {
	
					console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
	
				},
				set: function () {
	
					console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
	
				}
			}
	
		} );
	
		Object.defineProperties( LOD.prototype, {
	
			objects: {
				get: function () {
	
					console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
					return this.levels;
	
				}
			}
	
		} );
	
		//
	
		PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {
	
			console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
					"Use .setFocalLength and .filmGauge for a photographic setup." );
	
			if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
			this.setFocalLength( focalLength );
	
		};
	
		//
	
		Object.defineProperties( Light.prototype, {
			onlyShadow: {
				set: function () {
	
					console.warn( 'THREE.Light: .onlyShadow has been removed.' );
	
				}
			},
			shadowCameraFov: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
					this.shadow.camera.fov = value;
	
				}
			},
			shadowCameraLeft: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
					this.shadow.camera.left = value;
	
				}
			},
			shadowCameraRight: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
					this.shadow.camera.right = value;
	
				}
			},
			shadowCameraTop: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
					this.shadow.camera.top = value;
	
				}
			},
			shadowCameraBottom: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
					this.shadow.camera.bottom = value;
	
				}
			},
			shadowCameraNear: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
					this.shadow.camera.near = value;
	
				}
			},
			shadowCameraFar: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
					this.shadow.camera.far = value;
	
				}
			},
			shadowCameraVisible: {
				set: function () {
	
					console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
	
				}
			},
			shadowBias: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
					this.shadow.bias = value;
	
				}
			},
			shadowDarkness: {
				set: function () {
	
					console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
	
				}
			},
			shadowMapWidth: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
					this.shadow.mapSize.width = value;
	
				}
			},
			shadowMapHeight: {
				set: function ( value ) {
	
					console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
					this.shadow.mapSize.height = value;
	
				}
			}
		} );
	
		//
	
		Object.defineProperties( BufferAttribute.prototype, {
	
			length: {
				get: function () {
	
					console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
					return this.array.length;
	
				}
			}
	
		} );
	
		Object.assign( BufferGeometry.prototype, {
	
			addIndex: function ( index ) {
	
				console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
				this.setIndex( index );
	
			},
			addDrawCall: function ( start, count, indexOffset ) {
	
				if ( indexOffset !== undefined ) {
	
					console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
	
				}
				console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
				this.addGroup( start, count );
	
			},
			clearDrawCalls: function () {
	
				console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
				this.clearGroups();
	
			},
			computeTangents: function () {
	
				console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
	
			},
			computeOffsets: function () {
	
				console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
	
			}
	
		} );
	
		Object.defineProperties( BufferGeometry.prototype, {
	
			drawcalls: {
				get: function () {
	
					console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
					return this.groups;
	
				}
			},
			offsets: {
				get: function () {
	
					console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
					return this.groups;
	
				}
			}
	
		} );
	
		//
	
		Object.defineProperties( Uniform.prototype, {
	
			dynamic: {
				set: function () {
	
					console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );
	
				}
			},
			onUpdate: {
				value: function () {
	
					console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
					return this;
	
				}
			}
	
		} );
	
		//
	
		Object.defineProperties( Material.prototype, {
	
			wrapAround: {
				get: function () {
	
					console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
	
				},
				set: function () {
	
					console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );
	
				}
			},
			wrapRGB: {
				get: function () {
	
					console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
					return new Color();
	
				}
			}
	
		} );
	
		Object.defineProperties( MeshPhongMaterial.prototype, {
	
			metal: {
				get: function () {
	
					console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
					return false;
	
				},
				set: function () {
	
					console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
	
				}
			}
	
		} );
	
		Object.defineProperties( ShaderMaterial.prototype, {
	
			derivatives: {
				get: function () {
	
					console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
					return this.extensions.derivatives;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
					this.extensions.derivatives = value;
	
				}
			}
	
		} );
	
		//
	
		Object.assign( WebGLRenderer.prototype, {
	
			supportsFloatTextures: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
				return this.extensions.get( 'OES_texture_float' );
	
			},
			supportsHalfFloatTextures: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
				return this.extensions.get( 'OES_texture_half_float' );
	
			},
			supportsStandardDerivatives: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
				return this.extensions.get( 'OES_standard_derivatives' );
	
			},
			supportsCompressedTextureS3TC: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
	
			},
			supportsCompressedTexturePVRTC: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
				return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	
			},
			supportsBlendMinMax: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
				return this.extensions.get( 'EXT_blend_minmax' );
	
			},
			supportsVertexTextures: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
				return this.capabilities.vertexTextures;
	
			},
			supportsInstancedArrays: function () {
	
				console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
				return this.extensions.get( 'ANGLE_instanced_arrays' );
	
			},
			enableScissorTest: function ( boolean ) {
	
				console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
				this.setScissorTest( boolean );
	
			},
			initMaterial: function () {
	
				console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
	
			},
			addPrePlugin: function () {
	
				console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
	
			},
			addPostPlugin: function () {
	
				console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
	
			},
			updateShadowMap: function () {
	
				console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
	
			}
	
		} );
	
		Object.defineProperties( WebGLRenderer.prototype, {
	
			shadowMapEnabled: {
				get: function () {
	
					return this.shadowMap.enabled;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
					this.shadowMap.enabled = value;
	
				}
			},
			shadowMapType: {
				get: function () {
	
					return this.shadowMap.type;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
					this.shadowMap.type = value;
	
				}
			},
			shadowMapCullFace: {
				get: function () {
	
					return this.shadowMap.cullFace;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
					this.shadowMap.cullFace = value;
	
				}
			}
		} );
	
		Object.defineProperties( WebGLShadowMap.prototype, {
	
			cullFace: {
				get: function () {
	
					return this.renderReverseSided ? CullFaceFront : CullFaceBack;
	
				},
				set: function ( cullFace ) {
	
					var value = ( cullFace !== CullFaceBack );
					console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
					this.renderReverseSided = value;
	
				}
			}
	
		} );
	
		//
	
		Object.defineProperties( WebGLRenderTarget.prototype, {
	
			wrapS: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
					return this.texture.wrapS;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
					this.texture.wrapS = value;
	
				}
			},
			wrapT: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
					return this.texture.wrapT;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
					this.texture.wrapT = value;
	
				}
			},
			magFilter: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
					return this.texture.magFilter;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
					this.texture.magFilter = value;
	
				}
			},
			minFilter: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
					return this.texture.minFilter;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
					this.texture.minFilter = value;
	
				}
			},
			anisotropy: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
					return this.texture.anisotropy;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
					this.texture.anisotropy = value;
	
				}
			},
			offset: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
					return this.texture.offset;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
					this.texture.offset = value;
	
				}
			},
			repeat: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
					return this.texture.repeat;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
					this.texture.repeat = value;
	
				}
			},
			format: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
					return this.texture.format;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
					this.texture.format = value;
	
				}
			},
			type: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
					return this.texture.type;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
					this.texture.type = value;
	
				}
			},
			generateMipmaps: {
				get: function () {
	
					console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
					return this.texture.generateMipmaps;
	
				},
				set: function ( value ) {
	
					console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
					this.texture.generateMipmaps = value;
	
				}
			}
	
		} );
	
		//
	
		Audio.prototype.load = function ( file ) {
	
			console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
			var scope = this;
			var audioLoader = new AudioLoader();
			audioLoader.load( file, function ( buffer ) {
	
				scope.setBuffer( buffer );
	
			} );
			return this;
	
		};
	
		AudioAnalyser.prototype.getData = function () {
	
			console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
			return this.getFrequencyData();
	
		};
	
		//
	
		var GeometryUtils = {
	
			merge: function ( geometry1, geometry2, materialIndexOffset ) {
	
				console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
				var matrix;
	
				if ( geometry2.isMesh ) {
	
					geometry2.matrixAutoUpdate && geometry2.updateMatrix();
	
					matrix = geometry2.matrix;
					geometry2 = geometry2.geometry;
	
				}
	
				geometry1.merge( geometry2, matrix, materialIndexOffset );
	
			},
	
			center: function ( geometry ) {
	
				console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
				return geometry.center();
	
			}
	
		};
	
		var ImageUtils = {
	
			crossOrigin: undefined,
	
			loadTexture: function ( url, mapping, onLoad, onError ) {
	
				console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );
	
				var loader = new TextureLoader();
				loader.setCrossOrigin( this.crossOrigin );
	
				var texture = loader.load( url, onLoad, undefined, onError );
	
				if ( mapping ) texture.mapping = mapping;
	
				return texture;
	
			},
	
			loadTextureCube: function ( urls, mapping, onLoad, onError ) {
	
				console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );
	
				var loader = new CubeTextureLoader();
				loader.setCrossOrigin( this.crossOrigin );
	
				var texture = loader.load( urls, onLoad, undefined, onError );
	
				if ( mapping ) texture.mapping = mapping;
	
				return texture;
	
			},
	
			loadCompressedTexture: function () {
	
				console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );
	
			},
	
			loadCompressedTextureCube: function () {
	
				console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );
	
			}
	
		};
	
		//
	
		function Projector() {
	
			console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );
	
			this.projectVector = function ( vector, camera ) {
	
				console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
				vector.project( camera );
	
			};
	
			this.unprojectVector = function ( vector, camera ) {
	
				console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
				vector.unproject( camera );
	
			};
	
			this.pickingRay = function () {
	
				console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );
	
			};
	
		}
	
		//
	
		function CanvasRenderer() {
	
			console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );
	
			this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			this.clear = function () {};
			this.render = function () {};
			this.setClearColor = function () {};
			this.setSize = function () {};
	
		}
	
		exports.WebGLRenderTargetCube = WebGLRenderTargetCube;
		exports.WebGLRenderTarget = WebGLRenderTarget;
		exports.WebGLRenderer = WebGLRenderer;
		exports.ShaderLib = ShaderLib;
		exports.UniformsLib = UniformsLib;
		exports.UniformsUtils = UniformsUtils;
		exports.ShaderChunk = ShaderChunk;
		exports.FogExp2 = FogExp2;
		exports.Fog = Fog;
		exports.Scene = Scene;
		exports.LensFlare = LensFlare;
		exports.Sprite = Sprite;
		exports.LOD = LOD;
		exports.SkinnedMesh = SkinnedMesh;
		exports.Skeleton = Skeleton;
		exports.Bone = Bone;
		exports.Mesh = Mesh;
		exports.LineSegments = LineSegments;
		exports.Line = Line;
		exports.Points = Points;
		exports.Group = Group;
		exports.VideoTexture = VideoTexture;
		exports.DataTexture = DataTexture;
		exports.CompressedTexture = CompressedTexture;
		exports.CubeTexture = CubeTexture;
		exports.CanvasTexture = CanvasTexture;
		exports.DepthTexture = DepthTexture;
		exports.Texture = Texture;
		exports.CompressedTextureLoader = CompressedTextureLoader;
		exports.DataTextureLoader = DataTextureLoader;
		exports.CubeTextureLoader = CubeTextureLoader;
		exports.TextureLoader = TextureLoader;
		exports.ObjectLoader = ObjectLoader;
		exports.MaterialLoader = MaterialLoader;
		exports.BufferGeometryLoader = BufferGeometryLoader;
		exports.DefaultLoadingManager = DefaultLoadingManager;
		exports.LoadingManager = LoadingManager;
		exports.JSONLoader = JSONLoader;
		exports.ImageLoader = ImageLoader;
		exports.FontLoader = FontLoader;
		exports.FileLoader = FileLoader;
		exports.Loader = Loader;
		exports.Cache = Cache;
		exports.AudioLoader = AudioLoader;
		exports.SpotLightShadow = SpotLightShadow;
		exports.SpotLight = SpotLight;
		exports.PointLight = PointLight;
		exports.RectAreaLight = RectAreaLight;
		exports.HemisphereLight = HemisphereLight;
		exports.DirectionalLightShadow = DirectionalLightShadow;
		exports.DirectionalLight = DirectionalLight;
		exports.AmbientLight = AmbientLight;
		exports.LightShadow = LightShadow;
		exports.Light = Light;
		exports.StereoCamera = StereoCamera;
		exports.PerspectiveCamera = PerspectiveCamera;
		exports.OrthographicCamera = OrthographicCamera;
		exports.CubeCamera = CubeCamera;
		exports.Camera = Camera;
		exports.AudioListener = AudioListener;
		exports.PositionalAudio = PositionalAudio;
		exports.AudioContext = AudioContext;
		exports.AudioAnalyser = AudioAnalyser;
		exports.Audio = Audio;
		exports.VectorKeyframeTrack = VectorKeyframeTrack;
		exports.StringKeyframeTrack = StringKeyframeTrack;
		exports.QuaternionKeyframeTrack = QuaternionKeyframeTrack;
		exports.NumberKeyframeTrack = NumberKeyframeTrack;
		exports.ColorKeyframeTrack = ColorKeyframeTrack;
		exports.BooleanKeyframeTrack = BooleanKeyframeTrack;
		exports.PropertyMixer = PropertyMixer;
		exports.PropertyBinding = PropertyBinding;
		exports.KeyframeTrack = KeyframeTrack;
		exports.AnimationUtils = AnimationUtils;
		exports.AnimationObjectGroup = AnimationObjectGroup;
		exports.AnimationMixer = AnimationMixer;
		exports.AnimationClip = AnimationClip;
		exports.Uniform = Uniform;
		exports.InstancedBufferGeometry = InstancedBufferGeometry;
		exports.BufferGeometry = BufferGeometry;
		exports.GeometryIdCount = GeometryIdCount;
		exports.Geometry = Geometry;
		exports.InterleavedBufferAttribute = InterleavedBufferAttribute;
		exports.InstancedInterleavedBuffer = InstancedInterleavedBuffer;
		exports.InterleavedBuffer = InterleavedBuffer;
		exports.InstancedBufferAttribute = InstancedBufferAttribute;
		exports.Face3 = Face3;
		exports.Object3D = Object3D;
		exports.Raycaster = Raycaster;
		exports.Layers = Layers;
		exports.EventDispatcher = EventDispatcher;
		exports.Clock = Clock;
		exports.QuaternionLinearInterpolant = QuaternionLinearInterpolant;
		exports.LinearInterpolant = LinearInterpolant;
		exports.DiscreteInterpolant = DiscreteInterpolant;
		exports.CubicInterpolant = CubicInterpolant;
		exports.Interpolant = Interpolant;
		exports.Triangle = Triangle;
		exports.Math = _Math;
		exports.Spherical = Spherical;
		exports.Cylindrical = Cylindrical;
		exports.Plane = Plane;
		exports.Frustum = Frustum;
		exports.Sphere = Sphere;
		exports.Ray = Ray;
		exports.Matrix4 = Matrix4;
		exports.Matrix3 = Matrix3;
		exports.Box3 = Box3;
		exports.Box2 = Box2;
		exports.Line3 = Line3;
		exports.Euler = Euler;
		exports.Vector4 = Vector4;
		exports.Vector3 = Vector3;
		exports.Vector2 = Vector2;
		exports.Quaternion = Quaternion;
		exports.Color = Color;
		exports.MorphBlendMesh = MorphBlendMesh;
		exports.ImmediateRenderObject = ImmediateRenderObject;
		exports.VertexNormalsHelper = VertexNormalsHelper;
		exports.SpotLightHelper = SpotLightHelper;
		exports.SkeletonHelper = SkeletonHelper;
		exports.PointLightHelper = PointLightHelper;
		exports.RectAreaLightHelper = RectAreaLightHelper;
		exports.HemisphereLightHelper = HemisphereLightHelper;
		exports.GridHelper = GridHelper;
		exports.PolarGridHelper = PolarGridHelper;
		exports.FaceNormalsHelper = FaceNormalsHelper;
		exports.DirectionalLightHelper = DirectionalLightHelper;
		exports.CameraHelper = CameraHelper;
		exports.BoxHelper = BoxHelper;
		exports.ArrowHelper = ArrowHelper;
		exports.AxisHelper = AxisHelper;
		exports.CatmullRomCurve3 = CatmullRomCurve3;
		exports.CubicBezierCurve3 = CubicBezierCurve3;
		exports.QuadraticBezierCurve3 = QuadraticBezierCurve3;
		exports.LineCurve3 = LineCurve3;
		exports.ArcCurve = ArcCurve;
		exports.EllipseCurve = EllipseCurve;
		exports.SplineCurve = SplineCurve;
		exports.CubicBezierCurve = CubicBezierCurve;
		exports.QuadraticBezierCurve = QuadraticBezierCurve;
		exports.LineCurve = LineCurve;
		exports.Shape = Shape;
		exports.Path = Path;
		exports.ShapePath = ShapePath;
		exports.Font = Font;
		exports.CurvePath = CurvePath;
		exports.Curve = Curve;
		exports.ShapeUtils = ShapeUtils;
		exports.SceneUtils = SceneUtils;
		exports.WireframeGeometry = WireframeGeometry;
		exports.ParametricGeometry = ParametricGeometry;
		exports.ParametricBufferGeometry = ParametricBufferGeometry;
		exports.TetrahedronGeometry = TetrahedronGeometry;
		exports.TetrahedronBufferGeometry = TetrahedronBufferGeometry;
		exports.OctahedronGeometry = OctahedronGeometry;
		exports.OctahedronBufferGeometry = OctahedronBufferGeometry;
		exports.IcosahedronGeometry = IcosahedronGeometry;
		exports.IcosahedronBufferGeometry = IcosahedronBufferGeometry;
		exports.DodecahedronGeometry = DodecahedronGeometry;
		exports.DodecahedronBufferGeometry = DodecahedronBufferGeometry;
		exports.PolyhedronGeometry = PolyhedronGeometry;
		exports.PolyhedronBufferGeometry = PolyhedronBufferGeometry;
		exports.TubeGeometry = TubeGeometry;
		exports.TubeBufferGeometry = TubeBufferGeometry;
		exports.TorusKnotGeometry = TorusKnotGeometry;
		exports.TorusKnotBufferGeometry = TorusKnotBufferGeometry;
		exports.TorusGeometry = TorusGeometry;
		exports.TorusBufferGeometry = TorusBufferGeometry;
		exports.TextGeometry = TextGeometry;
		exports.SphereGeometry = SphereGeometry;
		exports.SphereBufferGeometry = SphereBufferGeometry;
		exports.RingGeometry = RingGeometry;
		exports.RingBufferGeometry = RingBufferGeometry;
		exports.PlaneGeometry = PlaneGeometry;
		exports.PlaneBufferGeometry = PlaneBufferGeometry;
		exports.LatheGeometry = LatheGeometry;
		exports.LatheBufferGeometry = LatheBufferGeometry;
		exports.ShapeGeometry = ShapeGeometry;
		exports.ShapeBufferGeometry = ShapeBufferGeometry;
		exports.ExtrudeGeometry = ExtrudeGeometry;
		exports.EdgesGeometry = EdgesGeometry;
		exports.ConeGeometry = ConeGeometry;
		exports.ConeBufferGeometry = ConeBufferGeometry;
		exports.CylinderGeometry = CylinderGeometry;
		exports.CylinderBufferGeometry = CylinderBufferGeometry;
		exports.CircleGeometry = CircleGeometry;
		exports.CircleBufferGeometry = CircleBufferGeometry;
		exports.BoxGeometry = BoxGeometry;
		exports.BoxBufferGeometry = BoxBufferGeometry;
		exports.ShadowMaterial = ShadowMaterial;
		exports.SpriteMaterial = SpriteMaterial;
		exports.RawShaderMaterial = RawShaderMaterial;
		exports.ShaderMaterial = ShaderMaterial;
		exports.PointsMaterial = PointsMaterial;
		exports.MultiMaterial = MultiMaterial;
		exports.MeshPhysicalMaterial = MeshPhysicalMaterial;
		exports.MeshStandardMaterial = MeshStandardMaterial;
		exports.MeshPhongMaterial = MeshPhongMaterial;
		exports.MeshToonMaterial = MeshToonMaterial;
		exports.MeshNormalMaterial = MeshNormalMaterial;
		exports.MeshLambertMaterial = MeshLambertMaterial;
		exports.MeshDepthMaterial = MeshDepthMaterial;
		exports.MeshBasicMaterial = MeshBasicMaterial;
		exports.LineDashedMaterial = LineDashedMaterial;
		exports.LineBasicMaterial = LineBasicMaterial;
		exports.Material = Material;
		exports.Float64BufferAttribute = Float64BufferAttribute;
		exports.Float32BufferAttribute = Float32BufferAttribute;
		exports.Uint32BufferAttribute = Uint32BufferAttribute;
		exports.Int32BufferAttribute = Int32BufferAttribute;
		exports.Uint16BufferAttribute = Uint16BufferAttribute;
		exports.Int16BufferAttribute = Int16BufferAttribute;
		exports.Uint8ClampedBufferAttribute = Uint8ClampedBufferAttribute;
		exports.Uint8BufferAttribute = Uint8BufferAttribute;
		exports.Int8BufferAttribute = Int8BufferAttribute;
		exports.BufferAttribute = BufferAttribute;
		exports.REVISION = REVISION;
		exports.MOUSE = MOUSE;
		exports.CullFaceNone = CullFaceNone;
		exports.CullFaceBack = CullFaceBack;
		exports.CullFaceFront = CullFaceFront;
		exports.CullFaceFrontBack = CullFaceFrontBack;
		exports.FrontFaceDirectionCW = FrontFaceDirectionCW;
		exports.FrontFaceDirectionCCW = FrontFaceDirectionCCW;
		exports.BasicShadowMap = BasicShadowMap;
		exports.PCFShadowMap = PCFShadowMap;
		exports.PCFSoftShadowMap = PCFSoftShadowMap;
		exports.FrontSide = FrontSide;
		exports.BackSide = BackSide;
		exports.DoubleSide = DoubleSide;
		exports.FlatShading = FlatShading;
		exports.SmoothShading = SmoothShading;
		exports.NoColors = NoColors;
		exports.FaceColors = FaceColors;
		exports.VertexColors = VertexColors;
		exports.NoBlending = NoBlending;
		exports.NormalBlending = NormalBlending;
		exports.AdditiveBlending = AdditiveBlending;
		exports.SubtractiveBlending = SubtractiveBlending;
		exports.MultiplyBlending = MultiplyBlending;
		exports.CustomBlending = CustomBlending;
		exports.AddEquation = AddEquation;
		exports.SubtractEquation = SubtractEquation;
		exports.ReverseSubtractEquation = ReverseSubtractEquation;
		exports.MinEquation = MinEquation;
		exports.MaxEquation = MaxEquation;
		exports.ZeroFactor = ZeroFactor;
		exports.OneFactor = OneFactor;
		exports.SrcColorFactor = SrcColorFactor;
		exports.OneMinusSrcColorFactor = OneMinusSrcColorFactor;
		exports.SrcAlphaFactor = SrcAlphaFactor;
		exports.OneMinusSrcAlphaFactor = OneMinusSrcAlphaFactor;
		exports.DstAlphaFactor = DstAlphaFactor;
		exports.OneMinusDstAlphaFactor = OneMinusDstAlphaFactor;
		exports.DstColorFactor = DstColorFactor;
		exports.OneMinusDstColorFactor = OneMinusDstColorFactor;
		exports.SrcAlphaSaturateFactor = SrcAlphaSaturateFactor;
		exports.NeverDepth = NeverDepth;
		exports.AlwaysDepth = AlwaysDepth;
		exports.LessDepth = LessDepth;
		exports.LessEqualDepth = LessEqualDepth;
		exports.EqualDepth = EqualDepth;
		exports.GreaterEqualDepth = GreaterEqualDepth;
		exports.GreaterDepth = GreaterDepth;
		exports.NotEqualDepth = NotEqualDepth;
		exports.MultiplyOperation = MultiplyOperation;
		exports.MixOperation = MixOperation;
		exports.AddOperation = AddOperation;
		exports.NoToneMapping = NoToneMapping;
		exports.LinearToneMapping = LinearToneMapping;
		exports.ReinhardToneMapping = ReinhardToneMapping;
		exports.Uncharted2ToneMapping = Uncharted2ToneMapping;
		exports.CineonToneMapping = CineonToneMapping;
		exports.UVMapping = UVMapping;
		exports.CubeReflectionMapping = CubeReflectionMapping;
		exports.CubeRefractionMapping = CubeRefractionMapping;
		exports.EquirectangularReflectionMapping = EquirectangularReflectionMapping;
		exports.EquirectangularRefractionMapping = EquirectangularRefractionMapping;
		exports.SphericalReflectionMapping = SphericalReflectionMapping;
		exports.CubeUVReflectionMapping = CubeUVReflectionMapping;
		exports.CubeUVRefractionMapping = CubeUVRefractionMapping;
		exports.RepeatWrapping = RepeatWrapping;
		exports.ClampToEdgeWrapping = ClampToEdgeWrapping;
		exports.MirroredRepeatWrapping = MirroredRepeatWrapping;
		exports.NearestFilter = NearestFilter;
		exports.NearestMipMapNearestFilter = NearestMipMapNearestFilter;
		exports.NearestMipMapLinearFilter = NearestMipMapLinearFilter;
		exports.LinearFilter = LinearFilter;
		exports.LinearMipMapNearestFilter = LinearMipMapNearestFilter;
		exports.LinearMipMapLinearFilter = LinearMipMapLinearFilter;
		exports.UnsignedByteType = UnsignedByteType;
		exports.ByteType = ByteType;
		exports.ShortType = ShortType;
		exports.UnsignedShortType = UnsignedShortType;
		exports.IntType = IntType;
		exports.UnsignedIntType = UnsignedIntType;
		exports.FloatType = FloatType;
		exports.HalfFloatType = HalfFloatType;
		exports.UnsignedShort4444Type = UnsignedShort4444Type;
		exports.UnsignedShort5551Type = UnsignedShort5551Type;
		exports.UnsignedShort565Type = UnsignedShort565Type;
		exports.UnsignedInt248Type = UnsignedInt248Type;
		exports.AlphaFormat = AlphaFormat;
		exports.RGBFormat = RGBFormat;
		exports.RGBAFormat = RGBAFormat;
		exports.LuminanceFormat = LuminanceFormat;
		exports.LuminanceAlphaFormat = LuminanceAlphaFormat;
		exports.RGBEFormat = RGBEFormat;
		exports.DepthFormat = DepthFormat;
		exports.DepthStencilFormat = DepthStencilFormat;
		exports.RGB_S3TC_DXT1_Format = RGB_S3TC_DXT1_Format;
		exports.RGBA_S3TC_DXT1_Format = RGBA_S3TC_DXT1_Format;
		exports.RGBA_S3TC_DXT3_Format = RGBA_S3TC_DXT3_Format;
		exports.RGBA_S3TC_DXT5_Format = RGBA_S3TC_DXT5_Format;
		exports.RGB_PVRTC_4BPPV1_Format = RGB_PVRTC_4BPPV1_Format;
		exports.RGB_PVRTC_2BPPV1_Format = RGB_PVRTC_2BPPV1_Format;
		exports.RGBA_PVRTC_4BPPV1_Format = RGBA_PVRTC_4BPPV1_Format;
		exports.RGBA_PVRTC_2BPPV1_Format = RGBA_PVRTC_2BPPV1_Format;
		exports.RGB_ETC1_Format = RGB_ETC1_Format;
		exports.LoopOnce = LoopOnce;
		exports.LoopRepeat = LoopRepeat;
		exports.LoopPingPong = LoopPingPong;
		exports.InterpolateDiscrete = InterpolateDiscrete;
		exports.InterpolateLinear = InterpolateLinear;
		exports.InterpolateSmooth = InterpolateSmooth;
		exports.ZeroCurvatureEnding = ZeroCurvatureEnding;
		exports.ZeroSlopeEnding = ZeroSlopeEnding;
		exports.WrapAroundEnding = WrapAroundEnding;
		exports.TrianglesDrawMode = TrianglesDrawMode;
		exports.TriangleStripDrawMode = TriangleStripDrawMode;
		exports.TriangleFanDrawMode = TriangleFanDrawMode;
		exports.LinearEncoding = LinearEncoding;
		exports.sRGBEncoding = sRGBEncoding;
		exports.GammaEncoding = GammaEncoding;
		exports.RGBEEncoding = RGBEEncoding;
		exports.LogLuvEncoding = LogLuvEncoding;
		exports.RGBM7Encoding = RGBM7Encoding;
		exports.RGBM16Encoding = RGBM16Encoding;
		exports.RGBDEncoding = RGBDEncoding;
		exports.BasicDepthPacking = BasicDepthPacking;
		exports.RGBADepthPacking = RGBADepthPacking;
		exports.CubeGeometry = BoxGeometry;
		exports.Face4 = Face4;
		exports.LineStrip = LineStrip;
		exports.LinePieces = LinePieces;
		exports.MeshFaceMaterial = MeshFaceMaterial;
		exports.PointCloud = PointCloud;
		exports.Particle = Particle;
		exports.ParticleSystem = ParticleSystem;
		exports.PointCloudMaterial = PointCloudMaterial;
		exports.ParticleBasicMaterial = ParticleBasicMaterial;
		exports.ParticleSystemMaterial = ParticleSystemMaterial;
		exports.Vertex = Vertex;
		exports.DynamicBufferAttribute = DynamicBufferAttribute;
		exports.Int8Attribute = Int8Attribute;
		exports.Uint8Attribute = Uint8Attribute;
		exports.Uint8ClampedAttribute = Uint8ClampedAttribute;
		exports.Int16Attribute = Int16Attribute;
		exports.Uint16Attribute = Uint16Attribute;
		exports.Int32Attribute = Int32Attribute;
		exports.Uint32Attribute = Uint32Attribute;
		exports.Float32Attribute = Float32Attribute;
		exports.Float64Attribute = Float64Attribute;
		exports.ClosedSplineCurve3 = ClosedSplineCurve3;
		exports.SplineCurve3 = SplineCurve3;
		exports.Spline = Spline;
		exports.BoundingBoxHelper = BoundingBoxHelper;
		exports.EdgesHelper = EdgesHelper;
		exports.WireframeHelper = WireframeHelper;
		exports.XHRLoader = XHRLoader;
		exports.BinaryTextureLoader = BinaryTextureLoader;
		exports.GeometryUtils = GeometryUtils;
		exports.ImageUtils = ImageUtils;
		exports.Projector = Projector;
		exports.CanvasRenderer = CanvasRenderer;
	
		Object.defineProperty(exports, '__esModule', { value: true });
	
	})));


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _promise = __webpack_require__(224);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _customEvent = __webpack_require__(221);
	
	var _customEvent2 = _interopRequireDefault(_customEvent);
	
	var _Sphere = __webpack_require__(246);
	
	var _Sphere2 = _interopRequireDefault(_Sphere);
	
	var _AnimationPlayer = __webpack_require__(247);
	
	var _AnimationPlayer2 = _interopRequireDefault(_AnimationPlayer);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// This set of controls performs orbiting, dollying (zooming), and panning. It maintains
	// the "up" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is
	// supported.
	//
	//    Orbit - left mouse / touch: one finger move
	//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
	//    Pan - right mouse, or arrow keys / touch: three finter swipe
	
	var selectClick = new _customEvent2.default('selectClick');
	var eventAnimationStarted = new _customEvent2.default('animationstarted');
	var eventAnimationStopped = new _customEvent2.default('animationstopped');
	var eventCenter = new _customEvent2.default('centercontrolchanged');
	var eventZoomChanged = new _customEvent2.default('zoomcontrolchanged');
	var eventOrientationChanged = new _customEvent2.default('orientationcontrolchanged');
	// TODO:
	// Recast touch for globe
	// Fix target problem with pan and panoramic (when target isn't on globe)
	// Fix problem with space
	// Add real collision
	
	// FIXME:
	// when move globe in damping orbit, there isn't move!!
	
	var CONTROL_STATE = {
	    NONE: -1,
	    ORBIT: 0,
	    DOLLY: 1,
	    PAN: 2,
	    TOUCH_ROTATE: 3,
	    TOUCH_DOLLY: 4,
	    TOUCH_PAN: 5,
	    MOVE_GLOBE: 6,
	    PANORAMIC: 7
	};
	
	// The control's keys
	var CONTROL_KEYS = {
	    LEFT: 37,
	    UP: 38,
	    RIGHT: 39,
	    BOTTOM: 40,
	    SPACE: 32,
	    SHIFT: 16,
	    CTRL: 17,
	    S: 83
	};
	
	// TODO: can be optimize for some uses
	var presiceSlerp = function presiceSlerp(qb, t) {
	    if (t === 0) {
	        return this;
	    }
	
	    if (t === 1) {
	        return this.copy(qb);
	    }
	
	    var x = this._x;
	    var y = this._y;
	    var z = this._z;
	    var w = this._w;
	
	    // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	
	    var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	
	    if (cosHalfTheta < 0) {
	        this._w = -qb._w;
	        this._x = -qb._x;
	        this._y = -qb._y;
	        this._z = -qb._z;
	
	        cosHalfTheta = -cosHalfTheta;
	    } else {
	        this.copy(qb);
	    }
	
	    if (cosHalfTheta >= 1.0) {
	        this._w = w;
	        this._x = x;
	        this._y = y;
	        this._z = z;
	
	        return this;
	    }
	
	    var sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);
	    var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
	    var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta;
	    var ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
	
	    this._w = w * ratioA + this._w * ratioB;
	    this._x = x * ratioA + this._x * ratioB;
	    this._y = y * ratioA + this._y * ratioB;
	    this._z = z * ratioA + this._z * ratioB;
	
	    this.onChangeCallback();
	
	    return this;
	};
	
	// private members
	var space = false;
	var EPS = 0.000001;
	
	// Orbit
	var rotateStart = new THREE.Vector2();
	var rotateEnd = new THREE.Vector2();
	var rotateDelta = new THREE.Vector2();
	var spherical = new THREE.Spherical(1.0, 0.01, 0);
	var sphericalDelta = new THREE.Spherical(1.0, 0, 0);
	var sphericalTo = new THREE.Spherical();
	var orbit = {
	    spherical: spherical,
	    sphericalDelta: sphericalDelta,
	    sphericalTo: sphericalTo,
	    scale: 1
	};
	
	// Pan
	var panStart = new THREE.Vector2();
	var panEnd = new THREE.Vector2();
	var panDelta = new THREE.Vector2();
	var panOffset = new THREE.Vector3();
	
	var offset = new THREE.Vector3();
	
	// Dolly
	var dollyStart = new THREE.Vector2();
	var dollyEnd = new THREE.Vector2();
	var dollyDelta = new THREE.Vector2();
	
	// Globe move
	var quatGlobe = new THREE.Quaternion();
	var globeTarget = new THREE.Object3D();
	var movingGlobeTarget = new THREE.Vector3();
	var animatedScale = 0.0;
	
	var ctrl = {
	    progress: 0,
	    quatGlobe: quatGlobe,
	    qDelta: new THREE.Quaternion(),
	    dampingFactor: 0.25
	};
	
	ctrl.qDelta.presiceSlerp = presiceSlerp;
	quatGlobe.presiceSlerp = presiceSlerp;
	
	// Animation player
	var player = null;
	// Save 2 last rotation globe for damping
	var lastRotation = [];
	
	// Expression used to damp camera's moves
	var dampingMoveAnimatedExpression = function getDampMoveAniExprFn() {
	    var damp = new THREE.Quaternion(0, 0, 0, 1);
	    return function dampingMoveAnimatedExpression(root) {
	        root.qDelta.presiceSlerp(damp, root.dampingFactor * 0.2);
	        root.quatGlobe.multiply(root.qDelta);
	    };
	}();
	
	// Expression used to animate camera's moves and zoom
	var zoomCenterAnimatedExpression = function zoomCenterAnimatedExpression(root, progress) {
	    root.quatGlobe.set(0, 0, 0, 1);
	    root.progress = 1 - Math.pow(1 - (Math.sin((progress - 0.5) * Math.PI) * 0.5 + 0.5), 2);
	    root.quatGlobe.presiceSlerp(root.qDelta, root.progress);
	};
	
	// Expression used to damp camera's moves
	var animationOrbitExpression = function animationOrbitExpression(root, progress) {
	    root.scale = 1.0 - (1.0 - root.sphericalTo.radius / root.spherical.radius) * progress;
	    root.sphericalDelta.theta = root.sphericalTo.theta;
	    root.sphericalDelta.phi = root.sphericalTo.phi;
	};
	
	// Animations
	var animationDampingMove = new _AnimationPlayer.AnimatedExpression({ duration: 120, root: ctrl, expression: dampingMoveAnimatedExpression, name: 'Damping Move' });
	var animationZoomCenter = new _AnimationPlayer.AnimatedExpression({ duration: 45, root: ctrl, expression: zoomCenterAnimatedExpression, name: 'Zoom Center' });
	var animationOrbit = new _AnimationPlayer.AnimatedExpression({ duration: 30, root: orbit, expression: animationOrbitExpression, name: 'set Orbit' });
	var dampingOrbitalMvt = new _AnimationPlayer.Animation({ duration: 60, name: 'orbit damping' });
	
	// Replace matrix float by matrix double
	globeTarget.matrixWorld.elements = new Float64Array(16);
	globeTarget.matrixWorldInverse = new THREE.Matrix4();
	globeTarget.matrixWorldInverse.elements = new Float64Array(16);
	
	// Pan Move
	var panVector = new THREE.Vector3();
	
	// Save last transformation
	var lastPosition = new THREE.Vector3();
	var lastQuaternion = new THREE.Quaternion();
	
	// State control
	var state = CONTROL_STATE.NONE;
	
	// Initial transformation
	var initialTarget;
	var initialPosition;
	var initialZoom;
	
	// picking
	var ptScreenClick = new THREE.Vector2();
	var sizeRendering = new THREE.Vector2();
	
	// Tangent sphere to ellispoid
	var tSphere = new _Sphere2.default();
	tSphere.picking = { position: new THREE.Vector3(), normal: new THREE.Vector3() };
	
	// Special key
	var keyCtrl = false;
	var keyShift = false;
	var keyS = false;
	
	// Set to true to enable target helper
	var enableTargetHelper = false;
	
	// Handle function
	var _handlerMouseMove;
	var _handlerMouseUp;
	
	// Pseudo collision
	var radiusCollision = 50;
	
	// SnapCamera saves transformation's camera
	// It's use to globe move
	function SnapCamera(camera) {
	    camera.updateMatrixWorld();
	
	    this.matrixWorld = new THREE.Matrix4();
	    this.projectionMatrix = new THREE.Matrix4();
	    this.invProjectionMatrix = new THREE.Matrix4();
	    this.position = new THREE.Vector3();
	
	    this.matrixWorld.elements = new Float64Array(16);
	    this.projectionMatrix.elements = new Float64Array(16);
	    this.invProjectionMatrix.elements = new Float64Array(16);
	
	    this.init = function init(camera) {
	        this.matrixWorld.elements.set(camera.matrixWorld.elements);
	        this.projectionMatrix.elements.set(camera.projectionMatrix.elements);
	        this.position.copy(camera.position);
	        this.invProjectionMatrix.getInverse(this.projectionMatrix);
	    };
	
	    this.init(camera);
	
	    this.shot = function shot(objectToSnap) {
	        objectToSnap.updateMatrixWorld();
	        this.matrixWorld.elements.set(objectToSnap.matrixWorld.elements);
	        this.position.copy(objectToSnap.position);
	    };
	
	    var matrix = new THREE.Matrix4();
	    matrix.elements = new Float64Array(16);
	
	    this.updateRay = function updateRay(ray, mouse) {
	        ray.origin.copy(this.position);
	        ray.direction.set(mouse.x, mouse.y, 0.5);
	        matrix.multiplyMatrices(this.matrixWorld, this.invProjectionMatrix);
	        ray.direction.applyMatrix4(matrix);
	        ray.direction.sub(ray.origin).normalize();
	    };
	}
	
	var snapShotCamera = null;
	
	// ///////////////////////
	
	/* globals document,window */
	
	function GlobeControls(camera, domElement, engine) {
	    this.viewerDiv = engine.viewerDiv;
	
	    player = new _AnimationPlayer2.default(domElement);
	    var scene = engine.scene;
	    this.camera = camera;
	    snapShotCamera = new SnapCamera(camera);
	
	    this.domElement = domElement !== undefined ? domElement : document;
	
	    // Set to false to disable this control
	    this.enabled = true;
	
	    // This option actually enables dollying in and out; left as "zoom" for
	    // backwards compatibility
	    this.enableZoom = true;
	    this.zoomSpeed = 1.0;
	
	    // Limits to how far you can dolly in and out ( PerspectiveCamera only )
	    this.minDistance = radiusCollision;
	    this.maxDistance = Infinity;
	
	    // Limits to how far you can zoom in and out ( OrthographicCamera only )
	    this.minZoom = 0;
	    this.maxZoom = Infinity;
	
	    // Set to true to disable this control
	    this.enableRotate = true;
	    this.rotateSpeed = 1.0;
	
	    // Set to true to disable this control
	    this.enablePan = true;
	    this.keyPanSpeed = 7.0; // pixels moved per arrow key push
	
	    // Set to true to automatically rotate around the target
	    this.autoRotate = false;
	    this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60
	
	    // How far you can orbit vertically, upper and lower limits.
	    // Range is 0 to Math.PI radians.
	    // TODO Warning minPolarAngle = 0.01 -> it isn't possible to be perpendicular on Globe
	    this.minPolarAngle = 0.01; // radians
	    this.maxPolarAngle = Math.PI * 0.5; // radians
	
	    // How far you can orbit horizontally, upper and lower limits.
	    // If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
	    this.minAzimuthAngle = -Infinity; // radians
	    this.maxAzimuthAngle = Infinity; // radians
	
	    // Set to true to disable use of the keys
	    this.enableKeys = true;
	
	    // Enable Damping
	    this.enableDamping = true;
	
	    if (enableTargetHelper) {
	        this.pickingHelper = new THREE.AxisHelper(500000);
	    }
	
	    // Mouse buttons
	    this.mouseButtons = {
	        PANORAMIC: THREE.MOUSE.LEFT,
	        ZOOM: THREE.MOUSE.MIDDLE,
	        PAN: THREE.MOUSE.RIGHT
	    };
	
	    // Radius tangent sphere
	    tSphere.setRadius(engine.size);
	    spherical.radius = tSphere.radius;
	
	    sizeRendering.set(engine.width, engine.height);
	
	    // Note A
	    // TODO: test before remove test code
	    // so camera.up is the orbit axis
	    // var quat = new THREE.Quaternion().setFromUnitVectors(camera.up, new THREE.Vector3(0, 1, 0));
	    // var quatInverse = quat.clone().inverse();
	
	    // events
	    this.changeEvent = {
	        type: 'change'
	    };
	    this.startEvent = {
	        type: 'start'
	    };
	    this.endEvent = {
	        type: 'end'
	    };
	
	    this.updateCamera = function updateCamera(camera) {
	        snapShotCamera.init(camera.camera3D);
	        sizeRendering.width = camera.width;
	        sizeRendering.height = camera.height;
	    };
	
	    this.getAutoRotationAngle = function getAutoRotationAngle() {
	        return 2 * Math.PI / 60 / 60 * this.autoRotateSpeed;
	    };
	
	    this.getZoomScale = function getZoomScale() {
	        return Math.pow(0.95, this.zoomSpeed);
	    };
	
	    this.rotateLeft = function rotateLeft(angle) {
	        if (angle === undefined) {
	            angle = this.getAutoRotationAngle();
	        }
	        sphericalDelta.theta -= angle;
	    };
	
	    this.rotateUp = function rotateUp(angle) {
	        if (angle === undefined) {
	            angle = this.getAutoRotationAngle();
	        }
	
	        sphericalDelta.phi -= angle;
	    };
	
	    // pass in distance in world space to move left
	    this.panLeft = function panLeft(distance) {
	        var te = this.camera.matrix.elements;
	
	        // get X column of matrix
	        panOffset.set(te[0], te[1], te[2]);
	        panOffset.multiplyScalar(-distance);
	
	        panVector.add(panOffset);
	    };
	
	    // pass in distance in world space to move up
	    this.panUp = function panUp(distance) {
	        var te = this.camera.matrix.elements;
	
	        // get Y column of matrix
	        panOffset.set(te[4], te[5], te[6]);
	        panOffset.multiplyScalar(distance);
	
	        panVector.add(panOffset);
	    };
	
	    // pass in x,y of change desired in pixel space,
	    // right and down are positive
	    this.mouseToPan = function mouseToPan(deltaX, deltaY) {
	        var element = this.domElement === document ? this.domElement.body : this.domElement;
	
	        if (this.camera instanceof THREE.PerspectiveCamera) {
	            // perspective
	            var position = this.camera.position;
	
	            // var offset = position.clone().sub(this.target);
	            var offset = position.clone().sub(this.getTargetCameraPosition());
	
	            var targetDistance = offset.length();
	
	            // half of the fov is center to top of screen
	            targetDistance *= Math.tan(this.camera.fov / 2 * Math.PI / 180.0);
	
	            // we actually don't use screenWidth, since perspective camera is fixed to screen height
	            this.panLeft(2 * deltaX * targetDistance / element.clientHeight);
	            this.panUp(2 * deltaY * targetDistance / element.clientHeight);
	        } else if (this.camera instanceof THREE.OrthographicCamera) {
	            // orthographic
	            this.panLeft(deltaX * (this.camera.right - this.camera.left) / element.clientWidth);
	            this.panUp(deltaY * (this.camera.top - this.camera.bottom) / element.clientHeight);
	        } else {
	
	            // camera neither orthographic or perspective
	            // console.warn('WARNING: GlobeControls.js encountered an unknown camera type - this.mouseToPan disabled.');
	
	        }
	    };
	
	    this.dollyIn = function dollyIn(dollyScale) {
	        if (dollyScale === undefined) {
	            dollyScale = this.getZoomScale();
	        }
	
	        if (this.camera instanceof THREE.PerspectiveCamera) {
	            orbit.scale /= dollyScale;
	        } else if (this.camera instanceof THREE.OrthographicCamera) {
	            this.camera.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.camera.zoom * dollyScale));
	            this.camera.updateProjectionMatrix();
	            this.dispatchEvent(this.changeEvent);
	        } else {
	
	            // console.warn('WARNING: GlobeControls.js encountered an unknown camera type - dolly/zoom disabled.');
	
	        }
	    };
	
	    this.dollyOut = function dollyOut(dollyScale) {
	        if (dollyScale === undefined) {
	            dollyScale = this.getZoomScale();
	        }
	
	        if (this.camera instanceof THREE.PerspectiveCamera) {
	            orbit.scale *= dollyScale;
	        } else if (this.camera instanceof THREE.OrthographicCamera) {
	            this.camera.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.camera.zoom / dollyScale));
	            this.camera.updateProjectionMatrix();
	            this.dispatchEvent(this.changeEvent);
	        } else {
	
	            // console.warn('WARNING: GlobeControls.js encountered an unknown camera type - dolly/zoom disabled.');
	
	        }
	    };
	
	    var getPickingPosition = function getGetPickingPositionFn() {
	        var engineGfx = engine;
	        var position;
	
	        return function getPickingPosition(coords) {
	            position = engineGfx.getPickingPositionFromDepth(coords);
	            engineGfx.renderScene();
	
	            return position;
	        };
	    }();
	
	    // introduction collision
	    // Not use for the moment
	    // eslint-disable-next-line
	    var collision = function collision(position) {
	        if (scene.getMap()) {
	            var coord = scene.getMap().projection.cartesianToGeo(position);
	            var bbox = scene.getMap().getTile(coord).bbox;
	            var delta = coord.altitude() - (bbox.top() + radiusCollision);
	
	            if (delta < 0) {
	                position.setLength(position.length() - delta);
	            }
	        }
	
	        return position;
	    };
	
	    var quaterPano = new THREE.Quaternion();
	    var quaterAxis = new THREE.Quaternion();
	    var axisX = new THREE.Vector3(1, 0, 0);
	
	    var update = function update() {
	        // MOVE_GLOBE
	        // Rotate globe with mouse
	        if (state === CONTROL_STATE.MOVE_GLOBE) {
	            movingGlobeTarget.copy(this.getTargetCameraPosition()).applyQuaternion(quatGlobe);
	            this.camera.position.copy(snapShotCamera.position).applyQuaternion(quatGlobe);
	            // combine zoom with move globe
	            if (ctrl.progress > 0) {
	                this.camera.position.lerp(movingGlobeTarget, ctrl.progress * animatedScale);
	            }
	            this.camera.up.copy(movingGlobeTarget.clone().normalize());
	            // PAN
	            // Move camera in projection plan
	        } else if (state === CONTROL_STATE.PAN) {
	            this.camera.position.add(panVector);
	            movingGlobeTarget.add(panVector);
	            // PANORAMIC
	            // Move target camera
	        } else if (state === CONTROL_STATE.PANORAMIC) {
	            // TODO: this part must be reworked
	            this.camera.worldToLocal(movingGlobeTarget);
	            var normal = this.camera.position.clone().normalize().applyQuaternion(this.camera.quaternion.clone().inverse());
	            quaterPano.setFromAxisAngle(normal, sphericalDelta.theta).multiply(quaterAxis.setFromAxisAngle(axisX, sphericalDelta.phi));
	            movingGlobeTarget.applyQuaternion(quaterPano);
	            this.camera.localToWorld(movingGlobeTarget);
	            this.camera.up.copy(movingGlobeTarget.clone().normalize());
	        } else {
	            // ZOOM/ORBIT
	            // Move Camera around the target camera
	
	            // TODO: test before remove test code see (Note A)
	            // offset.applyQuaternion( quat );
	
	            // get camera position in local space of target
	            offset.copy(this.camera.position).applyMatrix4(globeTarget.matrixWorldInverse);
	
	            // angle from z-axis around y-axis
	            if (sphericalDelta.theta || sphericalDelta.phi) {
	                spherical.setFromVector3(offset);
	            }
	
	            if (this.autoRotate && state === CONTROL_STATE.NONE) {
	                this.rotateLeft(this.getAutoRotationAngle());
	            }
	
	            spherical.theta += sphericalDelta.theta;
	            spherical.phi += sphericalDelta.phi;
	
	            // restrict spherical.theta to be between desired limits
	            spherical.theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, spherical.theta));
	
	            // restrict spherical.phi to be between desired limits
	            spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, spherical.phi));
	
	            spherical.radius = offset.length() * orbit.scale;
	
	            // restrict spherical.phi to be betwee EPS and PI-EPS
	            spherical.makeSafe();
	
	            // restrict radius to be between desired limits
	            spherical.radius = Math.max(this.minDistance, Math.min(this.maxDistance, spherical.radius));
	
	            offset.setFromSpherical(spherical);
	
	            // rotate point back to "camera-up-vector-is-up" space
	            // offset.applyQuaternion( quatInverse );
	
	            this.camera.position.copy(globeTarget.localToWorld(offset));
	        }
	
	        this.camera.lookAt(movingGlobeTarget);
	
	        if (!this.enableDamping) {
	            sphericalDelta.theta = 0;
	            sphericalDelta.phi = 0;
	        } else {
	            sphericalDelta.theta *= 1 - ctrl.dampingFactor;
	            sphericalDelta.phi *= 1 - ctrl.dampingFactor;
	        }
	
	        orbit.scale = 1;
	        panVector.set(0, 0, 0);
	
	        // update condition is:
	        // min(camera displacement, camera rotation in radians)^2 > EPS
	        // using small-angle approximation cos(x/2) = 1 - x^2 / 8
	
	        if (lastPosition.distanceToSquared(this.camera.position) > EPS || 8 * (1 - lastQuaternion.dot(this.camera.quaternion)) > EPS) {
	            this.dispatchEvent(this.changeEvent);
	
	            lastPosition.copy(this.camera.position);
	            lastQuaternion.copy(this.camera.quaternion);
	        }
	        // Launch animationdamping if mouse stops these movements
	        if (this.enableDamping && state === CONTROL_STATE.ORBIT && player.isStopped() && (sphericalDelta.theta > EPS || sphericalDelta.phi > EPS)) {
	            player.playLater(dampingOrbitalMvt, 2);
	        }
	    }.bind(this);
	
	    this.getSpace = function getSpace() {
	        return space;
	    };
	
	    this.getSphericalDelta = function getSphericalDelta() {
	        return sphericalDelta;
	    };
	
	    // Position object on globe
	    var positionObject = function getPositionObjectFn() {
	        var quaterionX = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 2);
	        return function positionObject(newPosition, object) {
	            object.position.copy(newPosition);
	            object.lookAt(newPosition.clone().multiplyScalar(1.1));
	            object.quaternion.multiply(quaterionX);
	            object.updateMatrixWorld();
	        };
	    }();
	
	    // set new globe target
	    var setGlobleTarget = function setGlobleTarget(newPosition) {
	        // Compute the new target center position
	        positionObject(newPosition, globeTarget);
	
	        globeTarget.matrixWorldInverse.getInverse(globeTarget.matrixWorld);
	    };
	
	    var cT = new THREE.Vector3();
	    // update globe target
	    var updateGlobeTarget = function updateGlobeTarget() {
	        // Get distance camera DME
	        var pickingPosition = getPickingPosition();
	
	        if (!pickingPosition) {
	            return;
	        }
	
	        var targt = {};
	        targt.x = globeTarget.position.x;
	        targt.y = globeTarget.position.y;
	
	        var distanceTarget = pickingPosition.distanceTo(this.camera.position);
	
	        // Position movingGlobeTarget on DME
	        cT.subVectors(movingGlobeTarget, this.camera.position);
	        cT.setLength(distanceTarget);
	        movingGlobeTarget.addVectors(this.camera.position, cT);
	
	        // set new globe target
	        setGlobleTarget(movingGlobeTarget);
	
	        if (targt.x != globeTarget.position.x && targt.y != globeTarget.position.y) {
	            this.viewerDiv.dispatchEvent(eventCenter);
	        }
	
	        // update spherical from target
	        offset.copy(this.camera.position);
	        offset.applyMatrix4(globeTarget.matrixWorldInverse);
	        spherical.setFromVector3(offset);
	        state = CONTROL_STATE.NONE;
	        lastRotation = [];
	    };
	
	    // Update helper
	    var updateHelper = enableTargetHelper ? function updateHelper(position, helper) {
	        positionObject(position, helper);
	        this.dispatchEvent(this.changeEvent);
	    } : function empty() {};
	
	    this.getPickingPositionOnSphere = function getPickingPositionOnSphere() {
	        return tSphere.picking.position;
	    };
	
	    // Update radius's sphere : the sphere must cross the point
	    // Return intersection with mouse and sphere
	    var updateSpherePicking = function getUpdateSpherePicking() {
	        var mouse = new THREE.Vector2();
	        var ray = new THREE.Ray();
	
	        return function updateSpherePicking(point, screenCoord) {
	            tSphere.setRadius(point.length());
	
	            mouse.x = screenCoord.x / sizeRendering.width * 2 - 1;
	            mouse.y = -(screenCoord.y / sizeRendering.height) * 2 + 1;
	
	            snapShotCamera.updateRay(ray, mouse);
	            // pick position on tSphere
	            tSphere.picking.position.copy(tSphere.intersectWithRay(ray));
	            tSphere.picking.normal = tSphere.picking.position.clone().normalize();
	
	            lastRotation.push(tSphere.picking.normal);
	            updateHelper.bind(this)(tSphere.picking.position, this.pickingHelper);
	        };
	    }();
	
	    var onMouseMove = function getOnMouseMoveFn() {
	        var ray = new THREE.Ray();
	        var mouse = new THREE.Vector2();
	
	        return function onMouseMove(event) {
	            if (player.isPlaying()) {
	                player.stop();
	            }
	            if (this.enabled === false) return;
	
	            event.preventDefault();
	
	            if (state === CONTROL_STATE.ORBIT || state === CONTROL_STATE.PANORAMIC) {
	                if (this.enableRotate === false) return;
	
	                rotateEnd.set(event.clientX - event.target.offsetLeft, event.clientY - event.target.offsetTop);
	                rotateDelta.subVectors(rotateEnd, rotateStart);
	
	                // rotating across whole screen goes 360 degrees around
	                if (!space) {
	                    this.rotateLeft(2 * Math.PI * rotateDelta.x / sizeRendering.width * this.rotateSpeed);
	
	                    // rotating up and down along whole screen attempts to go 360, but limited to 180
	                    this.rotateUp(2 * Math.PI * rotateDelta.y / sizeRendering.height * this.rotateSpeed);
	                } else {
	                    this.rotateLeft(rotateDelta.x);
	
	                    // rotating up and down along whole screen attempts to go 360, but limited to 180
	                    this.rotateUp(rotateDelta.y);
	                }
	
	                rotateStart.copy(rotateEnd);
	            } else if (state === CONTROL_STATE.DOLLY) {
	                if (this.enableZoom === false) return;
	
	                dollyEnd.set(event.clientX - event.target.offsetLeft, event.clientY - event.target.offsetTop);
	                dollyDelta.subVectors(dollyEnd, dollyStart);
	
	                if (dollyDelta.y > 0) {
	                    this.dollyIn();
	                } else if (dollyDelta.y < 0) {
	                    this.dollyOut();
	                }
	
	                dollyStart.copy(dollyEnd);
	            } else if (state === CONTROL_STATE.PAN) {
	                if (this.enablePan === false) return;
	
	                panEnd.set(event.clientX - event.target.offsetLeft, event.clientY - event.target.offsetTop);
	                panDelta.subVectors(panEnd, panStart);
	
	                this.mouseToPan(panDelta.x, panDelta.y);
	
	                panStart.copy(panEnd);
	            } else if (state === CONTROL_STATE.MOVE_GLOBE) {
	                mouse.x = (event.clientX - event.target.offsetLeft) / sizeRendering.width * 2 - 1;
	                mouse.y = -((event.clientY - event.target.offsetTop) / sizeRendering.height) * 2 + 1;
	
	                snapShotCamera.updateRay(ray, mouse);
	
	                var intersection = tSphere.intersectWithRay(ray);
	
	                // If there's intersection then move globe else we stop the move
	                if (intersection) {
	                    var normalizedIntersection = intersection.normalize();
	                    quatGlobe.setFromUnitVectors(normalizedIntersection, tSphere.picking.normal);
	                    // backups last move globe for damping
	                    lastRotation.push(normalizedIntersection.clone());
	                    // Remove unnecessary movements backups
	                    if (lastRotation.length > 2) {
	                        lastRotation.splice(0, 1);
	                    }
	                } else {
	                    onMouseUp.bind(this)();
	                }
	            }
	
	            if (state !== CONTROL_STATE.NONE) {
	                update();
	            }
	        };
	    }();
	
	    var onMouseDown = function onMouseDown(event) {
	        var _this = this;
	
	        player.stop().then(function () {
	            if (_this.enabled === false) return;
	            event.preventDefault();
	
	            if (event.button === _this.mouseButtons.PANORAMIC) {
	                if (_this.enableRotate === false) return;
	
	                if (keyCtrl) {
	                    state = CONTROL_STATE.ORBIT;
	                } else if (keyShift) {
	                    state = CONTROL_STATE.PANORAMIC;
	                } else if (keyS) {
	                    // If the key 'S' is down, the engine selects node under mouse
	                    selectClick.mouse = new THREE.Vector2(event.clientX - event.target.offsetLeft, event.clientY - event.target.offsetTop);
	
	                    domElement.dispatchEvent(selectClick);
	                } else {
	                    snapShotCamera.shot(_this.camera);
	                    ptScreenClick.x = event.clientX - event.target.offsetLeft;
	                    ptScreenClick.y = event.clientY - event.target.offsetTop;
	
	                    var point = getPickingPosition(ptScreenClick);
	                    lastRotation = [];
	                    // update tangent sphere which passes through the point
	                    if (point) {
	                        ctrl.range = _this.getRange();
	                        updateSpherePicking.bind(_this)(point, ptScreenClick);
	                        state = CONTROL_STATE.MOVE_GLOBE;
	                    }
	                }
	
	                rotateStart.set(event.clientX - event.target.offsetLeft, event.clientY - event.target.offsetTop);
	            } else if (event.button === _this.mouseButtons.ZOOM) {
	                if (_this.enableZoom === false) return;
	
	                state = CONTROL_STATE.DOLLY;
	
	                dollyStart.set(event.clientX - event.target.offsetLeft, event.clientY - event.target.offsetTop);
	            } else if (event.button === _this.mouseButtons.PAN) {
	                if (_this.enablePan === false) return;
	
	                state = CONTROL_STATE.PAN;
	
	                panStart.set(event.clientX - event.target.offsetLeft, event.clientY - event.target.offsetTop);
	            }
	
	            if (state !== CONTROL_STATE.NONE) {
	                _this.domElement.addEventListener('mousemove', _handlerMouseMove, false);
	                _this.domElement.addEventListener('mouseup', _handlerMouseUp, false);
	                _this.domElement.addEventListener('mouseleave', _handlerMouseUp, false);
	                _this.dispatchEvent(_this.startEvent);
	            }
	        });
	    };
	
	    var ondblclick = function ondblclick(event) {
	        if (this.enabled === false) return;
	
	        // Double click throws move camera's target with animation
	        if (!keyCtrl && !keyShift) {
	            ptScreenClick.x = event.clientX - event.target.offsetLeft;
	            ptScreenClick.y = event.clientY - event.target.offsetTop;
	
	            var point = getPickingPosition(ptScreenClick);
	
	            if (point) {
	                animatedScale = 0.6;
	                this.setCenter(point, true);
	            }
	        }
	    };
	
	    var onMouseUp = function onMouseUp() /* event */{
	        var _this2 = this;
	
	        if (this.enabled === false) return;
	
	        this.domElement.removeEventListener('mousemove', _handlerMouseMove, false);
	        this.domElement.removeEventListener('mouseup', _handlerMouseUp, false);
	        this.domElement.removeEventListener('mouseleave', _handlerMouseUp, false);
	        this.dispatchEvent(this.endEvent);
	
	        player.stop();
	
	        // Launch damping movement for :
	        //      * CONTROL_STATE.ORBIT
	        //      * CONTROL_STATE.MOVE_GLOBE
	        if (this.enableDamping) {
	            if (state === CONTROL_STATE.ORBIT && (sphericalDelta.theta > EPS || sphericalDelta.phi > EPS)) {
	                player.play(dampingOrbitalMvt).then(function () {
	                    _this2.resetControls();_this2.viewerDiv.dispatchEvent(eventOrientationChanged);
	                });
	            } else if (state === CONTROL_STATE.MOVE_GLOBE && lastRotation.length === 2 && !lastRotation[1].equals(lastRotation[0])) {
	                ctrl.qDelta.setFromUnitVectors(lastRotation[1], lastRotation[0]);
	                player.play(animationDampingMove).then(function () {
	                    return _this2.resetControls();
	                });
	            } else {
	                updateGlobeTarget.bind(this)();
	            }
	        } else {
	            updateGlobeTarget.bind(this)();
	        }
	    };
	
	    var onMouseWheel = function onMouseWheel(event) {
	        var _this3 = this;
	
	        player.stop().then(function () {
	            if (_this3.enabled === false || _this3.enableZoom === false /* || state !== CONTROL_STATE.NONE*/) return;
	
	            event.preventDefault();
	            event.stopPropagation();
	
	            var delta = 0;
	
	            // WebKit / Opera / Explorer 9
	            if (event.wheelDelta !== undefined) {
	                delta = event.wheelDelta;
	                // Firefox
	            } else if (event.detail !== undefined) {
	                delta = -event.detail;
	            }
	
	            if (delta > 0) {
	                _this3.dollyOut();
	            } else if (delta < 0) {
	                _this3.dollyIn();
	            }
	
	            update();
	
	            _this3.dispatchEvent(_this3.startEvent);
	            _this3.dispatchEvent(_this3.endEvent);
	
	            if (event.wheelDelta) {
	                _this3.viewerDiv.dispatchEvent(eventZoomChanged);
	            }
	        });
	    };
	
	    var onKeyUp = function onKeyUp() /* event*/{
	        if (this.enabled === false || this.enableKeys === false || this.enablePan === false) return;
	
	        if (state === CONTROL_STATE.PAN) {
	            updateGlobeTarget.bind(this)();
	        }
	
	        keyCtrl = false;
	        keyShift = false;
	        keyS = false;
	    };
	
	    var onKeyDown = function onKeyDown(event) {
	        var _this4 = this;
	
	        player.stop().then(function () {
	            if (_this4.enabled === false || _this4.enableKeys === false || _this4.enablePan === false) return;
	            keyCtrl = false;
	            keyShift = false;
	
	            switch (event.keyCode) {
	                case CONTROL_KEYS.UP:
	                    _this4.mouseToPan(0, _this4.keyPanSpeed);
	                    state = CONTROL_STATE.PAN;
	                    update();
	                    break;
	                case CONTROL_KEYS.BOTTOM:
	                    _this4.mouseToPan(0, -_this4.keyPanSpeed);
	                    state = CONTROL_STATE.PAN;
	                    update();
	                    break;
	                case CONTROL_KEYS.LEFT:
	                    _this4.mouseToPan(_this4.keyPanSpeed, 0);
	                    state = CONTROL_STATE.PAN;
	                    update();
	                    break;
	                case CONTROL_KEYS.RIGHT:
	                    _this4.mouseToPan(-_this4.keyPanSpeed, 0);
	                    state = CONTROL_STATE.PAN;
	                    update();
	                    break;
	                // TODO Why space key, looking for movement
	                case CONTROL_KEYS.SPACE:
	                    space = !space;
	                    // this.updateTarget();
	                    update();
	                    break;
	                case CONTROL_KEYS.CTRL:
	                    // computeVectorUp();
	                    keyCtrl = true;
	                    break;
	                case CONTROL_KEYS.SHIFT:
	                    // computeVectorUp();
	                    keyShift = true;
	                    break;
	                case CONTROL_KEYS.S:
	                    // WARNING loop !!!
	                    keyS = true;
	                    break;
	                default:
	            }
	        });
	    };
	
	    var onTouchStart = function onTouchStart(event) {
	        if (this.enabled === false) return;
	
	        switch (event.touches.length) {
	
	            case 1:
	                // one-fingered touch: rotate
	
	                if (this.enableRotate === false) return;
	
	                state = CONTROL_STATE.TOUCH_ROTATE;
	
	                rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
	                break;
	
	            case 2:
	                // two-fingered touch: dolly
	
	                if (this.enableZoom === false) return;
	
	                state = CONTROL_STATE.TOUCH_DOLLY;
	
	                var dx = event.touches[0].pageX - event.touches[1].pageX;
	                var dy = event.touches[0].pageY - event.touches[1].pageY;
	                var distance = Math.sqrt(dx * dx + dy * dy);
	                dollyStart.set(0, distance);
	                break;
	
	            case 3:
	                // three-fingered touch: this.mouseToPan
	
	                if (this.enablePan === false) return;
	
	                state = CONTROL_STATE.TOUCH_PAN;
	
	                panStart.set(event.touches[0].pageX, event.touches[0].pageY);
	                break;
	
	            default:
	
	                state = CONTROL_STATE.NONE;
	
	        }
	
	        if (state !== CONTROL_STATE.NONE) this.dispatchEvent(this.startEvent);
	    };
	
	    var onTouchMove = function onTouchMove(event) {
	        if (this.enabled === false) return;
	
	        event.preventDefault();
	        event.stopPropagation();
	
	        var element = this.domElement === document ? this.domElement.body : this.domElement;
	
	        switch (event.touches.length) {
	
	            case 1:
	                // one-fingered touch: rotate
	
	                if (this.enableRotate === false) return;
	                if (state !== CONTROL_STATE.TOUCH_ROTATE) return;
	
	                rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
	                rotateDelta.subVectors(rotateEnd, rotateStart);
	
	                // rotating across whole screen goes 360 degrees around
	                this.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * this.rotateSpeed);
	                // rotating up and down along whole screen attempts to go 360, but limited to 180
	                this.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * this.rotateSpeed);
	
	                rotateStart.copy(rotateEnd);
	
	                update();
	                break;
	
	            case 2:
	                // two-fingered touch: dolly
	
	                if (this.enableZoom === false) return;
	                if (state !== CONTROL_STATE.TOUCH_DOLLY) return;
	
	                var dx = event.touches[0].pageX - event.touches[1].pageX;
	                var dy = event.touches[0].pageY - event.touches[1].pageY;
	                var distance = Math.sqrt(dx * dx + dy * dy);
	
	                dollyEnd.set(0, distance);
	                dollyDelta.subVectors(dollyEnd, dollyStart);
	
	                if (dollyDelta.y > 0) {
	                    this.dollyOut();
	                } else if (dollyDelta.y < 0) {
	                    this.dollyIn();
	                }
	
	                dollyStart.copy(dollyEnd);
	
	                update();
	                break;
	
	            case 3:
	                // three-fingered touch: this.mouseToPan
	
	                if (this.enablePan === false) return;
	                if (state !== CONTROL_STATE.TOUCH_PAN) return;
	
	                panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
	                panDelta.subVectors(panEnd, panStart);
	
	                this.mouseToPan(panDelta.x, panDelta.y);
	
	                panStart.copy(panEnd);
	
	                update();
	                break;
	
	            default:
	
	                state = CONTROL_STATE.NONE;
	
	        }
	    };
	
	    var onTouchEnd = function onTouchEnd() /* event */{
	        if (this.enabled === false) return;
	
	        this.dispatchEvent(this.endEvent);
	        state = CONTROL_STATE.NONE;
	        keyCtrl = false;
	        keyShift = false;
	        keyS = false;
	    };
	
	    // Callback launched when player is stopped
	    this.resetControls = function resetControls() {
	        lastRotation.splice(0);
	        ctrl.progress = 0;
	        updateGlobeTarget.bind(this)();
	    };
	
	    // update object camera position
	    this.updateCameraTransformation = function updateCameraTransformation(controlState) {
	        var bkDamping = this.enableDamping;
	        this.enableDamping = false;
	        state = controlState || CONTROL_STATE.ORBIT;
	        update();
	        updateGlobeTarget.bind(this)();
	        this.enableDamping = bkDamping;
	    };
	
	    this.dispose = function dispose() {
	        // this.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
	        this.domElement.removeEventListener('mousedown', onMouseDown, false);
	        this.domElement.removeEventListener('mousewheel', onMouseWheel, false);
	        this.domElement.removeEventListener('DOMMouseScroll', onMouseWheel, false); // firefox
	
	        this.domElement.removeEventListener('touchstart', onTouchStart, false);
	        this.domElement.removeEventListener('touchend', onTouchEnd, false);
	        this.domElement.removeEventListener('touchmove', onTouchMove, false);
	
	        this.domElement.removeEventListener('mousemove', onMouseMove, false);
	        this.domElement.removeEventListener('mouseup', onMouseUp, false);
	
	        window.removeEventListener('keydown', onKeyDown, false);
	
	        // this.dispatchEvent( { type: 'dispose' } ); // should this be added here?
	    };
	
	    // Instance all
	    this.domElement.addEventListener('contextmenu', function (event) {
	        event.preventDefault();
	    }, false);
	    this.domElement.addEventListener('mousedown', onMouseDown.bind(this), false);
	    this.domElement.addEventListener('mousewheel', onMouseWheel.bind(this), false);
	    this.domElement.addEventListener('dblclick', ondblclick.bind(this), false);
	    this.domElement.addEventListener('DOMMouseScroll', onMouseWheel.bind(this), false); // firefox
	
	    this.domElement.addEventListener('touchstart', onTouchStart.bind(this), false);
	    this.domElement.addEventListener('touchend', onTouchEnd.bind(this), false);
	    this.domElement.addEventListener('touchmove', onTouchMove.bind(this), false);
	
	    // refresh control for each animation's frame
	    this.domElement.addEventListener('frameAnimation', update.bind(this), false);
	
	    // TODO: Why windows
	    window.addEventListener('keydown', onKeyDown.bind(this), false);
	    window.addEventListener('keyup', onKeyUp.bind(this), false);
	
	    // Initialisation Globe Target and movingGlobeTarget
	    var positionTarget = new THREE.Vector3().copy(camera.position).setLength(tSphere.radius);
	    setGlobleTarget(positionTarget);
	    movingGlobeTarget.copy(positionTarget);
	    this.camera.up.copy(positionTarget.normalize());
	    engine.scene3D.add(globeTarget);
	    spherical.radius = camera.position.length();
	
	    update();
	
	    if (enableTargetHelper) {
	        globeTarget.add(new THREE.AxisHelper(500000));
	        engine.scene3D.add(this.pickingHelper);
	    }
	
	    // Start position
	    initialTarget = globeTarget.clone();
	    initialPosition = this.camera.position.clone();
	    initialZoom = this.camera.zoom;
	
	    _handlerMouseMove = onMouseMove.bind(this);
	    _handlerMouseUp = onMouseUp.bind(this);
	}
	
	GlobeControls.prototype = (0, _create2.default)(THREE.EventDispatcher.prototype);
	GlobeControls.prototype.constructor = GlobeControls;
	
	// # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
	// API Function
	
	GlobeControls.prototype.setTilt = function setTilt(tilt, isAnimated) {
	    var deltaPhi = tilt * Math.PI / 180 - this.getTiltRad();
	    return this.moveOrbitalPosition(0, 0, deltaPhi, isAnimated);
	};
	
	GlobeControls.prototype.setHeading = function setHeading(heading, isAnimated) {
	    var deltaTheta = heading * Math.PI / 180 - this.getHeadingRad();
	    return this.moveOrbitalPosition(0, deltaTheta, 0, isAnimated);
	};
	
	GlobeControls.prototype.setRange = function setRange(pRange, isAnimated) {
	    var deltaRange = pRange - this.getRange();
	    return this.moveOrbitalPosition(deltaRange, 0, 0, isAnimated);
	};
	
	GlobeControls.prototype.setOrbitalPosition = function setOrbitalPosition(range, heading, tilt, isAnimated) {
	    var deltaPhi = tilt ? tilt * Math.PI / 180 - this.getTiltRad() : 0;
	    var deltaTheta = heading ? heading * Math.PI / 180 - this.getHeadingRad() : 0;
	    var deltaRange = range ? range - this.getRange() : 0;
	    return this.moveOrbitalPosition(deltaRange, deltaTheta, deltaPhi, isAnimated);
	};
	
	var destSpherical = new THREE.Spherical();
	
	GlobeControls.prototype.moveOrbitalPosition = function moveOrbitalPositionfunction(deltaRange, deltaTheta, deltaPhi, isAnimated) {
	    var _this5 = this;
	
	    var range = deltaRange + this.getRange();
	    if (isAnimated) {
	        this.viewerDiv.dispatchEvent(eventAnimationStarted);
	        destSpherical.theta = deltaTheta + spherical.theta;
	        destSpherical.phi = deltaPhi + spherical.phi;
	        sphericalTo.radius = range;
	        sphericalTo.theta = deltaTheta / (animationOrbit.duration - 1);
	        sphericalTo.phi = deltaPhi / (animationOrbit.duration - 1);
	        state = CONTROL_STATE.ORBIT;
	        return player.play(animationOrbit).then(function () {
	            // To correct errors at animation's end
	            if (player.isEnded()) {
	                _this5.moveOrbitalPosition(0, destSpherical.theta - spherical.theta, destSpherical.phi - spherical.phi);
	                _this5.viewerDiv.dispatchEvent(eventAnimationStopped);
	            } else if (player.isStopped()) {
	                _this5.viewerDiv.dispatchEvent(eventAnimationStopped);
	            }
	            _this5.resetControls();
	        });
	    } else {
	        sphericalDelta.theta = deltaTheta;
	        sphericalDelta.phi = deltaPhi;
	        orbit.scale = range / this.getRange();
	        this.updateCameraTransformation();
	        return new _promise2.default(function (r) {
	            r();
	        });
	    }
	};
	
	/**
	 * Gets camera's target position
	 *
	 * @return     {Vecto3}
	 */
	GlobeControls.prototype.getTargetCameraPosition = function getTargetCameraPosition() {
	    return globeTarget.position;
	};
	
	GlobeControls.prototype.setCenter = function setCenter(position, isAnimated) {
	    var _this6 = this;
	
	    var center = this.getTargetCameraPosition();
	
	    snapShotCamera.shot(this.camera);
	
	    ptScreenClick.x = this.domElement.width / 2;
	    ptScreenClick.y = this.domElement.height / 2;
	
	    var vFrom = center.clone().normalize();
	    var vTo = position.normalize();
	
	    if (isAnimated) {
	        this.viewerDiv.dispatchEvent(eventAnimationStarted);
	        ctrl.qDelta.setFromUnitVectors(vFrom, vTo);
	        if (position.range) {
	            animatedScale = 1.0 - position.range / this.getRange();
	        }
	        state = CONTROL_STATE.MOVE_GLOBE;
	        return player.play(animationZoomCenter).then(function () {
	            if (player.isEnded()) {
	                _this6.viewerDiv.dispatchEvent(eventAnimationStopped);
	                _this6.viewerDiv.dispatchEvent(eventZoomChanged);
	            } else if (player.isStopped()) {
	                _this6.viewerDiv.dispatchEvent(eventAnimationStopped);
	            }
	            animatedScale = 0.0;
	            _this6.resetControls();
	        });
	    } else {
	        quatGlobe.setFromUnitVectors(vFrom, vTo);
	        this.updateCameraTransformation(CONTROL_STATE.MOVE_GLOBE);
	        return new _promise2.default(function (r) {
	            r();
	        });
	    }
	};
	
	GlobeControls.prototype.getRange = function getRange() {
	    return this.getTargetCameraPosition().distanceTo(this.camera.position);
	};
	
	// TODO idea : remove this? used in API
	GlobeControls.prototype.getRay = function getRay() {
	    var direction = new THREE.Vector3(0, 0, 1);
	    this.camera.localToWorld(direction);
	    direction.sub(this.camera.position).negate().normalize();
	
	    return {
	        origin: this.camera.position,
	        direction: direction
	    };
	};
	
	GlobeControls.prototype.getTilt = function getTilt() {
	    return spherical.phi * 180 / Math.PI;
	};
	
	GlobeControls.prototype.getHeading = function getHeading() {
	    return spherical.theta * 180 / Math.PI;
	};
	
	// Same functions
	
	GlobeControls.prototype.getTiltRad = function getTiltRad() {
	    return spherical.phi;
	};
	
	GlobeControls.prototype.getHeadingRad = function getHeadingRad() {
	    return spherical.theta;
	};
	
	GlobeControls.prototype.getPolarAngle = function getPolarAngle() {
	    return spherical.phi;
	};
	
	GlobeControls.prototype.getAzimuthalAngle = function getAzimuthalAngle() {
	    return spherical.theta;
	};
	
	GlobeControls.prototype.moveTarget = function moveTarget() {
	    return movingGlobeTarget;
	};
	
	GlobeControls.prototype.pan = function pan(deltaX, deltaY) {
	    this.mouseToPan(deltaX, deltaY);
	    this.updateCameraTransformation(CONTROL_STATE.PAN);
	};
	
	// End API functions
	// # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
	
	GlobeControls.prototype.reset = function reset() {
	    // TODO not reset target globe
	
	    state = CONTROL_STATE.NONE;
	
	    this.target.copy(initialTarget);
	    this.camera.position.copy(initialPosition);
	    this.camera.zoom = initialZoom;
	
	    this.camera.updateProjectionMatrix();
	    this.dispatchEvent(this.changeEvent);
	
	    this.updateCameraTransformation();
	};
	
	exports.default = GlobeControls;

/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(244), __esModule: true };

/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(245);
	var $Object = __webpack_require__(15).Object;
	module.exports = function create(P, D){
	  return $Object.create(P, D);
	};

/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(14)
	// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
	$export($export.S, 'Object', {create: __webpack_require__(42)});

/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function Sphere(center, radius) {
	    this.center = center || new THREE.Vector3();
	    this.radius = radius || 1.0;
	}
	
	Sphere.prototype.constructor = Sphere;
	
	Sphere.prototype.setCenter = function setCenter(center) {
	    this.center.copy(center);
	};
	
	Sphere.prototype.setRadius = function setRadius(radius) {
	    this.radius = radius;
	};
	
	var vector = new THREE.Vector3();
	
	Sphere.prototype.intersectWithRayNoMiss = function intersectWithRayNoMiss(ray) {
	    var pc = ray.closestPointToPoint(this.center);
	    var a = pc.length();
	    var d = void 0;
	    var b = void 0;
	
	    // TODO: recompute mirror ray
	    // If the ray miss sphere, we recompute the new ray with point symetric to tangent sphere
	    if (a > this.radius) {
	        // mirror point is symetric of pc
	        // The mirror ray must pass through the point mirrorPoint
	        var mirrorPoint = pc.clone().setLength(this.radius * 2 - a);
	
	        // Compute the new direction
	        d = ray.direction.subVectors(mirrorPoint, ray.origin).normalize();
	
	        // Classic intersection with the new ray
	        pc = ray.closestPointToPoint(this.center);
	        a = pc.length();
	
	        b = Math.sqrt(this.radius * this.radius - a * a);
	        d.setLength(b);
	
	        return vector.addVectors(pc, d);
	    }
	
	    // TODO: check all intersections : if (ray.origin.length() > this.radius)
	    d = ray.direction.clone();
	    b = Math.sqrt(this.radius * this.radius - a * a);
	    d.setLength(b);
	
	    return vector.subVectors(pc, d);
	};
	
	Sphere.prototype.intersectWithRay = function intersectWithRay(ray) {
	    var pc = ray.closestPointToPoint(this.center);
	    var a = pc.length();
	    if (a > this.radius) return undefined;
	    var d = ray.direction.clone();
	    var b = Math.sqrt(this.radius * this.radius - a * a);
	    d.setLength(b);
	    return vector.subVectors(pc, d);
	};
	
	exports.default = Sphere;

/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.AnimatedExpression = exports.Animation = undefined;
	
	var _getPrototypeOf = __webpack_require__(2);
	
	var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);
	
	var _possibleConstructorReturn2 = __webpack_require__(248);
	
	var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);
	
	var _inherits2 = __webpack_require__(268);
	
	var _inherits3 = _interopRequireDefault(_inherits2);
	
	var _promise = __webpack_require__(224);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _classCallCheck2 = __webpack_require__(273);
	
	var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);
	
	var _createClass2 = __webpack_require__(274);
	
	var _createClass3 = _interopRequireDefault(_createClass2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var FRAMERATE = 60;
	var FRAME_DURATION = 1000 / FRAMERATE;
	// if is true console.log are enabled to sniff animation'state
	var debugAnimation = false;
	
	// player statut
	var PLAYER_STATE = {
	    // player is stopped
	    STOP: 0,
	    // player plays animation
	    PLAY: 1,
	    // player is at the end of an animation
	    END: 2,
	    // player is paused
	    PAUSE: 3
	};
	
	var debugMsg = ['Stop', 'Play', 'End', 'Pause'];
	
	// if debugAnimation is true console.log are enabled to sniff animation'state
	var _DEBUG = null;
	
	if (debugAnimation) {
	    _DEBUG = function DEBUG(message, animation) {
	        if (animation) {
	            // eslint-disable-next-line no-console
	            console.info('Animation ', message, ' : ', animation.name);
	        }
	    };
	} else {
	    _DEBUG = function _DEBUG() {};
	}
	
	// Private functions
	// stop timer and re-init parameter
	var resetTimer = function resetTimer(player) {
	    if (player.id) {
	        clearInterval(player.id);
	        player.id = undefined;
	    }
	    if (player.waitTimer) {
	        clearInterval(player.waitTimer);
	        player.waitTimer = undefined;
	    }
	    player.keyframe = 0;
	};
	
	// finish animation and re-init parameter
	var finishAnimation = function finishAnimation(player) {
	    resetTimer(player);
	    player.animation = null;
	    if (player.resolve) {
	        player.resolve();
	        player.resolve = null;
	        player.promise = null;
	    }
	};
	
	var setPlayerState = function setPlayerState(player, state) {
	    player.state = state;
	    _DEBUG(debugMsg[state], player.animation);
	};
	
	var frameEvent = new CustomEvent('frameAnimation');
	var stopEvent = new CustomEvent('stopAnimation');
	var endEvent = new CustomEvent('endAnimation');
	
	/**
	 * AnimationPlayer
	 * It can play, pause or stop Animation or AnimationExpression (See below).
	 * AnimationPlayer is needed to use Animation or AnimationExpression
	 * AnimationPlayer emits events :
	 *       - for each animation's frame;
	 *       - when Animation is stopped
	 *       - when Animation is ending
	 */
	
	var AnimationPlayer = function () {
	    function AnimationPlayer(dom) {
	        (0, _classCallCheck3.default)(this, AnimationPlayer);
	
	        this.dom = dom;
	        this.id = null;
	        this.keyframe = 0;
	        this.animation = null;
	        this.resolve = null;
	        this.promise = null;
	        this.state = PLAYER_STATE.STOP;
	        this.waitTimer = null;
	    }
	
	    (0, _createClass3.default)(AnimationPlayer, [{
	        key: 'isPlaying',
	        value: function isPlaying() {
	            return this.state === PLAYER_STATE.PLAY;
	        }
	    }, {
	        key: 'isStopped',
	        value: function isStopped() {
	            return this.state === PLAYER_STATE.STOP;
	        }
	    }, {
	        key: 'isEnded',
	        value: function isEnded() {
	            return this.state === PLAYER_STATE.END;
	        }
	
	        // Public functions
	
	        /**
	         * { Start animation }
	         * this function play one animation.
	         * If another animation is playing, it's stopped and the new animation is played
	         * @param      {Animation} The animation to play
	         * @return     {Promise}  Promise is resolved when animation is stopped or finished
	         */
	
	    }, {
	        key: 'play',
	        value: function play(animation) {
	            var _this = this;
	
	            this.animation = animation;
	            setPlayerState(this, PLAYER_STATE.PLAY);
	            resetTimer(this);
	            this.id = setInterval(this.frame.bind(this), FRAME_DURATION);
	            this.promise = new _promise2.default(function (r) {
	                _this.resolve = r;
	            });
	            return this.promise;
	        }
	
	        /**
	         * { The animation is played after a number of frames }
	         *
	         * @param      {Animation}  animation    The animation to play
	         * @param      {Number}  waitingTime  The waiting time before start animation (time in frame)
	         */
	
	    }, {
	        key: 'playLater',
	        value: function playLater(animation, waitingFrame) {
	            var _this2 = this;
	
	            this.resolveWait = null;
	            var promise = new _promise2.default(function (r) {
	                _this2.resolveWait = r;
	            });
	            var timew = Math.floor(FRAME_DURATION * waitingFrame);
	            window.clearInterval(this.waitTimer);
	            this.waitTimer = window.setTimeout(function () {
	                _this2.play(animation).then(function () {
	                    return _this2.resolveWait();
	                });
	            }, timew);
	            return promise;
	        }
	
	        /**
	         * { Stop current animation }
	         *
	         * @return  {Promise}  Promise is resolved when animation is stopped or finished
	         */
	
	    }, {
	        key: 'stop',
	        value: function stop() {
	            setPlayerState(this, PLAYER_STATE.STOP);
	            finishAnimation(this);
	            this.dom.dispatchEvent(stopEvent);
	            // needed to return promise to wait sync
	            return _promise2.default.resolve();
	        }
	
	        /**
	         * { this function is executed with each frame }
	         */
	
	    }, {
	        key: 'frame',
	        value: function frame() {
	            if (this.keyframe < this.animation.duration) {
	                if (this.animation.animate) {
	                    this.animation.animate(this.keyframe);
	                }
	                this.keyframe++;
	                this.dom.dispatchEvent(frameEvent);
	            } else {
	                setPlayerState(this, PLAYER_STATE.END);
	                finishAnimation(this);
	                this.dom.dispatchEvent(endEvent);
	            }
	        }
	    }]);
	    return AnimationPlayer;
	}();
	
	/**
	 * { Animation }
	 * Animation is play by the AnimationPlayer during the time of duration
	 * During playback, the AnimationPlayer emits event for each frame
	 * Animation is used to execute a callback to each frame
	 * @class      Animation
	 * @param      {Number}  duration  The animation's duration in number of frames. FRAMERATE is number of frames in one seconde.
	 * @param      {String}  name      The animation's name. It's used for debug message.
	 */
	
	
	var Animation = function Animation(params) {
	    (0, _classCallCheck3.default)(this, Animation);
	
	    this.duration = params.duration || FRAMERATE;
	    this.name = params.name;
	};
	
	/**
	 * { function_description }
	 * AnimatedExpression is play by the AnimationPlayer during the time of duration
	 * During playback, the AnimationPlayer emits event for each frame and
	 * it applies expression on root.
	 * AnimatedExpression is used to change object's values for each frame
	 * @class      AnimatedExpression (name)
	 * @param      {Number}   duration    The animation's duration in number of frames. FRAMERATE is number of frames in one seconde.
	 * @param      {Object}   root        The root is the object in scene to animate
	 * @param      {Function} expression  The expression is function applied to root with each frame
	 * @param      {String}   name        The animation's name. It's used for debug message
	  */
	
	var AnimatedExpression = function (_Animation) {
	    (0, _inherits3.default)(AnimatedExpression, _Animation);
	
	    function AnimatedExpression(params) {
	        (0, _classCallCheck3.default)(this, AnimatedExpression);
	
	        var _this3 = (0, _possibleConstructorReturn3.default)(this, (AnimatedExpression.__proto__ || (0, _getPrototypeOf2.default)(AnimatedExpression)).call(this, params));
	
	        _this3.root = params.root;
	        _this3.expression = params.expression;
	        return _this3;
	    }
	
	    (0, _createClass3.default)(AnimatedExpression, [{
	        key: 'animate',
	        value: function animate(keyFrame) {
	            this.expression(this.root, keyFrame / this.duration);
	        }
	    }]);
	    return AnimatedExpression;
	}(Animation);
	
	exports.Animation = Animation;
	exports.AnimatedExpression = AnimatedExpression;
	exports.default = AnimationPlayer;

/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _typeof2 = __webpack_require__(249);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (self, call) {
	  if (!self) {
	    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
	  }
	
	  return call && ((typeof call === "undefined" ? "undefined" : (0, _typeof3.default)(call)) === "object" || typeof call === "function") ? call : self;
	};

/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _iterator = __webpack_require__(250);
	
	var _iterator2 = _interopRequireDefault(_iterator);
	
	var _symbol = __webpack_require__(253);
	
	var _symbol2 = _interopRequireDefault(_symbol);
	
	var _typeof = typeof _symbol2.default === "function" && typeof _iterator2.default === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj; };
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = typeof _symbol2.default === "function" && _typeof(_iterator2.default) === "symbol" ? function (obj) {
	  return typeof obj === "undefined" ? "undefined" : _typeof(obj);
	} : function (obj) {
	  return obj && typeof _symbol2.default === "function" && obj.constructor === _symbol2.default && obj !== _symbol2.default.prototype ? "symbol" : typeof obj === "undefined" ? "undefined" : _typeof(obj);
	};

/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(251), __esModule: true };

/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(54);
	__webpack_require__(30);
	module.exports = __webpack_require__(252).f('iterator');

/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	exports.f = __webpack_require__(53);

/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(254), __esModule: true };

/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(255);
	__webpack_require__(226);
	__webpack_require__(266);
	__webpack_require__(267);
	module.exports = __webpack_require__(15).Symbol;

/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	// ECMAScript 6 symbols shim
	var global         = __webpack_require__(11)
	  , has            = __webpack_require__(8)
	  , DESCRIPTORS    = __webpack_require__(23)
	  , $export        = __webpack_require__(14)
	  , redefine       = __webpack_require__(40)
	  , META           = __webpack_require__(256).KEY
	  , $fails         = __webpack_require__(24)
	  , shared         = __webpack_require__(10)
	  , setToStringTag = __webpack_require__(52)
	  , uid            = __webpack_require__(12)
	  , wks            = __webpack_require__(53)
	  , wksExt         = __webpack_require__(252)
	  , wksDefine      = __webpack_require__(257)
	  , keyOf          = __webpack_require__(258)
	  , enumKeys       = __webpack_require__(259)
	  , isArray        = __webpack_require__(262)
	  , anObject       = __webpack_require__(20)
	  , toIObject      = __webpack_require__(35)
	  , toPrimitive    = __webpack_require__(26)
	  , createDesc     = __webpack_require__(27)
	  , _create        = __webpack_require__(42)
	  , gOPNExt        = __webpack_require__(263)
	  , $GOPD          = __webpack_require__(265)
	  , $DP            = __webpack_require__(19)
	  , $keys          = __webpack_require__(44)
	  , gOPD           = $GOPD.f
	  , dP             = $DP.f
	  , gOPN           = gOPNExt.f
	  , $Symbol        = global.Symbol
	  , $JSON          = global.JSON
	  , _stringify     = $JSON && $JSON.stringify
	  , PROTOTYPE      = 'prototype'
	  , HIDDEN         = wks('_hidden')
	  , TO_PRIMITIVE   = wks('toPrimitive')
	  , isEnum         = {}.propertyIsEnumerable
	  , SymbolRegistry = shared('symbol-registry')
	  , AllSymbols     = shared('symbols')
	  , OPSymbols      = shared('op-symbols')
	  , ObjectProto    = Object[PROTOTYPE]
	  , USE_NATIVE     = typeof $Symbol == 'function'
	  , QObject        = global.QObject;
	// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
	var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
	
	// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
	var setSymbolDesc = DESCRIPTORS && $fails(function(){
	  return _create(dP({}, 'a', {
	    get: function(){ return dP(this, 'a', {value: 7}).a; }
	  })).a != 7;
	}) ? function(it, key, D){
	  var protoDesc = gOPD(ObjectProto, key);
	  if(protoDesc)delete ObjectProto[key];
	  dP(it, key, D);
	  if(protoDesc && it !== ObjectProto)dP(ObjectProto, key, protoDesc);
	} : dP;
	
	var wrap = function(tag){
	  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);
	  sym._k = tag;
	  return sym;
	};
	
	var isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function(it){
	  return typeof it == 'symbol';
	} : function(it){
	  return it instanceof $Symbol;
	};
	
	var $defineProperty = function defineProperty(it, key, D){
	  if(it === ObjectProto)$defineProperty(OPSymbols, key, D);
	  anObject(it);
	  key = toPrimitive(key, true);
	  anObject(D);
	  if(has(AllSymbols, key)){
	    if(!D.enumerable){
	      if(!has(it, HIDDEN))dP(it, HIDDEN, createDesc(1, {}));
	      it[HIDDEN][key] = true;
	    } else {
	      if(has(it, HIDDEN) && it[HIDDEN][key])it[HIDDEN][key] = false;
	      D = _create(D, {enumerable: createDesc(0, false)});
	    } return setSymbolDesc(it, key, D);
	  } return dP(it, key, D);
	};
	var $defineProperties = function defineProperties(it, P){
	  anObject(it);
	  var keys = enumKeys(P = toIObject(P))
	    , i    = 0
	    , l = keys.length
	    , key;
	  while(l > i)$defineProperty(it, key = keys[i++], P[key]);
	  return it;
	};
	var $create = function create(it, P){
	  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
	};
	var $propertyIsEnumerable = function propertyIsEnumerable(key){
	  var E = isEnum.call(this, key = toPrimitive(key, true));
	  if(this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return false;
	  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
	};
	var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key){
	  it  = toIObject(it);
	  key = toPrimitive(key, true);
	  if(it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key))return;
	  var D = gOPD(it, key);
	  if(D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key]))D.enumerable = true;
	  return D;
	};
	var $getOwnPropertyNames = function getOwnPropertyNames(it){
	  var names  = gOPN(toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META)result.push(key);
	  } return result;
	};
	var $getOwnPropertySymbols = function getOwnPropertySymbols(it){
	  var IS_OP  = it === ObjectProto
	    , names  = gOPN(IS_OP ? OPSymbols : toIObject(it))
	    , result = []
	    , i      = 0
	    , key;
	  while(names.length > i){
	    if(has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true))result.push(AllSymbols[key]);
	  } return result;
	};
	
	// 19.4.1.1 Symbol([description])
	if(!USE_NATIVE){
	  $Symbol = function Symbol(){
	    if(this instanceof $Symbol)throw TypeError('Symbol is not a constructor!');
	    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);
	    var $set = function(value){
	      if(this === ObjectProto)$set.call(OPSymbols, value);
	      if(has(this, HIDDEN) && has(this[HIDDEN], tag))this[HIDDEN][tag] = false;
	      setSymbolDesc(this, tag, createDesc(1, value));
	    };
	    if(DESCRIPTORS && setter)setSymbolDesc(ObjectProto, tag, {configurable: true, set: $set});
	    return wrap(tag);
	  };
	  redefine($Symbol[PROTOTYPE], 'toString', function toString(){
	    return this._k;
	  });
	
	  $GOPD.f = $getOwnPropertyDescriptor;
	  $DP.f   = $defineProperty;
	  __webpack_require__(264).f = gOPNExt.f = $getOwnPropertyNames;
	  __webpack_require__(261).f  = $propertyIsEnumerable;
	  __webpack_require__(260).f = $getOwnPropertySymbols;
	
	  if(DESCRIPTORS && !__webpack_require__(39)){
	    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
	  }
	
	  wksExt.f = function(name){
	    return wrap(wks(name));
	  }
	}
	
	$export($export.G + $export.W + $export.F * !USE_NATIVE, {Symbol: $Symbol});
	
	for(var symbols = (
	  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
	  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'
	).split(','), i = 0; symbols.length > i; )wks(symbols[i++]);
	
	for(var symbols = $keys(wks.store), i = 0; symbols.length > i; )wksDefine(symbols[i++]);
	
	$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
	  // 19.4.2.1 Symbol.for(key)
	  'for': function(key){
	    return has(SymbolRegistry, key += '')
	      ? SymbolRegistry[key]
	      : SymbolRegistry[key] = $Symbol(key);
	  },
	  // 19.4.2.5 Symbol.keyFor(sym)
	  keyFor: function keyFor(key){
	    if(isSymbol(key))return keyOf(SymbolRegistry, key);
	    throw TypeError(key + ' is not a symbol!');
	  },
	  useSetter: function(){ setter = true; },
	  useSimple: function(){ setter = false; }
	});
	
	$export($export.S + $export.F * !USE_NATIVE, 'Object', {
	  // 19.1.2.2 Object.create(O [, Properties])
	  create: $create,
	  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
	  defineProperty: $defineProperty,
	  // 19.1.2.3 Object.defineProperties(O, Properties)
	  defineProperties: $defineProperties,
	  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
	  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
	  // 19.1.2.7 Object.getOwnPropertyNames(O)
	  getOwnPropertyNames: $getOwnPropertyNames,
	  // 19.1.2.8 Object.getOwnPropertySymbols(O)
	  getOwnPropertySymbols: $getOwnPropertySymbols
	});
	
	// 24.3.2 JSON.stringify(value [, replacer [, space]])
	$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function(){
	  var S = $Symbol();
	  // MS Edge converts symbol values to JSON as {}
	  // WebKit converts symbol values to JSON as null
	  // V8 throws on boxed symbols
	  return _stringify([S]) != '[null]' || _stringify({a: S}) != '{}' || _stringify(Object(S)) != '{}';
	})), 'JSON', {
	  stringify: function stringify(it){
	    if(it === undefined || isSymbol(it))return; // IE8 returns string on undefined
	    var args = [it]
	      , i    = 1
	      , replacer, $replacer;
	    while(arguments.length > i)args.push(arguments[i++]);
	    replacer = args[1];
	    if(typeof replacer == 'function')$replacer = replacer;
	    if($replacer || !isArray(replacer))replacer = function(key, value){
	      if($replacer)value = $replacer.call(this, key, value);
	      if(!isSymbol(value))return value;
	    };
	    args[1] = replacer;
	    return _stringify.apply($JSON, args);
	  }
	});
	
	// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)
	$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(18)($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
	// 19.4.3.5 Symbol.prototype[@@toStringTag]
	setToStringTag($Symbol, 'Symbol');
	// 20.2.1.9 Math[@@toStringTag]
	setToStringTag(Math, 'Math', true);
	// 24.3.3 JSON[@@toStringTag]
	setToStringTag(global.JSON, 'JSON', true);

/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	var META     = __webpack_require__(12)('meta')
	  , isObject = __webpack_require__(21)
	  , has      = __webpack_require__(8)
	  , setDesc  = __webpack_require__(19).f
	  , id       = 0;
	var isExtensible = Object.isExtensible || function(){
	  return true;
	};
	var FREEZE = !__webpack_require__(24)(function(){
	  return isExtensible(Object.preventExtensions({}));
	});
	var setMeta = function(it){
	  setDesc(it, META, {value: {
	    i: 'O' + ++id, // object ID
	    w: {}          // weak collections IDs
	  }});
	};
	var fastKey = function(it, create){
	  // return primitive with prefix
	  if(!isObject(it))return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return 'F';
	    // not necessary to add metadata
	    if(!create)return 'E';
	    // add missing metadata
	    setMeta(it);
	  // return object ID
	  } return it[META].i;
	};
	var getWeak = function(it, create){
	  if(!has(it, META)){
	    // can't set metadata to uncaught frozen object
	    if(!isExtensible(it))return true;
	    // not necessary to add metadata
	    if(!create)return false;
	    // add missing metadata
	    setMeta(it);
	  // return hash weak collections IDs
	  } return it[META].w;
	};
	// add metadata on freeze-family methods calling
	var onFreeze = function(it){
	  if(FREEZE && meta.NEED && isExtensible(it) && !has(it, META))setMeta(it);
	  return it;
	};
	var meta = module.exports = {
	  KEY:      META,
	  NEED:     false,
	  fastKey:  fastKey,
	  getWeak:  getWeak,
	  onFreeze: onFreeze
	};

/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	var global         = __webpack_require__(11)
	  , core           = __webpack_require__(15)
	  , LIBRARY        = __webpack_require__(39)
	  , wksExt         = __webpack_require__(252)
	  , defineProperty = __webpack_require__(19).f;
	module.exports = function(name){
	  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
	  if(name.charAt(0) != '_' && !(name in $Symbol))defineProperty($Symbol, name, {value: wksExt.f(name)});
	};

/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	var getKeys   = __webpack_require__(44)
	  , toIObject = __webpack_require__(35);
	module.exports = function(object, el){
	  var O      = toIObject(object)
	    , keys   = getKeys(O)
	    , length = keys.length
	    , index  = 0
	    , key;
	  while(length > index)if(O[key = keys[index++]] === el)return key;
	};

/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	// all enumerable object keys, includes symbols
	var getKeys = __webpack_require__(44)
	  , gOPS    = __webpack_require__(260)
	  , pIE     = __webpack_require__(261);
	module.exports = function(it){
	  var result     = getKeys(it)
	    , getSymbols = gOPS.f;
	  if(getSymbols){
	    var symbols = getSymbols(it)
	      , isEnum  = pIE.f
	      , i       = 0
	      , key;
	    while(symbols.length > i)if(isEnum.call(it, key = symbols[i++]))result.push(key);
	  } return result;
	};

/***/ },
/* 260 */
/***/ function(module, exports) {

	exports.f = Object.getOwnPropertySymbols;

/***/ },
/* 261 */
/***/ function(module, exports) {

	exports.f = {}.propertyIsEnumerable;

/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	// 7.2.2 IsArray(argument)
	var cof = __webpack_require__(37);
	module.exports = Array.isArray || function isArray(arg){
	  return cof(arg) == 'Array';
	};

/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
	var toIObject = __webpack_require__(35)
	  , gOPN      = __webpack_require__(264).f
	  , toString  = {}.toString;
	
	var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
	  ? Object.getOwnPropertyNames(window) : [];
	
	var getWindowNames = function(it){
	  try {
	    return gOPN(it);
	  } catch(e){
	    return windowNames.slice();
	  }
	};
	
	module.exports.f = function getOwnPropertyNames(it){
	  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
	};


/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
	var $keys      = __webpack_require__(45)
	  , hiddenKeys = __webpack_require__(50).concat('length', 'prototype');
	
	exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O){
	  return $keys(O, hiddenKeys);
	};

/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	var pIE            = __webpack_require__(261)
	  , createDesc     = __webpack_require__(27)
	  , toIObject      = __webpack_require__(35)
	  , toPrimitive    = __webpack_require__(26)
	  , has            = __webpack_require__(8)
	  , IE8_DOM_DEFINE = __webpack_require__(22)
	  , gOPD           = Object.getOwnPropertyDescriptor;
	
	exports.f = __webpack_require__(23) ? gOPD : function getOwnPropertyDescriptor(O, P){
	  O = toIObject(O);
	  P = toPrimitive(P, true);
	  if(IE8_DOM_DEFINE)try {
	    return gOPD(O, P);
	  } catch(e){ /* empty */ }
	  if(has(O, P))return createDesc(!pIE.f.call(O, P), O[P]);
	};

/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(257)('asyncIterator');

/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(257)('observable');

/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _setPrototypeOf = __webpack_require__(269);
	
	var _setPrototypeOf2 = _interopRequireDefault(_setPrototypeOf);
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _typeof2 = __webpack_require__(249);
	
	var _typeof3 = _interopRequireDefault(_typeof2);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (subClass, superClass) {
	  if (typeof superClass !== "function" && superClass !== null) {
	    throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === "undefined" ? "undefined" : (0, _typeof3.default)(superClass)));
	  }
	
	  subClass.prototype = (0, _create2.default)(superClass && superClass.prototype, {
	    constructor: {
	      value: subClass,
	      enumerable: false,
	      writable: true,
	      configurable: true
	    }
	  });
	  if (superClass) _setPrototypeOf2.default ? (0, _setPrototypeOf2.default)(subClass, superClass) : subClass.__proto__ = superClass;
	};

/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(270), __esModule: true };

/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(271);
	module.exports = __webpack_require__(15).Object.setPrototypeOf;

/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.3.19 Object.setPrototypeOf(O, proto)
	var $export = __webpack_require__(14);
	$export($export.S, 'Object', {setPrototypeOf: __webpack_require__(272).set});

/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	// Works with __proto__ only. Old v8 can't work with null proto objects.
	/* eslint-disable no-proto */
	var isObject = __webpack_require__(21)
	  , anObject = __webpack_require__(20);
	var check = function(O, proto){
	  anObject(O);
	  if(!isObject(proto) && proto !== null)throw TypeError(proto + ": can't set as prototype!");
	};
	module.exports = {
	  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
	    function(test, buggy, set){
	      try {
	        set = __webpack_require__(16)(Function.call, __webpack_require__(265).f(Object.prototype, '__proto__').set, 2);
	        set(test, []);
	        buggy = !(test instanceof Array);
	      } catch(e){ buggy = true; }
	      return function setPrototypeOf(O, proto){
	        check(O, proto);
	        if(buggy)O.__proto__ = proto;
	        else set(O, proto);
	        return O;
	      };
	    }({}, false) : undefined),
	  check: check
	};

/***/ },
/* 273 */
/***/ function(module, exports) {

	"use strict";
	
	exports.__esModule = true;
	
	exports.default = function (instance, Constructor) {
	  if (!(instance instanceof Constructor)) {
	    throw new TypeError("Cannot call a class as a function");
	  }
	};

/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _defineProperty = __webpack_require__(275);
	
	var _defineProperty2 = _interopRequireDefault(_defineProperty);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function () {
	  function defineProperties(target, props) {
	    for (var i = 0; i < props.length; i++) {
	      var descriptor = props[i];
	      descriptor.enumerable = descriptor.enumerable || false;
	      descriptor.configurable = true;
	      if ("value" in descriptor) descriptor.writable = true;
	      (0, _defineProperty2.default)(target, descriptor.key, descriptor);
	    }
	  }
	
	  return function (Constructor, protoProps, staticProps) {
	    if (protoProps) defineProperties(Constructor.prototype, protoProps);
	    if (staticProps) defineProperties(Constructor, staticProps);
	    return Constructor;
	  };
	}();

/***/ },
/* 275 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(276), __esModule: true };

/***/ },
/* 276 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(277);
	var $Object = __webpack_require__(15).Object;
	module.exports = function defineProperty(it, key, desc){
	  return $Object.defineProperty(it, key, desc);
	};

/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	var $export = __webpack_require__(14);
	// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)
	$export($export.S + $export.F * !__webpack_require__(23), 'Object', {defineProperty: __webpack_require__(19).f});

/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Node = __webpack_require__(279);
	
	var _Node2 = _interopRequireDefault(_Node);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: Camera
	 * Description: La camera scene, interface avec la camera du 3DEngine.
	 */
	
	/* global Float64Array*/
	
	function Camera(width, height, debug) {
	    // Constructor
	
	    _Node2.default.call(this);
	
	    this.ratio = width / height;
	    this.FOV = 30;
	
	    this.camera3D = new THREE.PerspectiveCamera(this.FOV, this.ratio);
	
	    // /!\ WARNING Matrix JS are in Float32Array
	    this.camera3D.matrixWorld.elements = new Float64Array(16);
	
	    this.camera3D.matrixAutoUpdate = false;
	    this.camera3D.rotationAutoUpdate = false;
	
	    this.direction = new THREE.Vector3();
	    this.frustum = new THREE.Frustum();
	    this.viewMatrix = new THREE.Matrix4();
	    this.width = width;
	    this.height = height;
	
	    this.updatePreSSE();
	
	    this.cameraHelper = debug ? new THREE.CameraHelper(this.camera3D) : undefined;
	}
	
	Camera.prototype = (0, _create2.default)(_Node2.default.prototype);
	
	Camera.prototype.constructor = Camera;
	
	/**
	 */
	Camera.prototype.position = function position() {
	    return this.camera3D.position;
	};
	
	Camera.prototype.camHelper = function camHelper() {
	    return this.cameraHelper;
	};
	
	Camera.prototype.updatePreSSE = function updatePreSSE() {
	    this.Hypotenuse = Math.sqrt(this.width * this.width + this.height * this.height);
	    var radAngle = this.FOV * Math.PI / 180;
	
	    this.HFOV = 2.0 * Math.atan(Math.tan(radAngle * 0.5) / this.ratio); // TODO: not correct -> see new preSSE
	    this.HYFOV = 2.0 * Math.atan(Math.tan(radAngle * 0.5) * this.Hypotenuse / this.width);
	    this.preSSE = this.Hypotenuse * (2.0 * Math.tan(this.HYFOV * 0.5));
	
	    /* TODO: New preSSE but problem on Windows
	    var d = this.height / (2*Math.tan(radAngle/2));
	     //TODO: Verify with arrow helper
	    this.HFOV = 2*Math.atan((this.width/2)/d);
	    this.HYFOV = 2*Math.atan((this.Hypotenuse/2)/d);
	     this.preSSE = this.Hypotenuse * (2.0 * Math.tan(this.HYFOV * 0.5));
	    */
	};
	
	Camera.prototype.createCamHelper = function createCamHelper() {
	    this.cameraHelper = new THREE.CameraHelper(this.camera3D);
	
	    var dir = new THREE.Vector3(0, 0, -1);
	    var quaternion = new THREE.Quaternion();
	
	    quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.HFOV / 2);
	    dir.applyQuaternion(quaternion);
	    var origin = new THREE.Vector3();
	    var length = 100000000;
	    var hex = 0xffff00;
	
	    this.arrowHelper = new THREE.ArrowHelper(dir, origin, length, hex);
	    this.cameraHelper.add(this.arrowHelper);
	};
	
	Camera.prototype.matrixWorldInverse = function matrixWorldInverse() {
	    return this.camera3D.matrixWorldInverse;
	};
	
	Camera.prototype.resize = function resize(width, height) {
	    this.width = width;
	    this.height = height;
	    this.ratio = width / height;
	
	    this.updatePreSSE();
	
	    this.camera3D.aspect = this.ratio;
	    this.camera3D.updateProjectionMatrix();
	
	    if (this.cameraHelper) {
	        var dir = new THREE.Vector3(0, 0, -1);
	        var quaternion = new THREE.Quaternion();
	        quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), this.HFOV / 2);
	        dir.applyQuaternion(quaternion);
	
	        this.arrowHelper.setDirection(dir);
	        this.cameraHelper.update();
	    }
	};
	
	Camera.prototype.computeNodeSSE = function computeNodeSSE(node) {
	    var boundingSphere = node.geometry.boundingSphere;
	    var distance = Math.max(0.0, this.camera3D.position.distanceTo(node.centerSphere) - boundingSphere.radius);
	
	    // Removed because is false computation, it doesn't consider the altitude of node
	    // Added small oblique weight (distance is not enough, tile orientation is needed)
	    /*
	    var altiW = node.bbox.top() === 10000 ? 0. : node.bbox.bottom() / 10000.;
	    var dotProductW = Math.min(altiW + Math.abs(this.camera3D.getWorldDirection().dot(node.centerSphere.clone().normalize())), 1.);
	    if (this.camera3D.position.length() > 6463300) dotProductW = 1;
	    var SSE = Math.sqrt(dotProductW) * this.preSSE * (node.geometricError / distance);
	    */
	
	    // TODO: node.geometricError is computed using a hardcoded 18 level
	    // The computation of node.geometricError is surely false
	    var SSE = this.preSSE * (node.geometricError / distance);
	
	    return SSE;
	};
	
	Camera.prototype.update = function update() {
	    var vector = new THREE.Vector3(0, 0, 1);
	
	    this.direction = vector.applyQuaternion(this.camera3D.quaternion);
	
	    this.updateMatrixWorld();
	    this.viewMatrix.multiplyMatrices(this.camera3D.projectionMatrix, this.camera3D.matrixWorldInverse);
	    this.frustum.setFromMatrix(this.viewMatrix);
	};
	
	Camera.prototype.updateMatrixWorld = function updateMatrixWorld() {
	    this.camera3D.updateMatrix();
	    this.camera3D.updateMatrixWorld(true);
	    this.camera3D.matrixWorldInverse.getInverse(this.camera3D.matrixWorld);
	};
	
	Camera.prototype.getDistanceFromOrigin = function getDistanceFromOrigin() {
	    return this.camera3D.position.length();
	};
	
	Camera.prototype.setPosition = function setPosition(position) {
	    this.camera3D.position.copy(position);
	};
	
	Camera.prototype.setRotation = function setRotation(rotation) {
	    this.camera3D.quaternion.copy(rotation);
	};
	
	Camera.prototype.getFrustum = function getFrustum() {
	    this.updateMatrixWorld();
	    this.frustum.setFromMatrix(new THREE.Matrix4().multiplyMatrices(this.camera3D.projectionMatrix, this.camera3D.matrixWorldInverse));
	
	    return this.frustum;
	};
	
	Camera.prototype.getFrustumLocalSpace = function getFrustumLocalSpace(position, quaternion) {
	    var m = new THREE.Matrix4();
	
	    m.makeRotationFromQuaternion(quaternion.inverse());
	    m.setPosition(position.negate().applyQuaternion(quaternion));
	
	    var f = new THREE.Frustum();
	    f.setFromMatrix(m.premultiply(this.camera3D.projectionMatrix));
	    return f;
	};
	
	exports.default = Camera;

/***/ },
/* 279 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/**
	 * Generated On: 2015-10-5
	 * Class: Node
	 * Description: Tous élément de la scène hérite de Node.
	 * Cette class permet de construire une structure de Node avec les membres parent et enfants.
	 */
	
	function Node() {
	    // Constructor
	
	    this.parent = null;
	    this.children = [];
	    this.bbox = null;
	    this.url = null;
	    this.link = null;
	    this.id = null;
	    this.level = 0;
	    this.screenSpaceError = 0.0;
	    this.loaded = false;
	    // TODO: remove pendingSubdivision and use layerUpdateState instead
	    this.pendingSubdivision = false;
	    this.layerUpdateState = {};
	    this.visible = true;
	    this.layer = null;
	}
	
	Node.prototype.setVisibility = function setVisibility(show) {
	    this.visible = show;
	};
	
	Node.prototype.setDisplayed = function setDisplayed() /* show*/{
	    // The default node has nothing to display
	};
	
	/**
	 * @documentation: Retourne le nombre d'enfants du Node
	 *
	 * @return  {int}
	 */
	Node.prototype.childrenCount = function childrenCount() {
	    return this.children.length;
	};
	
	Node.prototype.noChild = function noChild() {
	    return this.children.length === 0;
	};
	
	Node.prototype.childrenLoaded = function childrenLoaded() {
	    // TODO: '4' is specific to Quadtree
	    var fourChildren = this.children.length == 4;
	
	    if (!fourChildren) {
	        return false;
	    }
	
	    if (this.pendingSubdivision) {
	        // check children status
	        for (var i = 0, max = this.children.length; i < max; i++) {
	            if (this.children[i].loaded === false) {
	                return false;
	            }
	        }
	
	        this.pendingSubdivision = false;
	    }
	
	    return true;
	};
	
	/**
	 * @documentation: Rafraichi le Node si le contenu ou  le style a été modifié.
	 *
	 */
	Node.prototype.update = function update() {
	    // TODO: Implement Me
	
	};
	
	/**
	 *
	 * @param {type} level
	 * @returns {undefined}
	 */
	Node.prototype.getNodeAtLevel = function getNodeAtLevel(level) {
	    if (level === this.level) {
	        return this;
	    }
	
	    var functionToCheck = this.parent.getNodeAtLevel;
	
	    if (!functionToCheck || !(typeof functionToCheck === 'function') && this.parent.level !== level) {
	        return undefined;
	    }
	
	    return this.parent.level === level ? this.parent : this.parent.getNodeAtLevel(level);
	};
	
	/**
	 * @documentation: Méthode qui créer un memento de l'état de Node avant modification.
	 *param
	 * @return  {[object Object]}
	 */
	Node.prototype.hydrate = function hydrate() {
	    // TODO: Implement Me
	
	};
	
	/**
	 * @documentation: Cette méthode modifie l'état du node en fonction d'un memento.
	 *
	 * @param mem {[object Object]}
	 */
	Node.prototype.dehydrate = function dehydrate() /* mem*/{
	    // TODO: Implement Me
	
	};
	
	/**
	 * @documentation: Ajoute un enfant au Node.
	 *
	 * @param child {[object Object]}
	 */
	Node.prototype.add = function add(child) {
	    // TODO: Implement Me
	    this.children.push(child);
	    child.parent = this;
	
	    child.layer = this;
	};
	
	/**
	 * @documentation: Retire un enfant au node.
	 *
	 * @param child {[object Object]}
	 */
	Node.prototype.remove = function remove() /* child*/{
	    // TODO: Implement Me
	
	};
	
	/**
	 * @documentation: Cette Méthode permet étendre un objet enfant des fonctions prototypes de Node.
	 *
	 * @param childClass {Object}
	 */
	
	Node.extend = function extend(childClass) {
	    var membersToIgnore = ['add', 'remove', 'setVisibility', 'setDisplayed'];
	    for (var p in Node.prototype) {
	        if (Object.prototype.hasOwnProperty.call(Node.prototype, p) && !membersToIgnore.includes(p)) {
	            childClass.prototype[p] = Node.prototype[p];
	        }
	    }
	};
	
	exports.default = Node;
	
	// module.exports = {Node:Node};

/***/ },
/* 280 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.LIGHTING_POSITION = undefined;
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _NodeMesh = __webpack_require__(281);
	
	var _NodeMesh2 = _interopRequireDefault(_NodeMesh);
	
	var _SkyShader = __webpack_require__(282);
	
	var _SkyShader2 = _interopRequireDefault(_SkyShader);
	
	var _skyFS = __webpack_require__(283);
	
	var _skyFS2 = _interopRequireDefault(_skyFS);
	
	var _skyVS = __webpack_require__(284);
	
	var _skyVS2 = _interopRequireDefault(_skyVS);
	
	var _groundFS = __webpack_require__(285);
	
	var _groundFS2 = _interopRequireDefault(_groundFS);
	
	var _groundVS = __webpack_require__(286);
	
	var _groundVS2 = _interopRequireDefault(_groundVS);
	
	var _GlowFS = __webpack_require__(287);
	
	var _GlowFS2 = _interopRequireDefault(_GlowFS);
	
	var _GlowVS = __webpack_require__(288);
	
	var _GlowVS2 = _interopRequireDefault(_GlowVS);
	
	var _Coordinates = __webpack_require__(289);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */
	
	var LIGHTING_POSITION = exports.LIGHTING_POSITION = new THREE.Vector3(1, 0, 0);
	
	function Atmosphere() {
	    _NodeMesh2.default.call(this);
	
	    this.realistic = false;
	    this.sphereSun = null;
	
	    this.uniformsOut = {
	        atmoIN: {
	            type: 'i',
	            value: 0
	        },
	        screenSize: {
	            type: 'v2',
	            value: new THREE.Vector2(window.innerWidth, window.innerHeight)
	        } };
	
	    var material = new THREE.ShaderMaterial({
	
	        uniforms: this.uniformsOut,
	        vertexShader: _GlowVS2.default,
	        fragmentShader: _GlowFS2.default,
	        side: THREE.BackSide,
	        blending: THREE.AdditiveBlending,
	        transparent: true,
	        wireframe: false
	
	    });
	
	    var size = (0, _Coordinates.ellipsoidSizes)();
	    var geometry = new THREE.SphereGeometry(1.14, 128, 128).scale(size.x, size.y, size.z);
	
	    this.geometry = geometry;
	    this.material = material;
	
	    this.uniformsIn = {
	        atmoIN: {
	            type: 'i',
	            value: 1
	        },
	        screenSize: {
	            type: 'v2',
	            value: new THREE.Vector2(window.innerWidth, window.innerHeight)
	        } };
	
	    var materialAtmoIn = new THREE.ShaderMaterial({
	
	        uniforms: this.uniformsIn,
	        vertexShader: _GlowVS2.default,
	        fragmentShader: _GlowFS2.default,
	        side: THREE.FrontSide,
	        blending: THREE.AdditiveBlending,
	        transparent: true
	
	    });
	
	    this.atmosphereIN = new THREE.Mesh(new THREE.SphereGeometry(1.002, 64, 64).scale(size.x, size.y, size.z), materialAtmoIn);
	
	    this.add(this.atmosphereIN);
	
	    var atmosphere = {
	        Kr: 0.0025,
	        Km: 0.0010,
	        ESun: 20.0,
	        g: -0.950,
	        innerRadius: 6400000,
	        outerRadius: 6700000,
	        wavelength: [0.650, 0.570, 0.475],
	        scaleDepth: 0.25,
	        mieScaleDepth: 0.1
	    };
	
	    var uniformsSky = {
	        v3LightPosition: { value: LIGHTING_POSITION.clone().normalize() },
	        v3InvWavelength: { value: new THREE.Vector3(1 / Math.pow(atmosphere.wavelength[0], 4), 1 / Math.pow(atmosphere.wavelength[1], 4), 1 / Math.pow(atmosphere.wavelength[2], 4)) },
	        fCameraHeight: { value: 0.0 },
	        fCameraHeight2: { value: 0.0 },
	        fInnerRadius: { value: atmosphere.innerRadius },
	        fInnerRadius2: { value: atmosphere.innerRadius * atmosphere.innerRadius },
	        fOuterRadius: { value: atmosphere.outerRadius },
	        fOuterRadius2: { value: atmosphere.outerRadius * atmosphere.outerRadius },
	        fKrESun: { value: atmosphere.Kr * atmosphere.ESun },
	        fKmESun: { value: atmosphere.Km * atmosphere.ESun },
	        fKr4PI: { value: atmosphere.Kr * 4.0 * Math.PI },
	        fKm4PI: { value: atmosphere.Km * 4.0 * Math.PI },
	        fScale: { value: 1 / (atmosphere.outerRadius - atmosphere.innerRadius) },
	        fScaleDepth: { value: atmosphere.scaleDepth },
	        fScaleOverScaleDepth: { value: 1 / (atmosphere.outerRadius - atmosphere.innerRadius) / atmosphere.scaleDepth },
	        g: { value: atmosphere.g },
	        g2: { value: atmosphere.g * atmosphere.g },
	        nSamples: { value: 3 },
	        fSamples: { value: 3.0 },
	        tDisplacement: { value: new THREE.Texture() },
	        tSkyboxDiffuse: { value: new THREE.Texture() },
	        fNightScale: { value: 1.0 }
	    };
	
	    this.ground = {
	        geometry: new THREE.SphereGeometry(atmosphere.innerRadius, 50, 50),
	        material: new THREE.ShaderMaterial({
	            uniforms: uniformsSky,
	            vertexShader: _groundVS2.default,
	            fragmentShader: _groundFS2.default,
	            blending: THREE.AdditiveBlending,
	            transparent: true,
	            depthTest: false,
	            depthWrite: false
	        })
	    };
	
	    this.ground.mesh = new THREE.Mesh(this.ground.geometry, this.ground.material);
	
	    this.sky = {
	        geometry: new THREE.SphereGeometry(atmosphere.outerRadius, 196, 196),
	        material: new THREE.ShaderMaterial({
	            uniforms: uniformsSky,
	            vertexShader: _skyVS2.default,
	            fragmentShader: _skyFS2.default
	        })
	    };
	
	    this.sky.mesh = new THREE.Mesh(this.sky.geometry, this.sky.material);
	    this.sky.material.side = THREE.BackSide;
	    this.sky.material.transparent = true;
	
	    this.ground.mesh.visible = false;
	    this.sky.mesh.visible = false;
	    this.add(this.ground.mesh);
	    this.add(this.sky.mesh);
	
	    this.skyDome = new _SkyShader2.default();
	    this.skyDome.mesh.frustumCulled = false;
	    this.skyDome.mesh.material.transparent = true;
	    this.skyDome.mesh.visible = false;
	    this.skyDome.mesh.material.depthWrite = false;
	    this.add(this.skyDome.mesh);
	
	    var effectController = {
	        turbidity: 10,
	        reileigh: 2,
	        mieCoefficient: 0.005,
	        mieDirectionalG: 0.8,
	        luminance: 1,
	        inclination: 0.49, // elevation / inclination
	        azimuth: 0.25, // Facing front,
	        sun: !true
	    };
	
	    var uniforms = this.skyDome.uniforms;
	    uniforms.turbidity.value = effectController.turbidity;
	    uniforms.reileigh.value = effectController.reileigh;
	    uniforms.luminance.value = effectController.luminance;
	    uniforms.mieCoefficient.value = effectController.mieCoefficient;
	    uniforms.mieDirectionalG.value = effectController.mieDirectionalG;
	    uniforms.up.value = new THREE.Vector3(); // no more necessary, estimate normal from cam..
	}
	
	Atmosphere.prototype = (0, _create2.default)(_NodeMesh2.default.prototype);
	Atmosphere.prototype.constructor = Atmosphere;
	
	Atmosphere.prototype.setRealisticOn = function setRealisticOn(bool) {
	    this.realistic = bool;
	    this.material.visible = !this.realistic;
	    this.atmosphereIN.visible = !this.realistic;
	    this.ground.mesh.visible = this.realistic;
	    this.sky.mesh.visible = this.realistic;
	    this.skyDome.mesh.visible = this.realistic;
	    // this.lensFlare.visible = this.realistic;
	
	    // this.sphereSun.visible     = this.realistic;
	};
	
	Atmosphere.prototype.updateLightingPos = function updateLightingPos(pos) {
	    this.ground.material.uniforms.v3LightPosition.value = pos.clone().normalize();
	    this.sky.material.uniforms.v3LightPosition.value = pos.clone().normalize();
	    //  this.sphereSun.position.copy(pos);
	    this.skyDome.uniforms.sunPosition.value.copy(pos);
	    // this.lensFlare.position.copy(pos);
	};
	
	exports.default = Atmosphere;

/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Node = __webpack_require__(279);
	
	var _Node2 = _interopRequireDefault(_Node);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: NodeMesh
	 * Description: Node + THREE.Mesh. Combine les paramètres d'un Node. NodeMesh peut etre ajouté à la THREE.Scene.
	 */
	
	var NodeMesh = function NodeMesh() {
	    // Constructor
	
	    _Node2.default.call(this);
	    THREE.Mesh.call(this);
	
	    this.sse = 0.0;
	    this.pendingSubdivision = false;
	    this.helper = undefined;
	};
	
	NodeMesh.prototype = (0, _create2.default)(THREE.Mesh.prototype);
	
	NodeMesh.prototype.constructor = NodeMesh;
	
	NodeMesh.prototype.enableRTC = function enableRTC() {};
	
	NodeMesh.prototype.showHelper = function showHelper(show) {
	    if (this.helper !== undefined) {
	        this.helper.visible = show;
	    }
	};
	
	NodeMesh.prototype.isVisible = function isVisible() {
	    return this.visible;
	};
	
	NodeMesh.prototype.setVisibility = function setVisibility(show) {
	    this.visible = show;
	    this.showHelper(show);
	};
	
	NodeMesh.prototype.setDisplayed = function setDisplayed(show) {
	    this.material.visible = show;
	    if (this.helper !== undefined) {
	        this.helper.setMaterialVisibility(show);
	    }
	
	    if (this.content !== null && show) {
	        this.content.visible = true;
	    }
	};
	
	NodeMesh.prototype.isDisplayed = function isDisplayed() {
	    return this.material.visible;
	};
	
	_Node2.default.extend(NodeMesh);
	
	exports.default = NodeMesh;

/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var skyShader = {
	
	    uniforms: {
	
	        luminance: {
	            type: 'f',
	            value: 1
	        },
	        turbidity: {
	            type: 'f',
	            value: 2
	        },
	        reileigh: {
	            type: 'f',
	            value: 1
	        },
	        mieCoefficient: {
	            type: 'f',
	            value: 0.005
	        },
	        mieDirectionalG: {
	            type: 'f',
	            value: 0.8
	        },
	        sunPosition: {
	            type: 'v3',
	            value: new THREE.Vector3()
	        },
	        up: {
	            type: 'v3',
	            value: new THREE.Vector3(0.0, 1.0, 0.0)
	        }
	
	    },
	
	    vertexShader: ['varying vec3 vWorldPosition;', 'void main() {', 'vec4 worldPosition = modelMatrix *  vec4( cameraPosition + position, 1.0 );', 'vWorldPosition = worldPosition.xyz;', 'gl_Position = projectionMatrix * modelViewMatrix * vec4( cameraPosition + position, 1.0 );', '}'].join('\n'),
	
	    fragmentShader: ['uniform sampler2D skySampler;', 'uniform vec3 sunPosition;', 'uniform vec3 up;', 'varying vec3 vWorldPosition;',
	
	    // "vec3 cameraPos = cameraPosition; //vec3(0., 0., 0.);",
	    '// uniform sampler2D sDiffuse;', '// const float turbidity = 10.0; //', '// const float reileigh = 2.; //', '// const float luminance = 1.0; //', '// const float mieCoefficient = 0.005;', '// const float mieDirectionalG = 0.8;', 'uniform float luminance;', 'uniform float turbidity;', 'uniform float reileigh;', 'uniform float mieCoefficient;', 'uniform float mieDirectionalG;', '// constants for atmospheric scattering', 'const float e = 2.71828182845904523536028747135266249775724709369995957;', 'const float pi = 3.141592653589793238462643383279502884197169;', 'const float n = 1.0003; // refractive index of air', 'const float N = 2.545E25; // number of molecules per unit volume for air at', '// 288.15K and 1013mb (sea level -45 celsius)', 'const float pn = 0.035; // depolatization factor for standard air', '// wavelength of used primaries, according to preetham', 'const vec3 lambda = vec3(680E-9, 550E-9, 450E-9);', '// mie stuff', '// K coefficient for the primaries', 'const vec3 K = vec3(0.686, 0.678, 0.666);', 'const float v = 4.0;', '// optical length at zenith for molecules', 'const float rayleighZenithLength = 8.4E3;', 'const float mieZenithLength = 1.25E3;',
	    // "const vec3 up = vec3(0.0, 1.0, 0.0);",
	
	
	    'const float EE = 1000.0;', 'const float sunAngularDiameterCos = 0.999956676946448443553574619906976478926848692873900859324;', '// 66 arc seconds -> degrees, and the cosine of that', '// earth shadow hack', 'const float cutoffAngle = pi/1.95;', 'const float steepness = 1.5;', 'vec3 totalRayleigh(vec3 lambda)', '{', 'return (8.0 * pow(pi, 3.0) * pow(pow(n, 2.0) - 1.0, 2.0) * (6.0 + 3.0 * pn)) / (3.0 * N * pow(lambda, vec3(4.0)) * (6.0 - 7.0 * pn));', '}',
	
	    // see http://blenderartists.org/forum/showthread.php?321110-Shaders-and-Skybox-madness
	    '// A simplied version of the total Reayleigh scattering to works on browsers that use ANGLE', 'vec3 simplifiedRayleigh()', '{', 'return 0.0005 / vec3(94, 40, 18);',
	    // return 0.00054532832366 / (3.0 * 2.545E25 * pow(vec3(680E-9, 550E-9, 450E-9), vec3(4.0)) * 6.245);
	    '}', 'float rayleighPhase(float cosTheta)', '{ ', 'return (3.0 / (16.0*pi)) * (1.0 + pow(cosTheta, 2.0));', '// return (1.0 / (3.0*pi)) * (1.0 + pow(cosTheta, 2.0));', '// return (3.0 / 4.0) * (1.0 + pow(cosTheta, 2.0));', '}', 'vec3 totalMie(vec3 lambda, vec3 K, float T)', '{', 'float c = (0.2 * T ) * 10E-18;', 'return 0.434 * c * pi * pow((2.0 * pi) / lambda, vec3(v - 2.0)) * K;', '}', 'float hgPhase(float cosTheta, float g)', '{', 'return (1.0 / (4.0*pi)) * ((1.0 - pow(g, 2.0)) / pow(1.0 - 2.0*g*cosTheta + pow(g, 2.0), 1.5));', '}', 'float sunIntensity(float zenithAngleCos)', '{', 'return EE * max(0.0, 1.0 - exp(-((cutoffAngle - acos(zenithAngleCos))/steepness)));', '}', '// float logLuminance(vec3 c)', '// {', '//     return log(c.r * 0.2126 + c.g * 0.7152 + c.b * 0.0722);', '// }', '// Filmic ToneMapping http://filmicgames.com/archives/75', 'float A = 0.15;', 'float B = 0.50;', 'float C = 0.10;', 'float D = 0.20;', 'float E = 0.02;', 'float F = 0.30;', 'float W = 1000.0;', 'vec3 Uncharted2Tonemap(vec3 x)', '{', 'return ((x*(A*x+C*B)+D*E)/(x*(A*x+B)+D*F))-E/F;', '}', 'void main() ', '{', 'vec3 up2 = normalize(cameraPosition.xyz);', 'float sunfade = 1.0-clamp(1.0-exp((sunPosition.y/450000.0)),0.0,1.0);', 'float reileighCoefficient = reileigh - (1.0* (1.0-sunfade));', 'vec3 sunDirection = normalize(sunPosition);', 'float sunE = sunIntensity(dot(sunDirection, up2));', '// extinction (absorbtion + out scattering) ', '// rayleigh coefficients',
	
	    // "vec3 betaR = totalRayleigh(lambda) * reileighCoefficient;",
	    'vec3 betaR = simplifiedRayleigh() * reileighCoefficient;', '// mie coefficients', 'vec3 betaM = totalMie(lambda, K, turbidity) * mieCoefficient;', '// optical length', '// cutoff angle at 90 to avoid singularity in next formula.', 'float zenithAngle = acos(max(0.0, dot(up2, normalize(vWorldPosition - cameraPosition))));', 'float sR = rayleighZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));', 'float sM = mieZenithLength / (cos(zenithAngle) + 0.15 * pow(93.885 - ((zenithAngle * 180.0) / pi), -1.253));', '// combined extinction factor', 'vec3 Fex = exp(-(betaR * sR + betaM * sM));', '// in scattering', 'float cosTheta = dot(normalize(vWorldPosition - cameraPosition), sunDirection);', 'float rPhase = rayleighPhase(cosTheta*0.5+0.5);', 'vec3 betaRTheta = betaR * rPhase;', 'float mPhase = hgPhase(cosTheta, mieDirectionalG);', 'vec3 betaMTheta = betaM * mPhase;', 'vec3 Lin = pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * (1.0 - Fex),vec3(1.5));', 'Lin *= mix(vec3(1.0),pow(sunE * ((betaRTheta + betaMTheta) / (betaR + betaM)) * Fex,vec3(1.0/2.0)),clamp(pow(1.0-dot(up2, sunDirection),5.0),0.0,1.0));', '//nightsky', 'vec3 direction = normalize(vWorldPosition - cameraPosition);', 'float theta = acos(direction.y); // elevation --> y-axis, [-pi/2, pi/2]', 'float phi = atan(direction.z, direction.x); // azimuth --> x-axis [-pi/2, pi/2]', 'vec2 uv = vec2(phi, theta) / vec2(2.0*pi, pi) + vec2(0.5, 0.0);', '// vec3 L0 = texture2D(skySampler, uv).rgb+0.1 * Fex;', 'vec3 L0 = vec3(0.1) * Fex;', '// composition + solar disc', '//if (cosTheta > sunAngularDiameterCos)', 'float sundisk = smoothstep(sunAngularDiameterCos,sunAngularDiameterCos+0.00002,cosTheta);', '// if (normalize(vWorldPosition - cameraPosition).y>0.0)', 'L0 += (sunE * 19000.0 * Fex)*sundisk;', 'vec3 whiteScale = 1.0/Uncharted2Tonemap(vec3(W));', 'vec3 texColor = (Lin+L0);   ', 'texColor *= 0.04 ;', 'texColor += vec3(0.0,0.001,0.0025)*0.3;', 'float g_fMaxLuminance = 1.0;', 'float fLumScaled = 0.1 / luminance;     ', 'float fLumCompressed = (fLumScaled * (1.0 + (fLumScaled / (g_fMaxLuminance * g_fMaxLuminance)))) / (1.0 + fLumScaled); ', 'float ExposureBias = fLumCompressed;', 'vec3 curr = Uncharted2Tonemap((log2(2.0/pow(luminance,4.0)))*texColor);', 'vec3 color = curr*whiteScale;', 'vec3 retColor = pow(color,vec3(1.0/(1.2+(1.2*sunfade))));', 'gl_FragColor.rgb = retColor;', 'gl_FragColor.a = 1. - ( (length(cameraPosition) - 6400000.) / 1000.);', '}'].join('\n')
	
	}; /**
	    * @author zz85 / https://github.com/zz85
	    *
	    * Based on "A Practical Analytic Model for Daylight"
	    * aka The Preetham Model, the de facto standard analytic skydome model
	    * http://www.cs.utah.edu/~shirley/papers/sunsky/sunsky.pdf
	    *
	    * First implemented by Simon Wallner
	    * http://www.simonwallner.at/projects/atmospheric-scattering
	    *
	    * Improved by Martin Upitis
	    * http://blenderartists.org/forum/showthread.php?245954-preethams-sky-impementation-HDR
	    *
	    * Three.js integration by zz85 http://twitter.com/blurspline
	    */
	
	function Sky() {
	    var skyUniforms = THREE.UniformsUtils.clone(skyShader.uniforms);
	
	    var skyMat = new THREE.ShaderMaterial({
	        fragmentShader: skyShader.fragmentShader,
	        vertexShader: skyShader.vertexShader,
	        uniforms: skyUniforms,
	        side: THREE.BackSide
	    });
	
	    var skyGeo = new THREE.SphereBufferGeometry(40000, 32, 15);
	    var skyMesh = new THREE.Mesh(skyGeo, skyMat);
	
	    // Expose variables
	    this.mesh = skyMesh;
	    this.uniforms = skyUniforms;
	}
	// Sky.prototype = Object.create(THREE.EventDispatcher.prototype);
	Sky.prototype.constructor = Sky;
	
	exports.default = Sky;

/***/ },
/* 283 */
/***/ function(module, exports) {

	module.exports = "uniform vec3 v3LightPos;\nuniform float g;\nuniform float g2;\n\nvarying vec3 v3Direction;\nvarying vec3 c0;\nvarying vec3 c1;\n\n// Calculates the Mie phase function\nfloat getMiePhase(float fCos, float fCos2, float g, float g2) {\n    return 1.5 * ((1.0 - g2) / (2.0 + g2)) * (1.0 + fCos2) / pow(1.0 + g2 - 2.0 * g * fCos, 1.5);\n}\n\n// Calculates the Rayleigh phase function\nfloat getRayleighPhase(float fCos2) {\n    return 0.75 + 0.75 * fCos2;\n}\n\nvoid main (void) {\n    float fCos = dot(v3LightPos, v3Direction) / length(v3Direction);\n    float fCos2 = fCos * fCos;\n\n    vec3 color = getRayleighPhase(fCos2) * c0 + getMiePhase(fCos, fCos2, g, g2) * c1;\n\n    gl_FragColor = vec4(color, 1.0);\n    gl_FragColor.a = gl_FragColor.b;\n}"

/***/ },
/* 284 */
/***/ function(module, exports) {

	module.exports = "uniform vec3 v3LightPosition;   // The direction vector to the light source\nuniform vec3 v3InvWavelength;   // 1 / pow(wavelength, 4) for the red, green, and blue channels\nuniform float fCameraHeight;    // The camera's current height\nuniform float fCameraHeight2;   // fCameraHeight^2\nuniform float fOuterRadius;     // The outer (atmosphere) radius\nuniform float fOuterRadius2;    // fOuterRadius^2\nuniform float fInnerRadius;     // The inner (planetary) radius\nuniform float fInnerRadius2;    // fInnerRadius^2\nuniform float fKrESun;          // Kr * ESun\nuniform float fKmESun;          // Km * ESun\nuniform float fKr4PI;           // Kr * 4 * PI\nuniform float fKm4PI;           // Km * 4 * PI\nuniform float fScale;           // 1 / (fOuterRadius - fInnerRadius)\nuniform float fScaleDepth;      // The scale depth (i.e. the altitude at which the atmosphere's average density is found)\nuniform float fScaleOverScaleDepth; // fScale / fScaleDepth\n\nconst int nSamples = 3;\nconst float fSamples = 3.0;\n\nvarying vec3 v3Direction;\nvarying vec3 c0;\nvarying vec3 c1;\n\nfloat scale(float fCos) {\n    float x = 1.0 - fCos;\n    return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nvoid main(void) {\n    float lengthCamera = length(cameraPosition);\n    float cameraHeight2 = lengthCamera * lengthCamera;\n\n    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n    vec3 v3Ray = position - cameraPosition;\n    float fFar = length(v3Ray);\n    v3Ray /= fFar;\n\n    // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n    float B = 2.0 * dot(cameraPosition, v3Ray);\n    float C = cameraHeight2 - fOuterRadius2;\n    float fDet = max(0.0, B*B - 4.0 * C);\n    float fNear = 0.5 * (-B - sqrt(fDet));\n\n    // Calculate the ray's starting position, then calculate its scattering offset\n    vec3 v3Start = cameraPosition + v3Ray * fNear;\n    fFar -= fNear;\n    float fStartAngle = dot(v3Ray, v3Start) / fOuterRadius;\n    float fStartDepth = exp(-1.0 / fScaleDepth);\n    float fStartOffset = fStartDepth * scale(fStartAngle);\n\n    // Initialize the scattering loop variables\n    float fSampleLength = fFar / fSamples;\n    float fScaledLength = fSampleLength * fScale;\n    vec3 v3SampleRay = v3Ray * fSampleLength;\n    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n    // Now loop through the sample rays\n    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n    for(int i=0; i<nSamples; i++)\n    {\n        float fHeight = length(v3SamplePoint);\n        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n        float fLightAngle = dot(v3LightPosition, v3SamplePoint) / fHeight;\n        float fCameraAngle = dot(v3Ray, v3SamplePoint) / fHeight;\n        float fScatter = (fStartOffset + fDepth * (scale(fLightAngle) - scale(fCameraAngle)));\n        vec3 v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n\n        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n        v3SamplePoint += v3SampleRay;\n    }\n\n    // Finally, scale the Mie and Rayleigh colors and set up the varying variables for the pixel shader\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n    c0 = v3FrontColor * (v3InvWavelength * fKrESun);\n    c1 = v3FrontColor * fKmESun;\n    v3Direction = cameraPosition - position;\n}"

/***/ },
/* 285 */
/***/ function(module, exports) {

	module.exports = "varying vec3 c0;\nvarying vec3 c1;\n\nvoid main (void) {\n\tgl_FragColor = vec4(c1, 1.0 - c0/4.);\n}"

/***/ },
/* 286 */
/***/ function(module, exports) {

	module.exports = "uniform vec3 v3LightPosition;   // The direction vector to the light source\nuniform vec3 v3InvWavelength;   // 1 / pow(wavelength, 4) for the red, green, and blue channels\nuniform float fCameraHeight;    // The camera's current height\nuniform float fCameraHeight2;   // fCameraHeight^2\nuniform float fOuterRadius;     // The outer (atmosphere) radius\nuniform float fOuterRadius2;    // fOuterRadius^2\nuniform float fInnerRadius;     // The inner (planetary) radius\nuniform float fInnerRadius2;    // fInnerRadius^2\nuniform float fKrESun;          // Kr * ESun\nuniform float fKmESun;          // Km * ESun\nuniform float fKr4PI;           // Kr * 4 * PI\nuniform float fKm4PI;           // Km * 4 * PI\nuniform float fScale;           // 1 / (fOuterRadius - fInnerRadius)\nuniform float fScaleDepth;      // The scale depth (i.e. the altitude at which the atmosphere's average density is found)\nuniform float fScaleOverScaleDepth; // fScale / fScaleDepth\n\nvarying vec3 c0;\nvarying vec3 c1;\n\nconst int nSamples = 3;\nconst float fSamples = 3.0;\n\nfloat scale(float fCos)\n{\n    float x = 1.0 - fCos;\n    return fScaleDepth * exp(-0.00287 + x*(0.459 + x*(3.83 + x*(-6.80 + x*5.25))));\n}\n\nvoid main(void) {\n\n     float cameraHeight2 = length(cameraPosition) * length(cameraPosition);\n\n    // Get the ray from the camera to the vertex and its length (which is the far point of the ray passing through the atmosphere)\n    vec3 v3Ray = position - cameraPosition;\n    float fFar = length(v3Ray);\n    v3Ray /= fFar;\n\n    // Calculate the closest intersection of the ray with the outer atmosphere (which is the near point of the ray passing through the atmosphere)\n    float B = 2.0 * dot(cameraPosition, v3Ray);\n    float C = cameraHeight2 - fOuterRadius2;\n    float fDet = max(0.0, B*B - 4.0 * C);\n    float fNear = 0.5 * (-B - sqrt(fDet));\n\n    // Calculate the ray's starting position, then calculate its scattering offset\n    vec3 v3Start = cameraPosition + v3Ray * fNear;\n    fFar -= fNear;\n    float fDepth = exp((fInnerRadius - fOuterRadius) / fScaleDepth);\n    float fCameraAngle = dot(-v3Ray, position) / length(position);\n    float fLightAngle = dot(v3LightPosition, position) / length(position);\n    float fCameraScale = scale(fCameraAngle);\n    float fLightScale = scale(fLightAngle);\n    float fCameraOffset = fDepth*fCameraScale;\n    float fTemp = (fLightScale + fCameraScale);\n\n    // Initialize the scattering loop variables\n    float fSampleLength = fFar / fSamples;\n    float fScaledLength = fSampleLength * fScale;\n    vec3 v3SampleRay = v3Ray * fSampleLength;\n    vec3 v3SamplePoint = v3Start + v3SampleRay * 0.5;\n\n    // Now loop through the sample rays\n    vec3 v3FrontColor = vec3(0.0, 0.0, 0.0);\n    vec3 v3Attenuate = vec3(0.0, 0.0, 0.0);\n    for(int i=0; i<nSamples; i++)\n    {\n        float fHeight = length(v3SamplePoint);\n        float fDepth = exp(fScaleOverScaleDepth * (fInnerRadius - fHeight));\n        float fScatter = fDepth*fTemp - fCameraOffset;\n        v3Attenuate = exp(-fScatter * (v3InvWavelength * fKr4PI + fKm4PI));\n        v3FrontColor += v3Attenuate * (fDepth * fScaledLength);\n        v3SamplePoint += v3SampleRay;\n    }\n\n    // Calculate the attenuation factor for the ground\n    c0 = v3Attenuate;\n    c1 = v3FrontColor * (v3InvWavelength * fKrESun + fKmESun);\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}"

/***/ },
/* 287 */
/***/ function(module, exports) {

	module.exports = "#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        //#extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\n\n\nuniform int atmoIN;\nvarying float intensity;\n\nvec4 glowColor = vec4(0.45, 0.74, 1. ,1.0);\n\nvoid main() \n{\n     #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n    #endif\n\n    gl_FragColor = glowColor * intensity;\n\n}\n\n"

/***/ },
/* 288 */
/***/ function(module, exports) {

	module.exports = "\n#ifdef USE_LOGDEPTHBUF\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\n\n#define EPSILON 1e-6\n\n\nuniform int atmoIN;\nvarying float intensity;\nvec3 normalES;\nvec3 normalCAMES;\n\nvoid main() \n{\n    normalES    = normalize( normalMatrix * normal );\n    normalCAMES = normalize( normalMatrix * cameraPosition );\n\n    if(atmoIN == 0)\n        intensity = pow(0.666 - dot(normalES, normalCAMES), 4. ); \n      else\n        intensity = pow( 1.  - dot(normalES, normalCAMES), 0.8 );\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position,  1.0 );\n\n    \n    #ifdef USE_LOGDEPTHBUF\n\n        gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n        #ifdef USE_LOGDEPTHBUF_EXT\n\n            vFragDepth = 1.0 + gl_Position.w;\n\n        #else\n\n            gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n        #endif\n\n    #endif\n    \n}\n\n\n"

/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.C = exports.UNIT = undefined;
	
	var _toConsumableArray2 = __webpack_require__(290);
	
	var _toConsumableArray3 = _interopRequireDefault(_toConsumableArray2);
	
	exports.ellipsoidSizes = ellipsoidSizes;
	exports.crsToUnit = crsToUnit;
	exports.assertCrsIsValid = assertCrsIsValid;
	exports.crsIsGeographic = crsIsGeographic;
	exports.crsIsGeocentric = crsIsGeocentric;
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _proj = __webpack_require__(295);
	
	var _proj2 = _interopRequireDefault(_proj);
	
	var _MathExtended = __webpack_require__(296);
	
	var _MathExtended2 = _interopRequireDefault(_MathExtended);
	
	var _Ellipsoid = __webpack_require__(297);
	
	var _Ellipsoid2 = _interopRequireDefault(_Ellipsoid);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: Coordinates
	 * Description: Coordonnées cartographiques
	 */
	
	function ellipsoidSizes() {
	    return {
	        x: 6378137,
	        y: 6356752.3142451793,
	        z: 6378137
	    };
	}
	
	var ellipsoid = new _Ellipsoid2.default(ellipsoidSizes());
	
	var UNIT = exports.UNIT = {
	    RADIAN: 0,
	    DEGREE: 1,
	    METER: 2
	};
	
	function _unitFromProj4Unit(projunit) {
	    if (projunit === 'degrees') {
	        return UNIT.DEGREE;
	    } else if (projunit === 'm') {
	        return UNIT.METER;
	    } else if (projunit === 'radians') {
	        return UNIT.RADIAN;
	    } else {
	        return undefined;
	    }
	}
	
	function crsToUnit(crs) {
	    switch (crs) {
	        case 'EPSG:4326':
	            return UNIT.DEGREE;
	        case 'EPSG:4978':
	            return UNIT.METER;
	        default:
	            {
	                var p = _proj2.default.defs(crs);
	                if (!p) {
	                    return undefined;
	                }
	                return _unitFromProj4Unit(p.units);
	            }
	    }
	}
	
	function _crsToUnitWithError(crs) {
	    var u = crsToUnit(crs);
	    if (crs === undefined || u === undefined) {
	        throw new Error('Invalid crs paramater value \'' + crs + '\'');
	    }
	    return u;
	}
	
	function assertCrsIsValid(crs) {
	    _crsToUnitWithError(crs);
	}
	
	function crsIsGeographic(crs) {
	    return _crsToUnitWithError(crs) != UNIT.METER;
	}
	
	function crsIsGeocentric(crs) {
	    return _crsToUnitWithError(crs) == UNIT.METER;
	}
	
	function _assertIsGeographic(crs) {
	    if (!crsIsGeographic(crs)) {
	        throw new Error('Can\'t query crs ' + crs + ' long/lat');
	    }
	}
	
	function _assertIsGeocentric(crs) {
	    if (!crsIsGeocentric(crs)) {
	        throw new Error('Can\'t query crs ' + crs + ' x/y/z');
	    }
	}
	
	// Only support explicit conversions
	function _convert(coordsIn, newCrs) {
	    if (newCrs === coordsIn.crs) {
	        var refUnit = crsToUnit(newCrs);
	        if (coordsIn._internalStorageUnit != refUnit) {
	            // custom internal unit
	            if (coordsIn._internalStorageUnit == UNIT.DEGREE && refUnit == UNIT.RADIAN) {
	                return new (Function.prototype.bind.apply(Coordinates, [null].concat([newCrs], (0, _toConsumableArray3.default)(coordsIn._values.map(function (x) {
	                    return _MathExtended2.default.degToRad(x);
	                })))))();
	            } else if (coordsIn._internalStorageUnit == UNIT.RADIAN && refUnit == UNIT.DEGREE) {
	                return new (Function.prototype.bind.apply(Coordinates, [null].concat([newCrs], (0, _toConsumableArray3.default)(coordsIn._values.map(function (x) {
	                    return _MathExtended2.default.radToDeg(x);
	                })))))();
	            }
	        } else {
	            // No need to create a new object as Coordinates objects are mostly
	            // immutable (there's no .setLongitude() method etc)
	            return coordsIn;
	        }
	    } else {
	        if (coordsIn.crs === 'EPSG:4326' && newCrs === 'EPSG:4978') {
	            var cartesian = ellipsoid.cartographicToCartesian(coordsIn);
	            return new Coordinates(newCrs, cartesian.x, cartesian.y, cartesian.z);
	        }
	
	        if (coordsIn.crs in _proj2.default.defs && newCrs in _proj2.default.defs) {
	            var p = (0, _proj2.default)(coordsIn.crs, newCrs, [coordsIn._values[0], coordsIn._values[1]]);
	            return new Coordinates(newCrs, p[0], p[1], coordsIn._values[2]);
	        }
	
	        throw new Error('Cannot convert from crs ' + coordsIn.crs + ' (unit=' + coordsIn._internalStorageUnit + ') to ' + newCrs);
	    }
	}
	
	function _convertValue(unitIn, unitOut, value) {
	    if (unitOut == undefined || unitIn == unitOut) {
	        return value;
	    } else {
	        if (unitIn == UNIT.DEGREE && unitOut == UNIT.RADIAN) {
	            return _MathExtended2.default.degToRad(value);
	        }
	        if (unitIn == UNIT.RADIAN && unitOut == UNIT.DEGREE) {
	            return _MathExtended2.default.radToDeg(value);
	        }
	        throw new Error('Cannot convert from unit ' + unitIn + ' to ' + unitOut);
	    }
	}
	
	/**
	 * Build a Coordinates object, given a crs and a number of coordinates value.
	 * crs parameter can currently only be WGS84
	 */
	function Coordinates(crs) {
	    _crsToUnitWithError(crs);
	    this.crs = crs;
	    this._values = new Float64Array(3);
	
	    for (var _len = arguments.length, coordinates = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
	        coordinates[_key - 1] = arguments[_key];
	    }
	
	    for (var i = 0; i < coordinates.length && i < 3; i++) {
	        this._values[i] = coordinates[i];
	    }
	    for (var _i = coordinates.length; _i < 3; _i++) {
	        this._values[_i] = 0;
	    }
	    this._internalStorageUnit = crsToUnit(crs);
	}
	
	Coordinates.prototype.constructor = Coordinates;
	
	Coordinates.prototype.clone = function clone() {
	    var r = new (Function.prototype.bind.apply(Coordinates, [null].concat([this.crs], (0, _toConsumableArray3.default)(this._values))))();
	    r._internalStorageUnit = this._internalStorageUnit;
	    return r;
	};
	
	Coordinates.prototype.longitude = function longitude(unit) {
	    _assertIsGeographic(this.crs);
	    return _convertValue(this._internalStorageUnit, unit, this._values[0]);
	};
	
	Coordinates.prototype.latitude = function latitude(unit) {
	    _assertIsGeographic(this.crs);
	    return _convertValue(this._internalStorageUnit, unit, this._values[1]);
	};
	
	Coordinates.prototype.altitude = function altitude() {
	    _assertIsGeographic(this.crs);
	    return this._values[2];
	};
	
	Coordinates.prototype.x = function x() {
	    _assertIsGeocentric(this.crs);
	    return this._values[0];
	};
	
	Coordinates.prototype.y = function y() {
	    _assertIsGeocentric(this.crs);
	    return this._values[1];
	};
	
	Coordinates.prototype.z = function z() {
	    _assertIsGeocentric(this.crs);
	    return this._values[2];
	};
	
	Coordinates.prototype.xyz = function xyz() {
	    _assertIsGeocentric(this.crs);
	    var v = new THREE.Vector3();
	    v.fromArray(this._values);
	    return v;
	};
	
	Coordinates.prototype.as = function as(crs) {
	    if (crs === undefined || !crsToUnit(crs)) {
	        throw new Error('Invalid crs paramater value \'' + crs + '\'');
	    }
	    return _convert(this, crs);
	};
	
	var C = exports.C = {
	    EPSG_4326: function EPSG_4326() {
	        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
	            args[_key2] = arguments[_key2];
	        }
	
	        return new (Function.prototype.bind.apply(Coordinates, [null].concat(['EPSG:4326'], args)))();
	    },
	    EPSG_4326_Radians: function EPSG_4326() {
	        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
	            args[_key3] = arguments[_key3];
	        }
	
	        var result = new (Function.prototype.bind.apply(Coordinates, [null].concat(['EPSG:4326'], args)))();
	        result._internalStorageUnit = UNIT.RADIAN;
	        return result;
	    }
	};
	
	exports.default = Coordinates;

/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	exports.__esModule = true;
	
	var _from = __webpack_require__(291);
	
	var _from2 = _interopRequireDefault(_from);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	exports.default = function (arr) {
	  if (Array.isArray(arr)) {
	    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
	      arr2[i] = arr[i];
	    }
	
	    return arr2;
	  } else {
	    return (0, _from2.default)(arr);
	  }
	};

/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(292), __esModule: true };

/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(54);
	__webpack_require__(293);
	module.exports = __webpack_require__(15).Array.from;

/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var ctx            = __webpack_require__(16)
	  , $export        = __webpack_require__(14)
	  , toObject       = __webpack_require__(5)
	  , call           = __webpack_require__(230)
	  , isArrayIter    = __webpack_require__(231)
	  , toLength       = __webpack_require__(47)
	  , createProperty = __webpack_require__(294)
	  , getIterFn      = __webpack_require__(57);
	
	$export($export.S + $export.F * !__webpack_require__(238)(function(iter){ Array.from(iter); }), 'Array', {
	  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
	  from: function from(arrayLike/*, mapfn = undefined, thisArg = undefined*/){
	    var O       = toObject(arrayLike)
	      , C       = typeof this == 'function' ? this : Array
	      , aLen    = arguments.length
	      , mapfn   = aLen > 1 ? arguments[1] : undefined
	      , mapping = mapfn !== undefined
	      , index   = 0
	      , iterFn  = getIterFn(O)
	      , length, result, step, iterator;
	    if(mapping)mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);
	    // if object isn't iterable or it's array with default iterator - use simple case
	    if(iterFn != undefined && !(C == Array && isArrayIter(iterFn))){
	      for(iterator = iterFn.call(O), result = new C; !(step = iterator.next()).done; index++){
	        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
	      }
	    } else {
	      length = toLength(O.length);
	      for(result = new C(length); length > index; index++){
	        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
	      }
	    }
	    result.length = index;
	    return result;
	  }
	});


/***/ },
/* 294 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var $defineProperty = __webpack_require__(19)
	  , createDesc      = __webpack_require__(27);
	
	module.exports = function(object, index, value){
	  if(index in object)$defineProperty.f(object, index, createDesc(0, value));
	  else object[index] = value;
	};

/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	(function (global, factory) {
		 true ? module.exports = factory() :
		typeof define === 'function' && define.amd ? define(factory) :
		(global.proj4 = factory());
	}(this, (function () { 'use strict';
	
		var globals = function(defs) {
		  defs('EPSG:4326', "+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees");
		  defs('EPSG:4269', "+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees");
		  defs('EPSG:3857', "+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs");
	
		  defs.WGS84 = defs['EPSG:4326'];
		  defs['EPSG:3785'] = defs['EPSG:3857']; // maintain backward compat, official code is 3857
		  defs.GOOGLE = defs['EPSG:3857'];
		  defs['EPSG:900913'] = defs['EPSG:3857'];
		  defs['EPSG:102113'] = defs['EPSG:3857'];
		};
	
		var PJD_3PARAM = 1;
		var PJD_7PARAM = 2;
		var PJD_WGS84 = 4; // WGS84 or equivalent
		var PJD_NODATUM = 5; // WGS84 or equivalent
		var SEC_TO_RAD = 4.84813681109535993589914102357e-6;
		var HALF_PI = Math.PI/2;
		// ellipoid pj_set_ell.c
		var SIXTH = 0.1666666666666666667;
		/* 1/6 */
		var RA4 = 0.04722222222222222222;
		/* 17/360 */
		var RA6 = 0.02215608465608465608;
		var EPSLN = (typeof Number.EPSILON === 'undefined') ? 1.0e-10 : Number.EPSILON;
		var D2R = 0.01745329251994329577;
		var R2D = 57.29577951308232088;
		var FORTPI = Math.PI/4;
		var TWO_PI = Math.PI * 2;
		// SPI is slightly greater than Math.PI, so values that exceed the -180..180
		// degree range by a tiny amount don't get wrapped. This prevents points that
		// have drifted from their original location along the 180th meridian (due to
		// floating point error) from changing their sign.
		var SPI = 3.14159265359;
	
		var exports$1 = {};
		exports$1.greenwich = 0.0; //"0dE",
		exports$1.lisbon = -9.131906111111; //"9d07'54.862\"W",
		exports$1.paris = 2.337229166667; //"2d20'14.025\"E",
		exports$1.bogota = -74.080916666667; //"74d04'51.3\"W",
		exports$1.madrid = -3.687938888889; //"3d41'16.58\"W",
		exports$1.rome = 12.452333333333; //"12d27'8.4\"E",
		exports$1.bern = 7.439583333333; //"7d26'22.5\"E",
		exports$1.jakarta = 106.807719444444; //"106d48'27.79\"E",
		exports$1.ferro = -17.666666666667; //"17d40'W",
		exports$1.brussels = 4.367975; //"4d22'4.71\"E",
		exports$1.stockholm = 18.058277777778; //"18d3'29.8\"E",
		exports$1.athens = 23.7163375; //"23d42'58.815\"E",
		exports$1.oslo = 10.722916666667; //"10d43'22.5\"E"
	
		var units = {
		  ft: {to_meter: 0.3048},
		  'us-ft': {to_meter: 1200 / 3937}
		};
	
		var ignoredChar = /[\s_\-\/\(\)]/g;
		function match(obj, key) {
		  if (obj[key]) {
		    return obj[key];
		  }
		  var keys = Object.keys(obj);
		  var lkey = key.toLowerCase().replace(ignoredChar, '');
		  var i = -1;
		  var testkey, processedKey;
		  while (++i < keys.length) {
		    testkey = keys[i];
		    processedKey = testkey.toLowerCase().replace(ignoredChar, '');
		    if (processedKey === lkey) {
		      return obj[testkey];
		    }
		  }
		}
	
		var parseProj = function(defData) {
		  var self = {};
		  var paramObj = defData.split('+').map(function(v) {
		    return v.trim();
		  }).filter(function(a) {
		    return a;
		  }).reduce(function(p, a) {
		    var split = a.split('=');
		    split.push(true);
		    p[split[0].toLowerCase()] = split[1];
		    return p;
		  }, {});
		  var paramName, paramVal, paramOutname;
		  var params = {
		    proj: 'projName',
		    datum: 'datumCode',
		    rf: function(v) {
		      self.rf = parseFloat(v);
		    },
		    lat_0: function(v) {
		      self.lat0 = v * D2R;
		    },
		    lat_1: function(v) {
		      self.lat1 = v * D2R;
		    },
		    lat_2: function(v) {
		      self.lat2 = v * D2R;
		    },
		    lat_ts: function(v) {
		      self.lat_ts = v * D2R;
		    },
		    lon_0: function(v) {
		      self.long0 = v * D2R;
		    },
		    lon_1: function(v) {
		      self.long1 = v * D2R;
		    },
		    lon_2: function(v) {
		      self.long2 = v * D2R;
		    },
		    alpha: function(v) {
		      self.alpha = parseFloat(v) * D2R;
		    },
		    lonc: function(v) {
		      self.longc = v * D2R;
		    },
		    x_0: function(v) {
		      self.x0 = parseFloat(v);
		    },
		    y_0: function(v) {
		      self.y0 = parseFloat(v);
		    },
		    k_0: function(v) {
		      self.k0 = parseFloat(v);
		    },
		    k: function(v) {
		      self.k0 = parseFloat(v);
		    },
		    a: function(v) {
		      self.a = parseFloat(v);
		    },
		    b: function(v) {
		      self.b = parseFloat(v);
		    },
		    r_a: function() {
		      self.R_A = true;
		    },
		    zone: function(v) {
		      self.zone = parseInt(v, 10);
		    },
		    south: function() {
		      self.utmSouth = true;
		    },
		    towgs84: function(v) {
		      self.datum_params = v.split(",").map(function(a) {
		        return parseFloat(a);
		      });
		    },
		    to_meter: function(v) {
		      self.to_meter = parseFloat(v);
		    },
		    units: function(v) {
		      self.units = v;
		      var unit = match(units, v);
		      if (unit) {
		        self.to_meter = unit.to_meter;
		      }
		    },
		    from_greenwich: function(v) {
		      self.from_greenwich = v * D2R;
		    },
		    pm: function(v) {
		      var pm = match(exports$1, v);
		      self.from_greenwich = (pm ? pm : parseFloat(v)) * D2R;
		    },
		    nadgrids: function(v) {
		      if (v === '@null') {
		        self.datumCode = 'none';
		      }
		      else {
		        self.nadgrids = v;
		      }
		    },
		    axis: function(v) {
		      var legalAxis = "ewnsud";
		      if (v.length === 3 && legalAxis.indexOf(v.substr(0, 1)) !== -1 && legalAxis.indexOf(v.substr(1, 1)) !== -1 && legalAxis.indexOf(v.substr(2, 1)) !== -1) {
		        self.axis = v;
		      }
		    }
		  };
		  for (paramName in paramObj) {
		    paramVal = paramObj[paramName];
		    if (paramName in params) {
		      paramOutname = params[paramName];
		      if (typeof paramOutname === 'function') {
		        paramOutname(paramVal);
		      }
		      else {
		        self[paramOutname] = paramVal;
		      }
		    }
		    else {
		      self[paramName] = paramVal;
		    }
		  }
		  if(typeof self.datumCode === 'string' && self.datumCode !== "WGS84"){
		    self.datumCode = self.datumCode.toLowerCase();
		  }
		  return self;
		};
	
		var NEUTRAL = 1;
		var KEYWORD = 2;
		var NUMBER = 3;
		var QUOTED = 4;
		var AFTERQUOTE = 5;
		var ENDED = -1;
		var whitespace = /\s/;
		var latin = /[A-Za-z]/;
		var keyword = /[A-Za-z84]/;
		var endThings = /[,\]]/;
		var digets = /[\d\.E\-\+]/;
		// const ignoredChar = /[\s_\-\/\(\)]/g;
		function Parser(text) {
		  if (typeof text !== 'string') {
		    throw new Error('not a string');
		  }
		  this.text = text.trim();
		  this.level = 0;
		  this.place = 0;
		  this.root = null;
		  this.stack = [];
		  this.currentObject = null;
		  this.state = NEUTRAL;
		}
		Parser.prototype.readCharicter = function() {
		  var char = this.text[this.place++];
		  if (this.state !== QUOTED) {
		    while (whitespace.test(char)) {
		      if (this.place >= this.text.length) {
		        return;
		      }
		      char = this.text[this.place++];
		    }
		  }
		  switch (this.state) {
		    case NEUTRAL:
		      return this.neutral(char);
		    case KEYWORD:
		      return this.keyword(char)
		    case QUOTED:
		      return this.quoted(char);
		    case AFTERQUOTE:
		      return this.afterquote(char);
		    case NUMBER:
		      return this.number(char);
		    case ENDED:
		      return;
		  }
		};
		Parser.prototype.afterquote = function(char) {
		  if (char === '"') {
		    this.word += '"';
		    this.state = QUOTED;
		    return;
		  }
		  if (endThings.test(char)) {
		    this.word = this.word.trim();
		    this.afterItem(char);
		    return;
		  }
		  throw new Error('havn\'t handled "' +char + '" in afterquote yet, index ' + this.place);
		};
		Parser.prototype.afterItem = function(char) {
		  if (char === ',') {
		    if (this.word !== null) {
		      this.currentObject.push(this.word);
		    }
		    this.word = null;
		    this.state = NEUTRAL;
		    return;
		  }
		  if (char === ']') {
		    this.level--;
		    if (this.word !== null) {
		      this.currentObject.push(this.word);
		      this.word = null;
		    }
		    this.state = NEUTRAL;
		    this.currentObject = this.stack.pop();
		    if (!this.currentObject) {
		      this.state = ENDED;
		    }
	
		    return;
		  }
		};
		Parser.prototype.number = function(char) {
		  if (digets.test(char)) {
		    this.word += char;
		    return;
		  }
		  if (endThings.test(char)) {
		    this.word = parseFloat(this.word);
		    this.afterItem(char);
		    return;
		  }
		  throw new Error('havn\'t handled "' +char + '" in number yet, index ' + this.place);
		};
		Parser.prototype.quoted = function(char) {
		  if (char === '"') {
		    this.state = AFTERQUOTE;
		    return;
		  }
		  this.word += char;
		  return;
		};
		Parser.prototype.keyword = function(char) {
		  if (keyword.test(char)) {
		    this.word += char;
		    return;
		  }
		  if (char === '[') {
		    var newObjects = [];
		    newObjects.push(this.word);
		    this.level++;
		    if (this.root === null) {
		      this.root = newObjects;
		    } else {
		      this.currentObject.push(newObjects);
		    }
		    this.stack.push(this.currentObject);
		    this.currentObject = newObjects;
		    this.state = NEUTRAL;
		    return;
		  }
		  if (endThings.test(char)) {
		    this.afterItem(char);
		    return;
		  }
		  throw new Error('havn\'t handled "' +char + '" in keyword yet, index ' + this.place);
		};
		Parser.prototype.neutral = function(char) {
		  if (latin.test(char)) {
		    this.word = char;
		    this.state = KEYWORD;
		    return;
		  }
		  if (char === '"') {
		    this.word = '';
		    this.state = QUOTED;
		    return;
		  }
		  if (digets.test(char)) {
		    this.word = char;
		    this.state = NUMBER;
		    return;
		  }
		  if (endThings.test(char)) {
		    this.afterItem(char);
		    return;
		  }
		  throw new Error('havn\'t handled "' +char + '" in neutral yet, index ' + this.place);
		};
		Parser.prototype.output = function() {
		  while (this.place < this.text.length) {
		    this.readCharicter();
		  }
		  if (this.state === ENDED) {
		    return this.root;
		  }
		  throw new Error('unable to parse string "' +this.text + '". State is ' + this.state);
		};
	
		function parseString(txt) {
		  var parser = new Parser(txt);
		  return parser.output();
		}
	
		function mapit(obj, key, value) {
		  if (Array.isArray(key)) {
		    value.unshift(key);
		    key = null;
		  }
		  var thing = key ? {} : obj;
	
		  var out = value.reduce(function(newObj, item) {
		    sExpr(item, newObj);
		    return newObj
		  }, thing);
		  if (key) {
		    obj[key] = out;
		  }
		}
	
		function sExpr(v, obj) {
		  if (!Array.isArray(v)) {
		    obj[v] = true;
		    return;
		  }
		  var key = v.shift();
		  if (key === 'PARAMETER') {
		    key = v.shift();
		  }
		  if (v.length === 1) {
		    if (Array.isArray(v[0])) {
		      obj[key] = {};
		      sExpr(v[0], obj[key]);
		      return;
		    }
		    obj[key] = v[0];
		    return;
		  }
		  if (!v.length) {
		    obj[key] = true;
		    return;
		  }
		  if (key === 'TOWGS84') {
		    obj[key] = v;
		    return;
		  }
		  if (!Array.isArray(key)) {
		    obj[key] = {};
		  }
	
		  var i;
		  switch (key) {
		    case 'UNIT':
		    case 'PRIMEM':
		    case 'VERT_DATUM':
		      obj[key] = {
		        name: v[0].toLowerCase(),
		        convert: v[1]
		      };
		      if (v.length === 3) {
		        sExpr(v[2], obj[key]);
		      }
		      return;
		    case 'SPHEROID':
		    case 'ELLIPSOID':
		      obj[key] = {
		        name: v[0],
		        a: v[1],
		        rf: v[2]
		      };
		      if (v.length === 4) {
		        sExpr(v[3], obj[key]);
		      }
		      return;
		    case 'PROJECTEDCRS':
		    case 'PROJCRS':
		    case 'GEOGCS':
		    case 'GEOCCS':
		    case 'PROJCS':
		    case 'LOCAL_CS':
		    case 'GEODCRS':
		    case 'GEODETICCRS':
		    case 'GEODETICDATUM':
		    case 'EDATUM':
		    case 'ENGINEERINGDATUM':
		    case 'VERT_CS':
		    case 'VERTCRS':
		    case 'VERTICALCRS':
		    case 'COMPD_CS':
		    case 'COMPOUNDCRS':
		    case 'ENGINEERINGCRS':
		    case 'ENGCRS':
		    case 'FITTED_CS':
		    case 'LOCAL_DATUM':
		    case 'DATUM':
		      v[0] = ['name', v[0]];
		      mapit(obj, key, v);
		      return;
		    default:
		      i = -1;
		      while (++i < v.length) {
		        if (!Array.isArray(v[i])) {
		          return sExpr(v, obj[key]);
		        }
		      }
		      return mapit(obj, key, v);
		  }
		}
	
		var D2R$1 = 0.01745329251994329577;
		function rename(obj, params) {
		  var outName = params[0];
		  var inName = params[1];
		  if (!(outName in obj) && (inName in obj)) {
		    obj[outName] = obj[inName];
		    if (params.length === 3) {
		      obj[outName] = params[2](obj[outName]);
		    }
		  }
		}
	
		function d2r(input) {
		  return input * D2R$1;
		}
	
		function cleanWKT(wkt) {
		  if (wkt.type === 'GEOGCS') {
		    wkt.projName = 'longlat';
		  } else if (wkt.type === 'LOCAL_CS') {
		    wkt.projName = 'identity';
		    wkt.local = true;
		  } else {
		    if (typeof wkt.PROJECTION === 'object') {
		      wkt.projName = Object.keys(wkt.PROJECTION)[0];
		    } else {
		      wkt.projName = wkt.PROJECTION;
		    }
		  }
		  if (wkt.UNIT) {
		    wkt.units = wkt.UNIT.name.toLowerCase();
		    if (wkt.units === 'metre') {
		      wkt.units = 'meter';
		    }
		    if (wkt.UNIT.convert) {
		      if (wkt.type === 'GEOGCS') {
		        if (wkt.DATUM && wkt.DATUM.SPHEROID) {
		          wkt.to_meter = wkt.UNIT.convert*wkt.DATUM.SPHEROID.a;
		        }
		      } else {
		        wkt.to_meter = wkt.UNIT.convert, 10;
		      }
		    }
		  }
		  var geogcs = wkt.GEOGCS;
		  if (wkt.type === 'GEOGCS') {
		    geogcs = wkt;
		  }
		  if (geogcs) {
		    //if(wkt.GEOGCS.PRIMEM&&wkt.GEOGCS.PRIMEM.convert){
		    //  wkt.from_greenwich=wkt.GEOGCS.PRIMEM.convert*D2R;
		    //}
		    if (geogcs.DATUM) {
		      wkt.datumCode = geogcs.DATUM.name.toLowerCase();
		    } else {
		      wkt.datumCode = geogcs.name.toLowerCase();
		    }
		    if (wkt.datumCode.slice(0, 2) === 'd_') {
		      wkt.datumCode = wkt.datumCode.slice(2);
		    }
		    if (wkt.datumCode === 'new_zealand_geodetic_datum_1949' || wkt.datumCode === 'new_zealand_1949') {
		      wkt.datumCode = 'nzgd49';
		    }
		    if (wkt.datumCode === 'wgs_1984') {
		      if (wkt.PROJECTION === 'Mercator_Auxiliary_Sphere') {
		        wkt.sphere = true;
		      }
		      wkt.datumCode = 'wgs84';
		    }
		    if (wkt.datumCode.slice(-6) === '_ferro') {
		      wkt.datumCode = wkt.datumCode.slice(0, - 6);
		    }
		    if (wkt.datumCode.slice(-8) === '_jakarta') {
		      wkt.datumCode = wkt.datumCode.slice(0, - 8);
		    }
		    if (~wkt.datumCode.indexOf('belge')) {
		      wkt.datumCode = 'rnb72';
		    }
		    if (geogcs.DATUM && geogcs.DATUM.SPHEROID) {
		      wkt.ellps = geogcs.DATUM.SPHEROID.name.replace('_19', '').replace(/[Cc]larke\_18/, 'clrk');
		      if (wkt.ellps.toLowerCase().slice(0, 13) === 'international') {
		        wkt.ellps = 'intl';
		      }
	
		      wkt.a = geogcs.DATUM.SPHEROID.a;
		      wkt.rf = parseFloat(geogcs.DATUM.SPHEROID.rf, 10);
		    }
		    if (~wkt.datumCode.indexOf('osgb_1936')) {
		      wkt.datumCode = 'osgb36';
		    }
		  }
		  if (wkt.b && !isFinite(wkt.b)) {
		    wkt.b = wkt.a;
		  }
	
		  function toMeter(input) {
		    var ratio = wkt.to_meter || 1;
		    return input * ratio;
		  }
		  var renamer = function(a) {
		    return rename(wkt, a);
		  };
		  var list = [
		    ['standard_parallel_1', 'Standard_Parallel_1'],
		    ['standard_parallel_2', 'Standard_Parallel_2'],
		    ['false_easting', 'False_Easting'],
		    ['false_northing', 'False_Northing'],
		    ['central_meridian', 'Central_Meridian'],
		    ['latitude_of_origin', 'Latitude_Of_Origin'],
		    ['latitude_of_origin', 'Central_Parallel'],
		    ['scale_factor', 'Scale_Factor'],
		    ['k0', 'scale_factor'],
		    ['latitude_of_center', 'Latitude_of_center'],
		    ['lat0', 'latitude_of_center', d2r],
		    ['longitude_of_center', 'Longitude_Of_Center'],
		    ['longc', 'longitude_of_center', d2r],
		    ['x0', 'false_easting', toMeter],
		    ['y0', 'false_northing', toMeter],
		    ['long0', 'central_meridian', d2r],
		    ['lat0', 'latitude_of_origin', d2r],
		    ['lat0', 'standard_parallel_1', d2r],
		    ['lat1', 'standard_parallel_1', d2r],
		    ['lat2', 'standard_parallel_2', d2r],
		    ['alpha', 'azimuth', d2r],
		    ['srsCode', 'name']
		  ];
		  list.forEach(renamer);
		  if (!wkt.long0 && wkt.longc && (wkt.projName === 'Albers_Conic_Equal_Area' || wkt.projName === 'Lambert_Azimuthal_Equal_Area')) {
		    wkt.long0 = wkt.longc;
		  }
		  if (!wkt.lat_ts && wkt.lat1 && (wkt.projName === 'Stereographic_South_Pole' || wkt.projName === 'Polar Stereographic (variant B)')) {
		    wkt.lat0 = d2r(wkt.lat1 > 0 ? 90 : -90);
		    wkt.lat_ts = wkt.lat1;
		  }
		}
		var wkt = function(wkt) {
		  var lisp = parseString(wkt);
		  var type = lisp.shift();
		  var name = lisp.shift();
		  lisp.unshift(['name', name]);
		  lisp.unshift(['type', type]);
		  var obj = {};
		  sExpr(lisp, obj);
		  cleanWKT(obj);
		  return obj;
		};
	
		function defs(name) {
		  /*global console*/
		  var that = this;
		  if (arguments.length === 2) {
		    var def = arguments[1];
		    if (typeof def === 'string') {
		      if (def.charAt(0) === '+') {
		        defs[name] = parseProj(arguments[1]);
		      }
		      else {
		        defs[name] = wkt(arguments[1]);
		      }
		    } else {
		      defs[name] = def;
		    }
		  }
		  else if (arguments.length === 1) {
		    if (Array.isArray(name)) {
		      return name.map(function(v) {
		        if (Array.isArray(v)) {
		          defs.apply(that, v);
		        }
		        else {
		          defs(v);
		        }
		      });
		    }
		    else if (typeof name === 'string') {
		      if (name in defs) {
		        return defs[name];
		      }
		    }
		    else if ('EPSG' in name) {
		      defs['EPSG:' + name.EPSG] = name;
		    }
		    else if ('ESRI' in name) {
		      defs['ESRI:' + name.ESRI] = name;
		    }
		    else if ('IAU2000' in name) {
		      defs['IAU2000:' + name.IAU2000] = name;
		    }
		    else {
		      console.log(name);
		    }
		    return;
		  }
	
	
		}
		globals(defs);
	
		function testObj(code){
		  return typeof code === 'string';
		}
		function testDef(code){
		  return code in defs;
		}
		 var codeWords = ['PROJECTEDCRS', 'PROJCRS', 'GEOGCS','GEOCCS','PROJCS','LOCAL_CS', 'GEODCRS', 'GEODETICCRS', 'GEODETICDATUM', 'ENGCRS', 'ENGINEERINGCRS']; 
		function testWKT(code){
		  return codeWords.some(function (word) {
		    return code.indexOf(word) > -1;
		  });
		}
		function testProj(code){
		  return code[0] === '+';
		}
		function parse(code){
		  if (testObj(code)) {
		    //check to see if this is a WKT string
		    if (testDef(code)) {
		      return defs[code];
		    }
		    if (testWKT(code)) {
		      return wkt(code);
		    }
		    if (testProj(code)) {
		      return parseProj(code);
		    }
		  }else{
		    return code;
		  }
		}
	
		var extend = function(destination, source) {
		  destination = destination || {};
		  var value, property;
		  if (!source) {
		    return destination;
		  }
		  for (property in source) {
		    value = source[property];
		    if (value !== undefined) {
		      destination[property] = value;
		    }
		  }
		  return destination;
		};
	
		var msfnz = function(eccent, sinphi, cosphi) {
		  var con = eccent * sinphi;
		  return cosphi / (Math.sqrt(1 - con * con));
		};
	
		var sign = function(x) {
		  return x<0 ? -1 : 1;
		};
	
		var adjust_lon = function(x) {
		  return (Math.abs(x) <= SPI) ? x : (x - (sign(x) * TWO_PI));
		};
	
		var tsfnz = function(eccent, phi, sinphi) {
		  var con = eccent * sinphi;
		  var com = 0.5 * eccent;
		  con = Math.pow(((1 - con) / (1 + con)), com);
		  return (Math.tan(0.5 * (HALF_PI - phi)) / con);
		};
	
		var phi2z = function(eccent, ts) {
		  var eccnth = 0.5 * eccent;
		  var con, dphi;
		  var phi = HALF_PI - 2 * Math.atan(ts);
		  for (var i = 0; i <= 15; i++) {
		    con = eccent * Math.sin(phi);
		    dphi = HALF_PI - 2 * Math.atan(ts * (Math.pow(((1 - con) / (1 + con)), eccnth))) - phi;
		    phi += dphi;
		    if (Math.abs(dphi) <= 0.0000000001) {
		      return phi;
		    }
		  }
		  //console.log("phi2z has NoConvergence");
		  return -9999;
		};
	
		function init() {
		  var con = this.b / this.a;
		  this.es = 1 - con * con;
		  if(!('x0' in this)){
		    this.x0 = 0;
		  }
		  if(!('y0' in this)){
		    this.y0 = 0;
		  }
		  this.e = Math.sqrt(this.es);
		  if (this.lat_ts) {
		    if (this.sphere) {
		      this.k0 = Math.cos(this.lat_ts);
		    }
		    else {
		      this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
		    }
		  }
		  else {
		    if (!this.k0) {
		      if (this.k) {
		        this.k0 = this.k;
		      }
		      else {
		        this.k0 = 1;
		      }
		    }
		  }
		}
	
		/* Mercator forward equations--mapping lat,long to x,y
		  --------------------------------------------------*/
	
		function forward(p) {
		  var lon = p.x;
		  var lat = p.y;
		  // convert to radians
		  if (lat * R2D > 90 && lat * R2D < -90 && lon * R2D > 180 && lon * R2D < -180) {
		    return null;
		  }
	
		  var x, y;
		  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
		    return null;
		  }
		  else {
		    if (this.sphere) {
		      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
		      y = this.y0 + this.a * this.k0 * Math.log(Math.tan(FORTPI + 0.5 * lat));
		    }
		    else {
		      var sinphi = Math.sin(lat);
		      var ts = tsfnz(this.e, lat, sinphi);
		      x = this.x0 + this.a * this.k0 * adjust_lon(lon - this.long0);
		      y = this.y0 - this.a * this.k0 * Math.log(ts);
		    }
		    p.x = x;
		    p.y = y;
		    return p;
		  }
		}
	
		/* Mercator inverse equations--mapping x,y to lat/long
		  --------------------------------------------------*/
		function inverse(p) {
	
		  var x = p.x - this.x0;
		  var y = p.y - this.y0;
		  var lon, lat;
	
		  if (this.sphere) {
		    lat = HALF_PI - 2 * Math.atan(Math.exp(-y / (this.a * this.k0)));
		  }
		  else {
		    var ts = Math.exp(-y / (this.a * this.k0));
		    lat = phi2z(this.e, ts);
		    if (lat === -9999) {
		      return null;
		    }
		  }
		  lon = adjust_lon(this.long0 + x / (this.a * this.k0));
	
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$1 = ["Mercator", "Popular Visualisation Pseudo Mercator", "Mercator_1SP", "Mercator_Auxiliary_Sphere", "merc"];
		var merc = {
		  init: init,
		  forward: forward,
		  inverse: inverse,
		  names: names$1
		};
	
		function init$1() {
		  //no-op for longlat
		}
	
		function identity(pt) {
		  return pt;
		}
		var names$2 = ["longlat", "identity"];
		var longlat = {
		  init: init$1,
		  forward: identity,
		  inverse: identity,
		  names: names$2
		};
	
		var projs = [merc, longlat];
		var names$$1 = {};
		var projStore = [];
	
		function add(proj, i) {
		  var len = projStore.length;
		  if (!proj.names) {
		    console.log(i);
		    return true;
		  }
		  projStore[len] = proj;
		  proj.names.forEach(function(n) {
		    names$$1[n.toLowerCase()] = len;
		  });
		  return this;
		}
	
		function get(name) {
		  if (!name) {
		    return false;
		  }
		  var n = name.toLowerCase();
		  if (typeof names$$1[n] !== 'undefined' && projStore[names$$1[n]]) {
		    return projStore[names$$1[n]];
		  }
		}
	
		function start() {
		  projs.forEach(add);
		}
		var projections = {
		  start: start,
		  add: add,
		  get: get
		};
	
		var exports$2 = {};
		exports$2.MERIT = {
		  a: 6378137.0,
		  rf: 298.257,
		  ellipseName: "MERIT 1983"
		};
	
		exports$2.SGS85 = {
		  a: 6378136.0,
		  rf: 298.257,
		  ellipseName: "Soviet Geodetic System 85"
		};
	
		exports$2.GRS80 = {
		  a: 6378137.0,
		  rf: 298.257222101,
		  ellipseName: "GRS 1980(IUGG, 1980)"
		};
	
		exports$2.IAU76 = {
		  a: 6378140.0,
		  rf: 298.257,
		  ellipseName: "IAU 1976"
		};
	
		exports$2.airy = {
		  a: 6377563.396,
		  b: 6356256.910,
		  ellipseName: "Airy 1830"
		};
	
		exports$2.APL4 = {
		  a: 6378137,
		  rf: 298.25,
		  ellipseName: "Appl. Physics. 1965"
		};
	
		exports$2.NWL9D = {
		  a: 6378145.0,
		  rf: 298.25,
		  ellipseName: "Naval Weapons Lab., 1965"
		};
	
		exports$2.mod_airy = {
		  a: 6377340.189,
		  b: 6356034.446,
		  ellipseName: "Modified Airy"
		};
	
		exports$2.andrae = {
		  a: 6377104.43,
		  rf: 300.0,
		  ellipseName: "Andrae 1876 (Den., Iclnd.)"
		};
	
		exports$2.aust_SA = {
		  a: 6378160.0,
		  rf: 298.25,
		  ellipseName: "Australian Natl & S. Amer. 1969"
		};
	
		exports$2.GRS67 = {
		  a: 6378160.0,
		  rf: 298.2471674270,
		  ellipseName: "GRS 67(IUGG 1967)"
		};
	
		exports$2.bessel = {
		  a: 6377397.155,
		  rf: 299.1528128,
		  ellipseName: "Bessel 1841"
		};
	
		exports$2.bess_nam = {
		  a: 6377483.865,
		  rf: 299.1528128,
		  ellipseName: "Bessel 1841 (Namibia)"
		};
	
		exports$2.clrk66 = {
		  a: 6378206.4,
		  b: 6356583.8,
		  ellipseName: "Clarke 1866"
		};
	
		exports$2.clrk80 = {
		  a: 6378249.145,
		  rf: 293.4663,
		  ellipseName: "Clarke 1880 mod."
		};
	
		exports$2.clrk58 = {
		  a: 6378293.645208759,
		  rf: 294.2606763692654,
		  ellipseName: "Clarke 1858"
		};
	
		exports$2.CPM = {
		  a: 6375738.7,
		  rf: 334.29,
		  ellipseName: "Comm. des Poids et Mesures 1799"
		};
	
		exports$2.delmbr = {
		  a: 6376428.0,
		  rf: 311.5,
		  ellipseName: "Delambre 1810 (Belgium)"
		};
	
		exports$2.engelis = {
		  a: 6378136.05,
		  rf: 298.2566,
		  ellipseName: "Engelis 1985"
		};
	
		exports$2.evrst30 = {
		  a: 6377276.345,
		  rf: 300.8017,
		  ellipseName: "Everest 1830"
		};
	
		exports$2.evrst48 = {
		  a: 6377304.063,
		  rf: 300.8017,
		  ellipseName: "Everest 1948"
		};
	
		exports$2.evrst56 = {
		  a: 6377301.243,
		  rf: 300.8017,
		  ellipseName: "Everest 1956"
		};
	
		exports$2.evrst69 = {
		  a: 6377295.664,
		  rf: 300.8017,
		  ellipseName: "Everest 1969"
		};
	
		exports$2.evrstSS = {
		  a: 6377298.556,
		  rf: 300.8017,
		  ellipseName: "Everest (Sabah & Sarawak)"
		};
	
		exports$2.fschr60 = {
		  a: 6378166.0,
		  rf: 298.3,
		  ellipseName: "Fischer (Mercury Datum) 1960"
		};
	
		exports$2.fschr60m = {
		  a: 6378155.0,
		  rf: 298.3,
		  ellipseName: "Fischer 1960"
		};
	
		exports$2.fschr68 = {
		  a: 6378150.0,
		  rf: 298.3,
		  ellipseName: "Fischer 1968"
		};
	
		exports$2.helmert = {
		  a: 6378200.0,
		  rf: 298.3,
		  ellipseName: "Helmert 1906"
		};
	
		exports$2.hough = {
		  a: 6378270.0,
		  rf: 297.0,
		  ellipseName: "Hough"
		};
	
		exports$2.intl = {
		  a: 6378388.0,
		  rf: 297.0,
		  ellipseName: "International 1909 (Hayford)"
		};
	
		exports$2.kaula = {
		  a: 6378163.0,
		  rf: 298.24,
		  ellipseName: "Kaula 1961"
		};
	
		exports$2.lerch = {
		  a: 6378139.0,
		  rf: 298.257,
		  ellipseName: "Lerch 1979"
		};
	
		exports$2.mprts = {
		  a: 6397300.0,
		  rf: 191.0,
		  ellipseName: "Maupertius 1738"
		};
	
		exports$2.new_intl = {
		  a: 6378157.5,
		  b: 6356772.2,
		  ellipseName: "New International 1967"
		};
	
		exports$2.plessis = {
		  a: 6376523.0,
		  rf: 6355863.0,
		  ellipseName: "Plessis 1817 (France)"
		};
	
		exports$2.krass = {
		  a: 6378245.0,
		  rf: 298.3,
		  ellipseName: "Krassovsky, 1942"
		};
	
		exports$2.SEasia = {
		  a: 6378155.0,
		  b: 6356773.3205,
		  ellipseName: "Southeast Asia"
		};
	
		exports$2.walbeck = {
		  a: 6376896.0,
		  b: 6355834.8467,
		  ellipseName: "Walbeck"
		};
	
		exports$2.WGS60 = {
		  a: 6378165.0,
		  rf: 298.3,
		  ellipseName: "WGS 60"
		};
	
		exports$2.WGS66 = {
		  a: 6378145.0,
		  rf: 298.25,
		  ellipseName: "WGS 66"
		};
	
		exports$2.WGS7 = {
		  a: 6378135.0,
		  rf: 298.26,
		  ellipseName: "WGS 72"
		};
	
		var WGS84 = exports$2.WGS84 = {
		  a: 6378137.0,
		  rf: 298.257223563,
		  ellipseName: "WGS 84"
		};
	
		exports$2.sphere = {
		  a: 6370997.0,
		  b: 6370997.0,
		  ellipseName: "Normal Sphere (r=6370997)"
		};
	
		function eccentricity(a, b, rf, R_A) {
		  var a2 = a * a; // used in geocentric
		  var b2 = b * b; // used in geocentric
		  var es = (a2 - b2) / a2; // e ^ 2
		  var e = 0;
		  if (R_A) {
		    a *= 1 - es * (SIXTH + es * (RA4 + es * RA6));
		    a2 = a * a;
		    es = 0;
		  } else {
		    e = Math.sqrt(es); // eccentricity
		  }
		  var ep2 = (a2 - b2) / b2; // used in geocentric
		  return {
		    es: es,
		    e: e,
		    ep2: ep2
		  };
		}
		function sphere(a, b, rf, ellps, sphere) {
		  if (!a) { // do we have an ellipsoid?
		    var ellipse = match(exports$2, ellps);
		    if (!ellipse) {
		      ellipse = WGS84;
		    }
		    a = ellipse.a;
		    b = ellipse.b;
		    rf = ellipse.rf;
		  }
	
		  if (rf && !b) {
		    b = (1.0 - 1.0 / rf) * a;
		  }
		  if (rf === 0 || Math.abs(a - b) < EPSLN) {
		    sphere = true;
		    b = a;
		  }
		  return {
		    a: a,
		    b: b,
		    rf: rf,
		    sphere: sphere
		  };
		}
	
		var exports$3 = {};
		exports$3.wgs84 = {
		  towgs84: "0,0,0",
		  ellipse: "WGS84",
		  datumName: "WGS84"
		};
	
		exports$3.ch1903 = {
		  towgs84: "674.374,15.056,405.346",
		  ellipse: "bessel",
		  datumName: "swiss"
		};
	
		exports$3.ggrs87 = {
		  towgs84: "-199.87,74.79,246.62",
		  ellipse: "GRS80",
		  datumName: "Greek_Geodetic_Reference_System_1987"
		};
	
		exports$3.nad83 = {
		  towgs84: "0,0,0",
		  ellipse: "GRS80",
		  datumName: "North_American_Datum_1983"
		};
	
		exports$3.nad27 = {
		  nadgrids: "@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",
		  ellipse: "clrk66",
		  datumName: "North_American_Datum_1927"
		};
	
		exports$3.potsdam = {
		  towgs84: "606.0,23.0,413.0",
		  ellipse: "bessel",
		  datumName: "Potsdam Rauenberg 1950 DHDN"
		};
	
		exports$3.carthage = {
		  towgs84: "-263.0,6.0,431.0",
		  ellipse: "clark80",
		  datumName: "Carthage 1934 Tunisia"
		};
	
		exports$3.hermannskogel = {
		  towgs84: "653.0,-212.0,449.0",
		  ellipse: "bessel",
		  datumName: "Hermannskogel"
		};
	
		exports$3.ire65 = {
		  towgs84: "482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",
		  ellipse: "mod_airy",
		  datumName: "Ireland 1965"
		};
	
		exports$3.rassadiran = {
		  towgs84: "-133.63,-157.5,-158.62",
		  ellipse: "intl",
		  datumName: "Rassadiran"
		};
	
		exports$3.nzgd49 = {
		  towgs84: "59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",
		  ellipse: "intl",
		  datumName: "New Zealand Geodetic Datum 1949"
		};
	
		exports$3.osgb36 = {
		  towgs84: "446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",
		  ellipse: "airy",
		  datumName: "Airy 1830"
		};
	
		exports$3.s_jtsk = {
		  towgs84: "589,76,480",
		  ellipse: 'bessel',
		  datumName: 'S-JTSK (Ferro)'
		};
	
		exports$3.beduaram = {
		  towgs84: '-106,-87,188',
		  ellipse: 'clrk80',
		  datumName: 'Beduaram'
		};
	
		exports$3.gunung_segara = {
		  towgs84: '-403,684,41',
		  ellipse: 'bessel',
		  datumName: 'Gunung Segara Jakarta'
		};
	
		exports$3.rnb72 = {
		  towgs84: "106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",
		  ellipse: "intl",
		  datumName: "Reseau National Belge 1972"
		};
	
		function datum(datumCode, datum_params, a, b, es, ep2) {
		  var out = {};
	
		  if (datumCode === undefined || datumCode === 'none') {
		    out.datum_type = PJD_NODATUM;
		  } else {
		    out.datum_type = PJD_WGS84;
		  }
	
		  if (datum_params) {
		    out.datum_params = datum_params.map(parseFloat);
		    if (out.datum_params[0] !== 0 || out.datum_params[1] !== 0 || out.datum_params[2] !== 0) {
		      out.datum_type = PJD_3PARAM;
		    }
		    if (out.datum_params.length > 3) {
		      if (out.datum_params[3] !== 0 || out.datum_params[4] !== 0 || out.datum_params[5] !== 0 || out.datum_params[6] !== 0) {
		        out.datum_type = PJD_7PARAM;
		        out.datum_params[3] *= SEC_TO_RAD;
		        out.datum_params[4] *= SEC_TO_RAD;
		        out.datum_params[5] *= SEC_TO_RAD;
		        out.datum_params[6] = (out.datum_params[6] / 1000000.0) + 1.0;
		      }
		    }
		  }
	
		  out.a = a; //datum object also uses these values
		  out.b = b;
		  out.es = es;
		  out.ep2 = ep2;
		  return out;
		}
	
		function Projection$1(srsCode,callback) {
		  if (!(this instanceof Projection$1)) {
		    return new Projection$1(srsCode);
		  }
		  callback = callback || function(error){
		    if(error){
		      throw error;
		    }
		  };
		  var json = parse(srsCode);
		  if(typeof json !== 'object'){
		    callback(srsCode);
		    return;
		  }
		  var ourProj = Projection$1.projections.get(json.projName);
		  if(!ourProj){
		    callback(srsCode);
		    return;
		  }
		  if (json.datumCode && json.datumCode !== 'none') {
		    var datumDef = match(exports$3, json.datumCode);
		    if (datumDef) {
		      json.datum_params = datumDef.towgs84 ? datumDef.towgs84.split(',') : null;
		      json.ellps = datumDef.ellipse;
		      json.datumName = datumDef.datumName ? datumDef.datumName : json.datumCode;
		    }
		  }
		  json.k0 = json.k0 || 1.0;
		  json.axis = json.axis || 'enu';
		  json.ellps = json.ellps || 'wgs84';
		  var sphere_ = sphere(json.a, json.b, json.rf, json.ellps, json.sphere);
		  var ecc = eccentricity(sphere_.a, sphere_.b, sphere_.rf, json.R_A);
		  var datumObj = json.datum || datum(json.datumCode, json.datum_params, sphere_.a, sphere_.b, ecc.es, ecc.ep2);
	
		  extend(this, json); // transfer everything over from the projection because we don't know what we'll need
		  extend(this, ourProj); // transfer all the methods from the projection
	
		  // copy the 4 things over we calulated in deriveConstants.sphere
		  this.a = sphere_.a;
		  this.b = sphere_.b;
		  this.rf = sphere_.rf;
		  this.sphere = sphere_.sphere;
	
		  // copy the 3 things we calculated in deriveConstants.eccentricity
		  this.es = ecc.es;
		  this.e = ecc.e;
		  this.ep2 = ecc.ep2;
	
		  // add in the datum object
		  this.datum = datumObj;
	
		  // init the projection
		  this.init();
	
		  // legecy callback from back in the day when it went to spatialreference.org
		  callback(null, this);
	
		}
		Projection$1.projections = projections;
		Projection$1.projections.start();
	
		function compareDatums(source, dest) {
		  if (source.datum_type !== dest.datum_type) {
		    return false; // false, datums are not equal
		  } else if (source.a !== dest.a || Math.abs(source.es - dest.es) > 0.000000000050) {
		    // the tolerance for es is to ensure that GRS80 and WGS84
		    // are considered identical
		    return false;
		  } else if (source.datum_type === PJD_3PARAM) {
		    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2]);
		  } else if (source.datum_type === PJD_7PARAM) {
		    return (source.datum_params[0] === dest.datum_params[0] && source.datum_params[1] === dest.datum_params[1] && source.datum_params[2] === dest.datum_params[2] && source.datum_params[3] === dest.datum_params[3] && source.datum_params[4] === dest.datum_params[4] && source.datum_params[5] === dest.datum_params[5] && source.datum_params[6] === dest.datum_params[6]);
		  } else {
		    return true; // datums are equal
		  }
		} // cs_compare_datums()
	
		/*
		 * The function Convert_Geodetic_To_Geocentric converts geodetic coordinates
		 * (latitude, longitude, and height) to geocentric coordinates (X, Y, Z),
		 * according to the current ellipsoid parameters.
		 *
		 *    Latitude  : Geodetic latitude in radians                     (input)
		 *    Longitude : Geodetic longitude in radians                    (input)
		 *    Height    : Geodetic height, in meters                       (input)
		 *    X         : Calculated Geocentric X coordinate, in meters    (output)
		 *    Y         : Calculated Geocentric Y coordinate, in meters    (output)
		 *    Z         : Calculated Geocentric Z coordinate, in meters    (output)
		 *
		 */
		function geodeticToGeocentric(p, es, a) {
		  var Longitude = p.x;
		  var Latitude = p.y;
		  var Height = p.z ? p.z : 0; //Z value not always supplied
	
		  var Rn; /*  Earth radius at location  */
		  var Sin_Lat; /*  Math.sin(Latitude)  */
		  var Sin2_Lat; /*  Square of Math.sin(Latitude)  */
		  var Cos_Lat; /*  Math.cos(Latitude)  */
	
		  /*
		   ** Don't blow up if Latitude is just a little out of the value
		   ** range as it may just be a rounding issue.  Also removed longitude
		   ** test, it should be wrapped by Math.cos() and Math.sin().  NFW for PROJ.4, Sep/2001.
		   */
		  if (Latitude < -HALF_PI && Latitude > -1.001 * HALF_PI) {
		    Latitude = -HALF_PI;
		  } else if (Latitude > HALF_PI && Latitude < 1.001 * HALF_PI) {
		    Latitude = HALF_PI;
		  } else if ((Latitude < -HALF_PI) || (Latitude > HALF_PI)) {
		    /* Latitude out of range */
		    //..reportError('geocent:lat out of range:' + Latitude);
		    return null;
		  }
	
		  if (Longitude > Math.PI) {
		    Longitude -= (2 * Math.PI);
		  }
		  Sin_Lat = Math.sin(Latitude);
		  Cos_Lat = Math.cos(Latitude);
		  Sin2_Lat = Sin_Lat * Sin_Lat;
		  Rn = a / (Math.sqrt(1.0e0 - es * Sin2_Lat));
		  return {
		    x: (Rn + Height) * Cos_Lat * Math.cos(Longitude),
		    y: (Rn + Height) * Cos_Lat * Math.sin(Longitude),
		    z: ((Rn * (1 - es)) + Height) * Sin_Lat
		  };
		} // cs_geodetic_to_geocentric()
	
		function geocentricToGeodetic(p, es, a, b) {
		  /* local defintions and variables */
		  /* end-criterium of loop, accuracy of sin(Latitude) */
		  var genau = 1e-12;
		  var genau2 = (genau * genau);
		  var maxiter = 30;
	
		  var P; /* distance between semi-minor axis and location */
		  var RR; /* distance between center and location */
		  var CT; /* sin of geocentric latitude */
		  var ST; /* cos of geocentric latitude */
		  var RX;
		  var RK;
		  var RN; /* Earth radius at location */
		  var CPHI0; /* cos of start or old geodetic latitude in iterations */
		  var SPHI0; /* sin of start or old geodetic latitude in iterations */
		  var CPHI; /* cos of searched geodetic latitude */
		  var SPHI; /* sin of searched geodetic latitude */
		  var SDPHI; /* end-criterium: addition-theorem of sin(Latitude(iter)-Latitude(iter-1)) */
		  var iter; /* # of continous iteration, max. 30 is always enough (s.a.) */
	
		  var X = p.x;
		  var Y = p.y;
		  var Z = p.z ? p.z : 0.0; //Z value not always supplied
		  var Longitude;
		  var Latitude;
		  var Height;
	
		  P = Math.sqrt(X * X + Y * Y);
		  RR = Math.sqrt(X * X + Y * Y + Z * Z);
	
		  /*      special cases for latitude and longitude */
		  if (P / a < genau) {
	
		    /*  special case, if P=0. (X=0., Y=0.) */
		    Longitude = 0.0;
	
		    /*  if (X,Y,Z)=(0.,0.,0.) then Height becomes semi-minor axis
		     *  of ellipsoid (=center of mass), Latitude becomes PI/2 */
		    if (RR / a < genau) {
		      Latitude = HALF_PI;
		      Height = -b;
		      return {
		        x: p.x,
		        y: p.y,
		        z: p.z
		      };
		    }
		  } else {
		    /*  ellipsoidal (geodetic) longitude
		     *  interval: -PI < Longitude <= +PI */
		    Longitude = Math.atan2(Y, X);
		  }
	
		  /* --------------------------------------------------------------
		   * Following iterative algorithm was developped by
		   * "Institut for Erdmessung", University of Hannover, July 1988.
		   * Internet: www.ife.uni-hannover.de
		   * Iterative computation of CPHI,SPHI and Height.
		   * Iteration of CPHI and SPHI to 10**-12 radian resp.
		   * 2*10**-7 arcsec.
		   * --------------------------------------------------------------
		   */
		  CT = Z / RR;
		  ST = P / RR;
		  RX = 1.0 / Math.sqrt(1.0 - es * (2.0 - es) * ST * ST);
		  CPHI0 = ST * (1.0 - es) * RX;
		  SPHI0 = CT * RX;
		  iter = 0;
	
		  /* loop to find sin(Latitude) resp. Latitude
		   * until |sin(Latitude(iter)-Latitude(iter-1))| < genau */
		  do {
		    iter++;
		    RN = a / Math.sqrt(1.0 - es * SPHI0 * SPHI0);
	
		    /*  ellipsoidal (geodetic) height */
		    Height = P * CPHI0 + Z * SPHI0 - RN * (1.0 - es * SPHI0 * SPHI0);
	
		    RK = es * RN / (RN + Height);
		    RX = 1.0 / Math.sqrt(1.0 - RK * (2.0 - RK) * ST * ST);
		    CPHI = ST * (1.0 - RK) * RX;
		    SPHI = CT * RX;
		    SDPHI = SPHI * CPHI0 - CPHI * SPHI0;
		    CPHI0 = CPHI;
		    SPHI0 = SPHI;
		  }
		  while (SDPHI * SDPHI > genau2 && iter < maxiter);
	
		  /*      ellipsoidal (geodetic) latitude */
		  Latitude = Math.atan(SPHI / Math.abs(CPHI));
		  return {
		    x: Longitude,
		    y: Latitude,
		    z: Height
		  };
		} // cs_geocentric_to_geodetic()
	
		/****************************************************************/
		// pj_geocentic_to_wgs84( p )
		//  p = point to transform in geocentric coordinates (x,y,z)
	
	
		/** point object, nothing fancy, just allows values to be
		    passed back and forth by reference rather than by value.
		    Other point classes may be used as long as they have
		    x and y properties, which will get modified in the transform method.
		*/
		function geocentricToWgs84(p, datum_type, datum_params) {
	
		  if (datum_type === PJD_3PARAM) {
		    // if( x[io] === HUGE_VAL )
		    //    continue;
		    return {
		      x: p.x + datum_params[0],
		      y: p.y + datum_params[1],
		      z: p.z + datum_params[2],
		    };
		  } else if (datum_type === PJD_7PARAM) {
		    var Dx_BF = datum_params[0];
		    var Dy_BF = datum_params[1];
		    var Dz_BF = datum_params[2];
		    var Rx_BF = datum_params[3];
		    var Ry_BF = datum_params[4];
		    var Rz_BF = datum_params[5];
		    var M_BF = datum_params[6];
		    // if( x[io] === HUGE_VAL )
		    //    continue;
		    return {
		      x: M_BF * (p.x - Rz_BF * p.y + Ry_BF * p.z) + Dx_BF,
		      y: M_BF * (Rz_BF * p.x + p.y - Rx_BF * p.z) + Dy_BF,
		      z: M_BF * (-Ry_BF * p.x + Rx_BF * p.y + p.z) + Dz_BF
		    };
		  }
		} // cs_geocentric_to_wgs84
	
		/****************************************************************/
		// pj_geocentic_from_wgs84()
		//  coordinate system definition,
		//  point to transform in geocentric coordinates (x,y,z)
		function geocentricFromWgs84(p, datum_type, datum_params) {
	
		  if (datum_type === PJD_3PARAM) {
		    //if( x[io] === HUGE_VAL )
		    //    continue;
		    return {
		      x: p.x - datum_params[0],
		      y: p.y - datum_params[1],
		      z: p.z - datum_params[2],
		    };
	
		  } else if (datum_type === PJD_7PARAM) {
		    var Dx_BF = datum_params[0];
		    var Dy_BF = datum_params[1];
		    var Dz_BF = datum_params[2];
		    var Rx_BF = datum_params[3];
		    var Ry_BF = datum_params[4];
		    var Rz_BF = datum_params[5];
		    var M_BF = datum_params[6];
		    var x_tmp = (p.x - Dx_BF) / M_BF;
		    var y_tmp = (p.y - Dy_BF) / M_BF;
		    var z_tmp = (p.z - Dz_BF) / M_BF;
		    //if( x[io] === HUGE_VAL )
		    //    continue;
	
		    return {
		      x: x_tmp + Rz_BF * y_tmp - Ry_BF * z_tmp,
		      y: -Rz_BF * x_tmp + y_tmp + Rx_BF * z_tmp,
		      z: Ry_BF * x_tmp - Rx_BF * y_tmp + z_tmp
		    };
		  } //cs_geocentric_from_wgs84()
		}
	
		function checkParams(type) {
		  return (type === PJD_3PARAM || type === PJD_7PARAM);
		}
	
		var datum_transform = function(source, dest, point) {
		  // Short cut if the datums are identical.
		  if (compareDatums(source, dest)) {
		    return point; // in this case, zero is sucess,
		    // whereas cs_compare_datums returns 1 to indicate TRUE
		    // confusing, should fix this
		  }
	
		  // Explicitly skip datum transform by setting 'datum=none' as parameter for either source or dest
		  if (source.datum_type === PJD_NODATUM || dest.datum_type === PJD_NODATUM) {
		    return point;
		  }
	
		  // If this datum requires grid shifts, then apply it to geodetic coordinates.
	
		  // Do we need to go through geocentric coordinates?
		  if (source.es === dest.es && source.a === dest.a && !checkParams(source.datum_type) &&  !checkParams(dest.datum_type)) {
		    return point;
		  }
	
		  // Convert to geocentric coordinates.
		  point = geodeticToGeocentric(point, source.es, source.a);
		  // Convert between datums
		  if (checkParams(source.datum_type)) {
		    point = geocentricToWgs84(point, source.datum_type, source.datum_params);
		  }
		  if (checkParams(dest.datum_type)) {
		    point = geocentricFromWgs84(point, dest.datum_type, dest.datum_params);
		  }
		  return geocentricToGeodetic(point, dest.es, dest.a, dest.b);
	
		};
	
		var adjust_axis = function(crs, denorm, point) {
		  var xin = point.x,
		    yin = point.y,
		    zin = point.z || 0.0;
		  var v, t, i;
		  var out = {};
		  for (i = 0; i < 3; i++) {
		    if (denorm && i === 2 && point.z === undefined) {
		      continue;
		    }
		    if (i === 0) {
		      v = xin;
		      t = 'x';
		    }
		    else if (i === 1) {
		      v = yin;
		      t = 'y';
		    }
		    else {
		      v = zin;
		      t = 'z';
		    }
		    switch (crs.axis[i]) {
		    case 'e':
		      out[t] = v;
		      break;
		    case 'w':
		      out[t] = -v;
		      break;
		    case 'n':
		      out[t] = v;
		      break;
		    case 's':
		      out[t] = -v;
		      break;
		    case 'u':
		      if (point[t] !== undefined) {
		        out.z = v;
		      }
		      break;
		    case 'd':
		      if (point[t] !== undefined) {
		        out.z = -v;
		      }
		      break;
		    default:
		      //console.log("ERROR: unknow axis ("+crs.axis[i]+") - check definition of "+crs.projName);
		      return null;
		    }
		  }
		  return out;
		};
	
		var toPoint = function (array){
		  var out = {
		    x: array[0],
		    y: array[1]
		  };
		  if (array.length>2) {
		    out.z = array[2];
		  }
		  if (array.length>3) {
		    out.m = array[3];
		  }
		  return out;
		};
	
		function checkNotWGS(source, dest) {
		  return ((source.datum.datum_type === PJD_3PARAM || source.datum.datum_type === PJD_7PARAM) && dest.datumCode !== 'WGS84') || ((dest.datum.datum_type === PJD_3PARAM || dest.datum.datum_type === PJD_7PARAM) && source.datumCode !== 'WGS84');
		}
	
		function transform(source, dest, point) {
		  var wgs84;
		  if (Array.isArray(point)) {
		    point = toPoint(point);
		  }
	
		  // Workaround for datum shifts towgs84, if either source or destination projection is not wgs84
		  if (source.datum && dest.datum && checkNotWGS(source, dest)) {
		    wgs84 = new Projection$1('WGS84');
		    point = transform(source, wgs84, point);
		    source = wgs84;
		  }
		  // DGR, 2010/11/12
		  if (source.axis !== 'enu') {
		    point = adjust_axis(source, false, point);
		  }
		  // Transform source points to long/lat, if they aren't already.
		  if (source.projName === 'longlat') {
		    point = {
		      x: point.x * D2R,
		      y: point.y * D2R
		    };
		  }
		  else {
		    if (source.to_meter) {
		      point = {
		        x: point.x * source.to_meter,
		        y: point.y * source.to_meter
		      };
		    }
		    point = source.inverse(point); // Convert Cartesian to longlat
		  }
		  // Adjust for the prime meridian if necessary
		  if (source.from_greenwich) {
		    point.x += source.from_greenwich;
		  }
	
		  // Convert datums if needed, and if possible.
		  point = datum_transform(source.datum, dest.datum, point);
	
		  // Adjust for the prime meridian if necessary
		  if (dest.from_greenwich) {
		    point = {
		      x: point.x - dest.from_greenwich,
		      y: point.y
		    };
		  }
	
		  if (dest.projName === 'longlat') {
		    // convert radians to decimal degrees
		    point = {
		      x: point.x * R2D,
		      y: point.y * R2D
		    };
		  } else { // else project
		    point = dest.forward(point);
		    if (dest.to_meter) {
		      point = {
		        x: point.x / dest.to_meter,
		        y: point.y / dest.to_meter
		      };
		    }
		  }
	
		  // DGR, 2010/11/12
		  if (dest.axis !== 'enu') {
		    return adjust_axis(dest, true, point);
		  }
	
		  return point;
		}
	
		var wgs84 = Projection$1('WGS84');
	
		function transformer(from, to, coords) {
		  var transformedArray;
		  if (Array.isArray(coords)) {
		    transformedArray = transform(from, to, coords);
		    if (coords.length === 3) {
		      return [transformedArray.x, transformedArray.y, transformedArray.z];
		    }
		    else {
		      return [transformedArray.x, transformedArray.y];
		    }
		  }
		  else {
		    return transform(from, to, coords);
		  }
		}
	
		function checkProj(item) {
		  if (item instanceof Projection$1) {
		    return item;
		  }
		  if (item.oProj) {
		    return item.oProj;
		  }
		  return Projection$1(item);
		}
		function proj4$1(fromProj, toProj, coord) {
		  fromProj = checkProj(fromProj);
		  var single = false;
		  var obj;
		  if (typeof toProj === 'undefined') {
		    toProj = fromProj;
		    fromProj = wgs84;
		    single = true;
		  }
		  else if (typeof toProj.x !== 'undefined' || Array.isArray(toProj)) {
		    coord = toProj;
		    toProj = fromProj;
		    fromProj = wgs84;
		    single = true;
		  }
		  toProj = checkProj(toProj);
		  if (coord) {
		    return transformer(fromProj, toProj, coord);
		  }
		  else {
		    obj = {
		      forward: function(coords) {
		        return transformer(fromProj, toProj, coords);
		      },
		      inverse: function(coords) {
		        return transformer(toProj, fromProj, coords);
		      }
		    };
		    if (single) {
		      obj.oProj = toProj;
		    }
		    return obj;
		  }
		}
	
		/**
		 * UTM zones are grouped, and assigned to one of a group of 6
		 * sets.
		 *
		 * {int} @private
		 */
		var NUM_100K_SETS = 6;
	
		/**
		 * The column letters (for easting) of the lower left value, per
		 * set.
		 *
		 * {string} @private
		 */
		var SET_ORIGIN_COLUMN_LETTERS = 'AJSAJS';
	
		/**
		 * The row letters (for northing) of the lower left value, per
		 * set.
		 *
		 * {string} @private
		 */
		var SET_ORIGIN_ROW_LETTERS = 'AFAFAF';
	
		var A = 65; // A
		var I = 73; // I
		var O = 79; // O
		var V = 86; // V
		var Z = 90; // Z
		var mgrs = {
		  forward: forward$1,
		  inverse: inverse$1,
		  toPoint: toPoint$1
		};
		/**
		 * Conversion of lat/lon to MGRS.
		 *
		 * @param {object} ll Object literal with lat and lon properties on a
		 *     WGS84 ellipsoid.
		 * @param {int} accuracy Accuracy in digits (5 for 1 m, 4 for 10 m, 3 for
		 *      100 m, 2 for 1000 m or 1 for 10000 m). Optional, default is 5.
		 * @return {string} the MGRS string for the given location and accuracy.
		 */
		function forward$1(ll, accuracy) {
		  accuracy = accuracy || 5; // default accuracy 1m
		  return encode(LLtoUTM({
		    lat: ll[1],
		    lon: ll[0]
		  }), accuracy);
		}
	
		/**
		 * Conversion of MGRS to lat/lon.
		 *
		 * @param {string} mgrs MGRS string.
		 * @return {array} An array with left (longitude), bottom (latitude), right
		 *     (longitude) and top (latitude) values in WGS84, representing the
		 *     bounding box for the provided MGRS reference.
		 */
		function inverse$1(mgrs) {
		  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
		  if (bbox.lat && bbox.lon) {
		    return [bbox.lon, bbox.lat, bbox.lon, bbox.lat];
		  }
		  return [bbox.left, bbox.bottom, bbox.right, bbox.top];
		}
	
		function toPoint$1(mgrs) {
		  var bbox = UTMtoLL(decode(mgrs.toUpperCase()));
		  if (bbox.lat && bbox.lon) {
		    return [bbox.lon, bbox.lat];
		  }
		  return [(bbox.left + bbox.right) / 2, (bbox.top + bbox.bottom) / 2];
		}
		/**
		 * Conversion from degrees to radians.
		 *
		 * @private
		 * @param {number} deg the angle in degrees.
		 * @return {number} the angle in radians.
		 */
		function degToRad(deg) {
		  return (deg * (Math.PI / 180.0));
		}
	
		/**
		 * Conversion from radians to degrees.
		 *
		 * @private
		 * @param {number} rad the angle in radians.
		 * @return {number} the angle in degrees.
		 */
		function radToDeg(rad) {
		  return (180.0 * (rad / Math.PI));
		}
	
		/**
		 * Converts a set of Longitude and Latitude co-ordinates to UTM
		 * using the WGS84 ellipsoid.
		 *
		 * @private
		 * @param {object} ll Object literal with lat and lon properties
		 *     representing the WGS84 coordinate to be converted.
		 * @return {object} Object literal containing the UTM value with easting,
		 *     northing, zoneNumber and zoneLetter properties, and an optional
		 *     accuracy property in digits. Returns null if the conversion failed.
		 */
		function LLtoUTM(ll) {
		  var Lat = ll.lat;
		  var Long = ll.lon;
		  var a = 6378137.0; //ellip.radius;
		  var eccSquared = 0.00669438; //ellip.eccsq;
		  var k0 = 0.9996;
		  var LongOrigin;
		  var eccPrimeSquared;
		  var N, T, C, A, M;
		  var LatRad = degToRad(Lat);
		  var LongRad = degToRad(Long);
		  var LongOriginRad;
		  var ZoneNumber;
		  // (int)
		  ZoneNumber = Math.floor((Long + 180) / 6) + 1;
	
		  //Make sure the longitude 180.00 is in Zone 60
		  if (Long === 180) {
		    ZoneNumber = 60;
		  }
	
		  // Special zone for Norway
		  if (Lat >= 56.0 && Lat < 64.0 && Long >= 3.0 && Long < 12.0) {
		    ZoneNumber = 32;
		  }
	
		  // Special zones for Svalbard
		  if (Lat >= 72.0 && Lat < 84.0) {
		    if (Long >= 0.0 && Long < 9.0) {
		      ZoneNumber = 31;
		    }
		    else if (Long >= 9.0 && Long < 21.0) {
		      ZoneNumber = 33;
		    }
		    else if (Long >= 21.0 && Long < 33.0) {
		      ZoneNumber = 35;
		    }
		    else if (Long >= 33.0 && Long < 42.0) {
		      ZoneNumber = 37;
		    }
		  }
	
		  LongOrigin = (ZoneNumber - 1) * 6 - 180 + 3; //+3 puts origin
		  // in middle of
		  // zone
		  LongOriginRad = degToRad(LongOrigin);
	
		  eccPrimeSquared = (eccSquared) / (1 - eccSquared);
	
		  N = a / Math.sqrt(1 - eccSquared * Math.sin(LatRad) * Math.sin(LatRad));
		  T = Math.tan(LatRad) * Math.tan(LatRad);
		  C = eccPrimeSquared * Math.cos(LatRad) * Math.cos(LatRad);
		  A = Math.cos(LatRad) * (LongRad - LongOriginRad);
	
		  M = a * ((1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256) * LatRad - (3 * eccSquared / 8 + 3 * eccSquared * eccSquared / 32 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(2 * LatRad) + (15 * eccSquared * eccSquared / 256 + 45 * eccSquared * eccSquared * eccSquared / 1024) * Math.sin(4 * LatRad) - (35 * eccSquared * eccSquared * eccSquared / 3072) * Math.sin(6 * LatRad));
	
		  var UTMEasting = (k0 * N * (A + (1 - T + C) * A * A * A / 6.0 + (5 - 18 * T + T * T + 72 * C - 58 * eccPrimeSquared) * A * A * A * A * A / 120.0) + 500000.0);
	
		  var UTMNorthing = (k0 * (M + N * Math.tan(LatRad) * (A * A / 2 + (5 - T + 9 * C + 4 * C * C) * A * A * A * A / 24.0 + (61 - 58 * T + T * T + 600 * C - 330 * eccPrimeSquared) * A * A * A * A * A * A / 720.0)));
		  if (Lat < 0.0) {
		    UTMNorthing += 10000000.0; //10000000 meter offset for
		    // southern hemisphere
		  }
	
		  return {
		    northing: Math.round(UTMNorthing),
		    easting: Math.round(UTMEasting),
		    zoneNumber: ZoneNumber,
		    zoneLetter: getLetterDesignator(Lat)
		  };
		}
	
		/**
		 * Converts UTM coords to lat/long, using the WGS84 ellipsoid. This is a convenience
		 * class where the Zone can be specified as a single string eg."60N" which
		 * is then broken down into the ZoneNumber and ZoneLetter.
		 *
		 * @private
		 * @param {object} utm An object literal with northing, easting, zoneNumber
		 *     and zoneLetter properties. If an optional accuracy property is
		 *     provided (in meters), a bounding box will be returned instead of
		 *     latitude and longitude.
		 * @return {object} An object literal containing either lat and lon values
		 *     (if no accuracy was provided), or top, right, bottom and left values
		 *     for the bounding box calculated according to the provided accuracy.
		 *     Returns null if the conversion failed.
		 */
		function UTMtoLL(utm) {
	
		  var UTMNorthing = utm.northing;
		  var UTMEasting = utm.easting;
		  var zoneLetter = utm.zoneLetter;
		  var zoneNumber = utm.zoneNumber;
		  // check the ZoneNummber is valid
		  if (zoneNumber < 0 || zoneNumber > 60) {
		    return null;
		  }
	
		  var k0 = 0.9996;
		  var a = 6378137.0; //ellip.radius;
		  var eccSquared = 0.00669438; //ellip.eccsq;
		  var eccPrimeSquared;
		  var e1 = (1 - Math.sqrt(1 - eccSquared)) / (1 + Math.sqrt(1 - eccSquared));
		  var N1, T1, C1, R1, D, M;
		  var LongOrigin;
		  var mu, phi1Rad;
	
		  // remove 500,000 meter offset for longitude
		  var x = UTMEasting - 500000.0;
		  var y = UTMNorthing;
	
		  // We must know somehow if we are in the Northern or Southern
		  // hemisphere, this is the only time we use the letter So even
		  // if the Zone letter isn't exactly correct it should indicate
		  // the hemisphere correctly
		  if (zoneLetter < 'N') {
		    y -= 10000000.0; // remove 10,000,000 meter offset used
		    // for southern hemisphere
		  }
	
		  // There are 60 zones with zone 1 being at West -180 to -174
		  LongOrigin = (zoneNumber - 1) * 6 - 180 + 3; // +3 puts origin
		  // in middle of
		  // zone
	
		  eccPrimeSquared = (eccSquared) / (1 - eccSquared);
	
		  M = y / k0;
		  mu = M / (a * (1 - eccSquared / 4 - 3 * eccSquared * eccSquared / 64 - 5 * eccSquared * eccSquared * eccSquared / 256));
	
		  phi1Rad = mu + (3 * e1 / 2 - 27 * e1 * e1 * e1 / 32) * Math.sin(2 * mu) + (21 * e1 * e1 / 16 - 55 * e1 * e1 * e1 * e1 / 32) * Math.sin(4 * mu) + (151 * e1 * e1 * e1 / 96) * Math.sin(6 * mu);
		  // double phi1 = ProjMath.radToDeg(phi1Rad);
	
		  N1 = a / Math.sqrt(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad));
		  T1 = Math.tan(phi1Rad) * Math.tan(phi1Rad);
		  C1 = eccPrimeSquared * Math.cos(phi1Rad) * Math.cos(phi1Rad);
		  R1 = a * (1 - eccSquared) / Math.pow(1 - eccSquared * Math.sin(phi1Rad) * Math.sin(phi1Rad), 1.5);
		  D = x / (N1 * k0);
	
		  var lat = phi1Rad - (N1 * Math.tan(phi1Rad) / R1) * (D * D / 2 - (5 + 3 * T1 + 10 * C1 - 4 * C1 * C1 - 9 * eccPrimeSquared) * D * D * D * D / 24 + (61 + 90 * T1 + 298 * C1 + 45 * T1 * T1 - 252 * eccPrimeSquared - 3 * C1 * C1) * D * D * D * D * D * D / 720);
		  lat = radToDeg(lat);
	
		  var lon = (D - (1 + 2 * T1 + C1) * D * D * D / 6 + (5 - 2 * C1 + 28 * T1 - 3 * C1 * C1 + 8 * eccPrimeSquared + 24 * T1 * T1) * D * D * D * D * D / 120) / Math.cos(phi1Rad);
		  lon = LongOrigin + radToDeg(lon);
	
		  var result;
		  if (utm.accuracy) {
		    var topRight = UTMtoLL({
		      northing: utm.northing + utm.accuracy,
		      easting: utm.easting + utm.accuracy,
		      zoneLetter: utm.zoneLetter,
		      zoneNumber: utm.zoneNumber
		    });
		    result = {
		      top: topRight.lat,
		      right: topRight.lon,
		      bottom: lat,
		      left: lon
		    };
		  }
		  else {
		    result = {
		      lat: lat,
		      lon: lon
		    };
		  }
		  return result;
		}
	
		/**
		 * Calculates the MGRS letter designator for the given latitude.
		 *
		 * @private
		 * @param {number} lat The latitude in WGS84 to get the letter designator
		 *     for.
		 * @return {char} The letter designator.
		 */
		function getLetterDesignator(lat) {
		  //This is here as an error flag to show that the Latitude is
		  //outside MGRS limits
		  var LetterDesignator = 'Z';
	
		  if ((84 >= lat) && (lat >= 72)) {
		    LetterDesignator = 'X';
		  }
		  else if ((72 > lat) && (lat >= 64)) {
		    LetterDesignator = 'W';
		  }
		  else if ((64 > lat) && (lat >= 56)) {
		    LetterDesignator = 'V';
		  }
		  else if ((56 > lat) && (lat >= 48)) {
		    LetterDesignator = 'U';
		  }
		  else if ((48 > lat) && (lat >= 40)) {
		    LetterDesignator = 'T';
		  }
		  else if ((40 > lat) && (lat >= 32)) {
		    LetterDesignator = 'S';
		  }
		  else if ((32 > lat) && (lat >= 24)) {
		    LetterDesignator = 'R';
		  }
		  else if ((24 > lat) && (lat >= 16)) {
		    LetterDesignator = 'Q';
		  }
		  else if ((16 > lat) && (lat >= 8)) {
		    LetterDesignator = 'P';
		  }
		  else if ((8 > lat) && (lat >= 0)) {
		    LetterDesignator = 'N';
		  }
		  else if ((0 > lat) && (lat >= -8)) {
		    LetterDesignator = 'M';
		  }
		  else if ((-8 > lat) && (lat >= -16)) {
		    LetterDesignator = 'L';
		  }
		  else if ((-16 > lat) && (lat >= -24)) {
		    LetterDesignator = 'K';
		  }
		  else if ((-24 > lat) && (lat >= -32)) {
		    LetterDesignator = 'J';
		  }
		  else if ((-32 > lat) && (lat >= -40)) {
		    LetterDesignator = 'H';
		  }
		  else if ((-40 > lat) && (lat >= -48)) {
		    LetterDesignator = 'G';
		  }
		  else if ((-48 > lat) && (lat >= -56)) {
		    LetterDesignator = 'F';
		  }
		  else if ((-56 > lat) && (lat >= -64)) {
		    LetterDesignator = 'E';
		  }
		  else if ((-64 > lat) && (lat >= -72)) {
		    LetterDesignator = 'D';
		  }
		  else if ((-72 > lat) && (lat >= -80)) {
		    LetterDesignator = 'C';
		  }
		  return LetterDesignator;
		}
	
		/**
		 * Encodes a UTM location as MGRS string.
		 *
		 * @private
		 * @param {object} utm An object literal with easting, northing,
		 *     zoneLetter, zoneNumber
		 * @param {number} accuracy Accuracy in digits (1-5).
		 * @return {string} MGRS string for the given UTM location.
		 */
		function encode(utm, accuracy) {
		  // prepend with leading zeroes
		  var seasting = "00000" + utm.easting,
		    snorthing = "00000" + utm.northing;
	
		  return utm.zoneNumber + utm.zoneLetter + get100kID(utm.easting, utm.northing, utm.zoneNumber) + seasting.substr(seasting.length - 5, accuracy) + snorthing.substr(snorthing.length - 5, accuracy);
		}
	
		/**
		 * Get the two letter 100k designator for a given UTM easting,
		 * northing and zone number value.
		 *
		 * @private
		 * @param {number} easting
		 * @param {number} northing
		 * @param {number} zoneNumber
		 * @return the two letter 100k designator for the given UTM location.
		 */
		function get100kID(easting, northing, zoneNumber) {
		  var setParm = get100kSetForZone(zoneNumber);
		  var setColumn = Math.floor(easting / 100000);
		  var setRow = Math.floor(northing / 100000) % 20;
		  return getLetter100kID(setColumn, setRow, setParm);
		}
	
		/**
		 * Given a UTM zone number, figure out the MGRS 100K set it is in.
		 *
		 * @private
		 * @param {number} i An UTM zone number.
		 * @return {number} the 100k set the UTM zone is in.
		 */
		function get100kSetForZone(i) {
		  var setParm = i % NUM_100K_SETS;
		  if (setParm === 0) {
		    setParm = NUM_100K_SETS;
		  }
	
		  return setParm;
		}
	
		/**
		 * Get the two-letter MGRS 100k designator given information
		 * translated from the UTM northing, easting and zone number.
		 *
		 * @private
		 * @param {number} column the column index as it relates to the MGRS
		 *        100k set spreadsheet, created from the UTM easting.
		 *        Values are 1-8.
		 * @param {number} row the row index as it relates to the MGRS 100k set
		 *        spreadsheet, created from the UTM northing value. Values
		 *        are from 0-19.
		 * @param {number} parm the set block, as it relates to the MGRS 100k set
		 *        spreadsheet, created from the UTM zone. Values are from
		 *        1-60.
		 * @return two letter MGRS 100k code.
		 */
		function getLetter100kID(column, row, parm) {
		  // colOrigin and rowOrigin are the letters at the origin of the set
		  var index = parm - 1;
		  var colOrigin = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(index);
		  var rowOrigin = SET_ORIGIN_ROW_LETTERS.charCodeAt(index);
	
		  // colInt and rowInt are the letters to build to return
		  var colInt = colOrigin + column - 1;
		  var rowInt = rowOrigin + row;
		  var rollover = false;
	
		  if (colInt > Z) {
		    colInt = colInt - Z + A - 1;
		    rollover = true;
		  }
	
		  if (colInt === I || (colOrigin < I && colInt > I) || ((colInt > I || colOrigin < I) && rollover)) {
		    colInt++;
		  }
	
		  if (colInt === O || (colOrigin < O && colInt > O) || ((colInt > O || colOrigin < O) && rollover)) {
		    colInt++;
	
		    if (colInt === I) {
		      colInt++;
		    }
		  }
	
		  if (colInt > Z) {
		    colInt = colInt - Z + A - 1;
		  }
	
		  if (rowInt > V) {
		    rowInt = rowInt - V + A - 1;
		    rollover = true;
		  }
		  else {
		    rollover = false;
		  }
	
		  if (((rowInt === I) || ((rowOrigin < I) && (rowInt > I))) || (((rowInt > I) || (rowOrigin < I)) && rollover)) {
		    rowInt++;
		  }
	
		  if (((rowInt === O) || ((rowOrigin < O) && (rowInt > O))) || (((rowInt > O) || (rowOrigin < O)) && rollover)) {
		    rowInt++;
	
		    if (rowInt === I) {
		      rowInt++;
		    }
		  }
	
		  if (rowInt > V) {
		    rowInt = rowInt - V + A - 1;
		  }
	
		  var twoLetter = String.fromCharCode(colInt) + String.fromCharCode(rowInt);
		  return twoLetter;
		}
	
		/**
		 * Decode the UTM parameters from a MGRS string.
		 *
		 * @private
		 * @param {string} mgrsString an UPPERCASE coordinate string is expected.
		 * @return {object} An object literal with easting, northing, zoneLetter,
		 *     zoneNumber and accuracy (in meters) properties.
		 */
		function decode(mgrsString) {
	
		  if (mgrsString && mgrsString.length === 0) {
		    throw ("MGRSPoint coverting from nothing");
		  }
	
		  var length = mgrsString.length;
	
		  var hunK = null;
		  var sb = "";
		  var testChar;
		  var i = 0;
	
		  // get Zone number
		  while (!(/[A-Z]/).test(testChar = mgrsString.charAt(i))) {
		    if (i >= 2) {
		      throw ("MGRSPoint bad conversion from: " + mgrsString);
		    }
		    sb += testChar;
		    i++;
		  }
	
		  var zoneNumber = parseInt(sb, 10);
	
		  if (i === 0 || i + 3 > length) {
		    // A good MGRS string has to be 4-5 digits long,
		    // ##AAA/#AAA at least.
		    throw ("MGRSPoint bad conversion from: " + mgrsString);
		  }
	
		  var zoneLetter = mgrsString.charAt(i++);
	
		  // Should we check the zone letter here? Why not.
		  if (zoneLetter <= 'A' || zoneLetter === 'B' || zoneLetter === 'Y' || zoneLetter >= 'Z' || zoneLetter === 'I' || zoneLetter === 'O') {
		    throw ("MGRSPoint zone letter " + zoneLetter + " not handled: " + mgrsString);
		  }
	
		  hunK = mgrsString.substring(i, i += 2);
	
		  var set = get100kSetForZone(zoneNumber);
	
		  var east100k = getEastingFromChar(hunK.charAt(0), set);
		  var north100k = getNorthingFromChar(hunK.charAt(1), set);
	
		  // We have a bug where the northing may be 2000000 too low.
		  // How
		  // do we know when to roll over?
	
		  while (north100k < getMinNorthing(zoneLetter)) {
		    north100k += 2000000;
		  }
	
		  // calculate the char index for easting/northing separator
		  var remainder = length - i;
	
		  if (remainder % 2 !== 0) {
		    throw ("MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters" + mgrsString);
		  }
	
		  var sep = remainder / 2;
	
		  var sepEasting = 0.0;
		  var sepNorthing = 0.0;
		  var accuracyBonus, sepEastingString, sepNorthingString, easting, northing;
		  if (sep > 0) {
		    accuracyBonus = 100000.0 / Math.pow(10, sep);
		    sepEastingString = mgrsString.substring(i, i + sep);
		    sepEasting = parseFloat(sepEastingString) * accuracyBonus;
		    sepNorthingString = mgrsString.substring(i + sep);
		    sepNorthing = parseFloat(sepNorthingString) * accuracyBonus;
		  }
	
		  easting = sepEasting + east100k;
		  northing = sepNorthing + north100k;
	
		  return {
		    easting: easting,
		    northing: northing,
		    zoneLetter: zoneLetter,
		    zoneNumber: zoneNumber,
		    accuracy: accuracyBonus
		  };
		}
	
		/**
		 * Given the first letter from a two-letter MGRS 100k zone, and given the
		 * MGRS table set for the zone number, figure out the easting value that
		 * should be added to the other, secondary easting value.
		 *
		 * @private
		 * @param {char} e The first letter from a two-letter MGRS 100´k zone.
		 * @param {number} set The MGRS table set for the zone number.
		 * @return {number} The easting value for the given letter and set.
		 */
		function getEastingFromChar(e, set) {
		  // colOrigin is the letter at the origin of the set for the
		  // column
		  var curCol = SET_ORIGIN_COLUMN_LETTERS.charCodeAt(set - 1);
		  var eastingValue = 100000.0;
		  var rewindMarker = false;
	
		  while (curCol !== e.charCodeAt(0)) {
		    curCol++;
		    if (curCol === I) {
		      curCol++;
		    }
		    if (curCol === O) {
		      curCol++;
		    }
		    if (curCol > Z) {
		      if (rewindMarker) {
		        throw ("Bad character: " + e);
		      }
		      curCol = A;
		      rewindMarker = true;
		    }
		    eastingValue += 100000.0;
		  }
	
		  return eastingValue;
		}
	
		/**
		 * Given the second letter from a two-letter MGRS 100k zone, and given the
		 * MGRS table set for the zone number, figure out the northing value that
		 * should be added to the other, secondary northing value. You have to
		 * remember that Northings are determined from the equator, and the vertical
		 * cycle of letters mean a 2000000 additional northing meters. This happens
		 * approx. every 18 degrees of latitude. This method does *NOT* count any
		 * additional northings. You have to figure out how many 2000000 meters need
		 * to be added for the zone letter of the MGRS coordinate.
		 *
		 * @private
		 * @param {char} n Second letter of the MGRS 100k zone
		 * @param {number} set The MGRS table set number, which is dependent on the
		 *     UTM zone number.
		 * @return {number} The northing value for the given letter and set.
		 */
		function getNorthingFromChar(n, set) {
	
		  if (n > 'V') {
		    throw ("MGRSPoint given invalid Northing " + n);
		  }
	
		  // rowOrigin is the letter at the origin of the set for the
		  // column
		  var curRow = SET_ORIGIN_ROW_LETTERS.charCodeAt(set - 1);
		  var northingValue = 0.0;
		  var rewindMarker = false;
	
		  while (curRow !== n.charCodeAt(0)) {
		    curRow++;
		    if (curRow === I) {
		      curRow++;
		    }
		    if (curRow === O) {
		      curRow++;
		    }
		    // fixing a bug making whole application hang in this loop
		    // when 'n' is a wrong character
		    if (curRow > V) {
		      if (rewindMarker) { // making sure that this loop ends
		        throw ("Bad character: " + n);
		      }
		      curRow = A;
		      rewindMarker = true;
		    }
		    northingValue += 100000.0;
		  }
	
		  return northingValue;
		}
	
		/**
		 * The function getMinNorthing returns the minimum northing value of a MGRS
		 * zone.
		 *
		 * Ported from Geotrans' c Lattitude_Band_Value structure table.
		 *
		 * @private
		 * @param {char} zoneLetter The MGRS zone to get the min northing for.
		 * @return {number}
		 */
		function getMinNorthing(zoneLetter) {
		  var northing;
		  switch (zoneLetter) {
		  case 'C':
		    northing = 1100000.0;
		    break;
		  case 'D':
		    northing = 2000000.0;
		    break;
		  case 'E':
		    northing = 2800000.0;
		    break;
		  case 'F':
		    northing = 3700000.0;
		    break;
		  case 'G':
		    northing = 4600000.0;
		    break;
		  case 'H':
		    northing = 5500000.0;
		    break;
		  case 'J':
		    northing = 6400000.0;
		    break;
		  case 'K':
		    northing = 7300000.0;
		    break;
		  case 'L':
		    northing = 8200000.0;
		    break;
		  case 'M':
		    northing = 9100000.0;
		    break;
		  case 'N':
		    northing = 0.0;
		    break;
		  case 'P':
		    northing = 800000.0;
		    break;
		  case 'Q':
		    northing = 1700000.0;
		    break;
		  case 'R':
		    northing = 2600000.0;
		    break;
		  case 'S':
		    northing = 3500000.0;
		    break;
		  case 'T':
		    northing = 4400000.0;
		    break;
		  case 'U':
		    northing = 5300000.0;
		    break;
		  case 'V':
		    northing = 6200000.0;
		    break;
		  case 'W':
		    northing = 7000000.0;
		    break;
		  case 'X':
		    northing = 7900000.0;
		    break;
		  default:
		    northing = -1.0;
		  }
		  if (northing >= 0.0) {
		    return northing;
		  }
		  else {
		    throw ("Invalid zone letter: " + zoneLetter);
		  }
	
		}
	
		function Point(x, y, z) {
		  if (!(this instanceof Point)) {
		    return new Point(x, y, z);
		  }
		  if (Array.isArray(x)) {
		    this.x = x[0];
		    this.y = x[1];
		    this.z = x[2] || 0.0;
		  } else if(typeof x === 'object') {
		    this.x = x.x;
		    this.y = x.y;
		    this.z = x.z || 0.0;
		  } else if (typeof x === 'string' && typeof y === 'undefined') {
		    var coords = x.split(',');
		    this.x = parseFloat(coords[0], 10);
		    this.y = parseFloat(coords[1], 10);
		    this.z = parseFloat(coords[2], 10) || 0.0;
		  } else {
		    this.x = x;
		    this.y = y;
		    this.z = z || 0.0;
		  }
		  console.warn('proj4.Point will be removed in version 3, use proj4.toPoint');
		}
	
		Point.fromMGRS = function(mgrsStr) {
		  return new Point(toPoint$1(mgrsStr));
		};
		Point.prototype.toMGRS = function(accuracy) {
		  return forward$1([this.x, this.y], accuracy);
		};
	
		var version = "2.4.3";
	
		var C00 = 1;
		var C02 = 0.25;
		var C04 = 0.046875;
		var C06 = 0.01953125;
		var C08 = 0.01068115234375;
		var C22 = 0.75;
		var C44 = 0.46875;
		var C46 = 0.01302083333333333333;
		var C48 = 0.00712076822916666666;
		var C66 = 0.36458333333333333333;
		var C68 = 0.00569661458333333333;
		var C88 = 0.3076171875;
	
		var pj_enfn = function(es) {
		  var en = [];
		  en[0] = C00 - es * (C02 + es * (C04 + es * (C06 + es * C08)));
		  en[1] = es * (C22 - es * (C04 + es * (C06 + es * C08)));
		  var t = es * es;
		  en[2] = t * (C44 - es * (C46 + es * C48));
		  t *= es;
		  en[3] = t * (C66 - es * C68);
		  en[4] = t * es * C88;
		  return en;
		};
	
		var pj_mlfn = function(phi, sphi, cphi, en) {
		  cphi *= sphi;
		  sphi *= sphi;
		  return (en[0] * phi - cphi * (en[1] + sphi * (en[2] + sphi * (en[3] + sphi * en[4]))));
		};
	
		var MAX_ITER = 20;
	
		var pj_inv_mlfn = function(arg, es, en) {
		  var k = 1 / (1 - es);
		  var phi = arg;
		  for (var i = MAX_ITER; i; --i) { /* rarely goes over 2 iterations */
		    var s = Math.sin(phi);
		    var t = 1 - es * s * s;
		    //t = this.pj_mlfn(phi, s, Math.cos(phi), en) - arg;
		    //phi -= t * (t * Math.sqrt(t)) * k;
		    t = (pj_mlfn(phi, s, Math.cos(phi), en) - arg) * (t * Math.sqrt(t)) * k;
		    phi -= t;
		    if (Math.abs(t) < EPSLN) {
		      return phi;
		    }
		  }
		  //..reportError("cass:pj_inv_mlfn: Convergence error");
		  return phi;
		};
	
		// Heavily based on this tmerc projection implementation
		// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/tmerc.js
	
		function init$2() {
		  this.x0 = this.x0 !== undefined ? this.x0 : 0;
		  this.y0 = this.y0 !== undefined ? this.y0 : 0;
		  this.long0 = this.long0 !== undefined ? this.long0 : 0;
		  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;
	
		  if (this.es) {
		    this.en = pj_enfn(this.es);
		    this.ml0 = pj_mlfn(this.lat0, Math.sin(this.lat0), Math.cos(this.lat0), this.en);
		  }
		}
	
		/**
		    Transverse Mercator Forward  - long/lat to x/y
		    long/lat in radians
		  */
		function forward$2(p) {
		  var lon = p.x;
		  var lat = p.y;
	
		  var delta_lon = adjust_lon(lon - this.long0);
		  var con;
		  var x, y;
		  var sin_phi = Math.sin(lat);
		  var cos_phi = Math.cos(lat);
	
		  if (!this.es) {
		    var b = cos_phi * Math.sin(delta_lon);
	
		    if ((Math.abs(Math.abs(b) - 1)) < EPSLN) {
		      return (93);
		    }
		    else {
		      x = 0.5 * this.a * this.k0 * Math.log((1 + b) / (1 - b)) + this.x0;
		      y = cos_phi * Math.cos(delta_lon) / Math.sqrt(1 - Math.pow(b, 2));
		      b = Math.abs(y);
	
		      if (b >= 1) {
		        if ((b - 1) > EPSLN) {
		          return (93);
		        }
		        else {
		          y = 0;
		        }
		      }
		      else {
		        y = Math.acos(y);
		      }
	
		      if (lat < 0) {
		        y = -y;
		      }
	
		      y = this.a * this.k0 * (y - this.lat0) + this.y0;
		    }
		  }
		  else {
		    var al = cos_phi * delta_lon;
		    var als = Math.pow(al, 2);
		    var c = this.ep2 * Math.pow(cos_phi, 2);
		    var cs = Math.pow(c, 2);
		    var tq = Math.abs(cos_phi) > EPSLN ? Math.tan(lat) : 0;
		    var t = Math.pow(tq, 2);
		    var ts = Math.pow(t, 2);
		    con = 1 - this.es * Math.pow(sin_phi, 2);
		    al = al / Math.sqrt(con);
		    var ml = pj_mlfn(lat, sin_phi, cos_phi, this.en);
	
		    x = this.a * (this.k0 * al * (1 +
		      als / 6 * (1 - t + c +
		      als / 20 * (5 - 18 * t + ts + 14 * c - 58 * t * c +
		      als / 42 * (61 + 179 * ts - ts * t - 479 * t))))) +
		      this.x0;
	
		    y = this.a * (this.k0 * (ml - this.ml0 +
		      sin_phi * delta_lon * al / 2 * (1 +
		      als / 12 * (5 - t + 9 * c + 4 * cs +
		      als / 30 * (61 + ts - 58 * t + 270 * c - 330 * t * c +
		      als / 56 * (1385 + 543 * ts - ts * t - 3111 * t)))))) +
		      this.y0;
		  }
	
		  p.x = x;
		  p.y = y;
	
		  return p;
		}
	
		/**
		    Transverse Mercator Inverse  -  x/y to long/lat
		  */
		function inverse$2(p) {
		  var con, phi;
		  var lat, lon;
		  var x = (p.x - this.x0) * (1 / this.a);
		  var y = (p.y - this.y0) * (1 / this.a);
	
		  if (!this.es) {
		    var f = Math.exp(x / this.k0);
		    var g = 0.5 * (f - 1 / f);
		    var temp = this.lat0 + y / this.k0;
		    var h = Math.cos(temp);
		    con = Math.sqrt((1 - Math.pow(h, 2)) / (1 + Math.pow(g, 2)));
		    lat = Math.asin(con);
	
		    if (y < 0) {
		      lat = -lat;
		    }
	
		    if ((g === 0) && (h === 0)) {
		      lon = 0;
		    }
		    else {
		      lon = adjust_lon(Math.atan2(g, h) + this.long0);
		    }
		  }
		  else { // ellipsoidal form
		    con = this.ml0 + y / this.k0;
		    phi = pj_inv_mlfn(con, this.es, this.en);
	
		    if (Math.abs(phi) < HALF_PI) {
		      var sin_phi = Math.sin(phi);
		      var cos_phi = Math.cos(phi);
		      var tan_phi = Math.abs(cos_phi) > EPSLN ? Math.tan(phi) : 0;
		      var c = this.ep2 * Math.pow(cos_phi, 2);
		      var cs = Math.pow(c, 2);
		      var t = Math.pow(tan_phi, 2);
		      var ts = Math.pow(t, 2);
		      con = 1 - this.es * Math.pow(sin_phi, 2);
		      var d = x * Math.sqrt(con) / this.k0;
		      var ds = Math.pow(d, 2);
		      con = con * tan_phi;
	
		      lat = phi - (con * ds / (1 - this.es)) * 0.5 * (1 -
		        ds / 12 * (5 + 3 * t - 9 * c * t + c - 4 * cs -
		        ds / 30 * (61 + 90 * t - 252 * c * t + 45 * ts + 46 * c -
		        ds / 56 * (1385 + 3633 * t + 4095 * ts + 1574 * ts * t))));
	
		      lon = adjust_lon(this.long0 + (d * (1 -
		        ds / 6 * (1 + 2 * t + c -
		        ds / 20 * (5 + 28 * t + 24 * ts + 8 * c * t + 6 * c -
		        ds / 42 * (61 + 662 * t + 1320 * ts + 720 * ts * t)))) / cos_phi));
		    }
		    else {
		      lat = HALF_PI * sign(y);
		      lon = 0;
		    }
		  }
	
		  p.x = lon;
		  p.y = lat;
	
		  return p;
		}
	
		var names$3 = ["Transverse_Mercator", "Transverse Mercator", "tmerc"];
		var tmerc = {
		  init: init$2,
		  forward: forward$2,
		  inverse: inverse$2,
		  names: names$3
		};
	
		var sinh = function(x) {
		  var r = Math.exp(x);
		  r = (r - 1 / r) / 2;
		  return r;
		};
	
		var hypot = function(x, y) {
		  x = Math.abs(x);
		  y = Math.abs(y);
		  var a = Math.max(x, y);
		  var b = Math.min(x, y) / (a ? a : 1);
	
		  return a * Math.sqrt(1 + Math.pow(b, 2));
		};
	
		var log1py = function(x) {
		  var y = 1 + x;
		  var z = y - 1;
	
		  return z === 0 ? x : x * Math.log(y) / z;
		};
	
		var asinhy = function(x) {
		  var y = Math.abs(x);
		  y = log1py(y * (1 + y / (hypot(1, y) + 1)));
	
		  return x < 0 ? -y : y;
		};
	
		var gatg = function(pp, B) {
		  var cos_2B = 2 * Math.cos(2 * B);
		  var i = pp.length - 1;
		  var h1 = pp[i];
		  var h2 = 0;
		  var h;
	
		  while (--i >= 0) {
		    h = -h2 + cos_2B * h1 + pp[i];
		    h2 = h1;
		    h1 = h;
		  }
	
		  return (B + h * Math.sin(2 * B));
		};
	
		var clens = function(pp, arg_r) {
		  var r = 2 * Math.cos(arg_r);
		  var i = pp.length - 1;
		  var hr1 = pp[i];
		  var hr2 = 0;
		  var hr;
	
		  while (--i >= 0) {
		    hr = -hr2 + r * hr1 + pp[i];
		    hr2 = hr1;
		    hr1 = hr;
		  }
	
		  return Math.sin(arg_r) * hr;
		};
	
		var cosh = function(x) {
		  var r = Math.exp(x);
		  r = (r + 1 / r) / 2;
		  return r;
		};
	
		var clens_cmplx = function(pp, arg_r, arg_i) {
		  var sin_arg_r = Math.sin(arg_r);
		  var cos_arg_r = Math.cos(arg_r);
		  var sinh_arg_i = sinh(arg_i);
		  var cosh_arg_i = cosh(arg_i);
		  var r = 2 * cos_arg_r * cosh_arg_i;
		  var i = -2 * sin_arg_r * sinh_arg_i;
		  var j = pp.length - 1;
		  var hr = pp[j];
		  var hi1 = 0;
		  var hr1 = 0;
		  var hi = 0;
		  var hr2;
		  var hi2;
	
		  while (--j >= 0) {
		    hr2 = hr1;
		    hi2 = hi1;
		    hr1 = hr;
		    hi1 = hi;
		    hr = -hr2 + r * hr1 - i * hi1 + pp[j];
		    hi = -hi2 + i * hr1 + r * hi1;
		  }
	
		  r = sin_arg_r * cosh_arg_i;
		  i = cos_arg_r * sinh_arg_i;
	
		  return [r * hr - i * hi, r * hi + i * hr];
		};
	
		// Heavily based on this etmerc projection implementation
		// https://github.com/mbloch/mapshaper-proj/blob/master/src/projections/etmerc.js
	
		function init$3() {
		  if (this.es === undefined || this.es <= 0) {
		    throw new Error('incorrect elliptical usage');
		  }
	
		  this.x0 = this.x0 !== undefined ? this.x0 : 0;
		  this.y0 = this.y0 !== undefined ? this.y0 : 0;
		  this.long0 = this.long0 !== undefined ? this.long0 : 0;
		  this.lat0 = this.lat0 !== undefined ? this.lat0 : 0;
	
		  this.cgb = [];
		  this.cbg = [];
		  this.utg = [];
		  this.gtu = [];
	
		  var f = this.es / (1 + Math.sqrt(1 - this.es));
		  var n = f / (2 - f);
		  var np = n;
	
		  this.cgb[0] = n * (2 + n * (-2 / 3 + n * (-2 + n * (116 / 45 + n * (26 / 45 + n * (-2854 / 675 ))))));
		  this.cbg[0] = n * (-2 + n * ( 2 / 3 + n * ( 4 / 3 + n * (-82 / 45 + n * (32 / 45 + n * (4642 / 4725))))));
	
		  np = np * n;
		  this.cgb[1] = np * (7 / 3 + n * (-8 / 5 + n * (-227 / 45 + n * (2704 / 315 + n * (2323 / 945)))));
		  this.cbg[1] = np * (5 / 3 + n * (-16 / 15 + n * ( -13 / 9 + n * (904 / 315 + n * (-1522 / 945)))));
	
		  np = np * n;
		  this.cgb[2] = np * (56 / 15 + n * (-136 / 35 + n * (-1262 / 105 + n * (73814 / 2835))));
		  this.cbg[2] = np * (-26 / 15 + n * (34 / 21 + n * (8 / 5 + n * (-12686 / 2835))));
	
		  np = np * n;
		  this.cgb[3] = np * (4279 / 630 + n * (-332 / 35 + n * (-399572 / 14175)));
		  this.cbg[3] = np * (1237 / 630 + n * (-12 / 5 + n * ( -24832 / 14175)));
	
		  np = np * n;
		  this.cgb[4] = np * (4174 / 315 + n * (-144838 / 6237));
		  this.cbg[4] = np * (-734 / 315 + n * (109598 / 31185));
	
		  np = np * n;
		  this.cgb[5] = np * (601676 / 22275);
		  this.cbg[5] = np * (444337 / 155925);
	
		  np = Math.pow(n, 2);
		  this.Qn = this.k0 / (1 + n) * (1 + np * (1 / 4 + np * (1 / 64 + np / 256)));
	
		  this.utg[0] = n * (-0.5 + n * ( 2 / 3 + n * (-37 / 96 + n * ( 1 / 360 + n * (81 / 512 + n * (-96199 / 604800))))));
		  this.gtu[0] = n * (0.5 + n * (-2 / 3 + n * (5 / 16 + n * (41 / 180 + n * (-127 / 288 + n * (7891 / 37800))))));
	
		  this.utg[1] = np * (-1 / 48 + n * (-1 / 15 + n * (437 / 1440 + n * (-46 / 105 + n * (1118711 / 3870720)))));
		  this.gtu[1] = np * (13 / 48 + n * (-3 / 5 + n * (557 / 1440 + n * (281 / 630 + n * (-1983433 / 1935360)))));
	
		  np = np * n;
		  this.utg[2] = np * (-17 / 480 + n * (37 / 840 + n * (209 / 4480 + n * (-5569 / 90720 ))));
		  this.gtu[2] = np * (61 / 240 + n * (-103 / 140 + n * (15061 / 26880 + n * (167603 / 181440))));
	
		  np = np * n;
		  this.utg[3] = np * (-4397 / 161280 + n * (11 / 504 + n * (830251 / 7257600)));
		  this.gtu[3] = np * (49561 / 161280 + n * (-179 / 168 + n * (6601661 / 7257600)));
	
		  np = np * n;
		  this.utg[4] = np * (-4583 / 161280 + n * (108847 / 3991680));
		  this.gtu[4] = np * (34729 / 80640 + n * (-3418889 / 1995840));
	
		  np = np * n;
		  this.utg[5] = np * (-20648693 / 638668800);
		  this.gtu[5] = np * (212378941 / 319334400);
	
		  var Z = gatg(this.cbg, this.lat0);
		  this.Zb = -this.Qn * (Z + clens(this.gtu, 2 * Z));
		}
	
		function forward$3(p) {
		  var Ce = adjust_lon(p.x - this.long0);
		  var Cn = p.y;
	
		  Cn = gatg(this.cbg, Cn);
		  var sin_Cn = Math.sin(Cn);
		  var cos_Cn = Math.cos(Cn);
		  var sin_Ce = Math.sin(Ce);
		  var cos_Ce = Math.cos(Ce);
	
		  Cn = Math.atan2(sin_Cn, cos_Ce * cos_Cn);
		  Ce = Math.atan2(sin_Ce * cos_Cn, hypot(sin_Cn, cos_Cn * cos_Ce));
		  Ce = asinhy(Math.tan(Ce));
	
		  var tmp = clens_cmplx(this.gtu, 2 * Cn, 2 * Ce);
	
		  Cn = Cn + tmp[0];
		  Ce = Ce + tmp[1];
	
		  var x;
		  var y;
	
		  if (Math.abs(Ce) <= 2.623395162778) {
		    x = this.a * (this.Qn * Ce) + this.x0;
		    y = this.a * (this.Qn * Cn + this.Zb) + this.y0;
		  }
		  else {
		    x = Infinity;
		    y = Infinity;
		  }
	
		  p.x = x;
		  p.y = y;
	
		  return p;
		}
	
		function inverse$3(p) {
		  var Ce = (p.x - this.x0) * (1 / this.a);
		  var Cn = (p.y - this.y0) * (1 / this.a);
	
		  Cn = (Cn - this.Zb) / this.Qn;
		  Ce = Ce / this.Qn;
	
		  var lon;
		  var lat;
	
		  if (Math.abs(Ce) <= 2.623395162778) {
		    var tmp = clens_cmplx(this.utg, 2 * Cn, 2 * Ce);
	
		    Cn = Cn + tmp[0];
		    Ce = Ce + tmp[1];
		    Ce = Math.atan(sinh(Ce));
	
		    var sin_Cn = Math.sin(Cn);
		    var cos_Cn = Math.cos(Cn);
		    var sin_Ce = Math.sin(Ce);
		    var cos_Ce = Math.cos(Ce);
	
		    Cn = Math.atan2(sin_Cn * cos_Ce, hypot(sin_Ce, cos_Ce * cos_Cn));
		    Ce = Math.atan2(sin_Ce, cos_Ce * cos_Cn);
	
		    lon = adjust_lon(Ce + this.long0);
		    lat = gatg(this.cgb, Cn);
		  }
		  else {
		    lon = Infinity;
		    lat = Infinity;
		  }
	
		  p.x = lon;
		  p.y = lat;
	
		  return p;
		}
	
		var names$4 = ["Extended_Transverse_Mercator", "Extended Transverse Mercator", "etmerc"];
		var etmerc = {
		  init: init$3,
		  forward: forward$3,
		  inverse: inverse$3,
		  names: names$4
		};
	
		var adjust_zone = function(zone, lon) {
		  if (zone === undefined) {
		    zone = Math.floor((adjust_lon(lon) + Math.PI) * 30 / Math.PI) + 1;
	
		    if (zone < 0) {
		      return 0;
		    } else if (zone > 60) {
		      return 60;
		    }
		  }
		  return zone;
		};
	
		var dependsOn = 'etmerc';
		function init$4() {
		  var zone = adjust_zone(this.zone, this.long0);
		  if (zone === undefined) {
		    throw new Error('unknown utm zone');
		  }
		  this.lat0 = 0;
		  this.long0 =  ((6 * Math.abs(zone)) - 183) * D2R;
		  this.x0 = 500000;
		  this.y0 = this.utmSouth ? 10000000 : 0;
		  this.k0 = 0.9996;
	
		  etmerc.init.apply(this);
		  this.forward = etmerc.forward;
		  this.inverse = etmerc.inverse;
		}
	
		var names$5 = ["Universal Transverse Mercator System", "utm"];
		var utm = {
		  init: init$4,
		  names: names$5,
		  dependsOn: dependsOn
		};
	
		var srat = function(esinp, exp) {
		  return (Math.pow((1 - esinp) / (1 + esinp), exp));
		};
	
		var MAX_ITER$1 = 20;
		function init$6() {
		  var sphi = Math.sin(this.lat0);
		  var cphi = Math.cos(this.lat0);
		  cphi *= cphi;
		  this.rc = Math.sqrt(1 - this.es) / (1 - this.es * sphi * sphi);
		  this.C = Math.sqrt(1 + this.es * cphi * cphi / (1 - this.es));
		  this.phic0 = Math.asin(sphi / this.C);
		  this.ratexp = 0.5 * this.C * this.e;
		  this.K = Math.tan(0.5 * this.phic0 + FORTPI) / (Math.pow(Math.tan(0.5 * this.lat0 + FORTPI), this.C) * srat(this.e * sphi, this.ratexp));
		}
	
		function forward$5(p) {
		  var lon = p.x;
		  var lat = p.y;
	
		  p.y = 2 * Math.atan(this.K * Math.pow(Math.tan(0.5 * lat + FORTPI), this.C) * srat(this.e * Math.sin(lat), this.ratexp)) - HALF_PI;
		  p.x = this.C * lon;
		  return p;
		}
	
		function inverse$5(p) {
		  var DEL_TOL = 1e-14;
		  var lon = p.x / this.C;
		  var lat = p.y;
		  var num = Math.pow(Math.tan(0.5 * lat + FORTPI) / this.K, 1 / this.C);
		  for (var i = MAX_ITER$1; i > 0; --i) {
		    lat = 2 * Math.atan(num * srat(this.e * Math.sin(p.y), - 0.5 * this.e)) - HALF_PI;
		    if (Math.abs(lat - p.y) < DEL_TOL) {
		      break;
		    }
		    p.y = lat;
		  }
		  /* convergence failed */
		  if (!i) {
		    return null;
		  }
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$7 = ["gauss"];
		var gauss = {
		  init: init$6,
		  forward: forward$5,
		  inverse: inverse$5,
		  names: names$7
		};
	
		function init$5() {
		  gauss.init.apply(this);
		  if (!this.rc) {
		    return;
		  }
		  this.sinc0 = Math.sin(this.phic0);
		  this.cosc0 = Math.cos(this.phic0);
		  this.R2 = 2 * this.rc;
		  if (!this.title) {
		    this.title = "Oblique Stereographic Alternative";
		  }
		}
	
		function forward$4(p) {
		  var sinc, cosc, cosl, k;
		  p.x = adjust_lon(p.x - this.long0);
		  gauss.forward.apply(this, [p]);
		  sinc = Math.sin(p.y);
		  cosc = Math.cos(p.y);
		  cosl = Math.cos(p.x);
		  k = this.k0 * this.R2 / (1 + this.sinc0 * sinc + this.cosc0 * cosc * cosl);
		  p.x = k * cosc * Math.sin(p.x);
		  p.y = k * (this.cosc0 * sinc - this.sinc0 * cosc * cosl);
		  p.x = this.a * p.x + this.x0;
		  p.y = this.a * p.y + this.y0;
		  return p;
		}
	
		function inverse$4(p) {
		  var sinc, cosc, lon, lat, rho;
		  p.x = (p.x - this.x0) / this.a;
		  p.y = (p.y - this.y0) / this.a;
	
		  p.x /= this.k0;
		  p.y /= this.k0;
		  if ((rho = Math.sqrt(p.x * p.x + p.y * p.y))) {
		    var c = 2 * Math.atan2(rho, this.R2);
		    sinc = Math.sin(c);
		    cosc = Math.cos(c);
		    lat = Math.asin(cosc * this.sinc0 + p.y * sinc * this.cosc0 / rho);
		    lon = Math.atan2(p.x * sinc, rho * this.cosc0 * cosc - p.y * this.sinc0 * sinc);
		  }
		  else {
		    lat = this.phic0;
		    lon = 0;
		  }
	
		  p.x = lon;
		  p.y = lat;
		  gauss.inverse.apply(this, [p]);
		  p.x = adjust_lon(p.x + this.long0);
		  return p;
		}
	
		var names$6 = ["Stereographic_North_Pole", "Oblique_Stereographic", "Polar_Stereographic", "sterea","Oblique Stereographic Alternative"];
		var sterea = {
		  init: init$5,
		  forward: forward$4,
		  inverse: inverse$4,
		  names: names$6
		};
	
		function ssfn_(phit, sinphi, eccen) {
		  sinphi *= eccen;
		  return (Math.tan(0.5 * (HALF_PI + phit)) * Math.pow((1 - sinphi) / (1 + sinphi), 0.5 * eccen));
		}
	
		function init$7() {
		  this.coslat0 = Math.cos(this.lat0);
		  this.sinlat0 = Math.sin(this.lat0);
		  if (this.sphere) {
		    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
		      this.k0 = 0.5 * (1 + sign(this.lat0) * Math.sin(this.lat_ts));
		    }
		  }
		  else {
		    if (Math.abs(this.coslat0) <= EPSLN) {
		      if (this.lat0 > 0) {
		        //North pole
		        //trace('stere:north pole');
		        this.con = 1;
		      }
		      else {
		        //South pole
		        //trace('stere:south pole');
		        this.con = -1;
		      }
		    }
		    this.cons = Math.sqrt(Math.pow(1 + this.e, 1 + this.e) * Math.pow(1 - this.e, 1 - this.e));
		    if (this.k0 === 1 && !isNaN(this.lat_ts) && Math.abs(this.coslat0) <= EPSLN) {
		      this.k0 = 0.5 * this.cons * msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts)) / tsfnz(this.e, this.con * this.lat_ts, this.con * Math.sin(this.lat_ts));
		    }
		    this.ms1 = msfnz(this.e, this.sinlat0, this.coslat0);
		    this.X0 = 2 * Math.atan(this.ssfn_(this.lat0, this.sinlat0, this.e)) - HALF_PI;
		    this.cosX0 = Math.cos(this.X0);
		    this.sinX0 = Math.sin(this.X0);
		  }
		}
	
		// Stereographic forward equations--mapping lat,long to x,y
		function forward$6(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var sinlat = Math.sin(lat);
		  var coslat = Math.cos(lat);
		  var A, X, sinX, cosX, ts, rh;
		  var dlon = adjust_lon(lon - this.long0);
	
		  if (Math.abs(Math.abs(lon - this.long0) - Math.PI) <= EPSLN && Math.abs(lat + this.lat0) <= EPSLN) {
		    //case of the origine point
		    //trace('stere:this is the origin point');
		    p.x = NaN;
		    p.y = NaN;
		    return p;
		  }
		  if (this.sphere) {
		    //trace('stere:sphere case');
		    A = 2 * this.k0 / (1 + this.sinlat0 * sinlat + this.coslat0 * coslat * Math.cos(dlon));
		    p.x = this.a * A * coslat * Math.sin(dlon) + this.x0;
		    p.y = this.a * A * (this.coslat0 * sinlat - this.sinlat0 * coslat * Math.cos(dlon)) + this.y0;
		    return p;
		  }
		  else {
		    X = 2 * Math.atan(this.ssfn_(lat, sinlat, this.e)) - HALF_PI;
		    cosX = Math.cos(X);
		    sinX = Math.sin(X);
		    if (Math.abs(this.coslat0) <= EPSLN) {
		      ts = tsfnz(this.e, lat * this.con, this.con * sinlat);
		      rh = 2 * this.a * this.k0 * ts / this.cons;
		      p.x = this.x0 + rh * Math.sin(lon - this.long0);
		      p.y = this.y0 - this.con * rh * Math.cos(lon - this.long0);
		      //trace(p.toString());
		      return p;
		    }
		    else if (Math.abs(this.sinlat0) < EPSLN) {
		      //Eq
		      //trace('stere:equateur');
		      A = 2 * this.a * this.k0 / (1 + cosX * Math.cos(dlon));
		      p.y = A * sinX;
		    }
		    else {
		      //other case
		      //trace('stere:normal case');
		      A = 2 * this.a * this.k0 * this.ms1 / (this.cosX0 * (1 + this.sinX0 * sinX + this.cosX0 * cosX * Math.cos(dlon)));
		      p.y = A * (this.cosX0 * sinX - this.sinX0 * cosX * Math.cos(dlon)) + this.y0;
		    }
		    p.x = A * cosX * Math.sin(dlon) + this.x0;
		  }
		  //trace(p.toString());
		  return p;
		}
	
		//* Stereographic inverse equations--mapping x,y to lat/long
		function inverse$6(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;
		  var lon, lat, ts, ce, Chi;
		  var rh = Math.sqrt(p.x * p.x + p.y * p.y);
		  if (this.sphere) {
		    var c = 2 * Math.atan(rh / (0.5 * this.a * this.k0));
		    lon = this.long0;
		    lat = this.lat0;
		    if (rh <= EPSLN) {
		      p.x = lon;
		      p.y = lat;
		      return p;
		    }
		    lat = Math.asin(Math.cos(c) * this.sinlat0 + p.y * Math.sin(c) * this.coslat0 / rh);
		    if (Math.abs(this.coslat0) < EPSLN) {
		      if (this.lat0 > 0) {
		        lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
		      }
		      else {
		        lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
		      }
		    }
		    else {
		      lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(c), rh * this.coslat0 * Math.cos(c) - p.y * this.sinlat0 * Math.sin(c)));
		    }
		    p.x = lon;
		    p.y = lat;
		    return p;
		  }
		  else {
		    if (Math.abs(this.coslat0) <= EPSLN) {
		      if (rh <= EPSLN) {
		        lat = this.lat0;
		        lon = this.long0;
		        p.x = lon;
		        p.y = lat;
		        //trace(p.toString());
		        return p;
		      }
		      p.x *= this.con;
		      p.y *= this.con;
		      ts = rh * this.cons / (2 * this.a * this.k0);
		      lat = this.con * phi2z(this.e, ts);
		      lon = this.con * adjust_lon(this.con * this.long0 + Math.atan2(p.x, - 1 * p.y));
		    }
		    else {
		      ce = 2 * Math.atan(rh * this.cosX0 / (2 * this.a * this.k0 * this.ms1));
		      lon = this.long0;
		      if (rh <= EPSLN) {
		        Chi = this.X0;
		      }
		      else {
		        Chi = Math.asin(Math.cos(ce) * this.sinX0 + p.y * Math.sin(ce) * this.cosX0 / rh);
		        lon = adjust_lon(this.long0 + Math.atan2(p.x * Math.sin(ce), rh * this.cosX0 * Math.cos(ce) - p.y * this.sinX0 * Math.sin(ce)));
		      }
		      lat = -1 * phi2z(this.e, Math.tan(0.5 * (HALF_PI + Chi)));
		    }
		  }
		  p.x = lon;
		  p.y = lat;
	
		  //trace(p.toString());
		  return p;
	
		}
	
		var names$8 = ["stere", "Stereographic_South_Pole", "Polar Stereographic (variant B)"];
		var stere = {
		  init: init$7,
		  forward: forward$6,
		  inverse: inverse$6,
		  names: names$8,
		  ssfn_: ssfn_
		};
	
		/*
		  references:
		    Formules et constantes pour le Calcul pour la
		    projection cylindrique conforme à axe oblique et pour la transformation entre
		    des systèmes de référence.
		    http://www.swisstopo.admin.ch/internet/swisstopo/fr/home/topics/survey/sys/refsys/switzerland.parsysrelated1.31216.downloadList.77004.DownloadFile.tmp/swissprojectionfr.pdf
		  */
	
		function init$8() {
		  var phy0 = this.lat0;
		  this.lambda0 = this.long0;
		  var sinPhy0 = Math.sin(phy0);
		  var semiMajorAxis = this.a;
		  var invF = this.rf;
		  var flattening = 1 / invF;
		  var e2 = 2 * flattening - Math.pow(flattening, 2);
		  var e = this.e = Math.sqrt(e2);
		  this.R = this.k0 * semiMajorAxis * Math.sqrt(1 - e2) / (1 - e2 * Math.pow(sinPhy0, 2));
		  this.alpha = Math.sqrt(1 + e2 / (1 - e2) * Math.pow(Math.cos(phy0), 4));
		  this.b0 = Math.asin(sinPhy0 / this.alpha);
		  var k1 = Math.log(Math.tan(Math.PI / 4 + this.b0 / 2));
		  var k2 = Math.log(Math.tan(Math.PI / 4 + phy0 / 2));
		  var k3 = Math.log((1 + e * sinPhy0) / (1 - e * sinPhy0));
		  this.K = k1 - this.alpha * k2 + this.alpha * e / 2 * k3;
		}
	
		function forward$7(p) {
		  var Sa1 = Math.log(Math.tan(Math.PI / 4 - p.y / 2));
		  var Sa2 = this.e / 2 * Math.log((1 + this.e * Math.sin(p.y)) / (1 - this.e * Math.sin(p.y)));
		  var S = -this.alpha * (Sa1 + Sa2) + this.K;
	
		  // spheric latitude
		  var b = 2 * (Math.atan(Math.exp(S)) - Math.PI / 4);
	
		  // spheric longitude
		  var I = this.alpha * (p.x - this.lambda0);
	
		  // psoeudo equatorial rotation
		  var rotI = Math.atan(Math.sin(I) / (Math.sin(this.b0) * Math.tan(b) + Math.cos(this.b0) * Math.cos(I)));
	
		  var rotB = Math.asin(Math.cos(this.b0) * Math.sin(b) - Math.sin(this.b0) * Math.cos(b) * Math.cos(I));
	
		  p.y = this.R / 2 * Math.log((1 + Math.sin(rotB)) / (1 - Math.sin(rotB))) + this.y0;
		  p.x = this.R * rotI + this.x0;
		  return p;
		}
	
		function inverse$7(p) {
		  var Y = p.x - this.x0;
		  var X = p.y - this.y0;
	
		  var rotI = Y / this.R;
		  var rotB = 2 * (Math.atan(Math.exp(X / this.R)) - Math.PI / 4);
	
		  var b = Math.asin(Math.cos(this.b0) * Math.sin(rotB) + Math.sin(this.b0) * Math.cos(rotB) * Math.cos(rotI));
		  var I = Math.atan(Math.sin(rotI) / (Math.cos(this.b0) * Math.cos(rotI) - Math.sin(this.b0) * Math.tan(rotB)));
	
		  var lambda = this.lambda0 + I / this.alpha;
	
		  var S = 0;
		  var phy = b;
		  var prevPhy = -1000;
		  var iteration = 0;
		  while (Math.abs(phy - prevPhy) > 0.0000001) {
		    if (++iteration > 20) {
		      //...reportError("omercFwdInfinity");
		      return;
		    }
		    //S = Math.log(Math.tan(Math.PI / 4 + phy / 2));
		    S = 1 / this.alpha * (Math.log(Math.tan(Math.PI / 4 + b / 2)) - this.K) + this.e * Math.log(Math.tan(Math.PI / 4 + Math.asin(this.e * Math.sin(phy)) / 2));
		    prevPhy = phy;
		    phy = 2 * Math.atan(Math.exp(S)) - Math.PI / 2;
		  }
	
		  p.x = lambda;
		  p.y = phy;
		  return p;
		}
	
		var names$9 = ["somerc"];
		var somerc = {
		  init: init$8,
		  forward: forward$7,
		  inverse: inverse$7,
		  names: names$9
		};
	
		/* Initialize the Oblique Mercator  projection
		    ------------------------------------------*/
		function init$9() {
		  this.no_off = this.no_off || false;
		  this.no_rot = this.no_rot || false;
	
		  if (isNaN(this.k0)) {
		    this.k0 = 1;
		  }
		  var sinlat = Math.sin(this.lat0);
		  var coslat = Math.cos(this.lat0);
		  var con = this.e * sinlat;
	
		  this.bl = Math.sqrt(1 + this.es / (1 - this.es) * Math.pow(coslat, 4));
		  this.al = this.a * this.bl * this.k0 * Math.sqrt(1 - this.es) / (1 - con * con);
		  var t0 = tsfnz(this.e, this.lat0, sinlat);
		  var dl = this.bl / coslat * Math.sqrt((1 - this.es) / (1 - con * con));
		  if (dl * dl < 1) {
		    dl = 1;
		  }
		  var fl;
		  var gl;
		  if (!isNaN(this.longc)) {
		    //Central point and azimuth method
	
		    if (this.lat0 >= 0) {
		      fl = dl + Math.sqrt(dl * dl - 1);
		    }
		    else {
		      fl = dl - Math.sqrt(dl * dl - 1);
		    }
		    this.el = fl * Math.pow(t0, this.bl);
		    gl = 0.5 * (fl - 1 / fl);
		    this.gamma0 = Math.asin(Math.sin(this.alpha) / dl);
		    this.long0 = this.longc - Math.asin(gl * Math.tan(this.gamma0)) / this.bl;
	
		  }
		  else {
		    //2 points method
		    var t1 = tsfnz(this.e, this.lat1, Math.sin(this.lat1));
		    var t2 = tsfnz(this.e, this.lat2, Math.sin(this.lat2));
		    if (this.lat0 >= 0) {
		      this.el = (dl + Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
		    }
		    else {
		      this.el = (dl - Math.sqrt(dl * dl - 1)) * Math.pow(t0, this.bl);
		    }
		    var hl = Math.pow(t1, this.bl);
		    var ll = Math.pow(t2, this.bl);
		    fl = this.el / hl;
		    gl = 0.5 * (fl - 1 / fl);
		    var jl = (this.el * this.el - ll * hl) / (this.el * this.el + ll * hl);
		    var pl = (ll - hl) / (ll + hl);
		    var dlon12 = adjust_lon(this.long1 - this.long2);
		    this.long0 = 0.5 * (this.long1 + this.long2) - Math.atan(jl * Math.tan(0.5 * this.bl * (dlon12)) / pl) / this.bl;
		    this.long0 = adjust_lon(this.long0);
		    var dlon10 = adjust_lon(this.long1 - this.long0);
		    this.gamma0 = Math.atan(Math.sin(this.bl * (dlon10)) / gl);
		    this.alpha = Math.asin(dl * Math.sin(this.gamma0));
		  }
	
		  if (this.no_off) {
		    this.uc = 0;
		  }
		  else {
		    if (this.lat0 >= 0) {
		      this.uc = this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
		    }
		    else {
		      this.uc = -1 * this.al / this.bl * Math.atan2(Math.sqrt(dl * dl - 1), Math.cos(this.alpha));
		    }
		  }
	
		}
	
		/* Oblique Mercator forward equations--mapping lat,long to x,y
		    ----------------------------------------------------------*/
		function forward$8(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var dlon = adjust_lon(lon - this.long0);
		  var us, vs;
		  var con;
		  if (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN) {
		    if (lat > 0) {
		      con = -1;
		    }
		    else {
		      con = 1;
		    }
		    vs = this.al / this.bl * Math.log(Math.tan(FORTPI + con * this.gamma0 * 0.5));
		    us = -1 * con * HALF_PI * this.al / this.bl;
		  }
		  else {
		    var t = tsfnz(this.e, lat, Math.sin(lat));
		    var ql = this.el / Math.pow(t, this.bl);
		    var sl = 0.5 * (ql - 1 / ql);
		    var tl = 0.5 * (ql + 1 / ql);
		    var vl = Math.sin(this.bl * (dlon));
		    var ul = (sl * Math.sin(this.gamma0) - vl * Math.cos(this.gamma0)) / tl;
		    if (Math.abs(Math.abs(ul) - 1) <= EPSLN) {
		      vs = Number.POSITIVE_INFINITY;
		    }
		    else {
		      vs = 0.5 * this.al * Math.log((1 - ul) / (1 + ul)) / this.bl;
		    }
		    if (Math.abs(Math.cos(this.bl * (dlon))) <= EPSLN) {
		      us = this.al * this.bl * (dlon);
		    }
		    else {
		      us = this.al * Math.atan2(sl * Math.cos(this.gamma0) + vl * Math.sin(this.gamma0), Math.cos(this.bl * dlon)) / this.bl;
		    }
		  }
	
		  if (this.no_rot) {
		    p.x = this.x0 + us;
		    p.y = this.y0 + vs;
		  }
		  else {
	
		    us -= this.uc;
		    p.x = this.x0 + vs * Math.cos(this.alpha) + us * Math.sin(this.alpha);
		    p.y = this.y0 + us * Math.cos(this.alpha) - vs * Math.sin(this.alpha);
		  }
		  return p;
		}
	
		function inverse$8(p) {
		  var us, vs;
		  if (this.no_rot) {
		    vs = p.y - this.y0;
		    us = p.x - this.x0;
		  }
		  else {
		    vs = (p.x - this.x0) * Math.cos(this.alpha) - (p.y - this.y0) * Math.sin(this.alpha);
		    us = (p.y - this.y0) * Math.cos(this.alpha) + (p.x - this.x0) * Math.sin(this.alpha);
		    us += this.uc;
		  }
		  var qp = Math.exp(-1 * this.bl * vs / this.al);
		  var sp = 0.5 * (qp - 1 / qp);
		  var tp = 0.5 * (qp + 1 / qp);
		  var vp = Math.sin(this.bl * us / this.al);
		  var up = (vp * Math.cos(this.gamma0) + sp * Math.sin(this.gamma0)) / tp;
		  var ts = Math.pow(this.el / Math.sqrt((1 + up) / (1 - up)), 1 / this.bl);
		  if (Math.abs(up - 1) < EPSLN) {
		    p.x = this.long0;
		    p.y = HALF_PI;
		  }
		  else if (Math.abs(up + 1) < EPSLN) {
		    p.x = this.long0;
		    p.y = -1 * HALF_PI;
		  }
		  else {
		    p.y = phi2z(this.e, ts);
		    p.x = adjust_lon(this.long0 - Math.atan2(sp * Math.cos(this.gamma0) - vp * Math.sin(this.gamma0), Math.cos(this.bl * us / this.al)) / this.bl);
		  }
		  return p;
		}
	
		var names$10 = ["Hotine_Oblique_Mercator", "Hotine Oblique Mercator", "Hotine_Oblique_Mercator_Azimuth_Natural_Origin", "Hotine_Oblique_Mercator_Azimuth_Center", "omerc"];
		var omerc = {
		  init: init$9,
		  forward: forward$8,
		  inverse: inverse$8,
		  names: names$10
		};
	
		function init$10() {
	
		  // array of:  r_maj,r_min,lat1,lat2,c_lon,c_lat,false_east,false_north
		  //double c_lat;                   /* center latitude                      */
		  //double c_lon;                   /* center longitude                     */
		  //double lat1;                    /* first standard parallel              */
		  //double lat2;                    /* second standard parallel             */
		  //double r_maj;                   /* major axis                           */
		  //double r_min;                   /* minor axis                           */
		  //double false_east;              /* x offset in meters                   */
		  //double false_north;             /* y offset in meters                   */
	
		  if (!this.lat2) {
		    this.lat2 = this.lat1;
		  } //if lat2 is not defined
		  if (!this.k0) {
		    this.k0 = 1;
		  }
		  this.x0 = this.x0 || 0;
		  this.y0 = this.y0 || 0;
		  // Standard Parallels cannot be equal and on opposite sides of the equator
		  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
		    return;
		  }
	
		  var temp = this.b / this.a;
		  this.e = Math.sqrt(1 - temp * temp);
	
		  var sin1 = Math.sin(this.lat1);
		  var cos1 = Math.cos(this.lat1);
		  var ms1 = msfnz(this.e, sin1, cos1);
		  var ts1 = tsfnz(this.e, this.lat1, sin1);
	
		  var sin2 = Math.sin(this.lat2);
		  var cos2 = Math.cos(this.lat2);
		  var ms2 = msfnz(this.e, sin2, cos2);
		  var ts2 = tsfnz(this.e, this.lat2, sin2);
	
		  var ts0 = tsfnz(this.e, this.lat0, Math.sin(this.lat0));
	
		  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
		    this.ns = Math.log(ms1 / ms2) / Math.log(ts1 / ts2);
		  }
		  else {
		    this.ns = sin1;
		  }
		  if (isNaN(this.ns)) {
		    this.ns = sin1;
		  }
		  this.f0 = ms1 / (this.ns * Math.pow(ts1, this.ns));
		  this.rh = this.a * this.f0 * Math.pow(ts0, this.ns);
		  if (!this.title) {
		    this.title = "Lambert Conformal Conic";
		  }
		}
	
		// Lambert Conformal conic forward equations--mapping lat,long to x,y
		// -----------------------------------------------------------------
		function forward$9(p) {
	
		  var lon = p.x;
		  var lat = p.y;
	
		  // singular cases :
		  if (Math.abs(2 * Math.abs(lat) - Math.PI) <= EPSLN) {
		    lat = sign(lat) * (HALF_PI - 2 * EPSLN);
		  }
	
		  var con = Math.abs(Math.abs(lat) - HALF_PI);
		  var ts, rh1;
		  if (con > EPSLN) {
		    ts = tsfnz(this.e, lat, Math.sin(lat));
		    rh1 = this.a * this.f0 * Math.pow(ts, this.ns);
		  }
		  else {
		    con = lat * this.ns;
		    if (con <= 0) {
		      return null;
		    }
		    rh1 = 0;
		  }
		  var theta = this.ns * adjust_lon(lon - this.long0);
		  p.x = this.k0 * (rh1 * Math.sin(theta)) + this.x0;
		  p.y = this.k0 * (this.rh - rh1 * Math.cos(theta)) + this.y0;
	
		  return p;
		}
	
		// Lambert Conformal Conic inverse equations--mapping x,y to lat/long
		// -----------------------------------------------------------------
		function inverse$9(p) {
	
		  var rh1, con, ts;
		  var lat, lon;
		  var x = (p.x - this.x0) / this.k0;
		  var y = (this.rh - (p.y - this.y0) / this.k0);
		  if (this.ns > 0) {
		    rh1 = Math.sqrt(x * x + y * y);
		    con = 1;
		  }
		  else {
		    rh1 = -Math.sqrt(x * x + y * y);
		    con = -1;
		  }
		  var theta = 0;
		  if (rh1 !== 0) {
		    theta = Math.atan2((con * x), (con * y));
		  }
		  if ((rh1 !== 0) || (this.ns > 0)) {
		    con = 1 / this.ns;
		    ts = Math.pow((rh1 / (this.a * this.f0)), con);
		    lat = phi2z(this.e, ts);
		    if (lat === -9999) {
		      return null;
		    }
		  }
		  else {
		    lat = -HALF_PI;
		  }
		  lon = adjust_lon(theta / this.ns + this.long0);
	
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$11 = ["Lambert Tangential Conformal Conic Projection", "Lambert_Conformal_Conic", "Lambert_Conformal_Conic_2SP", "lcc"];
		var lcc = {
		  init: init$10,
		  forward: forward$9,
		  inverse: inverse$9,
		  names: names$11
		};
	
		function init$11() {
		  this.a = 6377397.155;
		  this.es = 0.006674372230614;
		  this.e = Math.sqrt(this.es);
		  if (!this.lat0) {
		    this.lat0 = 0.863937979737193;
		  }
		  if (!this.long0) {
		    this.long0 = 0.7417649320975901 - 0.308341501185665;
		  }
		  /* if scale not set default to 0.9999 */
		  if (!this.k0) {
		    this.k0 = 0.9999;
		  }
		  this.s45 = 0.785398163397448; /* 45 */
		  this.s90 = 2 * this.s45;
		  this.fi0 = this.lat0;
		  this.e2 = this.es;
		  this.e = Math.sqrt(this.e2);
		  this.alfa = Math.sqrt(1 + (this.e2 * Math.pow(Math.cos(this.fi0), 4)) / (1 - this.e2));
		  this.uq = 1.04216856380474;
		  this.u0 = Math.asin(Math.sin(this.fi0) / this.alfa);
		  this.g = Math.pow((1 + this.e * Math.sin(this.fi0)) / (1 - this.e * Math.sin(this.fi0)), this.alfa * this.e / 2);
		  this.k = Math.tan(this.u0 / 2 + this.s45) / Math.pow(Math.tan(this.fi0 / 2 + this.s45), this.alfa) * this.g;
		  this.k1 = this.k0;
		  this.n0 = this.a * Math.sqrt(1 - this.e2) / (1 - this.e2 * Math.pow(Math.sin(this.fi0), 2));
		  this.s0 = 1.37008346281555;
		  this.n = Math.sin(this.s0);
		  this.ro0 = this.k1 * this.n0 / Math.tan(this.s0);
		  this.ad = this.s90 - this.uq;
		}
	
		/* ellipsoid */
		/* calculate xy from lat/lon */
		/* Constants, identical to inverse transform function */
		function forward$10(p) {
		  var gfi, u, deltav, s, d, eps, ro;
		  var lon = p.x;
		  var lat = p.y;
		  var delta_lon = adjust_lon(lon - this.long0);
		  /* Transformation */
		  gfi = Math.pow(((1 + this.e * Math.sin(lat)) / (1 - this.e * Math.sin(lat))), (this.alfa * this.e / 2));
		  u = 2 * (Math.atan(this.k * Math.pow(Math.tan(lat / 2 + this.s45), this.alfa) / gfi) - this.s45);
		  deltav = -delta_lon * this.alfa;
		  s = Math.asin(Math.cos(this.ad) * Math.sin(u) + Math.sin(this.ad) * Math.cos(u) * Math.cos(deltav));
		  d = Math.asin(Math.cos(u) * Math.sin(deltav) / Math.cos(s));
		  eps = this.n * d;
		  ro = this.ro0 * Math.pow(Math.tan(this.s0 / 2 + this.s45), this.n) / Math.pow(Math.tan(s / 2 + this.s45), this.n);
		  p.y = ro * Math.cos(eps) / 1;
		  p.x = ro * Math.sin(eps) / 1;
	
		  if (!this.czech) {
		    p.y *= -1;
		    p.x *= -1;
		  }
		  return (p);
		}
	
		/* calculate lat/lon from xy */
		function inverse$10(p) {
		  var u, deltav, s, d, eps, ro, fi1;
		  var ok;
	
		  /* Transformation */
		  /* revert y, x*/
		  var tmp = p.x;
		  p.x = p.y;
		  p.y = tmp;
		  if (!this.czech) {
		    p.y *= -1;
		    p.x *= -1;
		  }
		  ro = Math.sqrt(p.x * p.x + p.y * p.y);
		  eps = Math.atan2(p.y, p.x);
		  d = eps / Math.sin(this.s0);
		  s = 2 * (Math.atan(Math.pow(this.ro0 / ro, 1 / this.n) * Math.tan(this.s0 / 2 + this.s45)) - this.s45);
		  u = Math.asin(Math.cos(this.ad) * Math.sin(s) - Math.sin(this.ad) * Math.cos(s) * Math.cos(d));
		  deltav = Math.asin(Math.cos(s) * Math.sin(d) / Math.cos(u));
		  p.x = this.long0 - deltav / this.alfa;
		  fi1 = u;
		  ok = 0;
		  var iter = 0;
		  do {
		    p.y = 2 * (Math.atan(Math.pow(this.k, - 1 / this.alfa) * Math.pow(Math.tan(u / 2 + this.s45), 1 / this.alfa) * Math.pow((1 + this.e * Math.sin(fi1)) / (1 - this.e * Math.sin(fi1)), this.e / 2)) - this.s45);
		    if (Math.abs(fi1 - p.y) < 0.0000000001) {
		      ok = 1;
		    }
		    fi1 = p.y;
		    iter += 1;
		  } while (ok === 0 && iter < 15);
		  if (iter >= 15) {
		    return null;
		  }
	
		  return (p);
		}
	
		var names$12 = ["Krovak", "krovak"];
		var krovak = {
		  init: init$11,
		  forward: forward$10,
		  inverse: inverse$10,
		  names: names$12
		};
	
		var mlfn = function(e0, e1, e2, e3, phi) {
		  return (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi));
		};
	
		var e0fn = function(x) {
		  return (1 - 0.25 * x * (1 + x / 16 * (3 + 1.25 * x)));
		};
	
		var e1fn = function(x) {
		  return (0.375 * x * (1 + 0.25 * x * (1 + 0.46875 * x)));
		};
	
		var e2fn = function(x) {
		  return (0.05859375 * x * x * (1 + 0.75 * x));
		};
	
		var e3fn = function(x) {
		  return (x * x * x * (35 / 3072));
		};
	
		var gN = function(a, e, sinphi) {
		  var temp = e * sinphi;
		  return a / Math.sqrt(1 - temp * temp);
		};
	
		var adjust_lat = function(x) {
		  return (Math.abs(x) < HALF_PI) ? x : (x - (sign(x) * Math.PI));
		};
	
		var imlfn = function(ml, e0, e1, e2, e3) {
		  var phi;
		  var dphi;
	
		  phi = ml / e0;
		  for (var i = 0; i < 15; i++) {
		    dphi = (ml - (e0 * phi - e1 * Math.sin(2 * phi) + e2 * Math.sin(4 * phi) - e3 * Math.sin(6 * phi))) / (e0 - 2 * e1 * Math.cos(2 * phi) + 4 * e2 * Math.cos(4 * phi) - 6 * e3 * Math.cos(6 * phi));
		    phi += dphi;
		    if (Math.abs(dphi) <= 0.0000000001) {
		      return phi;
		    }
		  }
	
		  //..reportError("IMLFN-CONV:Latitude failed to converge after 15 iterations");
		  return NaN;
		};
	
		function init$12() {
		  if (!this.sphere) {
		    this.e0 = e0fn(this.es);
		    this.e1 = e1fn(this.es);
		    this.e2 = e2fn(this.es);
		    this.e3 = e3fn(this.es);
		    this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
		  }
		}
	
		/* Cassini forward equations--mapping lat,long to x,y
		  -----------------------------------------------------------------------*/
		function forward$11(p) {
	
		  /* Forward equations
		      -----------------*/
		  var x, y;
		  var lam = p.x;
		  var phi = p.y;
		  lam = adjust_lon(lam - this.long0);
	
		  if (this.sphere) {
		    x = this.a * Math.asin(Math.cos(phi) * Math.sin(lam));
		    y = this.a * (Math.atan2(Math.tan(phi), Math.cos(lam)) - this.lat0);
		  }
		  else {
		    //ellipsoid
		    var sinphi = Math.sin(phi);
		    var cosphi = Math.cos(phi);
		    var nl = gN(this.a, this.e, sinphi);
		    var tl = Math.tan(phi) * Math.tan(phi);
		    var al = lam * Math.cos(phi);
		    var asq = al * al;
		    var cl = this.es * cosphi * cosphi / (1 - this.es);
		    var ml = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
	
		    x = nl * al * (1 - asq * tl * (1 / 6 - (8 - tl + 8 * cl) * asq / 120));
		    y = ml - this.ml0 + nl * sinphi / cosphi * asq * (0.5 + (5 - tl + 6 * cl) * asq / 24);
	
	
		  }
	
		  p.x = x + this.x0;
		  p.y = y + this.y0;
		  return p;
		}
	
		/* Inverse equations
		  -----------------*/
		function inverse$11(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;
		  var x = p.x / this.a;
		  var y = p.y / this.a;
		  var phi, lam;
	
		  if (this.sphere) {
		    var dd = y + this.lat0;
		    phi = Math.asin(Math.sin(dd) * Math.cos(x));
		    lam = Math.atan2(Math.tan(x), Math.cos(dd));
		  }
		  else {
		    /* ellipsoid */
		    var ml1 = this.ml0 / this.a + y;
		    var phi1 = imlfn(ml1, this.e0, this.e1, this.e2, this.e3);
		    if (Math.abs(Math.abs(phi1) - HALF_PI) <= EPSLN) {
		      p.x = this.long0;
		      p.y = HALF_PI;
		      if (y < 0) {
		        p.y *= -1;
		      }
		      return p;
		    }
		    var nl1 = gN(this.a, this.e, Math.sin(phi1));
	
		    var rl1 = nl1 * nl1 * nl1 / this.a / this.a * (1 - this.es);
		    var tl1 = Math.pow(Math.tan(phi1), 2);
		    var dl = x * this.a / nl1;
		    var dsq = dl * dl;
		    phi = phi1 - nl1 * Math.tan(phi1) / rl1 * dl * dl * (0.5 - (1 + 3 * tl1) * dl * dl / 24);
		    lam = dl * (1 - dsq * (tl1 / 3 + (1 + 3 * tl1) * tl1 * dsq / 15)) / Math.cos(phi1);
	
		  }
	
		  p.x = adjust_lon(lam + this.long0);
		  p.y = adjust_lat(phi);
		  return p;
	
		}
	
		var names$13 = ["Cassini", "Cassini_Soldner", "cass"];
		var cass = {
		  init: init$12,
		  forward: forward$11,
		  inverse: inverse$11,
		  names: names$13
		};
	
		var qsfnz = function(eccent, sinphi) {
		  var con;
		  if (eccent > 1.0e-7) {
		    con = eccent * sinphi;
		    return ((1 - eccent * eccent) * (sinphi / (1 - con * con) - (0.5 / eccent) * Math.log((1 - con) / (1 + con))));
		  }
		  else {
		    return (2 * sinphi);
		  }
		};
	
		/*
		  reference
		    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
		    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
		  */
	
		var S_POLE = 1;
	
		var N_POLE = 2;
		var EQUIT = 3;
		var OBLIQ = 4;
	
		/* Initialize the Lambert Azimuthal Equal Area projection
		  ------------------------------------------------------*/
		function init$13() {
		  var t = Math.abs(this.lat0);
		  if (Math.abs(t - HALF_PI) < EPSLN) {
		    this.mode = this.lat0 < 0 ? this.S_POLE : this.N_POLE;
		  }
		  else if (Math.abs(t) < EPSLN) {
		    this.mode = this.EQUIT;
		  }
		  else {
		    this.mode = this.OBLIQ;
		  }
		  if (this.es > 0) {
		    var sinphi;
	
		    this.qp = qsfnz(this.e, 1);
		    this.mmf = 0.5 / (1 - this.es);
		    this.apa = authset(this.es);
		    switch (this.mode) {
		    case this.N_POLE:
		      this.dd = 1;
		      break;
		    case this.S_POLE:
		      this.dd = 1;
		      break;
		    case this.EQUIT:
		      this.rq = Math.sqrt(0.5 * this.qp);
		      this.dd = 1 / this.rq;
		      this.xmf = 1;
		      this.ymf = 0.5 * this.qp;
		      break;
		    case this.OBLIQ:
		      this.rq = Math.sqrt(0.5 * this.qp);
		      sinphi = Math.sin(this.lat0);
		      this.sinb1 = qsfnz(this.e, sinphi) / this.qp;
		      this.cosb1 = Math.sqrt(1 - this.sinb1 * this.sinb1);
		      this.dd = Math.cos(this.lat0) / (Math.sqrt(1 - this.es * sinphi * sinphi) * this.rq * this.cosb1);
		      this.ymf = (this.xmf = this.rq) / this.dd;
		      this.xmf *= this.dd;
		      break;
		    }
		  }
		  else {
		    if (this.mode === this.OBLIQ) {
		      this.sinph0 = Math.sin(this.lat0);
		      this.cosph0 = Math.cos(this.lat0);
		    }
		  }
		}
	
		/* Lambert Azimuthal Equal Area forward equations--mapping lat,long to x,y
		  -----------------------------------------------------------------------*/
		function forward$12(p) {
	
		  /* Forward equations
		      -----------------*/
		  var x, y, coslam, sinlam, sinphi, q, sinb, cosb, b, cosphi;
		  var lam = p.x;
		  var phi = p.y;
	
		  lam = adjust_lon(lam - this.long0);
		  if (this.sphere) {
		    sinphi = Math.sin(phi);
		    cosphi = Math.cos(phi);
		    coslam = Math.cos(lam);
		    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
		      y = (this.mode === this.EQUIT) ? 1 + cosphi * coslam : 1 + this.sinph0 * sinphi + this.cosph0 * cosphi * coslam;
		      if (y <= EPSLN) {
		        return null;
		      }
		      y = Math.sqrt(2 / y);
		      x = y * cosphi * Math.sin(lam);
		      y *= (this.mode === this.EQUIT) ? sinphi : this.cosph0 * sinphi - this.sinph0 * cosphi * coslam;
		    }
		    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
		      if (this.mode === this.N_POLE) {
		        coslam = -coslam;
		      }
		      if (Math.abs(phi + this.phi0) < EPSLN) {
		        return null;
		      }
		      y = FORTPI - phi * 0.5;
		      y = 2 * ((this.mode === this.S_POLE) ? Math.cos(y) : Math.sin(y));
		      x = y * Math.sin(lam);
		      y *= coslam;
		    }
		  }
		  else {
		    sinb = 0;
		    cosb = 0;
		    b = 0;
		    coslam = Math.cos(lam);
		    sinlam = Math.sin(lam);
		    sinphi = Math.sin(phi);
		    q = qsfnz(this.e, sinphi);
		    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
		      sinb = q / this.qp;
		      cosb = Math.sqrt(1 - sinb * sinb);
		    }
		    switch (this.mode) {
		    case this.OBLIQ:
		      b = 1 + this.sinb1 * sinb + this.cosb1 * cosb * coslam;
		      break;
		    case this.EQUIT:
		      b = 1 + cosb * coslam;
		      break;
		    case this.N_POLE:
		      b = HALF_PI + phi;
		      q = this.qp - q;
		      break;
		    case this.S_POLE:
		      b = phi - HALF_PI;
		      q = this.qp + q;
		      break;
		    }
		    if (Math.abs(b) < EPSLN) {
		      return null;
		    }
		    switch (this.mode) {
		    case this.OBLIQ:
		    case this.EQUIT:
		      b = Math.sqrt(2 / b);
		      if (this.mode === this.OBLIQ) {
		        y = this.ymf * b * (this.cosb1 * sinb - this.sinb1 * cosb * coslam);
		      }
		      else {
		        y = (b = Math.sqrt(2 / (1 + cosb * coslam))) * sinb * this.ymf;
		      }
		      x = this.xmf * b * cosb * sinlam;
		      break;
		    case this.N_POLE:
		    case this.S_POLE:
		      if (q >= 0) {
		        x = (b = Math.sqrt(q)) * sinlam;
		        y = coslam * ((this.mode === this.S_POLE) ? b : -b);
		      }
		      else {
		        x = y = 0;
		      }
		      break;
		    }
		  }
	
		  p.x = this.a * x + this.x0;
		  p.y = this.a * y + this.y0;
		  return p;
		}
	
		/* Inverse equations
		  -----------------*/
		function inverse$12(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;
		  var x = p.x / this.a;
		  var y = p.y / this.a;
		  var lam, phi, cCe, sCe, q, rho, ab;
		  if (this.sphere) {
		    var cosz = 0,
		      rh, sinz = 0;
	
		    rh = Math.sqrt(x * x + y * y);
		    phi = rh * 0.5;
		    if (phi > 1) {
		      return null;
		    }
		    phi = 2 * Math.asin(phi);
		    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
		      sinz = Math.sin(phi);
		      cosz = Math.cos(phi);
		    }
		    switch (this.mode) {
		    case this.EQUIT:
		      phi = (Math.abs(rh) <= EPSLN) ? 0 : Math.asin(y * sinz / rh);
		      x *= sinz;
		      y = cosz * rh;
		      break;
		    case this.OBLIQ:
		      phi = (Math.abs(rh) <= EPSLN) ? this.phi0 : Math.asin(cosz * this.sinph0 + y * sinz * this.cosph0 / rh);
		      x *= sinz * this.cosph0;
		      y = (cosz - Math.sin(phi) * this.sinph0) * rh;
		      break;
		    case this.N_POLE:
		      y = -y;
		      phi = HALF_PI - phi;
		      break;
		    case this.S_POLE:
		      phi -= HALF_PI;
		      break;
		    }
		    lam = (y === 0 && (this.mode === this.EQUIT || this.mode === this.OBLIQ)) ? 0 : Math.atan2(x, y);
		  }
		  else {
		    ab = 0;
		    if (this.mode === this.OBLIQ || this.mode === this.EQUIT) {
		      x /= this.dd;
		      y *= this.dd;
		      rho = Math.sqrt(x * x + y * y);
		      if (rho < EPSLN) {
		        p.x = 0;
		        p.y = this.phi0;
		        return p;
		      }
		      sCe = 2 * Math.asin(0.5 * rho / this.rq);
		      cCe = Math.cos(sCe);
		      x *= (sCe = Math.sin(sCe));
		      if (this.mode === this.OBLIQ) {
		        ab = cCe * this.sinb1 + y * sCe * this.cosb1 / rho;
		        q = this.qp * ab;
		        y = rho * this.cosb1 * cCe - y * this.sinb1 * sCe;
		      }
		      else {
		        ab = y * sCe / rho;
		        q = this.qp * ab;
		        y = rho * cCe;
		      }
		    }
		    else if (this.mode === this.N_POLE || this.mode === this.S_POLE) {
		      if (this.mode === this.N_POLE) {
		        y = -y;
		      }
		      q = (x * x + y * y);
		      if (!q) {
		        p.x = 0;
		        p.y = this.phi0;
		        return p;
		      }
		      ab = 1 - q / this.qp;
		      if (this.mode === this.S_POLE) {
		        ab = -ab;
		      }
		    }
		    lam = Math.atan2(x, y);
		    phi = authlat(Math.asin(ab), this.apa);
		  }
	
		  p.x = adjust_lon(this.long0 + lam);
		  p.y = phi;
		  return p;
		}
	
		/* determine latitude from authalic latitude */
		var P00 = 0.33333333333333333333;
	
		var P01 = 0.17222222222222222222;
		var P02 = 0.10257936507936507936;
		var P10 = 0.06388888888888888888;
		var P11 = 0.06640211640211640211;
		var P20 = 0.01641501294219154443;
	
		function authset(es) {
		  var t;
		  var APA = [];
		  APA[0] = es * P00;
		  t = es * es;
		  APA[0] += t * P01;
		  APA[1] = t * P10;
		  t *= es;
		  APA[0] += t * P02;
		  APA[1] += t * P11;
		  APA[2] = t * P20;
		  return APA;
		}
	
		function authlat(beta, APA) {
		  var t = beta + beta;
		  return (beta + APA[0] * Math.sin(t) + APA[1] * Math.sin(t + t) + APA[2] * Math.sin(t + t + t));
		}
	
		var names$14 = ["Lambert Azimuthal Equal Area", "Lambert_Azimuthal_Equal_Area", "laea"];
		var laea = {
		  init: init$13,
		  forward: forward$12,
		  inverse: inverse$12,
		  names: names$14,
		  S_POLE: S_POLE,
		  N_POLE: N_POLE,
		  EQUIT: EQUIT,
		  OBLIQ: OBLIQ
		};
	
		var asinz = function(x) {
		  if (Math.abs(x) > 1) {
		    x = (x > 1) ? 1 : -1;
		  }
		  return Math.asin(x);
		};
	
		function init$14() {
	
		  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
		    return;
		  }
		  this.temp = this.b / this.a;
		  this.es = 1 - Math.pow(this.temp, 2);
		  this.e3 = Math.sqrt(this.es);
	
		  this.sin_po = Math.sin(this.lat1);
		  this.cos_po = Math.cos(this.lat1);
		  this.t1 = this.sin_po;
		  this.con = this.sin_po;
		  this.ms1 = msfnz(this.e3, this.sin_po, this.cos_po);
		  this.qs1 = qsfnz(this.e3, this.sin_po, this.cos_po);
	
		  this.sin_po = Math.sin(this.lat2);
		  this.cos_po = Math.cos(this.lat2);
		  this.t2 = this.sin_po;
		  this.ms2 = msfnz(this.e3, this.sin_po, this.cos_po);
		  this.qs2 = qsfnz(this.e3, this.sin_po, this.cos_po);
	
		  this.sin_po = Math.sin(this.lat0);
		  this.cos_po = Math.cos(this.lat0);
		  this.t3 = this.sin_po;
		  this.qs0 = qsfnz(this.e3, this.sin_po, this.cos_po);
	
		  if (Math.abs(this.lat1 - this.lat2) > EPSLN) {
		    this.ns0 = (this.ms1 * this.ms1 - this.ms2 * this.ms2) / (this.qs2 - this.qs1);
		  }
		  else {
		    this.ns0 = this.con;
		  }
		  this.c = this.ms1 * this.ms1 + this.ns0 * this.qs1;
		  this.rh = this.a * Math.sqrt(this.c - this.ns0 * this.qs0) / this.ns0;
		}
	
		/* Albers Conical Equal Area forward equations--mapping lat,long to x,y
		  -------------------------------------------------------------------*/
		function forward$13(p) {
	
		  var lon = p.x;
		  var lat = p.y;
	
		  this.sin_phi = Math.sin(lat);
		  this.cos_phi = Math.cos(lat);
	
		  var qs = qsfnz(this.e3, this.sin_phi, this.cos_phi);
		  var rh1 = this.a * Math.sqrt(this.c - this.ns0 * qs) / this.ns0;
		  var theta = this.ns0 * adjust_lon(lon - this.long0);
		  var x = rh1 * Math.sin(theta) + this.x0;
		  var y = this.rh - rh1 * Math.cos(theta) + this.y0;
	
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		function inverse$13(p) {
		  var rh1, qs, con, theta, lon, lat;
	
		  p.x -= this.x0;
		  p.y = this.rh - p.y + this.y0;
		  if (this.ns0 >= 0) {
		    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
		    con = 1;
		  }
		  else {
		    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
		    con = -1;
		  }
		  theta = 0;
		  if (rh1 !== 0) {
		    theta = Math.atan2(con * p.x, con * p.y);
		  }
		  con = rh1 * this.ns0 / this.a;
		  if (this.sphere) {
		    lat = Math.asin((this.c - con * con) / (2 * this.ns0));
		  }
		  else {
		    qs = (this.c - con * con) / this.ns0;
		    lat = this.phi1z(this.e3, qs);
		  }
	
		  lon = adjust_lon(theta / this.ns0 + this.long0);
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		/* Function to compute phi1, the latitude for the inverse of the
		   Albers Conical Equal-Area projection.
		-------------------------------------------*/
		function phi1z(eccent, qs) {
		  var sinphi, cosphi, con, com, dphi;
		  var phi = asinz(0.5 * qs);
		  if (eccent < EPSLN) {
		    return phi;
		  }
	
		  var eccnts = eccent * eccent;
		  for (var i = 1; i <= 25; i++) {
		    sinphi = Math.sin(phi);
		    cosphi = Math.cos(phi);
		    con = eccent * sinphi;
		    com = 1 - con * con;
		    dphi = 0.5 * com * com / cosphi * (qs / (1 - eccnts) - sinphi / com + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
		    phi = phi + dphi;
		    if (Math.abs(dphi) <= 1e-7) {
		      return phi;
		    }
		  }
		  return null;
		}
	
		var names$15 = ["Albers_Conic_Equal_Area", "Albers", "aea"];
		var aea = {
		  init: init$14,
		  forward: forward$13,
		  inverse: inverse$13,
		  names: names$15,
		  phi1z: phi1z
		};
	
		/*
		  reference:
		    Wolfram Mathworld "Gnomonic Projection"
		    http://mathworld.wolfram.com/GnomonicProjection.html
		    Accessed: 12th November 2009
		  */
		function init$15() {
	
		  /* Place parameters in static storage for common use
		      -------------------------------------------------*/
		  this.sin_p14 = Math.sin(this.lat0);
		  this.cos_p14 = Math.cos(this.lat0);
		  // Approximation for projecting points to the horizon (infinity)
		  this.infinity_dist = 1000 * this.a;
		  this.rc = 1;
		}
	
		/* Gnomonic forward equations--mapping lat,long to x,y
		    ---------------------------------------------------*/
		function forward$14(p) {
		  var sinphi, cosphi; /* sin and cos value        */
		  var dlon; /* delta longitude value      */
		  var coslon; /* cos of longitude        */
		  var ksp; /* scale factor          */
		  var g;
		  var x, y;
		  var lon = p.x;
		  var lat = p.y;
		  /* Forward equations
		      -----------------*/
		  dlon = adjust_lon(lon - this.long0);
	
		  sinphi = Math.sin(lat);
		  cosphi = Math.cos(lat);
	
		  coslon = Math.cos(dlon);
		  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
		  ksp = 1;
		  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
		    x = this.x0 + this.a * ksp * cosphi * Math.sin(dlon) / g;
		    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon) / g;
		  }
		  else {
	
		    // Point is in the opposing hemisphere and is unprojectable
		    // We still need to return a reasonable point, so we project
		    // to infinity, on a bearing
		    // equivalent to the northern hemisphere equivalent
		    // This is a reasonable approximation for short shapes and lines that
		    // straddle the horizon.
	
		    x = this.x0 + this.infinity_dist * cosphi * Math.sin(dlon);
		    y = this.y0 + this.infinity_dist * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
	
		  }
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		function inverse$14(p) {
		  var rh; /* Rho */
		  var sinc, cosc;
		  var c;
		  var lon, lat;
	
		  /* Inverse equations
		      -----------------*/
		  p.x = (p.x - this.x0) / this.a;
		  p.y = (p.y - this.y0) / this.a;
	
		  p.x /= this.k0;
		  p.y /= this.k0;
	
		  if ((rh = Math.sqrt(p.x * p.x + p.y * p.y))) {
		    c = Math.atan2(rh, this.rc);
		    sinc = Math.sin(c);
		    cosc = Math.cos(c);
	
		    lat = asinz(cosc * this.sin_p14 + (p.y * sinc * this.cos_p14) / rh);
		    lon = Math.atan2(p.x * sinc, rh * this.cos_p14 * cosc - p.y * this.sin_p14 * sinc);
		    lon = adjust_lon(this.long0 + lon);
		  }
		  else {
		    lat = this.phic0;
		    lon = 0;
		  }
	
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$16 = ["gnom"];
		var gnom = {
		  init: init$15,
		  forward: forward$14,
		  inverse: inverse$14,
		  names: names$16
		};
	
		var iqsfnz = function(eccent, q) {
		  var temp = 1 - (1 - eccent * eccent) / (2 * eccent) * Math.log((1 - eccent) / (1 + eccent));
		  if (Math.abs(Math.abs(q) - temp) < 1.0E-6) {
		    if (q < 0) {
		      return (-1 * HALF_PI);
		    }
		    else {
		      return HALF_PI;
		    }
		  }
		  //var phi = 0.5* q/(1-eccent*eccent);
		  var phi = Math.asin(0.5 * q);
		  var dphi;
		  var sin_phi;
		  var cos_phi;
		  var con;
		  for (var i = 0; i < 30; i++) {
		    sin_phi = Math.sin(phi);
		    cos_phi = Math.cos(phi);
		    con = eccent * sin_phi;
		    dphi = Math.pow(1 - con * con, 2) / (2 * cos_phi) * (q / (1 - eccent * eccent) - sin_phi / (1 - con * con) + 0.5 / eccent * Math.log((1 - con) / (1 + con)));
		    phi += dphi;
		    if (Math.abs(dphi) <= 0.0000000001) {
		      return phi;
		    }
		  }
	
		  //console.log("IQSFN-CONV:Latitude failed to converge after 30 iterations");
		  return NaN;
		};
	
		/*
		  reference:
		    "Cartographic Projection Procedures for the UNIX Environment-
		    A User's Manual" by Gerald I. Evenden,
		    USGS Open File Report 90-284and Release 4 Interim Reports (2003)
		*/
		function init$16() {
		  //no-op
		  if (!this.sphere) {
		    this.k0 = msfnz(this.e, Math.sin(this.lat_ts), Math.cos(this.lat_ts));
		  }
		}
	
		/* Cylindrical Equal Area forward equations--mapping lat,long to x,y
		    ------------------------------------------------------------*/
		function forward$15(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var x, y;
		  /* Forward equations
		      -----------------*/
		  var dlon = adjust_lon(lon - this.long0);
		  if (this.sphere) {
		    x = this.x0 + this.a * dlon * Math.cos(this.lat_ts);
		    y = this.y0 + this.a * Math.sin(lat) / Math.cos(this.lat_ts);
		  }
		  else {
		    var qs = qsfnz(this.e, Math.sin(lat));
		    x = this.x0 + this.a * this.k0 * dlon;
		    y = this.y0 + this.a * qs * 0.5 / this.k0;
		  }
	
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		/* Cylindrical Equal Area inverse equations--mapping x,y to lat/long
		    ------------------------------------------------------------*/
		function inverse$15(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;
		  var lon, lat;
	
		  if (this.sphere) {
		    lon = adjust_lon(this.long0 + (p.x / this.a) / Math.cos(this.lat_ts));
		    lat = Math.asin((p.y / this.a) * Math.cos(this.lat_ts));
		  }
		  else {
		    lat = iqsfnz(this.e, 2 * p.y * this.k0 / this.a);
		    lon = adjust_lon(this.long0 + p.x / (this.a * this.k0));
		  }
	
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$17 = ["cea"];
		var cea = {
		  init: init$16,
		  forward: forward$15,
		  inverse: inverse$15,
		  names: names$17
		};
	
		function init$17() {
	
		  this.x0 = this.x0 || 0;
		  this.y0 = this.y0 || 0;
		  this.lat0 = this.lat0 || 0;
		  this.long0 = this.long0 || 0;
		  this.lat_ts = this.lat_ts || 0;
		  this.title = this.title || "Equidistant Cylindrical (Plate Carre)";
	
		  this.rc = Math.cos(this.lat_ts);
		}
	
		// forward equations--mapping lat,long to x,y
		// -----------------------------------------------------------------
		function forward$16(p) {
	
		  var lon = p.x;
		  var lat = p.y;
	
		  var dlon = adjust_lon(lon - this.long0);
		  var dlat = adjust_lat(lat - this.lat0);
		  p.x = this.x0 + (this.a * dlon * this.rc);
		  p.y = this.y0 + (this.a * dlat);
		  return p;
		}
	
		// inverse equations--mapping x,y to lat/long
		// -----------------------------------------------------------------
		function inverse$16(p) {
	
		  var x = p.x;
		  var y = p.y;
	
		  p.x = adjust_lon(this.long0 + ((x - this.x0) / (this.a * this.rc)));
		  p.y = adjust_lat(this.lat0 + ((y - this.y0) / (this.a)));
		  return p;
		}
	
		var names$18 = ["Equirectangular", "Equidistant_Cylindrical", "eqc"];
		var eqc = {
		  init: init$17,
		  forward: forward$16,
		  inverse: inverse$16,
		  names: names$18
		};
	
		var MAX_ITER$2 = 20;
	
		function init$18() {
		  /* Place parameters in static storage for common use
		      -------------------------------------------------*/
		  this.temp = this.b / this.a;
		  this.es = 1 - Math.pow(this.temp, 2); // devait etre dans tmerc.js mais n y est pas donc je commente sinon retour de valeurs nulles
		  this.e = Math.sqrt(this.es);
		  this.e0 = e0fn(this.es);
		  this.e1 = e1fn(this.es);
		  this.e2 = e2fn(this.es);
		  this.e3 = e3fn(this.es);
		  this.ml0 = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0); //si que des zeros le calcul ne se fait pas
		}
	
		/* Polyconic forward equations--mapping lat,long to x,y
		    ---------------------------------------------------*/
		function forward$17(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var x, y, el;
		  var dlon = adjust_lon(lon - this.long0);
		  el = dlon * Math.sin(lat);
		  if (this.sphere) {
		    if (Math.abs(lat) <= EPSLN) {
		      x = this.a * dlon;
		      y = -1 * this.a * this.lat0;
		    }
		    else {
		      x = this.a * Math.sin(el) / Math.tan(lat);
		      y = this.a * (adjust_lat(lat - this.lat0) + (1 - Math.cos(el)) / Math.tan(lat));
		    }
		  }
		  else {
		    if (Math.abs(lat) <= EPSLN) {
		      x = this.a * dlon;
		      y = -1 * this.ml0;
		    }
		    else {
		      var nl = gN(this.a, this.e, Math.sin(lat)) / Math.tan(lat);
		      x = nl * Math.sin(el);
		      y = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, lat) - this.ml0 + nl * (1 - Math.cos(el));
		    }
	
		  }
		  p.x = x + this.x0;
		  p.y = y + this.y0;
		  return p;
		}
	
		/* Inverse equations
		  -----------------*/
		function inverse$17(p) {
		  var lon, lat, x, y, i;
		  var al, bl;
		  var phi, dphi;
		  x = p.x - this.x0;
		  y = p.y - this.y0;
	
		  if (this.sphere) {
		    if (Math.abs(y + this.a * this.lat0) <= EPSLN) {
		      lon = adjust_lon(x / this.a + this.long0);
		      lat = 0;
		    }
		    else {
		      al = this.lat0 + y / this.a;
		      bl = x * x / this.a / this.a + al * al;
		      phi = al;
		      var tanphi;
		      for (i = MAX_ITER$2; i; --i) {
		        tanphi = Math.tan(phi);
		        dphi = -1 * (al * (phi * tanphi + 1) - phi - 0.5 * (phi * phi + bl) * tanphi) / ((phi - al) / tanphi - 1);
		        phi += dphi;
		        if (Math.abs(dphi) <= EPSLN) {
		          lat = phi;
		          break;
		        }
		      }
		      lon = adjust_lon(this.long0 + (Math.asin(x * Math.tan(phi) / this.a)) / Math.sin(lat));
		    }
		  }
		  else {
		    if (Math.abs(y + this.ml0) <= EPSLN) {
		      lat = 0;
		      lon = adjust_lon(this.long0 + x / this.a);
		    }
		    else {
	
		      al = (this.ml0 + y) / this.a;
		      bl = x * x / this.a / this.a + al * al;
		      phi = al;
		      var cl, mln, mlnp, ma;
		      var con;
		      for (i = MAX_ITER$2; i; --i) {
		        con = this.e * Math.sin(phi);
		        cl = Math.sqrt(1 - con * con) * Math.tan(phi);
		        mln = this.a * mlfn(this.e0, this.e1, this.e2, this.e3, phi);
		        mlnp = this.e0 - 2 * this.e1 * Math.cos(2 * phi) + 4 * this.e2 * Math.cos(4 * phi) - 6 * this.e3 * Math.cos(6 * phi);
		        ma = mln / this.a;
		        dphi = (al * (cl * ma + 1) - ma - 0.5 * cl * (ma * ma + bl)) / (this.es * Math.sin(2 * phi) * (ma * ma + bl - 2 * al * ma) / (4 * cl) + (al - ma) * (cl * mlnp - 2 / Math.sin(2 * phi)) - mlnp);
		        phi -= dphi;
		        if (Math.abs(dphi) <= EPSLN) {
		          lat = phi;
		          break;
		        }
		      }
	
		      //lat=phi4z(this.e,this.e0,this.e1,this.e2,this.e3,al,bl,0,0);
		      cl = Math.sqrt(1 - this.es * Math.pow(Math.sin(lat), 2)) * Math.tan(lat);
		      lon = adjust_lon(this.long0 + Math.asin(x * cl / this.a) / Math.sin(lat));
		    }
		  }
	
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$19 = ["Polyconic", "poly"];
		var poly = {
		  init: init$18,
		  forward: forward$17,
		  inverse: inverse$17,
		  names: names$19
		};
	
		/*
		  reference
		    Department of Land and Survey Technical Circular 1973/32
		      http://www.linz.govt.nz/docs/miscellaneous/nz-map-definition.pdf
		    OSG Technical Report 4.1
		      http://www.linz.govt.nz/docs/miscellaneous/nzmg.pdf
		  */
	
		/**
		 * iterations: Number of iterations to refine inverse transform.
		 *     0 -> km accuracy
		 *     1 -> m accuracy -- suitable for most mapping applications
		 *     2 -> mm accuracy
		 */
	
	
		function init$19() {
		  this.A = [];
		  this.A[1] = 0.6399175073;
		  this.A[2] = -0.1358797613;
		  this.A[3] = 0.063294409;
		  this.A[4] = -0.02526853;
		  this.A[5] = 0.0117879;
		  this.A[6] = -0.0055161;
		  this.A[7] = 0.0026906;
		  this.A[8] = -0.001333;
		  this.A[9] = 0.00067;
		  this.A[10] = -0.00034;
	
		  this.B_re = [];
		  this.B_im = [];
		  this.B_re[1] = 0.7557853228;
		  this.B_im[1] = 0;
		  this.B_re[2] = 0.249204646;
		  this.B_im[2] = 0.003371507;
		  this.B_re[3] = -0.001541739;
		  this.B_im[3] = 0.041058560;
		  this.B_re[4] = -0.10162907;
		  this.B_im[4] = 0.01727609;
		  this.B_re[5] = -0.26623489;
		  this.B_im[5] = -0.36249218;
		  this.B_re[6] = -0.6870983;
		  this.B_im[6] = -1.1651967;
	
		  this.C_re = [];
		  this.C_im = [];
		  this.C_re[1] = 1.3231270439;
		  this.C_im[1] = 0;
		  this.C_re[2] = -0.577245789;
		  this.C_im[2] = -0.007809598;
		  this.C_re[3] = 0.508307513;
		  this.C_im[3] = -0.112208952;
		  this.C_re[4] = -0.15094762;
		  this.C_im[4] = 0.18200602;
		  this.C_re[5] = 1.01418179;
		  this.C_im[5] = 1.64497696;
		  this.C_re[6] = 1.9660549;
		  this.C_im[6] = 2.5127645;
	
		  this.D = [];
		  this.D[1] = 1.5627014243;
		  this.D[2] = 0.5185406398;
		  this.D[3] = -0.03333098;
		  this.D[4] = -0.1052906;
		  this.D[5] = -0.0368594;
		  this.D[6] = 0.007317;
		  this.D[7] = 0.01220;
		  this.D[8] = 0.00394;
		  this.D[9] = -0.0013;
		}
	
		/**
		    New Zealand Map Grid Forward  - long/lat to x/y
		    long/lat in radians
		  */
		function forward$18(p) {
		  var n;
		  var lon = p.x;
		  var lat = p.y;
	
		  var delta_lat = lat - this.lat0;
		  var delta_lon = lon - this.long0;
	
		  // 1. Calculate d_phi and d_psi    ...                          // and d_lambda
		  // For this algorithm, delta_latitude is in seconds of arc x 10-5, so we need to scale to those units. Longitude is radians.
		  var d_phi = delta_lat / SEC_TO_RAD * 1E-5;
		  var d_lambda = delta_lon;
		  var d_phi_n = 1; // d_phi^0
	
		  var d_psi = 0;
		  for (n = 1; n <= 10; n++) {
		    d_phi_n = d_phi_n * d_phi;
		    d_psi = d_psi + this.A[n] * d_phi_n;
		  }
	
		  // 2. Calculate theta
		  var th_re = d_psi;
		  var th_im = d_lambda;
	
		  // 3. Calculate z
		  var th_n_re = 1;
		  var th_n_im = 0; // theta^0
		  var th_n_re1;
		  var th_n_im1;
	
		  var z_re = 0;
		  var z_im = 0;
		  for (n = 1; n <= 6; n++) {
		    th_n_re1 = th_n_re * th_re - th_n_im * th_im;
		    th_n_im1 = th_n_im * th_re + th_n_re * th_im;
		    th_n_re = th_n_re1;
		    th_n_im = th_n_im1;
		    z_re = z_re + this.B_re[n] * th_n_re - this.B_im[n] * th_n_im;
		    z_im = z_im + this.B_im[n] * th_n_re + this.B_re[n] * th_n_im;
		  }
	
		  // 4. Calculate easting and northing
		  p.x = (z_im * this.a) + this.x0;
		  p.y = (z_re * this.a) + this.y0;
	
		  return p;
		}
	
		/**
		    New Zealand Map Grid Inverse  -  x/y to long/lat
		  */
		function inverse$18(p) {
		  var n;
		  var x = p.x;
		  var y = p.y;
	
		  var delta_x = x - this.x0;
		  var delta_y = y - this.y0;
	
		  // 1. Calculate z
		  var z_re = delta_y / this.a;
		  var z_im = delta_x / this.a;
	
		  // 2a. Calculate theta - first approximation gives km accuracy
		  var z_n_re = 1;
		  var z_n_im = 0; // z^0
		  var z_n_re1;
		  var z_n_im1;
	
		  var th_re = 0;
		  var th_im = 0;
		  for (n = 1; n <= 6; n++) {
		    z_n_re1 = z_n_re * z_re - z_n_im * z_im;
		    z_n_im1 = z_n_im * z_re + z_n_re * z_im;
		    z_n_re = z_n_re1;
		    z_n_im = z_n_im1;
		    th_re = th_re + this.C_re[n] * z_n_re - this.C_im[n] * z_n_im;
		    th_im = th_im + this.C_im[n] * z_n_re + this.C_re[n] * z_n_im;
		  }
	
		  // 2b. Iterate to refine the accuracy of the calculation
		  //        0 iterations gives km accuracy
		  //        1 iteration gives m accuracy -- good enough for most mapping applications
		  //        2 iterations bives mm accuracy
		  for (var i = 0; i < this.iterations; i++) {
		    var th_n_re = th_re;
		    var th_n_im = th_im;
		    var th_n_re1;
		    var th_n_im1;
	
		    var num_re = z_re;
		    var num_im = z_im;
		    for (n = 2; n <= 6; n++) {
		      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
		      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
		      th_n_re = th_n_re1;
		      th_n_im = th_n_im1;
		      num_re = num_re + (n - 1) * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
		      num_im = num_im + (n - 1) * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
		    }
	
		    th_n_re = 1;
		    th_n_im = 0;
		    var den_re = this.B_re[1];
		    var den_im = this.B_im[1];
		    for (n = 2; n <= 6; n++) {
		      th_n_re1 = th_n_re * th_re - th_n_im * th_im;
		      th_n_im1 = th_n_im * th_re + th_n_re * th_im;
		      th_n_re = th_n_re1;
		      th_n_im = th_n_im1;
		      den_re = den_re + n * (this.B_re[n] * th_n_re - this.B_im[n] * th_n_im);
		      den_im = den_im + n * (this.B_im[n] * th_n_re + this.B_re[n] * th_n_im);
		    }
	
		    // Complex division
		    var den2 = den_re * den_re + den_im * den_im;
		    th_re = (num_re * den_re + num_im * den_im) / den2;
		    th_im = (num_im * den_re - num_re * den_im) / den2;
		  }
	
		  // 3. Calculate d_phi              ...                                    // and d_lambda
		  var d_psi = th_re;
		  var d_lambda = th_im;
		  var d_psi_n = 1; // d_psi^0
	
		  var d_phi = 0;
		  for (n = 1; n <= 9; n++) {
		    d_psi_n = d_psi_n * d_psi;
		    d_phi = d_phi + this.D[n] * d_psi_n;
		  }
	
		  // 4. Calculate latitude and longitude
		  // d_phi is calcuated in second of arc * 10^-5, so we need to scale back to radians. d_lambda is in radians.
		  var lat = this.lat0 + (d_phi * SEC_TO_RAD * 1E5);
		  var lon = this.long0 + d_lambda;
	
		  p.x = lon;
		  p.y = lat;
	
		  return p;
		}
	
		var names$20 = ["New_Zealand_Map_Grid", "nzmg"];
		var nzmg = {
		  init: init$19,
		  forward: forward$18,
		  inverse: inverse$18,
		  names: names$20
		};
	
		/*
		  reference
		    "New Equal-Area Map Projections for Noncircular Regions", John P. Snyder,
		    The American Cartographer, Vol 15, No. 4, October 1988, pp. 341-355.
		  */
	
	
		/* Initialize the Miller Cylindrical projection
		  -------------------------------------------*/
		function init$20() {
		  //no-op
		}
	
		/* Miller Cylindrical forward equations--mapping lat,long to x,y
		    ------------------------------------------------------------*/
		function forward$19(p) {
		  var lon = p.x;
		  var lat = p.y;
		  /* Forward equations
		      -----------------*/
		  var dlon = adjust_lon(lon - this.long0);
		  var x = this.x0 + this.a * dlon;
		  var y = this.y0 + this.a * Math.log(Math.tan((Math.PI / 4) + (lat / 2.5))) * 1.25;
	
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		/* Miller Cylindrical inverse equations--mapping x,y to lat/long
		    ------------------------------------------------------------*/
		function inverse$19(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;
	
		  var lon = adjust_lon(this.long0 + p.x / this.a);
		  var lat = 2.5 * (Math.atan(Math.exp(0.8 * p.y / this.a)) - Math.PI / 4);
	
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$21 = ["Miller_Cylindrical", "mill"];
		var mill = {
		  init: init$20,
		  forward: forward$19,
		  inverse: inverse$19,
		  names: names$21
		};
	
		var MAX_ITER$3 = 20;
		function init$21() {
		  /* Place parameters in static storage for common use
		    -------------------------------------------------*/
	
	
		  if (!this.sphere) {
		    this.en = pj_enfn(this.es);
		  }
		  else {
		    this.n = 1;
		    this.m = 0;
		    this.es = 0;
		    this.C_y = Math.sqrt((this.m + 1) / this.n);
		    this.C_x = this.C_y / (this.m + 1);
		  }
	
		}
	
		/* Sinusoidal forward equations--mapping lat,long to x,y
		  -----------------------------------------------------*/
		function forward$20(p) {
		  var x, y;
		  var lon = p.x;
		  var lat = p.y;
		  /* Forward equations
		    -----------------*/
		  lon = adjust_lon(lon - this.long0);
	
		  if (this.sphere) {
		    if (!this.m) {
		      lat = this.n !== 1 ? Math.asin(this.n * Math.sin(lat)) : lat;
		    }
		    else {
		      var k = this.n * Math.sin(lat);
		      for (var i = MAX_ITER$3; i; --i) {
		        var V = (this.m * lat + Math.sin(lat) - k) / (this.m + Math.cos(lat));
		        lat -= V;
		        if (Math.abs(V) < EPSLN) {
		          break;
		        }
		      }
		    }
		    x = this.a * this.C_x * lon * (this.m + Math.cos(lat));
		    y = this.a * this.C_y * lat;
	
		  }
		  else {
	
		    var s = Math.sin(lat);
		    var c = Math.cos(lat);
		    y = this.a * pj_mlfn(lat, s, c, this.en);
		    x = this.a * lon * c / Math.sqrt(1 - this.es * s * s);
		  }
	
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		function inverse$20(p) {
		  var lat, temp, lon, s;
	
		  p.x -= this.x0;
		  lon = p.x / this.a;
		  p.y -= this.y0;
		  lat = p.y / this.a;
	
		  if (this.sphere) {
		    lat /= this.C_y;
		    lon = lon / (this.C_x * (this.m + Math.cos(lat)));
		    if (this.m) {
		      lat = asinz((this.m * lat + Math.sin(lat)) / this.n);
		    }
		    else if (this.n !== 1) {
		      lat = asinz(Math.sin(lat) / this.n);
		    }
		    lon = adjust_lon(lon + this.long0);
		    lat = adjust_lat(lat);
		  }
		  else {
		    lat = pj_inv_mlfn(p.y / this.a, this.es, this.en);
		    s = Math.abs(lat);
		    if (s < HALF_PI) {
		      s = Math.sin(lat);
		      temp = this.long0 + p.x * Math.sqrt(1 - this.es * s * s) / (this.a * Math.cos(lat));
		      //temp = this.long0 + p.x / (this.a * Math.cos(lat));
		      lon = adjust_lon(temp);
		    }
		    else if ((s - EPSLN) < HALF_PI) {
		      lon = this.long0;
		    }
		  }
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$22 = ["Sinusoidal", "sinu"];
		var sinu = {
		  init: init$21,
		  forward: forward$20,
		  inverse: inverse$20,
		  names: names$22
		};
	
		function init$22() {}
		/* Mollweide forward equations--mapping lat,long to x,y
		    ----------------------------------------------------*/
		function forward$21(p) {
	
		  /* Forward equations
		      -----------------*/
		  var lon = p.x;
		  var lat = p.y;
	
		  var delta_lon = adjust_lon(lon - this.long0);
		  var theta = lat;
		  var con = Math.PI * Math.sin(lat);
	
		  /* Iterate using the Newton-Raphson method to find theta
		      -----------------------------------------------------*/
		  for (var i = 0; true; i++) {
		    var delta_theta = -(theta + Math.sin(theta) - con) / (1 + Math.cos(theta));
		    theta += delta_theta;
		    if (Math.abs(delta_theta) < EPSLN) {
		      break;
		    }
		  }
		  theta /= 2;
	
		  /* If the latitude is 90 deg, force the x coordinate to be "0 + false easting"
		       this is done here because of precision problems with "cos(theta)"
		       --------------------------------------------------------------------------*/
		  if (Math.PI / 2 - Math.abs(lat) < EPSLN) {
		    delta_lon = 0;
		  }
		  var x = 0.900316316158 * this.a * delta_lon * Math.cos(theta) + this.x0;
		  var y = 1.4142135623731 * this.a * Math.sin(theta) + this.y0;
	
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		function inverse$21(p) {
		  var theta;
		  var arg;
	
		  /* Inverse equations
		      -----------------*/
		  p.x -= this.x0;
		  p.y -= this.y0;
		  arg = p.y / (1.4142135623731 * this.a);
	
		  /* Because of division by zero problems, 'arg' can not be 1.  Therefore
		       a number very close to one is used instead.
		       -------------------------------------------------------------------*/
		  if (Math.abs(arg) > 0.999999999999) {
		    arg = 0.999999999999;
		  }
		  theta = Math.asin(arg);
		  var lon = adjust_lon(this.long0 + (p.x / (0.900316316158 * this.a * Math.cos(theta))));
		  if (lon < (-Math.PI)) {
		    lon = -Math.PI;
		  }
		  if (lon > Math.PI) {
		    lon = Math.PI;
		  }
		  arg = (2 * theta + Math.sin(2 * theta)) / Math.PI;
		  if (Math.abs(arg) > 1) {
		    arg = 1;
		  }
		  var lat = Math.asin(arg);
	
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$23 = ["Mollweide", "moll"];
		var moll = {
		  init: init$22,
		  forward: forward$21,
		  inverse: inverse$21,
		  names: names$23
		};
	
		function init$23() {
	
		  /* Place parameters in static storage for common use
		      -------------------------------------------------*/
		  // Standard Parallels cannot be equal and on opposite sides of the equator
		  if (Math.abs(this.lat1 + this.lat2) < EPSLN) {
		    return;
		  }
		  this.lat2 = this.lat2 || this.lat1;
		  this.temp = this.b / this.a;
		  this.es = 1 - Math.pow(this.temp, 2);
		  this.e = Math.sqrt(this.es);
		  this.e0 = e0fn(this.es);
		  this.e1 = e1fn(this.es);
		  this.e2 = e2fn(this.es);
		  this.e3 = e3fn(this.es);
	
		  this.sinphi = Math.sin(this.lat1);
		  this.cosphi = Math.cos(this.lat1);
	
		  this.ms1 = msfnz(this.e, this.sinphi, this.cosphi);
		  this.ml1 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat1);
	
		  if (Math.abs(this.lat1 - this.lat2) < EPSLN) {
		    this.ns = this.sinphi;
		  }
		  else {
		    this.sinphi = Math.sin(this.lat2);
		    this.cosphi = Math.cos(this.lat2);
		    this.ms2 = msfnz(this.e, this.sinphi, this.cosphi);
		    this.ml2 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat2);
		    this.ns = (this.ms1 - this.ms2) / (this.ml2 - this.ml1);
		  }
		  this.g = this.ml1 + this.ms1 / this.ns;
		  this.ml0 = mlfn(this.e0, this.e1, this.e2, this.e3, this.lat0);
		  this.rh = this.a * (this.g - this.ml0);
		}
	
		/* Equidistant Conic forward equations--mapping lat,long to x,y
		  -----------------------------------------------------------*/
		function forward$22(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var rh1;
	
		  /* Forward equations
		      -----------------*/
		  if (this.sphere) {
		    rh1 = this.a * (this.g - lat);
		  }
		  else {
		    var ml = mlfn(this.e0, this.e1, this.e2, this.e3, lat);
		    rh1 = this.a * (this.g - ml);
		  }
		  var theta = this.ns * adjust_lon(lon - this.long0);
		  var x = this.x0 + rh1 * Math.sin(theta);
		  var y = this.y0 + this.rh - rh1 * Math.cos(theta);
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		/* Inverse equations
		  -----------------*/
		function inverse$22(p) {
		  p.x -= this.x0;
		  p.y = this.rh - p.y + this.y0;
		  var con, rh1, lat, lon;
		  if (this.ns >= 0) {
		    rh1 = Math.sqrt(p.x * p.x + p.y * p.y);
		    con = 1;
		  }
		  else {
		    rh1 = -Math.sqrt(p.x * p.x + p.y * p.y);
		    con = -1;
		  }
		  var theta = 0;
		  if (rh1 !== 0) {
		    theta = Math.atan2(con * p.x, con * p.y);
		  }
	
		  if (this.sphere) {
		    lon = adjust_lon(this.long0 + theta / this.ns);
		    lat = adjust_lat(this.g - rh1 / this.a);
		    p.x = lon;
		    p.y = lat;
		    return p;
		  }
		  else {
		    var ml = this.g - rh1 / this.a;
		    lat = imlfn(ml, this.e0, this.e1, this.e2, this.e3);
		    lon = adjust_lon(this.long0 + theta / this.ns);
		    p.x = lon;
		    p.y = lat;
		    return p;
		  }
	
		}
	
		var names$24 = ["Equidistant_Conic", "eqdc"];
		var eqdc = {
		  init: init$23,
		  forward: forward$22,
		  inverse: inverse$22,
		  names: names$24
		};
	
		/* Initialize the Van Der Grinten projection
		  ----------------------------------------*/
		function init$24() {
		  //this.R = 6370997; //Radius of earth
		  this.R = this.a;
		}
	
		function forward$23(p) {
	
		  var lon = p.x;
		  var lat = p.y;
	
		  /* Forward equations
		    -----------------*/
		  var dlon = adjust_lon(lon - this.long0);
		  var x, y;
	
		  if (Math.abs(lat) <= EPSLN) {
		    x = this.x0 + this.R * dlon;
		    y = this.y0;
		  }
		  var theta = asinz(2 * Math.abs(lat / Math.PI));
		  if ((Math.abs(dlon) <= EPSLN) || (Math.abs(Math.abs(lat) - HALF_PI) <= EPSLN)) {
		    x = this.x0;
		    if (lat >= 0) {
		      y = this.y0 + Math.PI * this.R * Math.tan(0.5 * theta);
		    }
		    else {
		      y = this.y0 + Math.PI * this.R * -Math.tan(0.5 * theta);
		    }
		    //  return(OK);
		  }
		  var al = 0.5 * Math.abs((Math.PI / dlon) - (dlon / Math.PI));
		  var asq = al * al;
		  var sinth = Math.sin(theta);
		  var costh = Math.cos(theta);
	
		  var g = costh / (sinth + costh - 1);
		  var gsq = g * g;
		  var m = g * (2 / sinth - 1);
		  var msq = m * m;
		  var con = Math.PI * this.R * (al * (g - msq) + Math.sqrt(asq * (g - msq) * (g - msq) - (msq + asq) * (gsq - msq))) / (msq + asq);
		  if (dlon < 0) {
		    con = -con;
		  }
		  x = this.x0 + con;
		  //con = Math.abs(con / (Math.PI * this.R));
		  var q = asq + g;
		  con = Math.PI * this.R * (m * q - al * Math.sqrt((msq + asq) * (asq + 1) - q * q)) / (msq + asq);
		  if (lat >= 0) {
		    //y = this.y0 + Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
		    y = this.y0 + con;
		  }
		  else {
		    //y = this.y0 - Math.PI * this.R * Math.sqrt(1 - con * con - 2 * al * con);
		    y = this.y0 - con;
		  }
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		/* Van Der Grinten inverse equations--mapping x,y to lat/long
		  ---------------------------------------------------------*/
		function inverse$23(p) {
		  var lon, lat;
		  var xx, yy, xys, c1, c2, c3;
		  var a1;
		  var m1;
		  var con;
		  var th1;
		  var d;
	
		  /* inverse equations
		    -----------------*/
		  p.x -= this.x0;
		  p.y -= this.y0;
		  con = Math.PI * this.R;
		  xx = p.x / con;
		  yy = p.y / con;
		  xys = xx * xx + yy * yy;
		  c1 = -Math.abs(yy) * (1 + xys);
		  c2 = c1 - 2 * yy * yy + xx * xx;
		  c3 = -2 * c1 + 1 + 2 * yy * yy + xys * xys;
		  d = yy * yy / c3 + (2 * c2 * c2 * c2 / c3 / c3 / c3 - 9 * c1 * c2 / c3 / c3) / 27;
		  a1 = (c1 - c2 * c2 / 3 / c3) / c3;
		  m1 = 2 * Math.sqrt(-a1 / 3);
		  con = ((3 * d) / a1) / m1;
		  if (Math.abs(con) > 1) {
		    if (con >= 0) {
		      con = 1;
		    }
		    else {
		      con = -1;
		    }
		  }
		  th1 = Math.acos(con) / 3;
		  if (p.y >= 0) {
		    lat = (-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
		  }
		  else {
		    lat = -(-m1 * Math.cos(th1 + Math.PI / 3) - c2 / 3 / c3) * Math.PI;
		  }
	
		  if (Math.abs(xx) < EPSLN) {
		    lon = this.long0;
		  }
		  else {
		    lon = adjust_lon(this.long0 + Math.PI * (xys - 1 + Math.sqrt(1 + 2 * (xx * xx - yy * yy) + xys * xys)) / 2 / xx);
		  }
	
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$25 = ["Van_der_Grinten_I", "VanDerGrinten", "vandg"];
		var vandg = {
		  init: init$24,
		  forward: forward$23,
		  inverse: inverse$23,
		  names: names$25
		};
	
		function init$25() {
		  this.sin_p12 = Math.sin(this.lat0);
		  this.cos_p12 = Math.cos(this.lat0);
		}
	
		function forward$24(p) {
		  var lon = p.x;
		  var lat = p.y;
		  var sinphi = Math.sin(p.y);
		  var cosphi = Math.cos(p.y);
		  var dlon = adjust_lon(lon - this.long0);
		  var e0, e1, e2, e3, Mlp, Ml, tanphi, Nl1, Nl, psi, Az, G, H, GH, Hs, c, kp, cos_c, s, s2, s3, s4, s5;
		  if (this.sphere) {
		    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
		      //North Pole case
		      p.x = this.x0 + this.a * (HALF_PI - lat) * Math.sin(dlon);
		      p.y = this.y0 - this.a * (HALF_PI - lat) * Math.cos(dlon);
		      return p;
		    }
		    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
		      //South Pole case
		      p.x = this.x0 + this.a * (HALF_PI + lat) * Math.sin(dlon);
		      p.y = this.y0 + this.a * (HALF_PI + lat) * Math.cos(dlon);
		      return p;
		    }
		    else {
		      //default case
		      cos_c = this.sin_p12 * sinphi + this.cos_p12 * cosphi * Math.cos(dlon);
		      c = Math.acos(cos_c);
		      kp = c / Math.sin(c);
		      p.x = this.x0 + this.a * kp * cosphi * Math.sin(dlon);
		      p.y = this.y0 + this.a * kp * (this.cos_p12 * sinphi - this.sin_p12 * cosphi * Math.cos(dlon));
		      return p;
		    }
		  }
		  else {
		    e0 = e0fn(this.es);
		    e1 = e1fn(this.es);
		    e2 = e2fn(this.es);
		    e3 = e3fn(this.es);
		    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
		      //North Pole case
		      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
		      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
		      p.x = this.x0 + (Mlp - Ml) * Math.sin(dlon);
		      p.y = this.y0 - (Mlp - Ml) * Math.cos(dlon);
		      return p;
		    }
		    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
		      //South Pole case
		      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
		      Ml = this.a * mlfn(e0, e1, e2, e3, lat);
		      p.x = this.x0 + (Mlp + Ml) * Math.sin(dlon);
		      p.y = this.y0 + (Mlp + Ml) * Math.cos(dlon);
		      return p;
		    }
		    else {
		      //Default case
		      tanphi = sinphi / cosphi;
		      Nl1 = gN(this.a, this.e, this.sin_p12);
		      Nl = gN(this.a, this.e, sinphi);
		      psi = Math.atan((1 - this.es) * tanphi + this.es * Nl1 * this.sin_p12 / (Nl * cosphi));
		      Az = Math.atan2(Math.sin(dlon), this.cos_p12 * Math.tan(psi) - this.sin_p12 * Math.cos(dlon));
		      if (Az === 0) {
		        s = Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
		      }
		      else if (Math.abs(Math.abs(Az) - Math.PI) <= EPSLN) {
		        s = -Math.asin(this.cos_p12 * Math.sin(psi) - this.sin_p12 * Math.cos(psi));
		      }
		      else {
		        s = Math.asin(Math.sin(dlon) * Math.cos(psi) / Math.sin(Az));
		      }
		      G = this.e * this.sin_p12 / Math.sqrt(1 - this.es);
		      H = this.e * this.cos_p12 * Math.cos(Az) / Math.sqrt(1 - this.es);
		      GH = G * H;
		      Hs = H * H;
		      s2 = s * s;
		      s3 = s2 * s;
		      s4 = s3 * s;
		      s5 = s4 * s;
		      c = Nl1 * s * (1 - s2 * Hs * (1 - Hs) / 6 + s3 / 8 * GH * (1 - 2 * Hs) + s4 / 120 * (Hs * (4 - 7 * Hs) - 3 * G * G * (1 - 7 * Hs)) - s5 / 48 * GH);
		      p.x = this.x0 + c * Math.sin(Az);
		      p.y = this.y0 + c * Math.cos(Az);
		      return p;
		    }
		  }
	
	
		}
	
		function inverse$24(p) {
		  p.x -= this.x0;
		  p.y -= this.y0;
		  var rh, z, sinz, cosz, lon, lat, con, e0, e1, e2, e3, Mlp, M, N1, psi, Az, cosAz, tmp, A, B, D, Ee, F;
		  if (this.sphere) {
		    rh = Math.sqrt(p.x * p.x + p.y * p.y);
		    if (rh > (2 * HALF_PI * this.a)) {
		      return;
		    }
		    z = rh / this.a;
	
		    sinz = Math.sin(z);
		    cosz = Math.cos(z);
	
		    lon = this.long0;
		    if (Math.abs(rh) <= EPSLN) {
		      lat = this.lat0;
		    }
		    else {
		      lat = asinz(cosz * this.sin_p12 + (p.y * sinz * this.cos_p12) / rh);
		      con = Math.abs(this.lat0) - HALF_PI;
		      if (Math.abs(con) <= EPSLN) {
		        if (this.lat0 >= 0) {
		          lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
		        }
		        else {
		          lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
		        }
		      }
		      else {
		        /*con = cosz - this.sin_p12 * Math.sin(lat);
		        if ((Math.abs(con) < EPSLN) && (Math.abs(p.x) < EPSLN)) {
		          //no-op, just keep the lon value as is
		        } else {
		          var temp = Math.atan2((p.x * sinz * this.cos_p12), (con * rh));
		          lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz * this.cos_p12), (con * rh)));
		        }*/
		        lon = adjust_lon(this.long0 + Math.atan2(p.x * sinz, rh * this.cos_p12 * cosz - p.y * this.sin_p12 * sinz));
		      }
		    }
	
		    p.x = lon;
		    p.y = lat;
		    return p;
		  }
		  else {
		    e0 = e0fn(this.es);
		    e1 = e1fn(this.es);
		    e2 = e2fn(this.es);
		    e3 = e3fn(this.es);
		    if (Math.abs(this.sin_p12 - 1) <= EPSLN) {
		      //North pole case
		      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
		      rh = Math.sqrt(p.x * p.x + p.y * p.y);
		      M = Mlp - rh;
		      lat = imlfn(M / this.a, e0, e1, e2, e3);
		      lon = adjust_lon(this.long0 + Math.atan2(p.x, - 1 * p.y));
		      p.x = lon;
		      p.y = lat;
		      return p;
		    }
		    else if (Math.abs(this.sin_p12 + 1) <= EPSLN) {
		      //South pole case
		      Mlp = this.a * mlfn(e0, e1, e2, e3, HALF_PI);
		      rh = Math.sqrt(p.x * p.x + p.y * p.y);
		      M = rh - Mlp;
	
		      lat = imlfn(M / this.a, e0, e1, e2, e3);
		      lon = adjust_lon(this.long0 + Math.atan2(p.x, p.y));
		      p.x = lon;
		      p.y = lat;
		      return p;
		    }
		    else {
		      //default case
		      rh = Math.sqrt(p.x * p.x + p.y * p.y);
		      Az = Math.atan2(p.x, p.y);
		      N1 = gN(this.a, this.e, this.sin_p12);
		      cosAz = Math.cos(Az);
		      tmp = this.e * this.cos_p12 * cosAz;
		      A = -tmp * tmp / (1 - this.es);
		      B = 3 * this.es * (1 - A) * this.sin_p12 * this.cos_p12 * cosAz / (1 - this.es);
		      D = rh / N1;
		      Ee = D - A * (1 + A) * Math.pow(D, 3) / 6 - B * (1 + 3 * A) * Math.pow(D, 4) / 24;
		      F = 1 - A * Ee * Ee / 2 - D * Ee * Ee * Ee / 6;
		      psi = Math.asin(this.sin_p12 * Math.cos(Ee) + this.cos_p12 * Math.sin(Ee) * cosAz);
		      lon = adjust_lon(this.long0 + Math.asin(Math.sin(Az) * Math.sin(Ee) / Math.cos(psi)));
		      lat = Math.atan((1 - this.es * F * this.sin_p12 / Math.sin(psi)) * Math.tan(psi) / (1 - this.es));
		      p.x = lon;
		      p.y = lat;
		      return p;
		    }
		  }
	
		}
	
		var names$26 = ["Azimuthal_Equidistant", "aeqd"];
		var aeqd = {
		  init: init$25,
		  forward: forward$24,
		  inverse: inverse$24,
		  names: names$26
		};
	
		function init$26() {
		  //double temp;      /* temporary variable    */
	
		  /* Place parameters in static storage for common use
		      -------------------------------------------------*/
		  this.sin_p14 = Math.sin(this.lat0);
		  this.cos_p14 = Math.cos(this.lat0);
		}
	
		/* Orthographic forward equations--mapping lat,long to x,y
		    ---------------------------------------------------*/
		function forward$25(p) {
		  var sinphi, cosphi; /* sin and cos value        */
		  var dlon; /* delta longitude value      */
		  var coslon; /* cos of longitude        */
		  var ksp; /* scale factor          */
		  var g, x, y;
		  var lon = p.x;
		  var lat = p.y;
		  /* Forward equations
		      -----------------*/
		  dlon = adjust_lon(lon - this.long0);
	
		  sinphi = Math.sin(lat);
		  cosphi = Math.cos(lat);
	
		  coslon = Math.cos(dlon);
		  g = this.sin_p14 * sinphi + this.cos_p14 * cosphi * coslon;
		  ksp = 1;
		  if ((g > 0) || (Math.abs(g) <= EPSLN)) {
		    x = this.a * ksp * cosphi * Math.sin(dlon);
		    y = this.y0 + this.a * ksp * (this.cos_p14 * sinphi - this.sin_p14 * cosphi * coslon);
		  }
		  p.x = x;
		  p.y = y;
		  return p;
		}
	
		function inverse$25(p) {
		  var rh; /* height above ellipsoid      */
		  var z; /* angle          */
		  var sinz, cosz; /* sin of z and cos of z      */
		  var con;
		  var lon, lat;
		  /* Inverse equations
		      -----------------*/
		  p.x -= this.x0;
		  p.y -= this.y0;
		  rh = Math.sqrt(p.x * p.x + p.y * p.y);
		  z = asinz(rh / this.a);
	
		  sinz = Math.sin(z);
		  cosz = Math.cos(z);
	
		  lon = this.long0;
		  if (Math.abs(rh) <= EPSLN) {
		    lat = this.lat0;
		    p.x = lon;
		    p.y = lat;
		    return p;
		  }
		  lat = asinz(cosz * this.sin_p14 + (p.y * sinz * this.cos_p14) / rh);
		  con = Math.abs(this.lat0) - HALF_PI;
		  if (Math.abs(con) <= EPSLN) {
		    if (this.lat0 >= 0) {
		      lon = adjust_lon(this.long0 + Math.atan2(p.x, - p.y));
		    }
		    else {
		      lon = adjust_lon(this.long0 - Math.atan2(-p.x, p.y));
		    }
		    p.x = lon;
		    p.y = lat;
		    return p;
		  }
		  lon = adjust_lon(this.long0 + Math.atan2((p.x * sinz), rh * this.cos_p14 * cosz - p.y * this.sin_p14 * sinz));
		  p.x = lon;
		  p.y = lat;
		  return p;
		}
	
		var names$27 = ["ortho"];
		var ortho = {
		  init: init$26,
		  forward: forward$25,
		  inverse: inverse$25,
		  names: names$27
		};
	
		var includedProjections = function(proj4){
		  proj4.Proj.projections.add(tmerc);
		  proj4.Proj.projections.add(etmerc);
		  proj4.Proj.projections.add(utm);
		  proj4.Proj.projections.add(sterea);
		  proj4.Proj.projections.add(stere);
		  proj4.Proj.projections.add(somerc);
		  proj4.Proj.projections.add(omerc);
		  proj4.Proj.projections.add(lcc);
		  proj4.Proj.projections.add(krovak);
		  proj4.Proj.projections.add(cass);
		  proj4.Proj.projections.add(laea);
		  proj4.Proj.projections.add(aea);
		  proj4.Proj.projections.add(gnom);
		  proj4.Proj.projections.add(cea);
		  proj4.Proj.projections.add(eqc);
		  proj4.Proj.projections.add(poly);
		  proj4.Proj.projections.add(nzmg);
		  proj4.Proj.projections.add(mill);
		  proj4.Proj.projections.add(sinu);
		  proj4.Proj.projections.add(moll);
		  proj4.Proj.projections.add(eqdc);
		  proj4.Proj.projections.add(vandg);
		  proj4.Proj.projections.add(aeqd);
		  proj4.Proj.projections.add(ortho);
		};
	
		proj4$1.defaultDatum = 'WGS84'; //default datum
		proj4$1.Proj = Projection$1;
		proj4$1.WGS84 = new proj4$1.Proj('WGS84');
		proj4$1.Point = Point;
		proj4$1.toPoint = toPoint;
		proj4$1.defs = defs;
		proj4$1.transform = transform;
		proj4$1.mgrs = mgrs;
		proj4$1.version = version;
		includedProjections(proj4$1);
	
		return proj4$1;
	
	})));


/***/ },
/* 296 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/*
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */
	
	/**
	 * Math functions.
	 *
	 * @namespace
	 * @alias MathExt
	 */
	var MathExt = {};
	
	/**
	 * pi
	 *
	 * @type {Number}
	 * @constant
	 */
	MathExt.PI = Math.PI;
	
	/**
	 * pi/2
	 *
	 * @type {Number}
	 * @constant
	 */
	MathExt.PI_OV_TWO = Math.PI * 0.5;
	
	MathExt.PI_OV_FOUR = Math.PI * 0.25;
	
	/**
	 * pi*2
	 *
	 * @type {Number}
	 * @constant
	 */
	MathExt.TWO_PI = Math.PI * 2.0;
	
	MathExt.INV_TWO_PI = 1.0 / MathExt.TWO_PI;
	
	MathExt.LOG_TWO = Math.log(2.0);
	
	MathExt.RADTODEG = 180.0 / MathExt.PI;
	
	MathExt.DEGTORAD = MathExt.PI / 180.0;
	
	MathExt.radToDeg = function radToDeg(rad) {
	    return rad * MathExt.RADTODEG;
	};
	
	MathExt.degToRad = function degToRad(deg) {
	    return deg * MathExt.DEGTORAD;
	};
	
	MathExt.arrayDegToRad = function arrayDegToRad(arrayDeg) {
	    if (arrayDeg) {
	        for (var i = 0; i < arrayDeg.length; i++) {
	            arrayDeg[i] = MathExt.degToRad(arrayDeg[i]);
	        }
	    }
	};
	
	MathExt.arrayRadToDeg = function arrayRadToDeg(arrayDeg) {
	    if (arrayDeg) {
	        for (var i = 0; i < arrayDeg.length; i++) {
	            arrayDeg[i] = MathExt.radToDeg(arrayDeg[i]);
	        }
	    }
	};
	
	// TODO: Function in test :
	MathExt.step = function step(val, stepVal) {
	    if (val < stepVal) {
	        return 0.0;
	    } else {
	        return 1.0;
	    }
	};
	
	MathExt.exp2 = function exp2(expo) {
	    return Math.pow(2, expo);
	};
	
	exports.default = MathExt;

/***/ },
/* 297 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Coordinates = __webpack_require__(289);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: Ellipsoid
	 * Description: Classe mathématique de  l'ellispoide
	 */
	
	function Ellipsoid(size) {
	    // Constructor
	
	
	    this.rayon_1 = size.x;
	    this.rayon_2 = size.y;
	    this.rayon_3 = size.z;
	
	    this.size = new THREE.Vector3(size.x, size.y, size.z);
	
	    this._radiiSquared = new THREE.Vector3(size.x * size.x, size.y * size.y, size.z * size.z);
	}
	
	Ellipsoid.prototype.geodeticSurfaceNormalCartographic = function geodeticSurfaceNormalCartographic(coordCarto) {
	    var longitude = Math.PI * 2 - coordCarto.longitude(_Coordinates.UNIT.RADIAN);
	    var latitude = coordCarto.latitude(_Coordinates.UNIT.RADIAN);
	    var cosLatitude = Math.cos(latitude);
	
	    var x = cosLatitude * Math.cos(longitude);
	    var z = cosLatitude * Math.sin(longitude);
	    var y = Math.sin(latitude);
	
	    var result = new THREE.Vector3(x, y, z);
	
	    return result.normalize();
	};
	
	Ellipsoid.prototype.setSize = function setSize(size) {
	    this.rayon_1 = size.x;
	    this.rayon_2 = size.y;
	    this.rayon_3 = size.z;
	
	    this._radiiSquared = new THREE.Vector3(size.x * size.x, size.y * size.y, size.z * size.z);
	};
	
	Ellipsoid.prototype.cartographicToCartesian = function cartographicToCartesian(coordCarto) {
	    // var n;
	    var k = new THREE.Vector3();
	    var n = this.geodeticSurfaceNormalCartographic(coordCarto);
	
	    k.multiplyVectors(this._radiiSquared, n);
	
	    var gamma = Math.sqrt(n.dot(k));
	
	    k.divideScalar(gamma);
	
	    n.multiplyScalar(coordCarto.altitude());
	
	    // n.multiplyScalar(0.0);
	
	    return k.add(n);
	};
	
	Ellipsoid.prototype.cartographicToCartesianArray = function cartographicToCartesianArray(coordCartoArray) {
	    var cartesianArray = [];
	    for (var i = 0; i < coordCartoArray.length; i++) {
	        cartesianArray.push(this.cartographicToCartesian(coordCartoArray[i]));
	    }
	
	    return cartesianArray;
	};
	
	Ellipsoid.prototype.intersection = function intersection(ray) {
	    var EPSILON = 0.0001;
	    var O_C = ray.origin;
	    var dir = ray.direction;
	    // normalizeVector( dir );
	
	    var a = dir.x * dir.x / (this.size.x * this.size.x) + dir.y * dir.y / (this.size.y * this.size.y) + dir.z * dir.z / (this.size.z * this.size.z);
	
	    var b = 2 * O_C.x * dir.x / (this.size.x * this.size.x) + 2 * O_C.y * dir.y / (this.size.y * this.size.y) + 2 * O_C.z * dir.z / (this.size.z * this.size.z);
	    var c = O_C.x * O_C.x / (this.size.x * this.size.x) + O_C.y * O_C.y / (this.size.y * this.size.y) + O_C.z * O_C.z / (this.size.z * this.size.z) - 1;
	
	    var d = b * b - 4 * a * c;
	    if (d < 0 || a === 0 || b === 0 || c === 0) {
	        return false;
	    }
	
	    d = Math.sqrt(d);
	
	    var t1 = (-b + d) / (2 * a);
	    var t2 = (-b - d) / (2 * a);
	
	    if (t1 <= EPSILON && t2 <= EPSILON) return false; // both intersections are behind the ray origin
	    // var back = (t1 <= EPSILON || t2 <= EPSILON); // If only one intersection (t>0) then we are inside the ellipsoid and the intersection is at the back of the ellipsoid
	    var t = 0;
	    if (t1 <= EPSILON) {
	        t = t2;
	    } else if (t2 <= EPSILON) {
	        t = t1;
	    } else {
	        t = t1 < t2 ? t1 : t2;
	    }
	
	    if (t < EPSILON) return false; // Too close to intersection
	
	    var inter = new THREE.Vector3();
	
	    inter.addVectors(ray.origin, dir.clone().setLength(t));
	
	    return inter;
	    /*
	    var normal = intersection.clone();//-ellipsoid.center;
	    normal.x = 2*normal.x/(this.size.x*this.size.x);
	    normal.y = 2*normal.y/(this.size.y*this.size.y);
	    normal.z = 2*normal.z/(this.size.z*this.size.z);
	     //normal.w = 0.f;
	    normal *= (back) ? -1.f : 1.f;
	    normalizeVector(normal);
	    */
	};
	
	Ellipsoid.prototype.computeDistance = function computeDistance(coordCarto1, coordCarto2) {
	    var longitude1 = coordCarto1.longitude() * Math.PI / 180;
	    var latitude1 = coordCarto1.latitude() * Math.PI / 180;
	    var longitude2 = coordCarto2.longitude() * Math.PI / 180;
	    var latitude2 = coordCarto2.latitude() * Math.PI / 180;
	
	    var distRad = Math.acos(Math.sin(latitude1) * Math.sin(latitude2) + Math.cos(latitude1) * Math.cos(latitude2) * Math.cos(longitude2 - longitude1));
	
	    var a = this.rayon_1;
	    var b = this.rayon_2;
	    var e = Math.sqrt((a * a - b * b) / (a * a));
	    var latMoy = (latitude1 + latitude2) / 2;
	    var rho = a * (1 - e * e) / Math.sqrt(1 - e * e * Math.sin(latMoy) * Math.sin(latMoy));
	    var N = a / Math.sqrt(1 - e * e * Math.sin(latMoy) * Math.sin(latMoy));
	
	    var distMeter = distRad * Math.sqrt(rho * N);
	    return distMeter;
	};
	
	exports.default = Ellipsoid;

/***/ },
/* 298 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/**
	 * Generated On: 2015-10-5
	 * Class: Capabilities
	 */
	
	function Capabilities() {
	    // Constructor
	
	    this._systemCap = null;
	    this._gpuCap = null;
	}
	
	/**
	 */
	Capabilities.prototype.getSystemCapabilities = function getSystemCapabilities() {
	    // TODO: Implement Me
	    /*
	    var memory = window.performance.memory;
	    console.log(memory.totalJSHeapSize / (1024 * 1024) + '/' + memory.jsHeapSizeLimit / (1024 * 1024));
	    */
	};
	
	/**
	 */
	Capabilities.prototype.getGpuCapabilities = function getGpuCapabilities() {
	    // TODO: Implement Me
	
	};
	
	/**
	 */
	Capabilities.prototype.ioFile = function ioFile() {
	    // TODO: Implement Me
	
	};
	
	Capabilities.prototype.isInternetExplorer = function isInternetExplorer() {
	    return false || !!document.documentMode;
	};
	
	exports.default = Capabilities;

/***/ },
/* 299 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	// state to render
	// According to the state rendering, the material's object switches
	// to the correct state material
	exports.default = {
	    // final color
	    FINAL: 0,
	    // depth buffer
	    DEPTH: 1,
	    // id object
	    ID: 2
	};

/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Layer = __webpack_require__(301);
	
	var _Layer2 = _interopRequireDefault(_Layer);
	
	var _Quadtree = __webpack_require__(304);
	
	var _Quadtree2 = _interopRequireDefault(_Quadtree);
	
	var _SchemeTile = __webpack_require__(320);
	
	var _SchemeTile2 = _interopRequireDefault(_SchemeTile);
	
	var _MathExtended = __webpack_require__(296);
	
	var _MathExtended2 = _interopRequireDefault(_MathExtended);
	
	var _TileMesh = __webpack_require__(321);
	
	var _TileMesh2 = _interopRequireDefault(_TileMesh);
	
	var _Atmosphere = __webpack_require__(280);
	
	var _Atmosphere2 = _interopRequireDefault(_Atmosphere);
	
	var _Clouds = __webpack_require__(335);
	
	var _Clouds2 = _interopRequireDefault(_Clouds);
	
	var _Capabilities = __webpack_require__(298);
	
	var _Capabilities2 = _interopRequireDefault(_Capabilities);
	
	var _Coordinates = __webpack_require__(289);
	
	var _Coordinates2 = _interopRequireDefault(_Coordinates);
	
	var _BasicMaterial = __webpack_require__(323);
	
	var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);
	
	var _LayersConfiguration = __webpack_require__(344);
	
	var _LayersConfiguration2 = _interopRequireDefault(_LayersConfiguration);
	
	var _NodeProcess = __webpack_require__(345);
	
	var _BoundingBox = __webpack_require__(319);
	
	var _BoundingBox2 = _interopRequireDefault(_BoundingBox);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/* eslint-disable */
	// bbox longitude(0,360),latitude(-90,90)
	/**
	 * Generated On: 2015-10-5
	 * Class: Globe
	 * Description: Le globe est le noeud du globe (node) principale.
	 */
	
	var schemeTile_0 = 0;
	// bbox longitude(-180,180),latitude(-90,90)
	var schemeTile_1 = 1;
	/* eslint-enable */
	
	function Globe(ellipsoid, gLDebug) {
	    // Constructor
	
	    _Layer2.default.call(this);
	
	    var caps = new _Capabilities2.default();
	    this.NOIE = !caps.isInternetExplorer();
	    this.gLDebug = gLDebug;
	
	    this.batiments = new _Layer2.default();
	    this.layerWGS84Zup = new _Layer2.default();
	
	    var kml = new THREE.Object3D();
	    this.batiments.add(kml);
	
	    this.batiments.visible = false;
	
	    kml.visible = false;
	
	    this.gpxTracks = new _Layer2.default();
	    var gpx = new THREE.Object3D();
	    this.gpxTracks.add(gpx);
	    this.gpxTracks.visible = true;
	    gpx.visible = true;
	
	    this.tiles = new _Quadtree2.default(_TileMesh2.default, this.SchemeTileWMTS(schemeTile_1), kml);
	    this.layersConfiguration = new _LayersConfiguration2.default();
	
	    this.atmosphere = this.NOIE ? new _Atmosphere2.default(ellipsoid) : undefined;
	    this.clouds = new _Clouds2.default();
	
	    var material = new _BasicMaterial2.default(new THREE.Color(1, 0, 0));
	
	    var geometry = new THREE.SphereGeometry(5);
	    var batiment = new THREE.Mesh(geometry, material);
	
	    var position = new _Coordinates2.default('EPSG:4326', 48.846931, 2.337219, 50).as('EPSG:4978').xyz();
	
	    batiment.frustumCulled = false;
	    // material.wireframe      = true;
	    batiment.position.copy(position);
	
	    var material2 = new _BasicMaterial2.default(new THREE.Color(1, 0.5, 1));
	    material2.visible = false;
	    var batiment2 = new THREE.Mesh(geometry, material2);
	    var position2 = new _Coordinates2.default('EPSG:4326', 0.001, 48.87, 100).as('EPSG:4978').xyz();
	    batiment2.frustumCulled = false;
	    material2.wireframe = true;
	    batiment2.position.copy(position2);
	
	    // kml.add( batiment );
	    // kml.add( batiment2 );
	
	    var zUp = new THREE.Object3D();
	
	    zUp.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(1, 0, 0), -Math.PI / 2));
	    zUp.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 0, 1), Math.PI));
	
	    this.layerWGS84Zup.add(zUp);
	    zUp.add(new THREE.AxisHelper(10000000));
	    zUp.add(batiment);
	
	    this.add(this.tiles);
	    this.add(this.batiments);
	    this.add(this.gpxTracks);
	    // this.add(this.layerWGS84Zup);
	
	    if (this.atmosphere !== undefined && !this.gLDebug) {
	        this.atmosphere.add(this.clouds);
	        this.add(this.atmosphere);
	    }
	}
	
	Globe.prototype = (0, _create2.default)(_Layer2.default.prototype);
	
	Globe.prototype.constructor = Globe;
	
	/**
	 * @documentation: Rafrachi les materiaux en fonction du quadTree ORTHO
	 *
	 */
	Globe.prototype.QuadTreeToMaterial = function QuadTreeToMaterial() {
	    // TODO: Implement Me
	
	};
	
	Globe.prototype.SchemeTileWMTS = function SchemeTileWMTS(type) {
	    var schemeT = new _SchemeTile2.default();
	
	    if (type === 0) {
	        // bbox longitude(0,360),latitude(-90,90)
	        schemeT.add(new _BoundingBox2.default('EPSG:4326', 0, _MathExtended2.default.PI, -_MathExtended2.default.PI_OV_TWO, _MathExtended2.default.PI_OV_TWO));
	        schemeT.add(new _BoundingBox2.default('EPSG:4326', _MathExtended2.default.PI, _MathExtended2.default.TWO_PI, -_MathExtended2.default.PI_OV_TWO, _MathExtended2.default.PI_OV_TWO));
	    } else if (type == 1) {
	        // bbox longitude(-180,180),latitude(-90,90)
	        schemeT.add(new _BoundingBox2.default('EPSG:4326', -_MathExtended2.default.PI, 0, -_MathExtended2.default.PI_OV_TWO, _MathExtended2.default.PI_OV_TWO));
	        schemeT.add(new _BoundingBox2.default('EPSG:4326', 0, _MathExtended2.default.PI, -_MathExtended2.default.PI_OV_TWO, _MathExtended2.default.PI_OV_TWO));
	    }
	    // store internally as Radians to avoid doing too much deg->rad conversions
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = (0, _getIterator3.default)(schemeT.schemeBB), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var bbox = _step.value;
	
	            bbox.minCoordinate._internalStorageUnit = _Coordinates.UNIT.RADIAN;
	            bbox.maxCoordinate._internalStorageUnit = _Coordinates.UNIT.RADIAN;
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	
	    return schemeT;
	};
	
	Globe.prototype.showAtmosphere = function showAtmosphere(show) {
	    if (this.atmosphere !== undefined) {
	        this.atmosphere.visible = show;
	    }
	};
	
	Globe.prototype.showClouds = function showClouds(show, satelliteAnimation) {
	    if ( /* this.clouds.live === false && */show) {
	        this.clouds.generate(satelliteAnimation);
	    }
	    this.clouds.visible = show;
	};
	
	Globe.prototype.showKML = function showKML(show) {
	    this.batiments.visible = show;
	
	    this.batiments.children[0].visible = show;
	};
	
	Globe.prototype.updateLightingPos = function updateLightingPos(pos) {
	    this.atmosphere.updateLightingPos(pos);
	    this.clouds.updateLightingPos(pos);
	};
	
	Globe.prototype.setLayerOpacity = function setLayerOpacity(id, opacity) {
	    this.layersConfiguration.setLayerOpacity(id, opacity);
	
	    var cO = function cO(object) {
	        if (object.material.setLayerOpacity) {
	            object.material.setLayerOpacity(object.getIndexLayerColor(id), opacity);
	        }
	    };
	
	    // children[0] is rootNode
	    this.tiles.children[0].traverse(cO);
	};
	
	Globe.prototype.setLayerVisibility = function setLayerVisibility(id, visible) {
	    this.layersConfiguration.setLayerVisibility(id, visible);
	
	    var cO = function cO(object) {
	        if (object.material.setLayerOpacity) {
	            object.material.setLayerVisibility(object.getIndexLayerColor(id), visible);
	        }
	    };
	
	    // children[0] is rootNode
	    this.tiles.children[0].traverse(cO);
	};
	
	Globe.prototype.updateLayersOrdering = function updateLayersOrdering() {
	    var sequence = this.layersConfiguration.getColorLayersIdOrderedBySequence();
	
	    var cO = function cO(object) {
	        if (object.changeSequenceLayers) {
	            object.changeSequenceLayers(sequence);
	        }
	    };
	
	    this.tiles.children[0].traverse(cO);
	};
	
	Globe.prototype.removeColorLayer = function removeColorLayer(layer) {
	    var cO = function cO(object) {
	        if (object.removeColorLayer) {
	            object.removeColorLayer(layer);
	        }
	    };
	
	    this.tiles.children[0].traverse(cO);
	};
	
	Globe.prototype.getZoomLevel = function getZoomLevel() {
	    var cO = function getCOFn() {
	        var zoom = 0;
	        return function cO(object) {
	            if (object) {
	                zoom = Math.max(zoom, object.level);
	            }
	            return zoom;
	        };
	    }();
	
	    this.tiles.children[0].traverseVisible(cO);
	    return cO();
	};
	
	Globe.prototype.computeDistanceForZoomLevel = function computeDistanceForZoomLevel(zoom, camera) {
	    return camera.preSSE * Math.pow(this.tiles.minLevel, this.tiles.maxLevel - zoom + 1) / _NodeProcess.SSE_SUBDIVISION_THRESHOLD;
	};
	
	Globe.prototype.getTile = function getTile(coordinate) {
	    return this.tiles.getTile(coordinate);
	};
	
	Globe.prototype.setRealisticLightingOn = function setRealisticLightingOn(bool) {
	    this.atmosphere.setRealisticOn(bool);
	    this.clouds.setLightingOn(bool);
	};
	
	exports.default = Globe;

/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Node = __webpack_require__(279);
	
	var _Node2 = _interopRequireDefault(_Node);
	
	var _Projection = __webpack_require__(302);
	
	var _Projection2 = _interopRequireDefault(_Projection);
	
	var _NodeMesh = __webpack_require__(281);
	
	var _NodeMesh2 = _interopRequireDefault(_NodeMesh);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: Layer
	 * Description: Le layer est une couche de données. Cette couche peut etre des images ou de l'information 3D. Les requètes de cette couche sont acheminées par une interfaceCommander.
	 *
	 */
	
	/**
	 *
	 * @param {type} Node
	 * @param {type} InterfaceCommander
	 * @param {type} Projection
	 * @param {type} NodeMesh
	 * @returns {Layer_L15.Layer}
	 */
	function Layer() {
	    // Constructor
	
	    _Node2.default.call(this);
	    this.descriManager = null;
	    this.projection = new _Projection2.default();
	    this.id = Layer.count++;
	}
	
	Layer.count = 0;
	
	Layer.prototype = (0, _create2.default)(_Node2.default.prototype);
	
	Layer.prototype.constructor = Layer;
	
	// Should be plural as it return an array of meshes
	Layer.prototype.getMesh = function getMesh() {
	    var meshs = [];
	
	    for (var i = 0; i < this.children.length; i++) {
	        var node = this.children[i];
	
	        if (node instanceof _NodeMesh2.default || node instanceof THREE.Mesh || node instanceof THREE.Object3D) {
	            meshs.push(node);
	        } else if (node instanceof Layer) {
	            meshs = meshs.concat(node.getMesh());
	        }
	    }
	
	    return meshs;
	};
	
	exports.default = Layer;

/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _CoordWMTS = __webpack_require__(303);
	
	var _CoordWMTS2 = _interopRequireDefault(_CoordWMTS);
	
	var _MathExtended = __webpack_require__(296);
	
	var _MathExtended2 = _interopRequireDefault(_MathExtended);
	
	var _Coordinates = __webpack_require__(289);
	
	var _Coordinates2 = _interopRequireDefault(_Coordinates);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: Projection
	 * Description: Outils de projections cartographiques et de convertion
	 */
	function Projection() {
	    // Constructor
	
	}
	
	Projection.prototype.WGS84ToY = function WGS84ToY(latitude) {
	    return 0.5 - Math.log(Math.tan(_MathExtended2.default.PI_OV_FOUR + latitude * 0.5)) * _MathExtended2.default.INV_TWO_PI;
	};
	
	Projection.prototype.WGS84ToOneSubY = function WGS84ToOneSubY(latitude) {
	    return 0.5 + Math.log(Math.tan(_MathExtended2.default.PI_OV_FOUR + latitude * 0.5)) * _MathExtended2.default.INV_TWO_PI;
	};
	
	Projection.prototype.WGS84LatitudeClamp = function WGS84LatitudeClamp(latitude) {
	    // var min = -68.1389  / 180 * Math.PI;
	    var min = -86 / 180 * Math.PI;
	    var max = 84 / 180 * Math.PI;
	
	    latitude = Math.max(min, latitude);
	    latitude = Math.min(max, latitude);
	
	    return latitude;
	};
	
	Projection.prototype.getCoordWMTS_WGS84 = function getCoordWMTS_WGS84(tileCoord, bbox, tileMatrixSet) {
	    // TODO: PM, WGS84G are hard-coded reference to IGN's TileMatrixSet
	    if (tileMatrixSet === 'PM') {
	        return this.WMTS_WGS84ToWMTS_PM(tileCoord, bbox);
	    } else if (tileMatrixSet === 'WGS84G') {
	        return [tileCoord, tileCoord];
	    } else {
	        throw new Error('Unsupported TileMatrixSet \'' + tileMatrixSet + '\'');
	    }
	};
	
	Projection.prototype.getAllCoordsWMTS = function getAllCoordsWMTS(tileCoord, bbox, tileMatrixSets) {
	    var tilesMT = [];
	
	    for (var key in tileMatrixSets) {
	        if (Object.prototype.hasOwnProperty.call(tileMatrixSets, key)) {
	            tilesMT[key] = this.getCoordsWMTS(tileCoord, bbox, key);
	        }
	    }
	
	    return tilesMT;
	};
	
	Projection.prototype.getCoordsWMTS = function getCoordsWMTS(tileCoord, bbox, tileMatrixSet) {
	    var box = this.getCoordWMTS_WGS84(tileCoord, bbox, tileMatrixSet);
	    var tilesMT = [];
	
	    for (var row = box[0].row; row < box[1].row + 1; row++) {
	        tilesMT.push(new _CoordWMTS2.default(box[0].zoom, row, box[0].col));
	    }
	
	    return tilesMT;
	};
	
	/**
	 *
	 * @param {type} cWMTS
	 * @param {type} bbox
	 * @returns {Array} coord WMTS array in pseudo mercator
	 */
	Projection.prototype.WMTS_WGS84ToWMTS_PM = function WMTS_WGS84ToWMTS_PM(cWMTS, bbox) {
	    var wmtsBox = [];
	    var level = cWMTS.zoom + 1;
	    var nbRow = Math.pow(2, level);
	
	    // var sY      = this.WGS84ToY(this.WGS84LatitudeClamp(-Math.PI*0.5)) - this.WGS84ToY(this.WGS84LatitudeClamp(Math.PI*0.5));
	    var sizeRow = 1.0 / nbRow;
	
	    var yMin = this.WGS84ToY(this.WGS84LatitudeClamp(bbox.north(_Coordinates.UNIT.RADIAN)));
	    var yMax = this.WGS84ToY(this.WGS84LatitudeClamp(bbox.south(_Coordinates.UNIT.RADIAN)));
	
	    var maxRow = void 0;
	
	    var min = yMin / sizeRow;
	    var max = yMax / sizeRow;
	
	    var minRow = Math.floor(min);
	    maxRow = Math.floor(max);
	
	    if (max - maxRow === 0.0 || maxRow === nbRow) {
	        maxRow--;
	    }
	
	    var minCol = cWMTS.col;
	    var maxCol = minCol;
	
	    wmtsBox.push(new _CoordWMTS2.default(level, minRow, minCol));
	    wmtsBox.push(new _CoordWMTS2.default(level, maxRow, maxCol));
	
	    return wmtsBox;
	};
	
	Projection.prototype.WMTS_WGS84Parent = function WMTS_WGS84Parent(cWMTS, levelParent, pitch) {
	    var diffLevel = cWMTS.zoom - levelParent;
	    var diff = Math.pow(2, diffLevel);
	    var invDiff = 1 / diff;
	
	    var r = (cWMTS.row - cWMTS.row % diff) * invDiff;
	    var c = (cWMTS.col - cWMTS.col % diff) * invDiff;
	
	    pitch.x = cWMTS.col * invDiff - c;
	    pitch.y = cWMTS.row * invDiff - r;
	    pitch.z = invDiff;
	
	    return new _CoordWMTS2.default(levelParent, r, c);
	};
	
	Projection.prototype.WMS_WGS84Parent = function WMS_WGS84Parent(bbox, bboxParent) {
	    var dim = bbox.dimensions(_Coordinates.UNIT.RADIAN);
	    var dimParent = bboxParent.dimensions(_Coordinates.UNIT.RADIAN);
	    var scale = dim.x / dimParent.x;
	
	    var x = Math.abs(bbox.west(_Coordinates.UNIT.RADIAN) - bboxParent.west(_Coordinates.UNIT.RADIAN)) / dimParent.x;
	    var y = Math.abs(bbox.south(_Coordinates.UNIT.RADIAN) + dim.y - (bboxParent.south(_Coordinates.UNIT.RADIAN) + dimParent.y)) / dimParent.y;
	
	    return new THREE.Vector3(x, y, scale);
	};
	
	Projection.prototype.WGS84toWMTS = function WGS84toWMTS(bbox) {
	    var dim = bbox.dimensions(_Coordinates.UNIT.RADIAN);
	
	    var zoom = Math.floor(Math.log(_MathExtended2.default.PI / dim.y) / _MathExtended2.default.LOG_TWO + 0.5);
	
	    var nY = Math.pow(2, zoom);
	    var nX = 2 * nY;
	
	    var uX = _MathExtended2.default.TWO_PI / nX;
	    var uY = _MathExtended2.default.PI / nY;
	
	    var center = bbox.center();
	    var col = Math.floor((_MathExtended2.default.PI + center.longitude(_Coordinates.UNIT.RADIAN)) % (2 * Math.PI) / uX);
	    var row = Math.floor(nY - (_MathExtended2.default.PI_OV_TWO + center.latitude(_Coordinates.UNIT.RADIAN)) / uY);
	
	    return new _CoordWMTS2.default(zoom, row, col);
	};
	
	Projection.prototype.UnitaryToLongitudeWGS84 = function UnitaryToLongitudeWGS84(u, bbox) {
	    var dim = bbox.dimensions(_Coordinates.UNIT.RADIAN);
	    return bbox.west(_Coordinates.UNIT.RADIAN) + u * dim.x;
	};
	
	Projection.prototype.UnitaryToLatitudeWGS84 = function UnitaryToLatitudeWGS84(v, bbox) {
	    var dim = bbox.dimensions(_Coordinates.UNIT.RADIAN);
	    return bbox.south(_Coordinates.UNIT.RADIAN) + v * dim.y;
	};
	
	Projection.prototype.cartesianToGeo = function cartesianToGeo(position) {
	    // TODO: warning switch coord
	    var p = position.clone();
	    p.x = position.x;
	    p.y = position.z;
	    p.z = position.y;
	
	    var R = p.length();
	    var a = 6378137;
	    var b = 6356752.3142451793;
	    var e = Math.sqrt((a * a - b * b) / (a * a));
	    var f = 1 - Math.sqrt(1 - e * e);
	    var rsqXY = Math.sqrt(p.x * p.x + p.y * p.y);
	
	    var theta = Math.atan2(p.y, p.x);
	    var nu = Math.atan(p.z / rsqXY * (1 - f + e * e * a / R));
	
	    var sinu = Math.sin(nu);
	    var cosu = Math.cos(nu);
	
	    var phi = Math.atan((p.z * (1 - f) + e * e * a * sinu * sinu * sinu) / ((1 - f) * (rsqXY - e * e * a * cosu * cosu * cosu)));
	
	    var h = rsqXY * Math.cos(phi) + p.z * Math.sin(phi) - a * Math.sqrt(1 - e * e * Math.sin(phi) * Math.sin(phi));
	
	    return new _Coordinates2.default('EPSG:4326', -theta, phi, h);
	};
	
	Projection.prototype.wgs84_to_lambert93 = function wgs84_to_lambert93(latitude, longitude) // , x93, y93)
	{
	    /*
	    rfrences :
	    Mthode de calcul pour une projection de type lambert conique conforme scante (
	    NTG_71.pdf):
	    http://www.ign.fr/affiche_rubrique.asp?rbr_id=1700&lng_id=FR
	    */
	
	    // variables:
	
	    // systme WGS84
	    var a = 6378137; // demi grand axe de l'ellipsoide (m)
	    var e = 0.08181919106; // premire excentricit de l'ellipsoide
	
	
	    var deg2rad = function deg2rad() {};
	
	    // paramtres de projections
	    // var l0 =deg2rad(3);
	    var lc = deg2rad(3); // longitude de rfrence
	    var phi0 = deg2rad(46.5); // latitude d'origine en radian
	    var phi1 = deg2rad(44); // 1er parallele automcoque
	    var phi2 = deg2rad(49); // 2eme parallele automcoque
	
	    var x0 = 700000; // coordonnes l'origine
	    var y0 = 6600000; // coordonnes l'origine
	
	    // coordonnes du point traduire
	    var phi = deg2rad(latitude);
	    var l = deg2rad(longitude);
	
	    // calcul des grandes normales
	    var gN1 = a / Math.sqrt(1 - e * e * Math.sin(phi1) * Math.sin(phi1));
	    var gN2 = a / Math.sqrt(1 - e * e * Math.sin(phi2) * Math.sin(phi2));
	
	    // calculs de slatitudes isomtriques
	    var gl1 = Math.log(Math.tan(Math.PI / 4 + phi1 / 2) * Math.pow((1 - e * Math.sin(phi1)) / (1 + e * Math.sin(phi1)), e / 2));
	
	    var gl2 = Math.log(Math.tan(Math.PI / 4 + phi2 / 2) * Math.pow((1 - e * Math.sin(phi2)) / (1 + e * Math.sin(phi2)), e / 2));
	
	    var gl0 = Math.log(Math.tan(Math.PI / 4 + phi0 / 2) * Math.pow((1 - e * Math.sin(phi0)) / (1 + e * Math.sin(phi0)), e / 2));
	
	    var gl = Math.log(Math.tan(Math.PI / 4 + phi / 2) * Math.pow((1 - e * Math.sin(phi)) / (1 + e * Math.sin(phi)), e / 2));
	
	    // calcul de l'exposant de la projection
	    var n = Math.log(gN2 * Math.cos(phi2) / (gN1 * Math.cos(phi1))) / (gl1 - gl2); // ok
	
	    // calcul de la constante de projection
	    var c = gN1 * Math.cos(phi1) / n * Math.exp(n * gl1); // ok
	
	    // calcul des coordonnes
	    var ys = y0 + c * Math.exp(-1 * n * gl0);
	
	    // calcul des coordonnes lambert
	    var x93 = x0 + c * Math.exp(-1 * n * gl) * Math.sin(n * (l - lc));
	    var y93 = ys - c * Math.exp(-1 * n * gl) * Math.cos(n * (l - lc));
	
	    return {
	        x: x93,
	        y: y93
	    };
	};
	
	exports.default = Projection;

/***/ },
/* 303 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/**
	 *
	 * @param {type} zoom
	 * @param {type} row
	 * @param {type} col
	 * @returns {CoordWMTS_L12.CoordWMTS}
	 */
	function CoordWMTS(zoom, row, col) {
	    this.zoom = zoom || 0;
	    this.row = row || 0;
	    this.col = col || 0;
	}
	
	CoordWMTS.prototype.constructor = CoordWMTS;
	
	CoordWMTS.prototype.clone = function cloneCoord() {
	    return new CoordWMTS(this.zoom, this.row, this.col);
	};
	
	CoordWMTS.prototype.isInside = function isInside(limit) {
	    return this.row >= limit.minTileRow && this.row <= limit.maxTileRow && this.col <= limit.maxTileCol && this.col >= limit.minTileCol;
	};
	
	exports.default = CoordWMTS;

/***/ },
/* 304 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _promise = __webpack_require__(224);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _Layer = __webpack_require__(301);
	
	var _Layer2 = _interopRequireDefault(_Layer);
	
	var _Scheduler = __webpack_require__(305);
	
	var _Scheduler2 = _interopRequireDefault(_Scheduler);
	
	var _NodeMesh = __webpack_require__(281);
	
	var _NodeMesh2 = _interopRequireDefault(_NodeMesh);
	
	var _BoundingBox = __webpack_require__(319);
	
	var _BoundingBox2 = _interopRequireDefault(_BoundingBox);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: Quadtree
	 * Description: Structure de données spatiales possedant jusqu'à 4 Nodes
	 */
	
	/**
	 *
	 * @param {type} Layer
	 * @param {type} Quad
	 * @returns {Quadtree_L13.Quadtree}
	 */
	function Quadtree(type, schemeTile, link) {
	    _Layer2.default.call(this);
	
	    this.type = type;
	    this.scheduler = (0, _Scheduler2.default)();
	    this.link = link;
	    this.schemeTile = schemeTile;
	    this.tileType = type;
	    this.minLevel = 2;
	    this.maxLevel = 17;
	    var rootNode = new _NodeMesh2.default();
	
	    rootNode.frustumCulled = false;
	    rootNode.material.visible = false;
	
	    rootNode.link = this.link;
	
	    rootNode.changeState = function changeState() {
	        return true;
	    };
	
	    this.add(rootNode);
	}
	
	Quadtree.prototype = (0, _create2.default)(_Layer2.default.prototype);
	
	Quadtree.prototype.constructor = Quadtree;
	
	Quadtree.prototype.init = function init(geometryLayer, lightingLayer) {
	    var rootNode = this.children[0];
	    var promises = [];
	
	    for (var i = 0; i < this.schemeTile.rootCount(); i++) {
	        promises.push(this.requestNewTile(geometryLayer, this.schemeTile.getRoot(i), rootNode, lightingLayer));
	    }
	    return _promise2.default.all(promises);
	};
	
	Quadtree.prototype.northWest = function northWest(node) {
	    return node.children[0];
	};
	
	Quadtree.prototype.northEast = function northEast(node) {
	    return node.children[1];
	};
	
	Quadtree.prototype.southWest = function southWest(node) {
	    return node.children[2];
	};
	
	Quadtree.prototype.southEast = function southEast(node) {
	    return node.children[3];
	};
	
	Quadtree.prototype.requestNewTile = function requestNewTile(geometryLayer, bbox, parent, lightingLayer) {
	    var command = {
	        /* mandatory */
	        requester: parent,
	        layer: geometryLayer,
	        priority: 10000,
	        /* specific params */
	        bbox: bbox,
	        type: this.type,
	        level: 0,
	        light: lightingLayer
	    };
	
	    return this.scheduler.execute(command);
	};
	
	Quadtree.prototype.canSubdivideNode = function canSubdivideNode(node) {
	    return node.level < this.maxLevel;
	};
	
	/**
	 * @documentation: returns bounding boxes of a node's quadtree subdivision
	 * @param {type} node
	 * @returns {Array} an array of four bounding boxex
	 */
	Quadtree.prototype.subdivideNode = function subdivideNode(node) {
	    if (node.pendingSubdivision || !this.canSubdivideNode(node)) {
	        return [];
	    }
	
	    var bbox = node.bbox;
	    var center = bbox.center();
	
	    var northWest = new _BoundingBox2.default(bbox.crs(), bbox.west(), center._values[0], center._values[1], bbox.north());
	    var northEast = new _BoundingBox2.default(bbox.crs(), center._values[0], bbox.east(), center._values[1], bbox.north());
	    var southWest = new _BoundingBox2.default(bbox.crs(), bbox.west(), center._values[0], bbox.south(), center._values[1]);
	    var southEast = new _BoundingBox2.default(bbox.crs(), center._values[0], bbox.east(), bbox.south(), center._values[1]);
	
	    // scheme tiles store their coordinates in radians internally,
	    // so we need to fix the new bboxes as well
	    var result = [northWest, northEast, southWest, southEast];
	
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = (0, _getIterator3.default)(result), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var _bbox = _step.value;
	
	            _bbox.minCoordinate._internalStorageUnit = node.bbox.minCoordinate._internalStorageUnit;
	            _bbox.maxCoordinate._internalStorageUnit = node.bbox.minCoordinate._internalStorageUnit;
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	
	    return result;
	};
	
	Quadtree.prototype.traverse = function traverse(foo, node) {
	    if (foo(node)) {
	        for (var i = 0; i < node.children.length; i++) {
	            this.traverse(foo, node.children[i]);
	        }
	    }
	};
	
	Quadtree.prototype.getTile = function getTile(coordinate) {
	    var point = { x: coordinate.longitude(), y: coordinate.latitude() };
	
	    var gT = function gT(tile) {
	        var inside = tile.bbox ? tile.bbox.isInside(point) : true;
	
	        if (tile.children.length === 0 && inside) {
	            point.tile = tile;
	        }
	
	        // TODO: Fix error verify if this is correct
	        if (inside) {
	            point.parent = tile.parent;
	        }
	
	        return inside;
	    };
	
	    this.traverse(gT, this.children[0]);
	
	    if (point.tile === undefined) {
	        return point.parent;
	    } else {
	        return point.tile;
	    }
	};
	
	exports.default = Quadtree;

/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.CancelledCommandException = undefined;
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _map = __webpack_require__(306);
	
	var _map2 = _interopRequireDefault(_map);
	
	var _promise = __webpack_require__(224);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	exports.default = function (scene) {
	    instanceScheduler = instanceScheduler || new Scheduler(scene);
	    return instanceScheduler;
	};
	
	var _jsPriorityQueue = __webpack_require__(317);
	
	var _jsPriorityQueue2 = _interopRequireDefault(_jsPriorityQueue);
	
	var _EventsManager = __webpack_require__(318);
	
	var _EventsManager2 = _interopRequireDefault(_EventsManager);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: Scheduler
	 * Description: Cette classe singleton gère les requetes/Commandes  de la scène. Ces commandes peuvent etre synchrone ou asynchrone. Elle permet d'executer, de prioriser  et d'annuler les commandes de la pile. Les commandes executées sont placées dans une autre file d'attente.
	 */
	
	var instanceScheduler = null;
	
	function _instanciateQueue() {
	    return {
	        storage: new _jsPriorityQueue2.default({
	            comparator: function comparator(a, b) {
	                var cmp = b.priority - a.priority;
	                // Prioritize recent commands
	                if (cmp === 0) {
	                    return b.timestamp - a.timestamp;
	                }
	                return cmp;
	            }
	        }),
	        counters: {
	            // commands in progress
	            executing: 0,
	            // commands successfully executed
	            executed: 0,
	            // commands failed
	            failed: 0,
	            // commands cancelled
	            cancelled: 0
	        },
	        execute: function execute(cmd, provider, executingCounterUpToDate) {
	            var _this = this;
	
	            if (!executingCounterUpToDate) {
	                this.counters.executing++;
	            }
	
	            // If the provider returns a Promise, use it to handle counters
	            // Otherwise use a resolved Promise.
	            var p = provider.executeCommand(cmd) || _promise2.default.resolve();
	
	            return p.then(function (result) {
	                _this.counters.executing--;
	                cmd.resolve(result);
	                // only count successul commands
	                _this.counters.executed++;
	            }, function (err) {
	                _this.counters.executing--;
	                cmd.reject(err);
	                _this.counters.failed++;
	            });
	        }
	    };
	}
	
	function Scheduler(scene) {
	    // Constructor
	    if (instanceScheduler !== null) {
	        throw new Error('Cannot instantiate more than one Scheduler');
	    }
	
	    this.defaultQueue = _instanciateQueue();
	    this.hostQueues = new _map2.default();
	
	    this.providers = {};
	
	    this.eventsManager = new _EventsManager2.default();
	    this.maxConcurrentCommands = 16;
	    this.maxCommandsPerHost = 6;
	
	    if (!scene) {
	        throw new Error('Cannot instantiate Scheduler without scene');
	    }
	
	    this.scene = scene;
	}
	
	Scheduler.prototype.constructor = Scheduler;
	
	Scheduler.prototype.runCommand = function runCommand(command, queue, executingCounterUpToDate) {
	    var _this2 = this;
	
	    var provider = this.providers[command.layer.protocol];
	
	    if (!provider) {
	        throw new Error('No known provider for layer', command.layer.id);
	    }
	
	    queue.execute(command, provider, executingCounterUpToDate).then(function () {
	        // notify scene that one command ended.
	        // We allow the scene to delay the update/repaint up to 100ms
	        // to reduce CPU load (no need to perform an update on completion if we
	        // know there's another one ending soon)
	        _this2.scene.notifyChange(100, 'redraw' in command ? command.redraw : true);
	
	        // try to execute next command
	        if (queue.counters.executing < _this2.maxCommandsPerHost) {
	            var cmd = _this2.deQueue(queue);
	            if (cmd) {
	                return _this2.runCommand(cmd, queue);
	            }
	        }
	    });
	};
	
	Scheduler.prototype.execute = function execute(command) {
	    // parse host
	    var layer = command.layer;
	
	    var host = layer.url ? new URL(layer.url).host : undefined;
	
	    command.promise = new _promise2.default(function (resolve, reject) {
	        command.resolve = resolve;
	        command.reject = reject;
	    });
	
	    // init queue if needed
	    if (host && !this.hostQueues.has(host)) {
	        this.hostQueues.set(host, _instanciateQueue());
	    }
	
	    var q = host ? this.hostQueues.get(host) : this.defaultQueue;
	
	    // execute command now if possible
	    if (q.counters.executing < this.maxCommandsPerHost) {
	        // increment before
	        q.counters.executing++;
	
	        var runNow = function runNow() {
	            this.runCommand(command, q, true);
	        }.bind(this);
	
	        // We use a setTimeout to defer processing but we avoid the
	        // queue mechanism (why setTimeout and not Promise? see tasks vs microtasks priorities)
	        window.setTimeout(runNow, 0);
	    } else {
	        command.timestamp = Date.now();
	        q.storage.queue(command);
	    }
	
	    return command.promise;
	};
	
	Scheduler.prototype.addProtocolProvider = function addProtocolProvider(protocol, provider) {
	    this.providers[protocol] = provider;
	};
	
	Scheduler.prototype.getProtocolProvider = function getProtocolProvider(protocol) {
	    return this.providers[protocol];
	};
	
	Scheduler.prototype.commandsWaitingExecutionCount = function commandsWaitingExecutionCount() {
	    var sum = this.defaultQueue.storage.length + this.defaultQueue.counters.executing;
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = (0, _getIterator3.default)(this.hostQueues), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var q = _step.value;
	
	            sum += q[1].storage.length + q[1].counters.executing;
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	
	    return sum;
	};
	
	Scheduler.prototype.commandsRunningCount = function commandsRunningCount() {
	    var sum = this.defaultQueue.counters.executing;
	
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	        for (var _iterator2 = (0, _getIterator3.default)(this.hostQueues), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var q = _step2.value;
	
	            sum += q[1].counters.executing;
	        }
	    } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	            }
	        } finally {
	            if (_didIteratorError2) {
	                throw _iteratorError2;
	            }
	        }
	    }
	
	    return sum;
	};
	
	Scheduler.prototype.resetCommandsCount = function resetCommandsCount(type) {
	    var sum = this.defaultQueue.counters[type];
	    this.defaultQueue.counters[type] = 0;
	    var _iteratorNormalCompletion3 = true;
	    var _didIteratorError3 = false;
	    var _iteratorError3 = undefined;
	
	    try {
	        for (var _iterator3 = (0, _getIterator3.default)(this.hostQueues), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	            var q = _step3.value;
	
	            sum += q[1].counters[type];
	            q[1].counters[type] = 0;
	        }
	    } catch (err) {
	        _didIteratorError3 = true;
	        _iteratorError3 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                _iterator3.return();
	            }
	        } finally {
	            if (_didIteratorError3) {
	                throw _iteratorError3;
	            }
	        }
	    }
	
	    return sum;
	};
	
	Scheduler.prototype.getProviders = function getProviders() {
	    return this.providers.slice();
	};
	
	/**
	 * Custom error thrown when cancelling commands. Allows the caller to act differently if needed.
	 */
	function CancelledCommandException(command) {
	    this.command = command;
	}
	
	CancelledCommandException.prototype.toString = function toString() {
	    return 'Cancelled command ' + this.command.requester.id + '/' + this.command.layer.id;
	};
	
	/**
	 */
	Scheduler.prototype.deQueue = function deQueue(queue) {
	    var st = queue.storage;
	    while (st.length > 0) {
	        var cmd = st.dequeue();
	
	        if (cmd.earlyDropFunction && cmd.earlyDropFunction(cmd)) {
	            queue.counters.cancelled++;
	            cmd.reject(new CancelledCommandException(cmd));
	        } else {
	            return cmd;
	        }
	    }
	
	    return undefined;
	};
	
	/**
	 */
	Scheduler.prototype.wait = function wait() {
	    this.eventsManager.wait();
	};
	
	exports.CancelledCommandException = CancelledCommandException;

/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(307), __esModule: true };

/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(226);
	__webpack_require__(54);
	__webpack_require__(30);
	__webpack_require__(308);
	__webpack_require__(314);
	module.exports = __webpack_require__(15).Map;

/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var strong = __webpack_require__(309);
	
	// 23.1 Map Objects
	module.exports = __webpack_require__(310)('Map', function(get){
	  return function Map(){ return get(this, arguments.length > 0 ? arguments[0] : undefined); };
	}, {
	  // 23.1.3.6 Map.prototype.get(key)
	  get: function get(key){
	    var entry = strong.getEntry(this, key);
	    return entry && entry.v;
	  },
	  // 23.1.3.9 Map.prototype.set(key, value)
	  set: function set(key, value){
	    return strong.def(this, key === 0 ? 0 : key, value);
	  }
	}, strong, true);

/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var dP          = __webpack_require__(19).f
	  , create      = __webpack_require__(42)
	  , redefineAll = __webpack_require__(236)
	  , ctx         = __webpack_require__(16)
	  , anInstance  = __webpack_require__(228)
	  , defined     = __webpack_require__(6)
	  , forOf       = __webpack_require__(229)
	  , $iterDefine = __webpack_require__(38)
	  , step        = __webpack_require__(33)
	  , setSpecies  = __webpack_require__(237)
	  , DESCRIPTORS = __webpack_require__(23)
	  , fastKey     = __webpack_require__(256).fastKey
	  , SIZE        = DESCRIPTORS ? '_s' : 'size';
	
	var getEntry = function(that, key){
	  // fast case
	  var index = fastKey(key), entry;
	  if(index !== 'F')return that._i[index];
	  // frozen object case
	  for(entry = that._f; entry; entry = entry.n){
	    if(entry.k == key)return entry;
	  }
	};
	
	module.exports = {
	  getConstructor: function(wrapper, NAME, IS_MAP, ADDER){
	    var C = wrapper(function(that, iterable){
	      anInstance(that, C, NAME, '_i');
	      that._i = create(null); // index
	      that._f = undefined;    // first entry
	      that._l = undefined;    // last entry
	      that[SIZE] = 0;         // size
	      if(iterable != undefined)forOf(iterable, IS_MAP, that[ADDER], that);
	    });
	    redefineAll(C.prototype, {
	      // 23.1.3.1 Map.prototype.clear()
	      // 23.2.3.2 Set.prototype.clear()
	      clear: function clear(){
	        for(var that = this, data = that._i, entry = that._f; entry; entry = entry.n){
	          entry.r = true;
	          if(entry.p)entry.p = entry.p.n = undefined;
	          delete data[entry.i];
	        }
	        that._f = that._l = undefined;
	        that[SIZE] = 0;
	      },
	      // 23.1.3.3 Map.prototype.delete(key)
	      // 23.2.3.4 Set.prototype.delete(value)
	      'delete': function(key){
	        var that  = this
	          , entry = getEntry(that, key);
	        if(entry){
	          var next = entry.n
	            , prev = entry.p;
	          delete that._i[entry.i];
	          entry.r = true;
	          if(prev)prev.n = next;
	          if(next)next.p = prev;
	          if(that._f == entry)that._f = next;
	          if(that._l == entry)that._l = prev;
	          that[SIZE]--;
	        } return !!entry;
	      },
	      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
	      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
	      forEach: function forEach(callbackfn /*, that = undefined */){
	        anInstance(this, C, 'forEach');
	        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3)
	          , entry;
	        while(entry = entry ? entry.n : this._f){
	          f(entry.v, entry.k, this);
	          // revert to the last existing entry
	          while(entry && entry.r)entry = entry.p;
	        }
	      },
	      // 23.1.3.7 Map.prototype.has(key)
	      // 23.2.3.7 Set.prototype.has(value)
	      has: function has(key){
	        return !!getEntry(this, key);
	      }
	    });
	    if(DESCRIPTORS)dP(C.prototype, 'size', {
	      get: function(){
	        return defined(this[SIZE]);
	      }
	    });
	    return C;
	  },
	  def: function(that, key, value){
	    var entry = getEntry(that, key)
	      , prev, index;
	    // change existing entry
	    if(entry){
	      entry.v = value;
	    // create new entry
	    } else {
	      that._l = entry = {
	        i: index = fastKey(key, true), // <- index
	        k: key,                        // <- key
	        v: value,                      // <- value
	        p: prev = that._l,             // <- previous entry
	        n: undefined,                  // <- next entry
	        r: false                       // <- removed
	      };
	      if(!that._f)that._f = entry;
	      if(prev)prev.n = entry;
	      that[SIZE]++;
	      // add to index
	      if(index !== 'F')that._i[index] = entry;
	    } return that;
	  },
	  getEntry: getEntry,
	  setStrong: function(C, NAME, IS_MAP){
	    // add .keys, .values, .entries, [@@iterator]
	    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
	    $iterDefine(C, NAME, function(iterated, kind){
	      this._t = iterated;  // target
	      this._k = kind;      // kind
	      this._l = undefined; // previous
	    }, function(){
	      var that  = this
	        , kind  = that._k
	        , entry = that._l;
	      // revert to the last existing entry
	      while(entry && entry.r)entry = entry.p;
	      // get next entry
	      if(!that._t || !(that._l = entry = entry ? entry.n : that._t._f)){
	        // or finish the iteration
	        that._t = undefined;
	        return step(1);
	      }
	      // return step by kind
	      if(kind == 'keys'  )return step(0, entry.k);
	      if(kind == 'values')return step(0, entry.v);
	      return step(0, [entry.k, entry.v]);
	    }, IS_MAP ? 'entries' : 'values' , !IS_MAP, true);
	
	    // add [@@species], 23.1.2.2, 23.2.2.2
	    setSpecies(NAME);
	  }
	};

/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	var global         = __webpack_require__(11)
	  , $export        = __webpack_require__(14)
	  , meta           = __webpack_require__(256)
	  , fails          = __webpack_require__(24)
	  , hide           = __webpack_require__(18)
	  , redefineAll    = __webpack_require__(236)
	  , forOf          = __webpack_require__(229)
	  , anInstance     = __webpack_require__(228)
	  , isObject       = __webpack_require__(21)
	  , setToStringTag = __webpack_require__(52)
	  , dP             = __webpack_require__(19).f
	  , each           = __webpack_require__(311)(0)
	  , DESCRIPTORS    = __webpack_require__(23);
	
	module.exports = function(NAME, wrapper, methods, common, IS_MAP, IS_WEAK){
	  var Base  = global[NAME]
	    , C     = Base
	    , ADDER = IS_MAP ? 'set' : 'add'
	    , proto = C && C.prototype
	    , O     = {};
	  if(!DESCRIPTORS || typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function(){
	    new C().entries().next();
	  }))){
	    // create collection constructor
	    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
	    redefineAll(C.prototype, methods);
	    meta.NEED = true;
	  } else {
	    C = wrapper(function(target, iterable){
	      anInstance(target, C, NAME, '_c');
	      target._c = new Base;
	      if(iterable != undefined)forOf(iterable, IS_MAP, target[ADDER], target);
	    });
	    each('add,clear,delete,forEach,get,has,set,keys,values,entries,toJSON'.split(','),function(KEY){
	      var IS_ADDER = KEY == 'add' || KEY == 'set';
	      if(KEY in proto && !(IS_WEAK && KEY == 'clear'))hide(C.prototype, KEY, function(a, b){
	        anInstance(this, C, KEY);
	        if(!IS_ADDER && IS_WEAK && !isObject(a))return KEY == 'get' ? undefined : false;
	        var result = this._c[KEY](a === 0 ? 0 : a, b);
	        return IS_ADDER ? this : result;
	      });
	    });
	    if('size' in proto)dP(C.prototype, 'size', {
	      get: function(){
	        return this._c.size;
	      }
	    });
	  }
	
	  setToStringTag(C, NAME);
	
	  O[NAME] = C;
	  $export($export.G + $export.W + $export.F, O);
	
	  if(!IS_WEAK)common.setStrong(C, NAME, IS_MAP);
	
	  return C;
	};

/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	// 0 -> Array#forEach
	// 1 -> Array#map
	// 2 -> Array#filter
	// 3 -> Array#some
	// 4 -> Array#every
	// 5 -> Array#find
	// 6 -> Array#findIndex
	var ctx      = __webpack_require__(16)
	  , IObject  = __webpack_require__(36)
	  , toObject = __webpack_require__(5)
	  , toLength = __webpack_require__(47)
	  , asc      = __webpack_require__(312);
	module.exports = function(TYPE, $create){
	  var IS_MAP        = TYPE == 1
	    , IS_FILTER     = TYPE == 2
	    , IS_SOME       = TYPE == 3
	    , IS_EVERY      = TYPE == 4
	    , IS_FIND_INDEX = TYPE == 6
	    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
	    , create        = $create || asc;
	  return function($this, callbackfn, that){
	    var O      = toObject($this)
	      , self   = IObject(O)
	      , f      = ctx(callbackfn, that, 3)
	      , length = toLength(self.length)
	      , index  = 0
	      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
	      , val, res;
	    for(;length > index; index++)if(NO_HOLES || index in self){
	      val = self[index];
	      res = f(val, index, O);
	      if(TYPE){
	        if(IS_MAP)result[index] = res;            // map
	        else if(res)switch(TYPE){
	          case 3: return true;                    // some
	          case 5: return val;                     // find
	          case 6: return index;                   // findIndex
	          case 2: result.push(val);               // filter
	        } else if(IS_EVERY)return false;          // every
	      }
	    }
	    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
	  };
	};

/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
	var speciesConstructor = __webpack_require__(313);
	
	module.exports = function(original, length){
	  return new (speciesConstructor(original))(length);
	};

/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	var isObject = __webpack_require__(21)
	  , isArray  = __webpack_require__(262)
	  , SPECIES  = __webpack_require__(53)('species');
	
	module.exports = function(original){
	  var C;
	  if(isArray(original)){
	    C = original.constructor;
	    // cross-realm fallback
	    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
	    if(isObject(C)){
	      C = C[SPECIES];
	      if(C === null)C = undefined;
	    }
	  } return C === undefined ? Array : C;
	};

/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var $export  = __webpack_require__(14);
	
	$export($export.P + $export.R, 'Map', {toJSON: __webpack_require__(315)('Map')});

/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	// https://github.com/DavidBruant/Map-Set.prototype.toJSON
	var classof = __webpack_require__(58)
	  , from    = __webpack_require__(316);
	module.exports = function(NAME){
	  return function toJSON(){
	    if(classof(this) != NAME)throw TypeError(NAME + "#toJSON isn't generic");
	    return from(this);
	  };
	};

/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	var forOf = __webpack_require__(229);
	
	module.exports = function(iter, ITERATOR){
	  var result = [];
	  forOf(iter, false, result.push, result, ITERATOR);
	  return result;
	};


/***/ },
/* 317 */
/***/ function(module, exports) {

	(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.PriorityQueue = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
	var AbstractPriorityQueue, ArrayStrategy, BHeapStrategy, BinaryHeapStrategy, PriorityQueue,
	  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
	  hasProp = {}.hasOwnProperty;
	
	AbstractPriorityQueue = _dereq_('./PriorityQueue/AbstractPriorityQueue');
	
	ArrayStrategy = _dereq_('./PriorityQueue/ArrayStrategy');
	
	BinaryHeapStrategy = _dereq_('./PriorityQueue/BinaryHeapStrategy');
	
	BHeapStrategy = _dereq_('./PriorityQueue/BHeapStrategy');
	
	PriorityQueue = (function(superClass) {
	  extend(PriorityQueue, superClass);
	
	  function PriorityQueue(options) {
	    options || (options = {});
	    options.strategy || (options.strategy = BinaryHeapStrategy);
	    options.comparator || (options.comparator = function(a, b) {
	      return (a || 0) - (b || 0);
	    });
	    PriorityQueue.__super__.constructor.call(this, options);
	  }
	
	  return PriorityQueue;
	
	})(AbstractPriorityQueue);
	
	PriorityQueue.ArrayStrategy = ArrayStrategy;
	
	PriorityQueue.BinaryHeapStrategy = BinaryHeapStrategy;
	
	PriorityQueue.BHeapStrategy = BHeapStrategy;
	
	module.exports = PriorityQueue;
	
	
	},{"./PriorityQueue/AbstractPriorityQueue":2,"./PriorityQueue/ArrayStrategy":3,"./PriorityQueue/BHeapStrategy":4,"./PriorityQueue/BinaryHeapStrategy":5}],2:[function(_dereq_,module,exports){
	var AbstractPriorityQueue;
	
	module.exports = AbstractPriorityQueue = (function() {
	  function AbstractPriorityQueue(options) {
	    var ref;
	    if ((options != null ? options.strategy : void 0) == null) {
	      throw 'Must pass options.strategy, a strategy';
	    }
	    if ((options != null ? options.comparator : void 0) == null) {
	      throw 'Must pass options.comparator, a comparator';
	    }
	    this.priv = new options.strategy(options);
	    this.length = (options != null ? (ref = options.initialValues) != null ? ref.length : void 0 : void 0) || 0;
	  }
	
	  AbstractPriorityQueue.prototype.queue = function(value) {
	    this.length++;
	    this.priv.queue(value);
	    return void 0;
	  };
	
	  AbstractPriorityQueue.prototype.dequeue = function(value) {
	    if (!this.length) {
	      throw 'Empty queue';
	    }
	    this.length--;
	    return this.priv.dequeue();
	  };
	
	  AbstractPriorityQueue.prototype.peek = function(value) {
	    if (!this.length) {
	      throw 'Empty queue';
	    }
	    return this.priv.peek();
	  };
	
	  AbstractPriorityQueue.prototype.clear = function() {
	    this.length = 0;
	    return this.priv.clear();
	  };
	
	  return AbstractPriorityQueue;
	
	})();
	
	
	},{}],3:[function(_dereq_,module,exports){
	var ArrayStrategy, binarySearchForIndexReversed;
	
	binarySearchForIndexReversed = function(array, value, comparator) {
	  var high, low, mid;
	  low = 0;
	  high = array.length;
	  while (low < high) {
	    mid = (low + high) >>> 1;
	    if (comparator(array[mid], value) >= 0) {
	      low = mid + 1;
	    } else {
	      high = mid;
	    }
	  }
	  return low;
	};
	
	module.exports = ArrayStrategy = (function() {
	  function ArrayStrategy(options) {
	    var ref;
	    this.options = options;
	    this.comparator = this.options.comparator;
	    this.data = ((ref = this.options.initialValues) != null ? ref.slice(0) : void 0) || [];
	    this.data.sort(this.comparator).reverse();
	  }
	
	  ArrayStrategy.prototype.queue = function(value) {
	    var pos;
	    pos = binarySearchForIndexReversed(this.data, value, this.comparator);
	    this.data.splice(pos, 0, value);
	    return void 0;
	  };
	
	  ArrayStrategy.prototype.dequeue = function() {
	    return this.data.pop();
	  };
	
	  ArrayStrategy.prototype.peek = function() {
	    return this.data[this.data.length - 1];
	  };
	
	  ArrayStrategy.prototype.clear = function() {
	    this.data.length = 0;
	    return void 0;
	  };
	
	  return ArrayStrategy;
	
	})();
	
	
	},{}],4:[function(_dereq_,module,exports){
	var BHeapStrategy;
	
	module.exports = BHeapStrategy = (function() {
	  function BHeapStrategy(options) {
	    var arr, i, j, k, len, ref, ref1, shift, value;
	    this.comparator = (options != null ? options.comparator : void 0) || function(a, b) {
	      return a - b;
	    };
	    this.pageSize = (options != null ? options.pageSize : void 0) || 512;
	    this.length = 0;
	    shift = 0;
	    while ((1 << shift) < this.pageSize) {
	      shift += 1;
	    }
	    if (1 << shift !== this.pageSize) {
	      throw 'pageSize must be a power of two';
	    }
	    this._shift = shift;
	    this._emptyMemoryPageTemplate = arr = [];
	    for (i = j = 0, ref = this.pageSize; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
	      arr.push(null);
	    }
	    this._memory = [];
	    this._mask = this.pageSize - 1;
	    if (options.initialValues) {
	      ref1 = options.initialValues;
	      for (k = 0, len = ref1.length; k < len; k++) {
	        value = ref1[k];
	        this.queue(value);
	      }
	    }
	  }
	
	  BHeapStrategy.prototype.queue = function(value) {
	    this.length += 1;
	    this._write(this.length, value);
	    this._bubbleUp(this.length, value);
	    return void 0;
	  };
	
	  BHeapStrategy.prototype.dequeue = function() {
	    var ret, val;
	    ret = this._read(1);
	    val = this._read(this.length);
	    this.length -= 1;
	    if (this.length > 0) {
	      this._write(1, val);
	      this._bubbleDown(1, val);
	    }
	    return ret;
	  };
	
	  BHeapStrategy.prototype.peek = function() {
	    return this._read(1);
	  };
	
	  BHeapStrategy.prototype.clear = function() {
	    this.length = 0;
	    this._memory.length = 0;
	    return void 0;
	  };
	
	  BHeapStrategy.prototype._write = function(index, value) {
	    var page;
	    page = index >> this._shift;
	    while (page >= this._memory.length) {
	      this._memory.push(this._emptyMemoryPageTemplate.slice(0));
	    }
	    return this._memory[page][index & this._mask] = value;
	  };
	
	  BHeapStrategy.prototype._read = function(index) {
	    return this._memory[index >> this._shift][index & this._mask];
	  };
	
	  BHeapStrategy.prototype._bubbleUp = function(index, value) {
	    var compare, indexInPage, parentIndex, parentValue;
	    compare = this.comparator;
	    while (index > 1) {
	      indexInPage = index & this._mask;
	      if (index < this.pageSize || indexInPage > 3) {
	        parentIndex = (index & ~this._mask) | (indexInPage >> 1);
	      } else if (indexInPage < 2) {
	        parentIndex = (index - this.pageSize) >> this._shift;
	        parentIndex += parentIndex & ~(this._mask >> 1);
	        parentIndex |= this.pageSize >> 1;
	      } else {
	        parentIndex = index - 2;
	      }
	      parentValue = this._read(parentIndex);
	      if (compare(parentValue, value) < 0) {
	        break;
	      }
	      this._write(parentIndex, value);
	      this._write(index, parentValue);
	      index = parentIndex;
	    }
	    return void 0;
	  };
	
	  BHeapStrategy.prototype._bubbleDown = function(index, value) {
	    var childIndex1, childIndex2, childValue1, childValue2, compare;
	    compare = this.comparator;
	    while (index < this.length) {
	      if (index > this._mask && !(index & (this._mask - 1))) {
	        childIndex1 = childIndex2 = index + 2;
	      } else if (index & (this.pageSize >> 1)) {
	        childIndex1 = (index & ~this._mask) >> 1;
	        childIndex1 |= index & (this._mask >> 1);
	        childIndex1 = (childIndex1 + 1) << this._shift;
	        childIndex2 = childIndex1 + 1;
	      } else {
	        childIndex1 = index + (index & this._mask);
	        childIndex2 = childIndex1 + 1;
	      }
	      if (childIndex1 !== childIndex2 && childIndex2 <= this.length) {
	        childValue1 = this._read(childIndex1);
	        childValue2 = this._read(childIndex2);
	        if (compare(childValue1, value) < 0 && compare(childValue1, childValue2) <= 0) {
	          this._write(childIndex1, value);
	          this._write(index, childValue1);
	          index = childIndex1;
	        } else if (compare(childValue2, value) < 0) {
	          this._write(childIndex2, value);
	          this._write(index, childValue2);
	          index = childIndex2;
	        } else {
	          break;
	        }
	      } else if (childIndex1 <= this.length) {
	        childValue1 = this._read(childIndex1);
	        if (compare(childValue1, value) < 0) {
	          this._write(childIndex1, value);
	          this._write(index, childValue1);
	          index = childIndex1;
	        } else {
	          break;
	        }
	      } else {
	        break;
	      }
	    }
	    return void 0;
	  };
	
	  return BHeapStrategy;
	
	})();
	
	
	},{}],5:[function(_dereq_,module,exports){
	var BinaryHeapStrategy;
	
	module.exports = BinaryHeapStrategy = (function() {
	  function BinaryHeapStrategy(options) {
	    var ref;
	    this.comparator = (options != null ? options.comparator : void 0) || function(a, b) {
	      return a - b;
	    };
	    this.length = 0;
	    this.data = ((ref = options.initialValues) != null ? ref.slice(0) : void 0) || [];
	    this._heapify();
	  }
	
	  BinaryHeapStrategy.prototype._heapify = function() {
	    var i, j, ref;
	    if (this.data.length > 0) {
	      for (i = j = 1, ref = this.data.length; 1 <= ref ? j < ref : j > ref; i = 1 <= ref ? ++j : --j) {
	        this._bubbleUp(i);
	      }
	    }
	    return void 0;
	  };
	
	  BinaryHeapStrategy.prototype.queue = function(value) {
	    this.data.push(value);
	    this._bubbleUp(this.data.length - 1);
	    return void 0;
	  };
	
	  BinaryHeapStrategy.prototype.dequeue = function() {
	    var last, ret;
	    ret = this.data[0];
	    last = this.data.pop();
	    if (this.data.length > 0) {
	      this.data[0] = last;
	      this._bubbleDown(0);
	    }
	    return ret;
	  };
	
	  BinaryHeapStrategy.prototype.peek = function() {
	    return this.data[0];
	  };
	
	  BinaryHeapStrategy.prototype.clear = function() {
	    this.length = 0;
	    this.data.length = 0;
	    return void 0;
	  };
	
	  BinaryHeapStrategy.prototype._bubbleUp = function(pos) {
	    var parent, x;
	    while (pos > 0) {
	      parent = (pos - 1) >>> 1;
	      if (this.comparator(this.data[pos], this.data[parent]) < 0) {
	        x = this.data[parent];
	        this.data[parent] = this.data[pos];
	        this.data[pos] = x;
	        pos = parent;
	      } else {
	        break;
	      }
	    }
	    return void 0;
	  };
	
	  BinaryHeapStrategy.prototype._bubbleDown = function(pos) {
	    var last, left, minIndex, right, x;
	    last = this.data.length - 1;
	    while (true) {
	      left = (pos << 1) + 1;
	      right = left + 1;
	      minIndex = pos;
	      if (left <= last && this.comparator(this.data[left], this.data[minIndex]) < 0) {
	        minIndex = left;
	      }
	      if (right <= last && this.comparator(this.data[right], this.data[minIndex]) < 0) {
	        minIndex = right;
	      }
	      if (minIndex !== pos) {
	        x = this.data[minIndex];
	        this.data[minIndex] = this.data[pos];
	        this.data[pos] = x;
	        pos = minIndex;
	      } else {
	        break;
	      }
	    }
	    return void 0;
	  };
	
	  return BinaryHeapStrategy;
	
	})();
	
	
	},{}]},{},[1])(1)
	});

/***/ },
/* 318 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/**
	 * Generated On: 2015-10-5
	 * Class: EventsManager
	 * Description: Cette classe gère les évènements (souris, clavier,réseaux, temporelles, script). Il mets également en place les connections entre les évènements et les commandes.
	 */
	
	function EventsManager() {
	    // Constructor
	
	    this.commands = null;
	    this.events = null;
	    this.timer = null;
	}
	
	/**
	 * @param pevent {[object Object]}
	 * @param com {[object Object]}
	 */
	EventsManager.prototype.connect = function connect() /* pevent, com*/{
	    // TODO: Implement Me
	
	};
	
	EventsManager.prototype.command = function command() {};
	
	EventsManager.prototype.wait = function wait() {
	    var waitTime = 250;
	    if (this.timer === null) {
	        this.timer = window.setTimeout(this.command, waitTime);
	    } else {
	        window.clearInterval(this.timer);
	        this.timer = window.setTimeout(this.command, waitTime);
	    }
	};
	
	exports.default = EventsManager;

/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Coordinates = __webpack_require__(289);
	
	var _Coordinates2 = _interopRequireDefault(_Coordinates);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	/**
	 *
	 * @param {type} west : longitude minimum
	 * @param {type} east : longitude maximum
	 * @param {type} south  : latitude minimum
	 * @param {type} north  : latitude maximum
	 * @param {type} parentCenter : center parent
	 * @param {type} minAltitude  : altitude minimum
	 * @param {type} maxAltitude  : altitude maximum
	 * @returns {BoundingBox_L7.BoundingBox}
	 */
	
	/**
	 * Generated On: 2015-10-5
	 * Class: BoundingBox
	 * Description: BoundingBox délimite une zone de l'espace. Cette zone est défnie  par des coordonées cartographiques.
	 */
	
	function BoundingBox(crs, west, east, south, north, minAltitude, maxAltitude) {
	    (0, _Coordinates.assertCrsIsValid)(crs);
	
	    this.minCoordinate = new _Coordinates2.default(crs, west, south, minAltitude || 0);
	    this.maxCoordinate = new _Coordinates2.default(crs, east, north, maxAltitude || 0);
	}
	
	BoundingBox.prototype.as = function as(crs) {
	    var mi = this.minCoordinate.as(crs);
	    var ma = this.maxCoordinate.as(crs);
	    return new BoundingBox(crs, mi._values[0], ma._values[0], mi._values[1], ma._values[1], mi._values[2], ma._values[2]);
	};
	
	BoundingBox.prototype.west = function west(unit) {
	    if ((0, _Coordinates.crsIsGeographic)(this.crs())) {
	        return this.minCoordinate.longitude(unit);
	    } else {
	        return this.minCoordinate.x();
	    }
	};
	
	BoundingBox.prototype.east = function east(unit) {
	    if ((0, _Coordinates.crsIsGeographic)(this.crs())) {
	        return this.maxCoordinate.longitude(unit);
	    } else {
	        return this.maxCoordinate.x();
	    }
	};
	
	BoundingBox.prototype.north = function north(unit) {
	    if ((0, _Coordinates.crsIsGeographic)(this.crs())) {
	        return this.maxCoordinate.latitude(unit);
	    } else {
	        return this.maxCoordinate.y();
	    }
	};
	
	BoundingBox.prototype.south = function south(unit) {
	    if ((0, _Coordinates.crsIsGeographic)(this.crs())) {
	        return this.minCoordinate.latitude(unit);
	    } else {
	        return this.minCoordinate.y();
	    }
	};
	
	BoundingBox.prototype.top = function top() {
	    if ((0, _Coordinates.crsIsGeographic)(this.crs())) {
	        return this.maxCoordinate.altitude();
	    } else {
	        return this.maxCoordinate.z();
	    }
	};
	
	BoundingBox.prototype.bottom = function bottom() {
	    if ((0, _Coordinates.crsIsGeographic)(this.crs())) {
	        return this.minCoordinate.altitude();
	    } else {
	        return this.minCoordinate.z();
	    }
	};
	
	BoundingBox.prototype.crs = function crs() {
	    return this.minCoordinate.crs;
	};
	
	BoundingBox.prototype.center = function center() {
	    var c = this.minCoordinate.clone();
	    var dim = this.dimensions();
	    c._values[0] += dim.x * 0.5;
	    c._values[1] += dim.y * 0.5;
	    c._values[2] += dim.z * 0.5;
	    return c;
	};
	
	BoundingBox.prototype.dimensions = function dimensions(unit) {
	    return {
	        x: Math.abs(this.east(unit) - this.west(unit)),
	        y: Math.abs(this.north(unit) - this.south(unit)),
	        z: Math.abs(this.top() - this.bottom())
	    };
	};
	
	/**
	 * @documentation: Retourne True if point is inside the bounding box
	 *
	 * @param point {[object Object]}
	 */
	BoundingBox.prototype.isInside = function isInside(coord) {
	    var c = this.crs() == coord.crs ? coord : coord.as(this.crs());
	
	    // TODO this ignores altitude
	    if ((0, _Coordinates.crsIsGeographic)(this.crs())) {
	        return c.longitude() <= this.east() && c.longitude() >= this.west() && c.latitude() <= this.north() && c.latitude() >= this.south();
	    } else {
	        return c.x() <= this.east() && c.x() >= this.west() && c.y() <= this.north() && c.y() >= this.south();
	    }
	};
	
	BoundingBox.prototype.BBoxIsInside = function BBoxIsInside(bbox) {
	    var unit = (0, _Coordinates.crsToUnit)(this.crs());
	    return bbox.east(unit) <= this.east() && bbox.west(unit) >= this.west() && bbox.north(unit) <= this.north() && bbox.south(unit) >= this.south();
	};
	
	BoundingBox.prototype.offsetScale = function offsetScale(bbox) {
	    if (bbox.crs() != this.crs()) {
	        throw new Error('unsupported offscale between 2 diff crs');
	    }
	    var pitX = Math.abs(bbox.west() - this.west()) / this._dimension.x;
	    var pitY = Math.abs(bbox.north() - this.north()) / this._dimension.y;
	    var scale = bbox._dimension.x / this._dimension.x;
	    return new THREE.Vector3(pitX, pitY, scale);
	};
	
	/**
	 * @documentation: Set altitude of bounding box
	 * @param {type} min : minimum altitude
	 * @param {type} max : maximum altitude
	 * @returns {undefined}
	 */
	BoundingBox.prototype.setBBoxZ = function setBBoxZ(min, max) {
	    this.minCoordinate._values[2] = min;
	    this.maxCoordinate._values[2] = max;
	};
	
	/**
	 * @documentation: Return true if this bounding box intersect with the bouding box parameter
	 * @param {type} bbox
	 * @returns {Boolean}
	 */
	BoundingBox.prototype.intersect = function intersect(bbox) {
	    var other = bbox.crs() == this.crs() ? bbox : bbox.as(this.crs());
	    return !(this.west() >= other.east() || this.east() <= other.west() || this.south() >= other.north() || this.north() <= other.south());
	};
	
	exports.default = BoundingBox;

/***/ },
/* 320 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/**
	 * Generated On: 2015-10-5
	 * Class: SchemeTile
	 * Description: Cette classe décrit un découpage spatiale.
	 */
	
	function SchemeTile() {
	    // Constructor
	
	    this.maximumChildren = 4;
	    this.schemeBB = [];
	}
	/**
	 *
	 * @param {type} minLo
	 * @param {type} maxLo
	 * @param {type} minLa
	 * @param {type} maxLa
	 * @returns {SchemeTile_L8.SchemeTile.prototype@pro;schemeBB@call;push}
	 */
	
	SchemeTile.prototype.add = function add(bbox) {
	    return this.schemeBB.push(bbox);
	};
	
	SchemeTile.prototype.rootCount = function rootCount() {
	    return this.schemeBB.length;
	};
	
	SchemeTile.prototype.getRoot = function getRoot(id) {
	    return this.schemeBB[id];
	};
	
	exports.default = SchemeTile;

/***/ },
/* 321 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _NodeMesh = __webpack_require__(281);
	
	var _NodeMesh2 = _interopRequireDefault(_NodeMesh);
	
	var _LayeredMaterial = __webpack_require__(322);
	
	var _LayeredMaterial2 = _interopRequireDefault(_LayeredMaterial);
	
	var _GlobeDepthMaterial = __webpack_require__(330);
	
	var _GlobeDepthMaterial2 = _interopRequireDefault(_GlobeDepthMaterial);
	
	var _MatteIdsMaterial = __webpack_require__(333);
	
	var _MatteIdsMaterial2 = _interopRequireDefault(_MatteIdsMaterial);
	
	var _RendererConstant = __webpack_require__(299);
	
	var _RendererConstant2 = _interopRequireDefault(_RendererConstant);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: TileMesh
	 * Description: Tuile de maillage, noeud du quadtree MNT. Le Materiel est issus du QuadTree ORTHO.
	 */
	
	function TileMesh(geometry, params) {
	    // Constructor
	    _NodeMesh2.default.call(this);
	
	    this.matrixAutoUpdate = false;
	    this.rotationAutoUpdate = false;
	
	    if (!params.bbox) {
	        throw new Error('params.bbox is mandatory to build a TileMesh');
	    }
	
	    this.level = params.level;
	    this.bbox = params.bbox;
	
	    this.geometry = geometry;
	    this.normal = params.center.clone().normalize();
	
	    // TODO Why move sphere center
	    this.centerSphere = new THREE.Vector3().addVectors(this.geometry.boundingSphere.center, params.center);
	
	    this.oSphere = new THREE.Sphere(this.centerSphere.clone(), this.geometry.boundingSphere.radius);
	    this.texturesNeeded = 0;
	
	    this.materials = [];
	
	    // instantiations all state materials : final, depth, id
	    // Final rendering : return layered color + fog
	    this.materials[_RendererConstant2.default.FINAL] = new _LayeredMaterial2.default();
	    // Depth : return the distance between projection point and the node
	    this.materials[_RendererConstant2.default.DEPTH] = new _GlobeDepthMaterial2.default(this.materials[_RendererConstant2.default.FINAL]);
	    // ID : return id color in RGBA (float Pack in RGBA)
	    this.materials[_RendererConstant2.default.ID] = new _MatteIdsMaterial2.default(this.materials[_RendererConstant2.default.FINAL]);
	    // Set current material in Final Rendering
	    this.material = this.materials[_RendererConstant2.default.FINAL];
	
	    this.frustumCulled = false;
	
	    // Layer
	    this.setDisplayed(false);
	}
	
	TileMesh.prototype = (0, _create2.default)(_NodeMesh2.default.prototype);
	
	TileMesh.prototype.constructor = TileMesh;
	
	TileMesh.prototype.dispose = function dispose() {
	    // TODO à mettre dans node mesh
	    this.material.dispose();
	    this.geometry.dispose();
	    this.geometry = null;
	    this.material = null;
	};
	
	TileMesh.prototype.setUuid = function setUuid(uuid) {
	    this.id = uuid;
	    this.materials[_RendererConstant2.default.FINAL].setUuid(uuid);
	    this.materials[_RendererConstant2.default.ID].setUuid(uuid);
	};
	
	TileMesh.prototype.getUuid = function getUuid(uuid) {
	    return this.materials[_RendererConstant2.default.ID].getUuid(uuid);
	};
	
	TileMesh.prototype.setColorLayerParameters = function setColorLayerParameters(paramsTextureColor, lighting) {
	    if (!this.loaded) {
	        var material = this.materials[_RendererConstant2.default.FINAL];
	        material.setLightingOn(lighting.enable);
	        material.uniforms.lightPosition.value = lighting.position;
	        material.setColorLayerParameters(paramsTextureColor);
	    }
	};
	/**
	 *
	 * @returns {undefined}     */
	TileMesh.prototype.disposeChildren = function disposeChildren() {
	    this.pendingSubdivision = false;
	
	    while (this.children.length > 0) {
	        var child = this.children[0];
	        this.remove(child);
	        child.dispose();
	    }
	};
	
	TileMesh.prototype.setDisplayed = function setDisplayed(show) {
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = (0, _getIterator3.default)(this.materials), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var material = _step.value;
	
	            material.visible = show;
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	};
	
	TileMesh.prototype.enableRTC = function enableRTC(enable) {
	    this.materials[_RendererConstant2.default.FINAL].enableRTC(enable);
	};
	
	// switch material in function of state
	TileMesh.prototype.changeState = function changeState(state) {
	    if (state !== _RendererConstant2.default.FINAL) {
	        this.materials[state].visible = this.materials[_RendererConstant2.default.FINAL].visible;
	    }
	
	    this.material = this.materials[state];
	};
	
	TileMesh.prototype.setFog = function setFog(fog) {
	    this.materials[_RendererConstant2.default.FINAL].setFogDistance(fog);
	};
	
	TileMesh.prototype.setMatrixRTC = function setMatrixRTC(rtc) {
	    var _iteratorNormalCompletion2 = true;
	    var _didIteratorError2 = false;
	    var _iteratorError2 = undefined;
	
	    try {
	        for (var _iterator2 = (0, _getIterator3.default)(this.materials), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	            var material = _step2.value;
	
	            material.setMatrixRTC(rtc);
	        }
	    } catch (err) {
	        _didIteratorError2 = true;
	        _iteratorError2 = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                _iterator2.return();
	            }
	        } finally {
	            if (_didIteratorError2) {
	                throw _iteratorError2;
	            }
	        }
	    }
	};
	
	TileMesh.prototype.setDebug = function setDebug(enable) {
	    this.materials[_RendererConstant2.default.FINAL].setDebug(enable);
	};
	
	TileMesh.prototype.setSelected = function setSelected(select) {
	    this.materials[_RendererConstant2.default.FINAL].setSelected(select);
	};
	
	TileMesh.prototype.setTextureElevation = function setTextureElevation(elevation) {
	    if (this.materials[_RendererConstant2.default.FINAL] === null) {
	        return;
	    }
	
	    var offsetScale = elevation.pitch || new THREE.Vector3(0, 0, 1);
	    this.setBBoxZ(elevation.min, elevation.max);
	
	    this.materials[_RendererConstant2.default.FINAL].setTexture(elevation.texture, _LayeredMaterial.l_ELEVATION, 0, offsetScale);
	    this.materials[_RendererConstant2.default.DEPTH].uniforms.texturesCount.value = this.materials[_RendererConstant2.default.FINAL].loadedTexturesCount[0];
	    this.materials[_RendererConstant2.default.ID].uniforms.texturesCount.value = this.materials[_RendererConstant2.default.FINAL].loadedTexturesCount[0];
	
	    this.loadingCheck();
	};
	
	TileMesh.prototype.setBBoxZ = function setBBoxZ(min, max) {
	    if (Math.floor(min) !== Math.floor(this.bbox.bottom()) || Math.floor(max) !== Math.floor(this.bbox.top())) {
	        this.bbox.setBBoxZ(min, max);
	        var delta = this.geometry.OBB.addHeight(this.bbox);
	
	        var trans = this.normal.clone().setLength(delta.y);
	
	        this.geometry.boundingSphere.radius = Math.sqrt(delta.x * delta.x + this.oSphere.radius * this.oSphere.radius);
	        this.centerSphere = new THREE.Vector3().addVectors(this.oSphere.center, trans);
	    }
	};
	
	TileMesh.prototype.setTexturesLayer = function setTexturesLayer(textures, layerType, layer) {
	    if (this.material === null) {
	        return;
	    }
	    if (textures) {
	        this.material.setTexturesLayer(textures, layerType, layer);
	    }
	    this.loadingCheck();
	};
	
	TileMesh.prototype.isColorLayerDownscaled = function isColorLayerDownscaled(layer) {
	    var mat = this.materials[_RendererConstant2.default.FINAL];
	    return mat.isColorLayerDownscaled(layer, this.level);
	};
	
	TileMesh.prototype.isLayerTypeDownscaled = function isLayerTypeDownscaled(layerType) {
	    var mat = this.materials[_RendererConstant2.default.FINAL];
	    return mat.isLayerTypeDownscaled(layerType, this.level);
	};
	
	TileMesh.prototype.normals = function normals() {
	    return this.geometry.normals;
	};
	
	TileMesh.prototype.fourCorners = function fourCorners() {
	    return this.geometry.fourCorners;
	};
	
	TileMesh.prototype.normal = function normal() {
	    return this.geometry.normal;
	};
	
	TileMesh.prototype.center = function center() {
	    return this.geometry.center;
	};
	
	TileMesh.prototype.OBB = function OBB() {
	    return this.geometry.OBB;
	};
	
	TileMesh.prototype.allTexturesAreLoaded = function allTexturesAreLoaded() {
	    return this.texturesNeeded === this.materials[_RendererConstant2.default.FINAL].getLoadedTexturesCount();
	};
	
	TileMesh.prototype.loadingCheck = function loadingCheck() {
	    if (this.allTexturesAreLoaded()) {
	        this.loaded = true;
	        this.parent.childrenLoaded();
	    }
	};
	
	TileMesh.prototype.getIndexLayerColor = function getIndexLayerColor(idLayer) {
	    return this.materials[_RendererConstant2.default.FINAL].indexOfColorLayer(idLayer);
	};
	
	TileMesh.prototype.removeColorLayer = function removeColorLayer(idLayer) {
	    var index = this.materials[_RendererConstant2.default.FINAL].indexOfColorLayer(idLayer);
	    var texturesCount = this.materials[_RendererConstant2.default.FINAL].getTextureCountByLayerIndex(index);
	    this.materials[_RendererConstant2.default.FINAL].removeColorLayer(idLayer);
	    this.texturesNeeded -= texturesCount;
	    this.loadingCheck();
	};
	
	TileMesh.prototype.changeSequenceLayers = function changeSequenceLayers(sequence) {
	    var layerCount = this.materials[_RendererConstant2.default.FINAL].getColorLayersCount();
	
	    // Quit if there is only one layer
	    if (layerCount < 2) {
	        return;
	    }
	
	    this.materials[_RendererConstant2.default.FINAL].setSequence(sequence);
	};
	
	exports.default = TileMesh;

/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.l_COLOR = exports.l_ELEVATION = undefined;
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _BasicMaterial = __webpack_require__(323);
	
	var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);
	
	var _c3DEngine = __webpack_require__(240);
	
	var _c3DEngine2 = _interopRequireDefault(_c3DEngine);
	
	var _GlobeVS = __webpack_require__(327);
	
	var _GlobeVS2 = _interopRequireDefault(_GlobeVS);
	
	var _GlobeFS = __webpack_require__(328);
	
	var _GlobeFS2 = _interopRequireDefault(_GlobeFS);
	
	var _pitUV = __webpack_require__(329);
	
	var _pitUV2 = _interopRequireDefault(_pitUV);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */
	
	var EMPTY_TEXTURE_LEVEL = -1;
	
	var emptyTexture = new THREE.Texture();
	emptyTexture.level = EMPTY_TEXTURE_LEVEL;
	
	var layerTypesCount = 2;
	var vector = new THREE.Vector3(0.0, 0.0, 0.0);
	var vector4 = new THREE.Vector4(0.0, 0.0, 0.0, 0.0);
	var fooTexture;
	
	var l_ELEVATION = exports.l_ELEVATION = 0;
	var l_COLOR = exports.l_COLOR = 1;
	
	var getColorAtIdUv = function getColorAtIdUv(nbTex) {
	    if (!fooTexture) {
	        fooTexture = 'vec4 colorAtIdUv(sampler2D dTextures[TEX_UNITS],vec3 offsetScale[TEX_UNITS],int id, vec2 uv){\n';
	        fooTexture += ' if (id == 0) return texture2D(dTextures[0],  pitUV(uv,offsetScale[0]));\n';
	
	        for (var l = 1; l < nbTex; l++) {
	            var sL = l.toString();
	            fooTexture += '    else if (id == ' + sL + ') return texture2D(dTextures[' + sL + '],  pitUV(uv,offsetScale[' + sL + ']));\n';
	        }
	
	        fooTexture += 'else return vec4(0.0,0.0,0.0,0.0);}\n';
	    }
	
	    return fooTexture;
	};
	
	// Array not suported in IE
	var fillArray = function fillArray(array, remp) {
	    for (var i = 0; i < array.length; i++) {
	        array[i] = remp;
	    }
	};
	
	var moveElementArray = function moveElementArray(array, oldIndex, newIndex) {
	    array.splice(newIndex, 0, array.splice(oldIndex, 1)[0]);
	};
	
	var moveElementsArray = function moveElementsArray(array, index, howMany, toIndex) {
	    if (toIndex > index && toIndex <= index + howMany) {
	        toIndex = index + howMany;
	    }
	
	    array.splice.apply(array, [toIndex, 0].concat(array.splice(index, howMany)));
	};
	
	/* eslint-disable */
	var moveElementsArraySafe = function moveElementsArraySafe(array, index, howMany, toIndex) {
	    index = parseInt(index) || 0;
	    index = index < 0 ? array.length + index : index;
	    toIndex = parseInt(toIndex) || 0;
	    toIndex = toIndex < 0 ? array.length + toIndex : toIndex;
	    if (toIndex > index && toIndex <= index + howMany) {
	        toIndex = index + howMany;
	    }
	
	    var moved;
	    array.splice.apply(array, [toIndex, 0].concat(moved = array.splice(index, howMany)));
	    return moved;
	};
	/* eslint-enable */
	
	var LayeredMaterial = function LayeredMaterial(id) {
	    _BasicMaterial2.default.call(this);
	
	    var maxTexturesUnits = (0, _c3DEngine2.default)().glParams.maxTexturesUnits;
	    var nbSamplers = Math.min(maxTexturesUnits - 1, 16 - 1);
	    this.vertexShader = _GlobeVS2.default;
	
	    this.fragmentShaderHeader += 'const int   TEX_UNITS   = ' + nbSamplers.toString() + ';\n';
	    this.fragmentShaderHeader += _pitUV2.default;
	
	    if (false) {
	        this.fragmentShaderHeader += '#define DEBUG\n';
	    }
	
	    // see GLOBE FS
	    this.fragmentShaderHeader += getColorAtIdUv(nbSamplers);
	
	    this.fragmentShader = this.fragmentShaderHeader + _GlobeFS2.default;
	    this.vertexShader = this.vertexShaderHeader + _GlobeVS2.default;
	
	    // handle on textures uniforms
	    this.textures = [];
	    // handle on textures offsetScale uniforms
	    this.offsetScale = [];
	    // handle Loaded textures count by layer's type uniforms
	    this.loadedTexturesCount = [0, 0];
	
	    // Uniform three js needs no empty array
	    // WARNING TODO: prevent empty slot, but it's not the solution
	    this.offsetScale[l_COLOR] = Array(nbSamplers);
	    this.offsetScale[l_ELEVATION] = [vector];
	    fillArray(this.offsetScale[l_COLOR], vector);
	
	    this.textures[l_ELEVATION] = [emptyTexture];
	    this.textures[l_COLOR] = Array(nbSamplers);
	    var paramLayers = Array(8);
	    this.layerTexturesCount = Array(8);
	
	    fillArray(this.textures[l_COLOR], emptyTexture);
	    fillArray(paramLayers, vector4);
	    fillArray(this.layerTexturesCount, 0);
	
	    // Elevation texture
	    this.uniforms.dTextures_00 = new THREE.Uniform(this.textures[l_ELEVATION]);
	
	    // Color textures's layer
	    this.uniforms.dTextures_01 = new THREE.Uniform(this.textures[l_COLOR]);
	
	    // Visibility layer
	    this.uniforms.visibility = new THREE.Uniform([true, true, true, true, true, true, true, true]);
	
	    // Loaded textures count by layer's type
	    this.uniforms.loadedTexturesCount = new THREE.Uniform(this.loadedTexturesCount);
	
	    // Count color layers
	    this.uniforms.colorLayersCount = new THREE.Uniform(1);
	
	    // Layer setting
	    // Offset color texture slot | Projection | fx | Opacity
	    this.uniforms.paramLayers = new THREE.Uniform(paramLayers);
	
	    // Elevation texture cropping
	    this.uniforms.offsetScale_L00 = new THREE.Uniform(this.offsetScale[l_ELEVATION]);
	
	    // Color texture cropping
	    this.uniforms.offsetScale_L01 = new THREE.Uniform(this.offsetScale[l_COLOR]);
	
	    // Light position
	    this.uniforms.lightPosition = new THREE.Uniform(new THREE.Vector3(-0.5, 0.0, 1.0));
	
	    this.setUuid(id || 0);
	    this.wireframe = false;
	    // this.wireframe = true;
	
	    this.colorLayersId = [];
	};
	
	LayeredMaterial.prototype = (0, _create2.default)(_BasicMaterial2.default.prototype);
	LayeredMaterial.prototype.constructor = LayeredMaterial;
	
	LayeredMaterial.prototype.dispose = function dispose() {
	    // TODO: WARNING  verify if textures to dispose aren't attached with ancestor
	
	    this.dispatchEvent({
	        type: 'dispose'
	    });
	
	    for (var l = 0; l < layerTypesCount; l++) {
	        for (var i = 0, max = this.textures[l].length; i < max; i++) {
	            if (this.textures[l][i] instanceof THREE.Texture) {
	                this.textures[l][i].dispose();
	            }
	        }
	    }
	};
	
	LayeredMaterial.prototype.setSequence = function setSequence(sequenceLayer) {
	    var offsetLayer = 0;
	    var offsetTexture = 0;
	
	    for (var l = 0; l < sequenceLayer.length; l++) {
	        var layer = sequenceLayer[l];
	        var oldIndex = this.indexOfColorLayer(layer);
	        if (oldIndex > -1) {
	            var newIndex = l - offsetLayer;
	            var texturesCount = this.layerTexturesCount[oldIndex];
	
	            if (newIndex !== oldIndex) {
	                moveElementArray(this.colorLayersId, oldIndex, newIndex);
	                moveElementArray(this.layerTexturesCount, oldIndex, newIndex);
	                moveElementArray(this.uniforms.paramLayers.value, oldIndex, newIndex);
	                moveElementArray(this.uniforms.visibility.value, oldIndex, newIndex);
	                var oldOffset = this.getTextureOffsetByLayerIndex(newIndex);
	                moveElementsArray(this.uniforms.offsetScale_L01.value, oldOffset, texturesCount, offsetTexture);
	                moveElementsArray(this.uniforms.dTextures_01.value, oldOffset, texturesCount, offsetTexture);
	            }
	
	            this.setTextureOffsetByLayerIndex(newIndex, offsetTexture);
	            offsetTexture += texturesCount;
	        } else {
	            offsetLayer++;
	        }
	    }
	
	    this.uniforms.colorLayersCount.value = this.getColorLayersCount();
	};
	
	LayeredMaterial.prototype.removeColorLayer = function removeColorLayer(layer) {
	    var layerIndex = this.indexOfColorLayer(layer);
	
	    if (layerIndex === -1) {
	        return;
	    }
	
	    var offset = this.getTextureOffsetByLayerIndex(layerIndex);
	    var texturesCount = this.getTextureCountByLayerIndex(layerIndex);
	
	    // remove layer
	    this.colorLayersId.splice(layerIndex, 1);
	    this.uniforms.colorLayersCount.value = this.getColorLayersCount();
	
	    // remove nb textures
	    this.layerTexturesCount.splice(layerIndex, 1);
	    this.layerTexturesCount.push(0);
	
	    // Remove Layers Parameters
	    this.uniforms.paramLayers.value.splice(layerIndex, 1);
	    this.uniforms.paramLayers.value.push(vector4);
	
	    // Remove visibility Parameters
	    this.uniforms.visibility.value.splice(layerIndex, 1);
	    this.uniforms.visibility.value.push(true);
	
	    // Dispose Layers textures
	    for (var i = offset, max = offset + texturesCount; i < max; i++) {
	        if (this.textures[l_COLOR][i] instanceof THREE.Texture) {
	            this.textures[l_COLOR][i].dispose();
	        }
	    }
	
	    var removedTexturesLayer = this.textures[l_COLOR].splice(offset, texturesCount);
	    this.offsetScale[l_COLOR].splice(offset, texturesCount);
	
	    var loadedTexturesLayerCount = removedTexturesLayer.reduce(function (sum, texture) {
	        return sum + (texture.level > -1);
	    }, 0);
	
	    // refill remove textures
	    for (var _i = 0, _max = texturesCount; _i < _max; _i++) {
	        this.textures[l_COLOR].push(emptyTexture);
	        this.offsetScale[l_COLOR].push(vector);
	    }
	
	    // Update slot start texture layer
	    for (var j = layerIndex, mx = this.getColorLayersCount(); j < mx; j++) {
	        this.uniforms.paramLayers.value[j].x -= texturesCount;
	    }
	
	    this.loadedTexturesCount[l_COLOR] -= loadedTexturesLayerCount;
	
	    this.uniforms.offsetScale_L01.value = this.offsetScale[l_COLOR];
	    this.uniforms.dTextures_01.value = this.textures[l_COLOR];
	};
	
	LayeredMaterial.prototype.setTexturesLayer = function setTexturesLayer(textures, layerType, layer) {
	    var index = this.indexOfColorLayer(layer);
	    var slotOffset = this.getTextureOffsetByLayerIndex(index);
	    for (var i = 0, max = textures.length; i < max; i++) {
	        if (textures[i]) {
	            if (textures[i].texture !== null) {
	                this.setTexture(textures[i].texture, layerType, i + (slotOffset || 0), textures[i].pitch);
	            } else {
	                this.setLayerVisibility(index, false);
	                break;
	            }
	        }
	    }
	};
	
	LayeredMaterial.prototype.setTexture = function setTexture(texture, layerType, slot, offsetScale) {
	    if (this.textures[layerType][slot] === undefined || this.textures[layerType][slot].image === undefined) {
	        this.loadedTexturesCount[layerType] += 1;
	    }
	
	    // BEWARE: array [] -> size: 0; array [10]="wao" -> size: 11
	    this.textures[layerType][slot] = texture || emptyTexture;
	    this.offsetScale[layerType][slot] = offsetScale || new THREE.Vector3(0.0, 0.0, 1.0);
	};
	
	LayeredMaterial.prototype.setColorLayerParameters = function setColorLayerParameters(params) {
	    if (this.getColorLayersCount() === 0) {
	        for (var l = 0; l < params.length; l++) {
	            this.pushLayer(params[l]);
	        }
	    }
	};
	
	LayeredMaterial.prototype.pushLayer = function pushLayer(param) {
	    var newIndex = this.getColorLayersCount();
	    var offset = newIndex === 0 ? 0 : this.getTextureOffsetByLayerIndex(newIndex - 1) + this.getTextureCountByLayerIndex(newIndex - 1);
	
	    this.uniforms.paramLayers.value[newIndex] = new THREE.Vector4();
	
	    this.setTextureOffsetByLayerIndex(newIndex, offset);
	    this.setLayerUV(newIndex, param.tileMT === 'PM' ? 1 : 0);
	    this.setLayerFx(newIndex, param.fx);
	    this.setLayerOpacity(newIndex, param.opacity);
	    this.setLayerVisibility(newIndex, param.visible);
	    this.setLayerTexturesCount(newIndex, param.texturesCount);
	    this.colorLayersId.push(param.idLayer);
	
	    this.uniforms.colorLayersCount.value = this.getColorLayersCount();
	};
	
	LayeredMaterial.prototype.indexOfColorLayer = function indexOfColorLayer(layer) {
	    return this.colorLayersId.indexOf(layer);
	};
	
	LayeredMaterial.prototype.getColorLayersCount = function getColorLayersCount() {
	    return this.colorLayersId.length;
	};
	
	LayeredMaterial.prototype.getTextureOffsetByLayerIndex = function getTextureOffsetByLayerIndex(index) {
	    return this.uniforms.paramLayers.value[index].x;
	};
	
	LayeredMaterial.prototype.getTextureCountByLayerIndex = function getTextureCountByLayerIndex(index) {
	    return this.layerTexturesCount[index];
	};
	
	LayeredMaterial.prototype.getLayerTextureOffset = function getLayerTextureOffset(layer) {
	    var index = this.indexOfColorLayer(layer);
	    return index > -1 ? this.getTextureOffsetByLayerIndex(index) : -1;
	};
	
	LayeredMaterial.prototype.setLightingOn = function setLightingOn(enable) {
	    this.uniforms.lightingEnabled.value = enable;
	};
	
	LayeredMaterial.prototype.setLayerFx = function setLayerFx(index, fx) {
	    this.uniforms.paramLayers.value[index].z = fx;
	};
	
	LayeredMaterial.prototype.setTextureOffsetByLayerIndex = function setTextureOffsetByLayerIndex(index, offset) {
	    this.uniforms.paramLayers.value[index].x = offset;
	};
	
	LayeredMaterial.prototype.setLayerUV = function setLayerUV(index, idUV) {
	    this.uniforms.paramLayers.value[index].y = idUV;
	};
	
	LayeredMaterial.prototype.setLayerOpacity = function setLayerOpacity(index, opacity) {
	    if (this.uniforms.paramLayers.value[index]) {
	        this.uniforms.paramLayers.value[index].w = opacity;
	    }
	};
	
	LayeredMaterial.prototype.setLayerVisibility = function setLayerVisibility(index, visible) {
	    this.uniforms.visibility.value[index] = visible;
	};
	
	LayeredMaterial.prototype.setLayerTexturesCount = function setLayerTexturesCount(index, count) {
	    this.layerTexturesCount[index] = count;
	};
	
	LayeredMaterial.prototype.getLoadedTexturesCount = function getLoadedTexturesCount() {
	    return this.loadedTexturesCount[l_ELEVATION] + this.loadedTexturesCount[l_COLOR];
	};
	
	LayeredMaterial.prototype.isColorLayerDownscaled = function isColorLayerDownscaled(layer, level) {
	    return this.textures[l_COLOR][this.getLayerTextureOffset(layer)].level < level;
	};
	
	LayeredMaterial.prototype.isLayerTypeDownscaled = function isLayerTypeDownscaled(layerType, level) {
	    if (layerType === l_ELEVATION) {
	        var tex = this.textures[l_ELEVATION][0];
	        // 3 possible cases
	        //   - initialization (no texture)
	        if (tex === undefined) {
	            return true;
	        }
	        //   - blank texture (eg: empty xbil texture)
	        if (tex.level === EMPTY_TEXTURE_LEVEL) {
	            return false;
	        }
	        //   - regular texture
	        return tex.level < level;
	    } else if (layerType === l_COLOR) {
	        // browse each layer
	        for (var index = 0, max = this.colorLayersId.length; index < max; index++) {
	            var offset = this.getTextureOffsetByLayerIndex(index);
	            if (this.textures[l_COLOR][offset].level < level) {
	                return true;
	            }
	        }
	    }
	
	    return false;
	};
	
	LayeredMaterial.prototype.getColorLayerLevelById = function getColorLayerLevelById(colorLayerId) {
	    var index = this.indexOfColorLayer(colorLayerId);
	    // TODO: hiding the "colorLayerId is invalid", it's problem, needs new PR
	    if (index === -1) {
	        index = 0;
	    }
	    var slot = this.getTextureOffsetByLayerIndex(index);
	    var tex = this.textures[l_COLOR][slot];
	
	    return tex ? tex.level : EMPTY_TEXTURE_LEVEL;
	};
	
	LayeredMaterial.prototype.getElevationLayerLevel = function getElevationLayerLevel() {
	    return this.textures[l_ELEVATION][0].level;
	};
	
	LayeredMaterial.prototype.getLayerLevel = function getLayerLevel(layerType, layer) {
	    if (layerType == l_ELEVATION) {
	        return this.getElevationLayerLevel();
	    } else {
	        return this.getColorLayerLevelById(layer);
	    }
	};
	
	exports.default = LayeredMaterial;

/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _c3DEngine = __webpack_require__(240);
	
	var _c3DEngine2 = _interopRequireDefault(_c3DEngine);
	
	var _SimpleVS = __webpack_require__(324);
	
	var _SimpleVS2 = _interopRequireDefault(_SimpleVS);
	
	var _SimpleFS = __webpack_require__(325);
	
	var _SimpleFS2 = _interopRequireDefault(_SimpleFS);
	
	var _LogDepthBuffer = __webpack_require__(326);
	
	var _LogDepthBuffer2 = _interopRequireDefault(_LogDepthBuffer);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function BasicMaterial(color) {
	    // Constructor
	
	    THREE.RawShaderMaterial.call(this);
	
	    this.vertexShaderHeader = '';
	    this.fragmentShaderHeader = '';
	
	    var logarithmicDepthBuffer = (0, _c3DEngine2.default)().renderer.capabilities.logarithmicDepthBuffer;
	
	    if (logarithmicDepthBuffer) {
	        this.fragmentShaderHeader += '#extension GL_EXT_frag_depth : enable\n';
	    }
	
	    this.fragmentShaderHeader += 'precision highp float;\n';
	    this.fragmentShaderHeader += 'precision highp int;\n';
	
	    if (logarithmicDepthBuffer) {
	        this.fragmentShaderHeader += '#define USE_LOGDEPTHBUF\n';
	        this.fragmentShaderHeader += '#define USE_LOGDEPTHBUF_EXT\n';
	        this.fragmentShaderHeader += _LogDepthBuffer2.default;
	    }
	
	    this.fragmentShaderHeader += '#define VERTEX_TEXTURES\n';
	    this.vertexShaderHeader = this.fragmentShaderHeader;
	
	    this.vertexShader = this.vertexShaderHeader + _SimpleVS2.default;
	    this.fragmentShader = this.fragmentShaderHeader + _SimpleFS2.default;
	
	    this.uniforms = {
	        diffuseColor: { value: color || new THREE.Color() },
	        useRTC: { value: true },
	        mVPMatRTC: { value: new THREE.Matrix4() },
	        distanceFog: { value: 1000000000.0 },
	        uuid: { value: 0 },
	        debug: { value: false },
	        selected: { value: false },
	        lightingEnabled: { value: true }
	    };
	} /*
	   * To change this license header, choose License Headers in Project Properties.
	   * To change this template file, choose Tools | Templates
	   * and open the template in the editor.
	   */
	
	BasicMaterial.prototype = (0, _create2.default)(THREE.RawShaderMaterial.prototype);
	BasicMaterial.prototype.constructor = BasicMaterial;
	
	BasicMaterial.prototype.enableRTC = function enableRTC(enable) {
	    this.uniforms.useRTC.value = enable;
	};
	
	BasicMaterial.prototype.setDebug = function setDebug(v) {
	    this.uniforms.debug.value = v;
	};
	
	BasicMaterial.prototype.setMatrixRTC = function setMatrixRTC(rtc) {
	    this.uniforms.mVPMatRTC.value = rtc;
	};
	
	BasicMaterial.prototype.getMatrixRTC = function getMatrixRTC() {
	    return this.uniforms.mVPMatRTC.value;
	};
	
	BasicMaterial.prototype.setUuid = function setUuid(uuid) {
	    this.uniforms.uuid.value = uuid;
	};
	
	BasicMaterial.prototype.getUuid = function getUuid() {
	    return this.uniforms.uuid.value;
	};
	
	BasicMaterial.prototype.setFogDistance = function setFogDistance(df) {
	    this.uniforms.distanceFog.value = df;
	};
	
	BasicMaterial.prototype.setSelected = function setSelected(selected) {
	    this.uniforms.selected.value = selected;
	};
	
	exports.default = BasicMaterial;

/***/ },
/* 324 */
/***/ function(module, exports) {

	module.exports = "#version 100\n\nprecision highp float;\nprecision highp int;\n\n#define SHADER_NAME SimpleMaterial\n#define VERTEX_TEXTURES\n\n#define USE_LOGDEPTHBUF\n#define USE_LOGDEPTHBUF_EXT\n\n#ifdef USE_LOGDEPTHBUF\n\n    #define EPSILON 1e-6\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\n\n\n//attribute vec2      uv;\nattribute vec3      position;\nattribute vec3      normal;\n\nuniform mat4        projectionMatrix;\nuniform mat4        modelViewMatrix;\n\nuniform mat4       mVPMatRTC;\nuniform bool       useRTC;\nvarying float      light;\n\n// IE error : Initializer for const variable must initialize to a constant value\n//const vec3 dir =  normalize(vec3(1.0,1.0,0.5));\n\nvoid main()\n{\n  vec3 dir =  normalize(vec3(1.0,1.0,0.5));\n\n  if(useRTC)\n        gl_Position = mVPMatRTC * vec4( position ,1.0 );\n  else\n        gl_Position = projectionMatrix * modelViewMatrix * vec4( position,  1.0 );\n\n    float h  = max(0.05,(1.0 - min(position.y / 50.0,1.0)));\n\n    light    =   h / max(0.25,dot(dir,normal));\n\n    #ifdef USE_LOGDEPTHBUF\n\n        gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n        #ifdef USE_LOGDEPTHBUF_EXT\n\n            vFragDepth = 1.0 + gl_Position.w;\n\n        #else\n\n            gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n        #endif\n\n    #endif\n\n}"

/***/ },
/* 325 */
/***/ function(module, exports) {

	module.exports = "#version 100\n\n#extension GL_EXT_frag_depth : enable\n\n#define SHADER_NAME simpleMaterial\n#define VERTEX_TEXTURES\n\nprecision highp float;\nprecision highp int;\n\n#define USE_LOGDEPTHBUF\n#define USE_LOGDEPTHBUF_EXT\n\n#ifdef USE_LOGDEPTHBUF\n\n\tuniform float logDepthBufFC;\n\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\n\t\tvarying float vFragDepth;\n\n\t#endif\n\n#endif\n\nuniform vec3 diffuseColor;\nuniform bool lightingEnabled;\nvarying float light;\n\nvoid main() {\n\n    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n    #endif\n\n    vec4 color = lightingEnabled ? vec4( diffuseColor / light,1.0) : vec4( diffuseColor, 1.0);\n\n    gl_FragColor = color;\n}"

/***/ },
/* 326 */
/***/ function(module, exports) {

	module.exports = "#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n    #define EPSILON 1e-6\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        //#extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\n"

/***/ },
/* 327 */
/***/ function(module, exports) {

	module.exports = "const float PI          = 3.14159265359;\nconst float INV_TWO_PI  = 1.0 / (2.0*PI);\nconst float PI4         = 0.78539816339;\n\nattribute float     uv_pm;\nattribute vec2      uv_wgs84;\nattribute vec3      position;\nattribute vec3      normal;\n\nuniform sampler2D   dTextures_00[1];\nuniform vec3        offsetScale_L00[1];\nuniform int         loadedTexturesCount[8];\nuniform bool        useRTC;\nuniform float       periArcLati;\nuniform mat4        mVPMatRTC;\n\nuniform mat4        projectionMatrix;\nuniform mat4        modelViewMatrix;\n\nvarying vec2        vUv_WGS84;\nvarying float       vUv_PM;\nvarying vec3        vNormal;\nvarying vec4        pos;\n\nhighp float decode32(highp vec4 rgba) {\n    highp float Sign = 1.0 - step(128.0,rgba[0])*2.0;\n    highp float Exponent = 2.0 * mod(rgba[0],128.0) + step(128.0,rgba[1]) - 127.0;\n    highp float Mantissa = mod(rgba[1],128.0)*65536.0 + rgba[2]*256.0 +rgba[3] + float(0x800000);\n    highp float Result =  Sign * exp2(Exponent) * (Mantissa * exp2(-23.0 ));\n    return Result;\n}\n\n//#define RGBA_ELEVATION\n\nvoid main() {\n\n        vUv_WGS84 = uv_wgs84;\n        vUv_PM = uv_pm;\n\n        vec4 vPosition;\n\n        if(loadedTexturesCount[0] > 0)\n        {\n            vec2    vVv = vec2(\n                vUv_WGS84.x * offsetScale_L00[0].z + offsetScale_L00[0].x,\n                (1.0 - vUv_WGS84.y) * offsetScale_L00[0].z + offsetScale_L00[0].y);\n\n\n            #ifdef RGBA_ELEVATION\n                vec4 rgba = texture2D( dTextures_00[0], vVv ) * 255.0;\n\n                rgba.rgba = rgba.abgr;\n\n                float dv = max(decode32(rgba),0.0);\n\n                // In RGBA elevation texture LinearFilter give some errors with nodata value.\n                // need to rewrite sample function in shader\n                // simple solution\n                if(dv>5000.0)\n                    dv = 0.0;\n\n            #else\n                float   dv  = max(texture2D( dTextures_00[0], vVv ).w, 0.);\n            #endif\n\n            vNormal     = normal;\n            vPosition   = vec4( position +  vNormal  * dv ,1.0 );\n        }\n        else\n            vPosition = vec4( position ,1.0 );\n\n        mat4 projModelViewMatrix = useRTC ? mVPMatRTC : projectionMatrix * modelViewMatrix;\n\n        gl_Position = projModelViewMatrix * vPosition;\n\n        #ifdef USE_LOGDEPTHBUF\n\n            gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n            #ifdef USE_LOGDEPTHBUF_EXT\n\n                vFragDepth = 1.0 + gl_Position.w;\n\n            #else\n\n                gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n            #endif\n\n        #endif\n\n}\n"

/***/ },
/* 328 */
/***/ function(module, exports) {

	module.exports = "// BUG CHROME 50 UBUNTU 16.04\n// Lose context on compiling shader with too many IF STATEMENT\n// runconformance/glsl/bugs/conditional-discard-in-loop.html\n// conformance/glsl/bugs/nested-loops-with-break-and-continue.html\n// Resolve CHROME unstable 52\n\nconst vec4 CFog = vec4( 0.76, 0.85, 1.0, 1.0);\nconst vec4 CWhite = vec4(1.0,1.0,1.0,1.0);\nconst vec4 CBlueOcean = vec4( 0.04, 0.23, 0.35, 1.0);\nconst vec4 COrange = vec4( 1.0, 0.3, 0.0, 1.0);\nconst vec4 CRed = vec4( 1.0, 0.0, 0.0, 1.0);\n\n\nuniform sampler2D   dTextures_01[TEX_UNITS];\nuniform vec3        offsetScale_L01[TEX_UNITS];\n\n// offset texture | Projection | fx | Opacity\nuniform vec4        paramLayers[8];\nuniform int         loadedTexturesCount[8];\nuniform bool        visibility[8];\n\nuniform float       distanceFog;\nuniform int         colorLayersCount;\nuniform vec3        lightPosition;\n\n// Options global\nuniform bool        selected;\nuniform bool        lightingEnabled;\n\nvarying vec2        vUv_WGS84;\nvarying float       vUv_PM;\nvarying vec3        vNormal;\n\n#if defined(DEBUG)\n    uniform bool showOutline;\n    const float sLine = 0.008;\n#endif\n\n// Note see after in code\n// int textureIndex = 0;\n// int getTextureIndex() {\n//     return textureIndex;\n// }\n\nvoid main() {\n\n    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\t   gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n    #endif\n\n    #if defined(DEBUG)\n         if (showOutline && (vUv_WGS84.x < sLine || vUv_WGS84.x > 1.0 - sLine || vUv_WGS84.y < sLine || vUv_WGS84.y > 1.0 - sLine))\n             gl_FragColor = CRed;\n         else\n    #endif\n    {\n        // Reconstruct PM uv and PM subtexture id (see TileGeometry)\n        vec2 uvPM ;\n        uvPM.x             = vUv_WGS84.x;\n        float y            = vUv_PM;\n        int pmSubTextureIndex = int(floor(y));\n        uvPM.y             = y - float(pmSubTextureIndex);\n\n        #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n            float depth = gl_FragDepthEXT / gl_FragCoord.w;\n            float fogIntensity = 1.0/(exp(depth/distanceFog));\n        #else\n            float fogIntensity = 1.0;\n        #endif\n\n        vec4 diffuseColor = CWhite;\n        bool validTexture = false;\n\n        // TODO Optimisation des uv1 peuvent copier pas lignes!!\n        for (int layer = 0; layer < 8; layer++) {\n            if(layer == colorLayersCount) {\n                break;\n            }\n\n            if(visibility[layer]) {\n                vec4 paramsA = paramLayers[layer];\n\n                if(paramsA.w > 0.0) {\n                    bool projWGS84 = paramsA.y == 0.0;\n                    int textureIndex = int(paramsA.x) + (projWGS84 ? 0 : pmSubTextureIndex);\n\n                    /* if (0 <= textureIndex && textureIndex < loadedTexturesCount[1]) */ {\n\n                        // TODO: Try other OS before delete dead\n                        // get value in array, the index must be constant\n                        // Strangely it's work with function returning a global variable, doesn't work on Chrome Windows\n                        // vec4 layerColor = texture2D(dTextures_01[getTextureIndex()],  pitUV(projWGS84 ? vUv_WGS84 : uvPM,pitScale_L01[getTextureIndex()]));\n                        vec4 layerColor = colorAtIdUv(\n                            dTextures_01,\n                            offsetScale_L01,\n                            textureIndex,\n                            projWGS84 ? vUv_WGS84 : uvPM);\n\n                        if (layerColor.a > 0.0) {\n                            validTexture = true;\n                            float lum = 1.0;\n\n                            if(paramsA.z > 0.0) {\n                                float a = max(0.05,1.0 - length(layerColor.xyz-CWhite.xyz));\n                                if(paramsA.z > 2.0) {\n                                    a = (layerColor.r + layerColor.g + layerColor.b)*0.333333333;\n                                    layerColor*= layerColor*layerColor;\n                                }\n                                lum = 1.0-pow(abs(a),paramsA.z);\n                            }\n\n                            diffuseColor = mix( diffuseColor,layerColor, lum*paramsA.w * layerColor.a);\n\n                        }\n                    }\n                }\n    // #if defined(DEBUG)\n    //                 else {\n    //                     // Invalid texture -> error color\n    //                     diffuseColor = vec4(1.0, 0.0, 1.0, 1.0);\n    //                 }\n    // #endif\n\n            }\n        }\n\n        // No texture color\n        if (!validTexture) {\n\n            diffuseColor = CBlueOcean;\n        }\n\n        // Selected\n        if(selected) {\n            diffuseColor = mix(COrange, diffuseColor, 0.5 );\n        }\n\n        // Fog\n        gl_FragColor = mix(CFog, diffuseColor, fogIntensity);\n\n        if(lightingEnabled) {   // Add lighting\n            float light = min(2. * dot(vNormal, lightPosition),1.);\n            gl_FragColor.rgb *= light;\n        }\n    }\n}\n"

/***/ },
/* 329 */
/***/ function(module, exports) {

	module.exports = "vec2    pitUV(vec2 uvIn, vec3 pit)\n{\n    vec2  uv;\n    uv.x = uvIn.x* pit.z + pit.x;\n    uv.y = 1.0 -( (1.0 - uvIn.y) * pit.z + pit.y);\n\n    return uv;\n}\n\n"

/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _BasicMaterial = __webpack_require__(323);
	
	var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);
	
	var _GlobeDepthFS = __webpack_require__(331);
	
	var _GlobeDepthFS2 = _interopRequireDefault(_GlobeDepthFS);
	
	var _GlobeDepthVS = __webpack_require__(332);
	
	var _GlobeDepthVS2 = _interopRequireDefault(_GlobeDepthVS);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var GlobeDepthMaterial = function GlobeDepthMaterial(otherMaterial) {
	    _BasicMaterial2.default.call(this);
	
	    this.vertexShader = this.vertexShaderHeader + _GlobeDepthVS2.default;
	    this.fragmentShader = this.fragmentShaderHeader + _GlobeDepthFS2.default;
	
	    // Why connect directily uniform doesn't work?
	    // Verify attributes's shaders
	
	    this.uniforms.dTextures_00 = new THREE.Uniform(otherMaterial.textures[0]);
	    this.uniforms.texturesCount = new THREE.Uniform(otherMaterial.loadedTexturesCount[0]);
	    this.uniforms.offsetScale_L00 = new THREE.Uniform(otherMaterial.offsetScale[0]);
	};
	
	GlobeDepthMaterial.prototype = (0, _create2.default)(_BasicMaterial2.default.prototype);
	GlobeDepthMaterial.prototype.constructor = GlobeDepthMaterial;
	
	exports.default = GlobeDepthMaterial;

/***/ },
/* 331 */
/***/ function(module, exports) {

	module.exports = "const vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\nconst vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\nvec4 pack1K ( float depth ) {\n    depth /= 100000000.0;\n    vec4 res = mod( depth * bitSh * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n    res -= res.xxyz * bitMsk;\n    return res;\n}\n\nvoid main() {\n\n    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\t   gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n    #endif\n\n    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n        float z = 1.0/ gl_FragCoord.w ;\n        gl_FragColor = pack1K(z);\n    #else\n        float z = gl_FragCoord.z / gl_FragCoord.w;\n        gl_FragColor = pack1K(z);\n    #endif\n\n}\n"

/***/ },
/* 332 */
/***/ function(module, exports) {

	module.exports = "attribute vec2      uv_wgs84;\nattribute vec3      position;\nattribute vec3      normal;\n\nuniform sampler2D   dTextures_00[1];\nuniform vec3        offsetScale_L00[1];\nuniform int         texturesCount;\nuniform mat4        mVPMatRTC;\n\nvoid main() {\n\n        vec4 vPosition;\n\n        if(texturesCount > 0) {\n            vec2    vVv = vec2(uv_wgs84.x * offsetScale_L00[0].z + offsetScale_L00[0].x,(1.0 - uv_wgs84.y) * offsetScale_L00[0].z + offsetScale_L00[0].y);\n\n            float   dv  = max(texture2D( dTextures_00[0], vVv ).w, 0.);\n\n            vPosition   = vec4(position + normal * dv, 1.0 );\n        }\n        else {\n            vPosition = vec4(position, 1.0);\n        }\n\n        gl_Position = mVPMatRTC * vPosition;\n\n        #ifdef USE_LOGDEPTHBUF\n\n            gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n            #ifdef USE_LOGDEPTHBUF_EXT\n\n                vFragDepth = 1.0 + gl_Position.w;\n\n            #else\n\n                gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n            #endif\n\n        #endif\n\n}\n"

/***/ },
/* 333 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _BasicMaterial = __webpack_require__(323);
	
	var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);
	
	var _MatteIdsFS = __webpack_require__(334);
	
	var _MatteIdsFS2 = _interopRequireDefault(_MatteIdsFS);
	
	var _GlobeDepthVS = __webpack_require__(332);
	
	var _GlobeDepthVS2 = _interopRequireDefault(_GlobeDepthVS);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// This material renders the id in RGBA Color
	// Warning the RGBA contains id in float pack in 4 unsigned char
	
	/*
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */
	
	var MatteIdsMaterial = function MatteIdsMaterial(otherMaterial) {
	    _BasicMaterial2.default.call(this);
	
	    this.vertexShader = this.vertexShaderHeader + _GlobeDepthVS2.default;
	    this.fragmentShader = this.fragmentShaderHeader + _MatteIdsFS2.default;
	
	    this.uniforms.uuid.value = otherMaterial.uniforms.uuid.value;
	    this.uniforms.diffuseColor.value = new THREE.Color(Math.random() * 0xffffff); // .setHex( Math.random() * 0xffffff );
	
	    this.uniforms.dTextures_00 = new THREE.Uniform(otherMaterial.textures[0]);
	    this.uniforms.texturesCount = new THREE.Uniform(otherMaterial.loadedTexturesCount[0]);
	    this.uniforms.offsetScale_L00 = new THREE.Uniform(otherMaterial.offsetScale[0]);
	};
	
	MatteIdsMaterial.prototype = (0, _create2.default)(_BasicMaterial2.default.prototype);
	MatteIdsMaterial.prototype.constructor = MatteIdsMaterial;
	
	MatteIdsMaterial.prototype.setMatrixRTC = function setMatrixRTC(rtc) {
	    this.uniforms.mVPMatRTC.value = rtc;
	};
	
	exports.default = MatteIdsMaterial;

/***/ },
/* 334 */
/***/ function(module, exports) {

	module.exports = "uniform int  uuid;\nuniform vec3 diffuseColor;\n\nconst vec4 bitSh = vec4( 256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0 );\nconst vec4 bitMsk = vec4( 0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0 );\n\nvec4 pack1K ( float depth ) {\n\n    depth /= 10000.0;\n    vec4 res = mod( depth * bitSh * vec4( 255 ), vec4( 256 ) ) / vec4( 255 );\n    res -= res.xxyz * bitMsk;\n    return res;\n}\n\n\nvoid main() {\n\n    #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\t   gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n    #endif\n\n    gl_FragColor = pack1K(float(uuid));\n\n}\n"

/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _NodeMesh = __webpack_require__(281);
	
	var _NodeMesh2 = _interopRequireDefault(_NodeMesh);
	
	var _WMS_Provider = __webpack_require__(336);
	
	var _WMS_Provider2 = _interopRequireDefault(_WMS_Provider);
	
	var _CloudsFS = __webpack_require__(342);
	
	var _CloudsFS2 = _interopRequireDefault(_CloudsFS);
	
	var _CloudsVS = __webpack_require__(343);
	
	var _CloudsVS2 = _interopRequireDefault(_CloudsVS);
	
	var _Atmosphere = __webpack_require__(280);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */
	
	function Clouds() /* size*/{
	    _NodeMesh2.default.call(this);
	
	    this.providerWMS = new _WMS_Provider2.default({});
	    this.loader = new THREE.TextureLoader();
	    this.loader.crossOrigin = '';
	    this.live = false;
	    this.satelliteAnimation = true;
	    this.texture = null;
	    this.geometry = new THREE.SphereGeometry(6400000, 96, 96);
	
	    this.uniforms = {
	        diffuse: {
	            type: 't',
	            value: new THREE.Texture() },
	        time: {
	            type: 'f',
	            value: 0.0
	        },
	        lightingEnabled: { value: false },
	        lightPosition: {
	            type: 'v3',
	            value: _Atmosphere.LIGHTING_POSITION.clone().normalize()
	        }
	    };
	
	    this.material = new THREE.ShaderMaterial({
	
	        uniforms: this.uniforms,
	        vertexShader: _CloudsVS2.default,
	        fragmentShader: _CloudsFS2.default,
	        //   blending        : THREE.AdditiveBlending,
	        transparent: true,
	        wireframe: false
	
	    });
	
	    this.rotation.y += Math.PI;
	
	    // this.generate();
	
	    this.visible = false;
	}
	
	Clouds.prototype = (0, _create2.default)(_NodeMesh2.default.prototype);
	Clouds.prototype.constructor = Clouds;
	
	Clouds.prototype.generate = function generate(satelliteAnimation) {
	    var _this = this;
	
	    this.satelliteAnimation = satelliteAnimation;
	    if (!satelliteAnimation) {
	        this.live = true;
	        var coWMS = {
	            latBound: new THREE.Vector2(-85, 85),
	            longBound: new THREE.Vector2(-178, 178),
	            width: 2048,
	            height: 1024
	        };
	
	        var url = this.providerWMS.urlGlobalIR(coWMS, 0);
	        this.loader.load(url, function (texture) {
	            _this.material.blending = THREE.NormalBlending;
	            _this.material.uniforms.diffuse.value = texture;
	            _this.material.uniforms.diffuse.needsUpdate = true;
	            _this.animate();
	        });
	    } else {
	        this.live = true;
	        var video = document.getElementById('video');
	
	        this.texture = new THREE.VideoTexture(video);
	        this.texture.minFilter = THREE.LinearFilter;
	        this.texture.magFilter = THREE.LinearFilter;
	        this.texture.format = THREE.RGBFormat;
	
	        // this.material = new THREE.MeshBasicMaterial( { color: 0xffffff, map: this.texture});//, transparent : true, opacity:0.8});
	        this.material.blending = THREE.AdditiveBlending;
	        this.material.uniforms.diffuse.value = this.texture;
	        this.material.uniforms.diffuse.needsUpdate = true;
	        this.animate();
	    }
	};
	
	Clouds.prototype.animate = function animate() {
	    if (!this.satelliteAnimation) this.material.uniforms.time.value += 0.01;
	    requestAnimationFrame(this.animate.bind(this));
	};
	
	Clouds.prototype.setLightingOn = function setLightingOn(enable) {
	    this.material.uniforms.lightingEnabled.value = enable;
	};
	
	Clouds.prototype.updateLightingPos = function updateLightingPos(pos) {
	    this.material.uniforms.lightPosition.value = pos.clone().normalize();
	};
	
	exports.default = Clouds;

/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _promise = __webpack_require__(224);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Provider = __webpack_require__(337);
	
	var _Provider2 = _interopRequireDefault(_Provider);
	
	var _IoDriver_XBIL = __webpack_require__(338);
	
	var _IoDriver_XBIL2 = _interopRequireDefault(_IoDriver_XBIL);
	
	var _Fetcher = __webpack_require__(340);
	
	var _Fetcher2 = _interopRequireDefault(_Fetcher);
	
	var _Projection = __webpack_require__(302);
	
	var _Projection2 = _interopRequireDefault(_Projection);
	
	var _CacheRessource = __webpack_require__(341);
	
	var _CacheRessource2 = _interopRequireDefault(_CacheRessource);
	
	var _BoundingBox = __webpack_require__(319);
	
	var _BoundingBox2 = _interopRequireDefault(_BoundingBox);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Return url wmts MNT
	 * @param {String} options.url: service base url
	 * @param {String} options.layer: requested data layer
	 * @param {String} options.format: image format (default: format/jpeg)
	 * @returns {Object@call;create.url.url|String}
	 */
	function WMS_Provider() /* options*/{
	    // Constructor
	    _Provider2.default.call(this, new _IoDriver_XBIL2.default());
	    this.cache = (0, _CacheRessource2.default)();
	    this.projection = new _Projection2.default();
	
	    this.getTextureFloat = function getTextureFloat(buffer) {
	        // Start float to RGBA uint8
	        var texture = new THREE.DataTexture(buffer, 256, 256, THREE.AlphaFormat, THREE.FloatType);
	
	        texture.needsUpdate = true;
	        return texture;
	    };
	} /**
	   * Generated On: 2015-10-5
	   * Class: WMS_Provider
	   * Description: Provides data from a WMS stream
	   */
	
	WMS_Provider.prototype = (0, _create2.default)(_Provider2.default.prototype);
	
	WMS_Provider.prototype.constructor = WMS_Provider;
	
	WMS_Provider.prototype.url = function url(bbox, layer) {
	    var box = bbox.as(layer.projection);
	    var v = [box.west(), box.south(), box.east(), box.north()];
	    var bboxInUnit = layer.bbox_url === 'swne' ? v[1] + ',' + v[0] + ',' + v[3] + ',' + v[2] : v[0] + ',' + v[1] + ',' + v[2] + ',' + v[3];
	
	    return layer.customUrl.replace('%bbox', bboxInUnit);
	};
	
	WMS_Provider.prototype.preprocessDataLayer = function preprocessDataLayer(layer) {
	    if (!layer.name) {
	        throw new Error('layerName is required.');
	    }
	    if (!layer.bbox) {
	        throw new Error('bbox is required');
	    }
	
	    layer.bbox = new _BoundingBox2.default(layer.projection, layer.bbox[0], layer.bbox[1], layer.bbox[2], layer.bbox[3]);
	
	    layer.bbox_url = layer.bbox_url || 'swne';
	    layer.format = layer.options.mimetype || 'image/png';
	    layer.width = layer.heightMapWidth || 256;
	    layer.version = layer.version || '1.3.0';
	    layer.style = layer.style || '';
	    layer.transparent = layer.transparent || false;
	
	    layer.customUrl = layer.url + '?SERVICE=WMS&REQUEST=GetMap&LAYERS=' + layer.name + '&VERSION=' + layer.version + '&STYLES=' + layer.style + '&FORMAT=' + layer.format + '&TRANSPARENT=' + layer.transparent + '&BBOX=%bbox' + ('&CRS=' + layer.projection + '&WIDTH=' + layer.width + '&HEIGHT=' + layer.width);
	};
	
	WMS_Provider.prototype.tileInsideLimit = function tileInsideLimit(tile, layer) {
	    return tile.level > 2 && layer.bbox.intersect(tile.bbox);
	};
	
	WMS_Provider.prototype.getColorTexture = function getColorTexture(tile, layer, bbox, pitch) {
	    var _this = this;
	
	    if (!this.tileInsideLimit(tile, layer) || tile.material === null) {
	        return _promise2.default.resolve();
	    }
	
	    var url = this.url(bbox.as('EPSG:4326'), layer);
	
	    var result = { pitch: pitch };
	    result.texture = this.cache.getRessource(url);
	
	    if (result.texture !== undefined) {
	        return _promise2.default.resolve(result);
	    }
	
	    var _Fetcher$texture = _Fetcher2.default.texture(url),
	        texture = _Fetcher$texture.texture,
	        promise = _Fetcher$texture.promise;
	
	    result.texture = texture;
	
	    result.texture.generateMipmaps = false;
	    result.texture.magFilter = THREE.LinearFilter;
	    result.texture.minFilter = THREE.LinearFilter;
	    result.texture.anisotropy = 16;
	
	    return promise.then(function () {
	        _this.cache.addRessource(url, result.texture);
	        result.texture.needsUpdate = true;
	        return result;
	    });
	};
	
	WMS_Provider.prototype.getXbilTexture = function getXbilTexture(tile, layer, bbox, pitch) {
	    var _this2 = this;
	
	    var url = this.url(bbox, layer);
	
	    // TODO: this is not optimal: if called again before the IoDriver resolves, it'll load the XBIL again
	    var textureCache = this.cache.getRessource(url);
	
	    if (textureCache !== undefined) {
	        return _promise2.default.resolve({
	            pitch: pitch,
	            texture: textureCache.texture,
	            min: textureCache.min,
	            max: textureCache.max
	        });
	    }
	
	    // bug #74
	    // var limits = layer.tileMatrixSetLimits[coWMTS.zoom];
	    // if (!limits || !coWMTS.isInside(limits)) {
	    //     var texture = -1;
	    //     this.cache.addRessource(url, texture);
	    //     return Promise.resolve(texture);
	    // }
	    // -> bug #74
	    return this._IoDriver.read(url).then(function (result) {
	        result.texture = _this2.getTextureFloat(result.floatArray);
	        result.texture.generateMipmaps = false;
	        result.texture.magFilter = THREE.LinearFilter;
	        result.texture.minFilter = THREE.LinearFilter;
	        result.pitch = pitch;
	
	        // In RGBA elevation texture LinearFilter give some errors with nodata value.
	        // need to rewrite sample function in shader
	        _this2.cache.addRessource(url, result);
	
	        return result;
	    });
	};
	
	WMS_Provider.prototype.executeCommand = function executeCommand(command) {
	    var layer = command.layer;
	    var tile = command.requester;
	    var ancestor = command.ancestor;
	
	    var supportedFormats = {
	        'image/png': this.getColorTexture.bind(this),
	        'image/jpg': this.getColorTexture.bind(this),
	        'image/jpeg': this.getColorTexture.bind(this),
	        'image/x-bil;bits=32': this.getXbilTexture.bind(this)
	    };
	
	    var func = supportedFormats[layer.format];
	    if (func) {
	        var pitch = ancestor ? this.projection.WMS_WGS84Parent(tile.bbox, ancestor.bbox) : new THREE.Vector3(0, 0, 1);
	
	        var bbox = ancestor ? ancestor.bbox : tile.bbox;
	
	        return func(tile, layer, bbox, pitch);
	    } else {
	        return _promise2.default.reject(new Error('Unsupported mimetype ' + layer.format));
	    }
	};
	
	/**
	 * Returns a texture from the WMS stream with the specified bounding box
	 * @param {BoundingBox} bbox: requested bounding box
	 * @returns {WMS_Provider_L15.WMS_Provider.prototype@pro;_IoDriver@call;read@call;then}
	 */
	WMS_Provider.prototype.getTexture = function getTexture(bbox) {
	    var _this3 = this;
	
	    if (bbox === undefined) {
	        return _promise2.default.resolve(-2);
	    }
	
	    var url = this.url(bbox);
	
	    // TODO: this is not optimal: if called again before ioDriverImage resolves, it'll load the image again
	    var textureCache = this.cache.getRessource(url);
	
	    if (textureCache !== undefined) {
	        return _promise2.default.resolve(textureCache);
	    }
	    return this.ioDriverImage.read(url).then(function (image) {
	        var result = {};
	        result.texture = new THREE.Texture(image);
	        result.texture.generateMipmaps = false;
	        result.texture.magFilter = THREE.LinearFilter;
	        result.texture.minFilter = THREE.LinearFilter;
	        result.texture.anisotropy = 16;
	        _this3.cache.addRessource(url, result.texture);
	        return result.texture;
	    });
	};
	
	exports.default = WMS_Provider;

/***/ },
/* 337 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * Generated On: 2015-10-5
	 * Class: Provider
	 * Description: Generic class to serve data, local or distant, nodes and services.
	 */
	
	function Provider(iodriver) {
	  // Constructor
	
	  this.type = null;
	  this._IoDriver = iodriver;
	}
	
	Provider.prototype.constructor = Provider;
	
	/**
	 * @param url
	 */
	Provider.prototype.get = function get() /* url*/{
	  // TODO: Implement Me
	
	};
	
	/**
	 * preprocessLayer will be called each time a layer is added.
	 * Allows the Provider to perform precomputations on the layer
	 */
	Provider.prototype.preprocessLayer = function preprocessLayer() /* layer*/{};
	
	/**
	 * @param url
	 */
	Provider.prototype.getInCache = function getInCache() /* url*/{
	  // TODO: Implement Me
	
	};
	
	exports.default = Provider;

/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _IoDriver = __webpack_require__(339);
	
	var _IoDriver2 = _interopRequireDefault(_IoDriver);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var portableXBIL = function portableXBIL(buffer) {
	    this.floatArray = new Float32Array(buffer);
	    this.max = undefined;
	    this.min = undefined;
	    this.texture = null;
	}; /**
	    * Generated On: 2015-10-5
	    * Class: IoDriver_XBIL
	    */
	/* global Float32Array*/
	
	function IoDriver_XBIL() {
	    // Constructor
	    _IoDriver2.default.call(this);
	}
	
	IoDriver_XBIL.prototype = (0, _create2.default)(_IoDriver2.default.prototype);
	
	IoDriver_XBIL.prototype.constructor = IoDriver_XBIL;
	
	IoDriver_XBIL.prototype.computeMinMaxElevation = function computeMinMaxElevation(buffer, width, height, offsetScale) {
	    var min = 1000000;
	    var max = -1000000;
	
	    var sizeX = offsetScale ? Math.floor(offsetScale.z * width) : buffer.length;
	    var sizeY = offsetScale ? Math.floor(offsetScale.z * height) : 1;
	    var xs = offsetScale ? Math.floor(offsetScale.x * width) : 0;
	    var ys = offsetScale ? Math.floor(offsetScale.y * height) : 0;
	
	    var inc = offsetScale ? Math.max(Math.floor(sizeX / 8), 2) : 16;
	
	    for (var y = ys; y < ys + sizeY; y += inc) {
	        var pit = y * (width || 0);
	        for (var x = xs; x < xs + sizeX; x += inc) {
	            var val = buffer[pit + x];
	            if (val > -10.0 && val !== undefined) {
	                max = Math.max(max, val);
	                min = Math.min(min, val);
	            }
	        }
	    }
	
	    if (max === -1000000 || min === 1000000) {
	        return { min: undefined, max: undefined };
	    }
	    return { min: min, max: max };
	};
	
	IoDriver_XBIL.prototype.parseXBil = function parseXBil(buffer, url) {
	    if (!buffer) {
	        throw new Error('Error processing XBIL');
	    }
	
	    var result = new portableXBIL(buffer);
	
	    var elevation = this.computeMinMaxElevation(result.floatArray);
	
	    result.min = elevation.min;
	    result.max = elevation.max;
	
	    result.url = url;
	
	    return result;
	};
	
	IoDriver_XBIL.prototype.read = function read(url) {
	    var _this = this;
	
	    return fetch(url).then(function (response) {
	        if (response.status < 200 || response.status >= 300) {
	            throw new Error('Error loading ' + url + ': status ' + response.status);
	        }
	        return response.arrayBuffer();
	    }).then(function (buffer) {
	        return _this.parseXBil(buffer, url);
	    });
	};
	
	exports.default = IoDriver_XBIL;

/***/ },
/* 339 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	/**
	 * Generated On: 2015-10-5
	 * Class: IoDriver
	 * Description: Cette classe générique parcourt un fichier et retourne un object.
	 */
	
	function IoDriver() {
	  // Constructor
	
	
	}
	
	IoDriver.prototype.constructor = IoDriver;
	
	/**
	 * @param url
	 */
	IoDriver.prototype.load = function load() /* url*/{
	  // TODO: Implement Me
	
	};
	
	/**
	 * @param url
	 * @param inputObject {Object}
	 */
	IoDriver.prototype.write = function write() /* url, inputObject*/{
	  // TODO: Implement Me
	
	};
	
	/**
	 * @param url
	 */
	IoDriver.prototype.readAsync = function readAsync() /* url*/{
	  // TODO: Implement Me
	
	};
	
	/**
	 * @param url
	 */
	IoDriver.prototype.writeAsync = function writeAsync() /* url*/{
	  // TODO: Implement Me
	
	};
	
	exports.default = IoDriver;

/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _promise = __webpack_require__(224);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _three = __webpack_require__(241);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var textureLoader = new _three.TextureLoader();
	
	textureLoader.setCrossOrigin('anonymous');
	
	function checkResponse(response) {
	    if (response.status < 200 || response.status >= 300) {
	        var error = new Error('Error loading ' + response.url + ': status ' + response.status);
	        error.status = response.status;
	        throw error;
	    }
	}
	
	exports.default = {
	    json: function json(url) {
	        return fetch(url).then(function (response) {
	            checkResponse(response);
	            return response.json();
	        });
	    },
	    xml: function xml(url) {
	        return fetch(url).then(function (response) {
	            checkResponse(response);
	            return response.text();
	        }).then(function (text) {
	            return new window.DOMParser().parseFromString(text, 'text/xml');
	        });
	    },
	    texture: function texture(url) {
	        var res = void 0;
	        var rej = void 0;
	        var promise = new _promise2.default(function (resolve, reject) {
	            res = resolve;
	            rej = reject;
	        });
	
	        var texture = textureLoader.load(url, res, function () {}, rej);
	        return { texture: texture, promise: promise };
	    }
	};

/***/ },
/* 341 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	exports.default = function () {
	    instanceCache = instanceCache || new CacheRessource();
	    return instanceCache;
	};
	
	/**
	 * Generated On: 2015-10-5
	 * Class: CacheRessource
	 * Description: Cette classe singleton est un cache des ressources et services
	 */
	
	var instanceCache = null;
	
	function CacheRessource() {
	    // Constructor
	
	    this.cacheObjects = [];
	    this._maximumSize = null;
	}
	
	/**
	 * @param url
	 */
	CacheRessource.prototype.getRessource = function getRessource(url) {
	    return this.cacheObjects[url];
	};
	
	CacheRessource.prototype.addRessource = function addRessource(url, ressource) {
	    this.cacheObjects[url] = ressource;
	};
	
	/**
	 * @param id
	 */
	CacheRessource.prototype.getRessourceByID = function getRessourceByID() /* id*/{
	    // TODO: Implement Me
	
	};

/***/ },
/* 342 */
/***/ function(module, exports) {

	module.exports = "#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        //#extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\n\nuniform vec3 lightPosition;\nuniform sampler2D diffuse;\nuniform float time;\nuniform bool lightingEnabled;\nvarying vec2  vUv;\nvarying vec3 pos;\nvarying vec3 vNormal;\n\nfloat speed = 0.01;\nfloat noiseScale = 0.005;\n\nvoid main()\n{\n     #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n\n    #endif\n\n    // Correct Y knowing image is -85 85\n    vec2 vUv2 = vec2(vUv.x, clamp(vUv.y + (vUv.y - 0.5) * - 0.45, 0., 1.));\n    float coefDistCam = (length(cameraPosition.xyz) - 6400000.) / 500000.;\n\n    vec2 uvTime =  vUv2 + vec2( -0.1, .1 ) * mod(time * speed, 1.);\n    vec4 noiseColor = texture2D( diffuse, uvTime );\n    vec2 uvNoise = vUv2 + noiseScale * vUv2 * vec2(noiseColor.r, noiseColor.b );\n\n    vec4 color = texture2D( diffuse, uvNoise); //texture2D( diffuse, vUv2 );\n    float l = (max(color.r,max(color.g,color.b)) + min(color.r,min(color.g,color.b))) / 2.;\n    l *= l*1.5;\n    gl_FragColor =  0.25 +  (texture2D( diffuse, vUv2 ) * 0.95);\n    gl_FragColor.b += 0.1;\n\n    gl_FragColor.a = min(time * min( coefDistCam, 1.2) , 1.) * (vUv.y <= 0.75 ? l : (1. - ((vUv.y - 0.75) / 0.25)) * l  );\n\n    if(lightingEnabled){   // Add lighting\n        float light = min(2. * dot(vNormal, lightPosition),1.); //normalize(pos.xyz)\n        gl_FragColor.a *= -light;\n    }\n}"

/***/ },
/* 343 */
/***/ function(module, exports) {

	module.exports = "\n#ifdef USE_LOGDEPTHBUF\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\n\n#define EPSILON 1e-6\n\nuniform vec3  lightPosition;\nvarying vec2  vUv;\nvarying vec3 vNormal;\nvarying vec3 pos;\nvec3 normalES;\nvec3 normalCAMES;\n\n\nvoid main()\n{\n\n    vUv = uv;\n    vNormal = normal;\n    pos = position;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position,  1.0 );\n\n\n    #ifdef USE_LOGDEPTHBUF\n\n        gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\n        #ifdef USE_LOGDEPTHBUF_EXT\n\n            vFragDepth = 1.0 + gl_Position.w;\n\n        #else\n\n            gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\n        #endif\n\n    #endif\n\n}\n\n\n"

/***/ },
/* 344 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	/**
	 * Generated On: 2015-10-5
	 * Class: Layer
	 * Description: Le layer est une couche de données. Cette couche peut etre des images ou de l'information 3D. Les requètes de cette couche sont acheminées par une interfaceCommander.
	 *
	 */
	
	/**
	 *
	 * @param {type} Node
	 * @param {type} InterfaceCommander
	 * @param {type} Projection
	 * @param {type} NodeMesh
	 * @returns {Layer_L15.Layer}
	 */
	function LayersConfiguration() {
	    // source layers
	    this.geometryLayers = [];
	    this.colorLayers = [];
	    this.elevationLayers = [];
	    this.lightingLayers = [];
	
	    this.lightingLayers[0] = {
	        enable: false,
	        position: { x: -0.5, y: 0.0, z: 1.0 }
	    };
	
	    // layers state (visibility, opacity)
	    this.layersState = {};
	}
	
	LayersConfiguration.prototype.constructor = LayersConfiguration;
	
	function defaultState(seq) {
	    return {
	        // / shared attributes
	        // if true, stop fetching new data
	        frozen: false,
	        // / color layers only attributes
	        // is this layer displayed
	        visible: true,
	        // layer's opacity (0.0 = transparent)
	        opacity: 1.0,
	        // rendering order
	        sequence: seq || 0
	    };
	}
	
	LayersConfiguration.prototype.addElevationLayer = function addElevationLayer(layer) {
	    this.elevationLayers.push(layer);
	    this.layersState[layer.id] = defaultState();
	};
	
	LayersConfiguration.prototype.addColorLayer = function addColorLayer(layer) {
	    this.colorLayers.push(layer);
	    this.layersState[layer.id] = defaultState(this.colorLayers.length - 1);
	};
	
	LayersConfiguration.prototype.addGeometryLayer = function addGeometryLayer(layer) {
	    this.geometryLayers.push(layer);
	    this.layersState[layer.id] = defaultState();
	};
	
	LayersConfiguration.prototype.removeColorLayer = function removeColorLayer(id) {
	    if (this.layersState[id]) {
	        this.colorLayers = this.colorLayers.filter(function (l) {
	            return l.id != id;
	        });
	        delete this.layersState[id];
	        return true;
	    }
	    return false;
	};
	
	LayersConfiguration.prototype.getColorLayers = function getColorLayers() {
	    return this.colorLayers;
	};
	
	LayersConfiguration.prototype.getColorLayersId = function getColorLayersId() {
	    return this.colorLayers.map(function (l) {
	        return l.id;
	    });
	};
	
	LayersConfiguration.prototype.getGeometryLayers = function getGeometryLayers() {
	    return this.geometryLayers;
	};
	
	LayersConfiguration.prototype.getElevationLayers = function getElevationLayers() {
	    return this.elevationLayers;
	};
	
	LayersConfiguration.prototype.setLayerOpacity = function setLayerOpacity(id, opacity) {
	    if (this.layersState[id]) {
	        this.layersState[id].opacity = opacity;
	    }
	};
	
	LayersConfiguration.prototype.setLayerVisibility = function setLayerVisibility(id, visible) {
	    if (this.layersState[id]) {
	        this.layersState[id].visible = visible;
	    }
	};
	
	LayersConfiguration.prototype.isColorLayerVisible = function isColorLayerVisible(id) {
	    return this.layersState[id].visible;
	};
	
	LayersConfiguration.prototype.getColorLayerOpacity = function getColorLayerOpacity(id) {
	    return this.layersState[id].opacity;
	};
	
	LayersConfiguration.prototype.setLayerFreeze = function setLayerFreeze(id, frozen) {
	    if (this.layersState[id]) {
	        this.layersState[id].frozen = frozen;
	    }
	};
	
	LayersConfiguration.prototype.isLayerFrozen = function isLayerFrozen(id) {
	    return this.layersState[id].frozen;
	};
	
	LayersConfiguration.prototype.moveLayerToIndex = function moveLayerToIndex(id, newIndex) {
	    if (this.layersState[id]) {
	        var oldIndex = this.layersState[id].sequence;
	        for (var i in this.layersState) {
	            if (Object.prototype.hasOwnProperty.call(this.layersState, i)) {
	                var state = this.layersState[i];
	                if (state.sequence === newIndex) {
	                    state.sequence = oldIndex;
	                    this.layersState[id].sequence = newIndex;
	                    break;
	                }
	            }
	        }
	
	        this.colorLayers.splice(newIndex, 0, this.colorLayers.splice(oldIndex, 1)[0]);
	    }
	};
	
	LayersConfiguration.prototype.moveLayerDown = function moveLayerDown(id) {
	    if (this.layersState[id] && this.layersState[id].sequence > 0) {
	        this.moveLayerToIndex(id, this.layersState[id].sequence - 1);
	    }
	};
	
	LayersConfiguration.prototype.moveLayerUp = function moveLayerUp(id) {
	    if (this.layersState[id] && this.layersState[id].sequence < this.colorLayers.length - 1) {
	        this.moveLayerToIndex(id, this.layersState[id].sequence + 1);
	    }
	};
	
	LayersConfiguration.prototype.getColorLayersIdOrderedBySequence = function getColorLayersIdOrderedBySequence() {
	    var _this = this;
	
	    var seq = this.colorLayers.map(function (l) {
	        return l.id;
	    });
	    seq.sort(function (a, b) {
	        return _this.layersState[a].sequence - _this.layersState[b].sequence;
	    });
	    return seq;
	};
	
	exports.default = LayersConfiguration;

/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.SSE_SUBDIVISION_THRESHOLD = undefined;
	
	var _promise = __webpack_require__(224);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _RendererConstant = __webpack_require__(299);
	
	var _RendererConstant2 = _interopRequireDefault(_RendererConstant);
	
	var _LayerUpdateStrategy = __webpack_require__(346);
	
	var _LayeredMaterial = __webpack_require__(322);
	
	var _LayerUpdateState = __webpack_require__(347);
	
	var _LayerUpdateState2 = _interopRequireDefault(_LayerUpdateState);
	
	var _Scheduler = __webpack_require__(305);
	
	var _Coordinates = __webpack_require__(289);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var SSE_SUBDIVISION_THRESHOLD = exports.SSE_SUBDIVISION_THRESHOLD = 6.0; /**
	                                                                          * Generated On: 2015-10-5
	                                                                          * Class: NodeProcess
	                                                                          * Description: NodeProcess effectue une opération sur un Node.
	                                                                          */
	
	function NodeProcess(scene) {
	    // TODO: consider removing this.scene + replacing scene.notifyChange by an event
	    this.scene = scene;
	
	    this.vhMagnitudeSquared = 1.0;
	
	    this.r = (0, _Coordinates.ellipsoidSizes)();
	    this.cV = new THREE.Vector3();
	}
	
	/**
	 * @documentation: Apply backface culling on node, change visibility; return true if the node is visible
	 * @param {type} node   : node to cull
	 * @param {type} camera : camera for the culling
	 * @returns {Boolean}
	 */
	NodeProcess.prototype.backFaceCulling = function backFaceCulling(node, camera) {
	    var normal = camera.direction;
	    for (var n = 0; n < node.normals().length; n++) {
	        var dot = normal.dot(node.normals()[n]);
	        if (dot > 0) {
	            node.visible = true;
	            return true;
	        }
	    }
	
	    // ??node.visible = true;
	
	    return node.visible;
	};
	
	/**
	 * @documentation:
	 * @param  {type} node  : the node to try to cull
	 * @param  {type} camera: the camera used for culling
	 * @return {Boolean}      the culling attempt's result
	 */
	NodeProcess.prototype.isCulled = function isCulled(node, camera) {
	    return !(this.frustumCullingOBB(node, camera) && this.horizonCulling(node, camera));
	};
	
	/**
	 * @documentation: Cull node with frustrum
	 * @param {type} node   : node to cull
	 * @param {type} camera : camera for culling
	 * @returns {unresolved}
	 */
	NodeProcess.prototype.frustumCulling = function frustumCulling(node, camera) {
	    var frustum = camera.frustum;
	
	    return frustum.intersectsObject(node);
	};
	
	NodeProcess.prototype.checkNodeSSE = function checkNodeSSE(node) {
	    return SSE_SUBDIVISION_THRESHOLD < node.sse || node.level <= 2;
	};
	
	NodeProcess.prototype.subdivideNode = function subdivideNode(node, camera, params) {
	    var _this = this;
	
	    if (!node.pendingSubdivision && node.noChild()) {
	        var bboxes = params.tree.subdivideNode(node);
	        node.pendingSubdivision = true;
	
	        for (var i = 0; i < bboxes.length; i++) {
	            var quadtree = params.tree;
	            var command = {
	                /* mandatory */
	                requester: node,
	                layer: params.layersConfig.getGeometryLayers()[0],
	                priority: 10000,
	                /* specific params */
	                bbox: bboxes[i],
	                type: quadtree.type,
	                redraw: false
	            };
	
	            quadtree.scheduler.execute(command).then(function (child) {
	                var colorTextureCount = 0;
	                var paramMaterial = [];
	
	                // update wmts
	                var colorLayers = params.layersConfig.getColorLayers();
	
	                // update Imagery wmts
	                var _iteratorNormalCompletion = true;
	                var _didIteratorError = false;
	                var _iteratorError = undefined;
	
	                try {
	                    for (var _iterator = (0, _getIterator3.default)(colorLayers), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	                        var layer = _step.value;
	
	                        if (layer.tileInsideLimit(child, layer)) {
	                            var texturesCount = layer.tileTextureCount ? layer.tileTextureCount(child, layer) : 1;
	
	                            paramMaterial.push({
	                                tileMT: layer.options.tileMatrixSet,
	                                texturesCount: texturesCount,
	                                visible: params.layersConfig.isColorLayerVisible(layer.id),
	                                opacity: params.layersConfig.getColorLayerOpacity(layer.id),
	                                fx: layer.fx,
	                                idLayer: layer.id
	                            });
	
	                            colorTextureCount += texturesCount;
	                        }
	                    }
	
	                    // update Imagery wmts
	                } catch (err) {
	                    _didIteratorError = true;
	                    _iteratorError = err;
	                } finally {
	                    try {
	                        if (!_iteratorNormalCompletion && _iterator.return) {
	                            _iterator.return();
	                        }
	                    } finally {
	                        if (_didIteratorError) {
	                            throw _iteratorError;
	                        }
	                    }
	                }
	
	                var elevationLayers = params.layersConfig.getElevationLayers();
	                var canHaveElevation = false;
	                var _iteratorNormalCompletion2 = true;
	                var _didIteratorError2 = false;
	                var _iteratorError2 = undefined;
	
	                try {
	                    for (var _iterator2 = (0, _getIterator3.default)(elevationLayers), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                        var _layer = _step2.value;
	
	                        canHaveElevation |= _layer.tileInsideLimit(child, _layer);
	                    }
	                } catch (err) {
	                    _didIteratorError2 = true;
	                    _iteratorError2 = err;
	                } finally {
	                    try {
	                        if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                            _iterator2.return();
	                        }
	                    } finally {
	                        if (_didIteratorError2) {
	                            throw _iteratorError2;
	                        }
	                    }
	                }
	
	                child.setColorLayerParameters(paramMaterial, params.layersConfig.lightingLayers[0]);
	                child.texturesNeeded = colorTextureCount + canHaveElevation;
	
	                // request layers (imagery/elevation) update
	                _this.refineNodeLayers(child, camera, params);
	
	                if (false) {
	                    var geometryLayer = params.layersConfig.getGeometryLayers()[0];
	                    child.material.uniforms.showOutline = { value: geometryLayer.showOutline || false };
	                    child.material.wireframe = geometryLayer.wireframe || false;
	                }
	
	                return 0;
	            });
	        }
	    }
	};
	
	function refinementCommandCancellationFn(cmd) {
	    if (!cmd.requester.parent || !cmd.requester.material) {
	        return true;
	    }
	    // If node A is divided into A1, A2, A3, A4 and the user zooms fast enough on A2
	    // We might end up in a situation where:
	    //    - commands for A1, A3 or A4 are canceled because they're not visible anymore
	    //    - A2 A2 cannot be displayed because A won't be hidden until all of its
	    //      children are loaded.
	
	    // allow cancellation of the command if the node isn't visible anymore
	    return cmd.requester.parent.childrenLoaded() && cmd.requester.visible === false && cmd.requester.level >= 2;
	}
	
	NodeProcess.prototype.refineNodeLayers = function refineNodeLayers(node, camera, params) {
	    // Elevation and Imagery updates require separate functions (for now):
	    //   * a node can only have 1 elevation texture
	    //   * a node inherits elevation texture from parent, even if tileInsideLimit(node)
	    //     returns false
	    //   * elevation uses a grouping strategy (see TileMesh.levelElevation)
	    var layerFunctions = [updateNodeElevation, updateNodeImagery];
	
	    for (var typeLayer = 0; typeLayer < 2; typeLayer++) {
	        if (!node.loaded || node.isLayerTypeDownscaled(typeLayer)) {
	            layerFunctions[typeLayer](this.scene, params.tree, node, params.layersConfig, !node.loaded);
	        }
	    }
	};
	
	NodeProcess.prototype.hideNodeChildren = function hideNodeChildren(node) {
	    for (var i = 0; i < node.children.length; i++) {
	        var child = node.children[i];
	        child.setDisplayed(false);
	    }
	};
	
	/**
	 * Return an ancestor of node if it has a texture for this layer
	 * that matches its level (not downsampled).
	 * Returns null otherwise
	 */
	function findAncestorWithValidTextureForLayer(node, layerType, layer) {
	    var parent = node.parent;
	    if (parent && parent.material && parent.material.getLayerLevel) {
	        var level = parent.material.getLayerLevel(layerType, layer ? layer.id : undefined);
	        if (level >= 0) {
	            return node.getNodeAtLevel(level);
	        } else {
	            return findAncestorWithValidTextureForLayer(parent, layerType, layer);
	        }
	    } else {
	        return null;
	    }
	}
	
	function nodeCommandQueuePriorityFunction(node) {
	    // We know that 'node' is visible because commands can only be
	    // issued for visible nodes.
	    //
	    if (!node.loaded) {
	        // Prioritize lower-level (ie: bigger) non-loaded nodes
	        // because we need them to be loaded to be able
	        // to subdivide.
	        return 1000 - node.level;
	    } else if (node.isDisplayed()) {
	        // Then prefer displayed() node over non-displayed one
	        return 100;
	    } else {
	        return 10;
	    }
	}
	
	function updateNodeImagery(scene, quadtree, node, layersConfig, force) {
	    var promises = [];
	
	    var ts = Date.now();
	    var colorLayers = layersConfig.getColorLayers();
	
	    var _loop = function _loop(i) {
	        var layer = colorLayers[i];
	
	        // is tile covered by this layer?
	        // We test early (rather than after chooseNextLevelToFetch like elevation)
	        // because colorParams only exist for tiles where tileInsideLimit is true
	        // (see `subdivideNode`)
	        if (!layer.tileInsideLimit(node, layer)) {
	            return 'continue';
	        }
	
	        if (node.layerUpdateState[layer.id] === undefined) {
	            node.layerUpdateState[layer.id] = new _LayerUpdateState2.default();
	        }
	
	        if (!node.layerUpdateState[layer.id].canTryUpdate(ts)) {
	            return 'continue';
	        }
	
	        if (!force) {
	            // does this tile needs a new texture?
	            if (!node.isColorLayerDownscaled(layer.id)) {
	                return 'continue';
	            }
	            // is fetching data from this layer disabled?
	            if (!layersConfig.isColorLayerVisible(layer.id) || layersConfig.isLayerFrozen(layer.id)) {
	                return 'continue';
	            }
	        }
	
	        var ancestor = null;
	
	        var currentLevel = node.materials[_RendererConstant2.default.FINAL].getColorLayerLevelById(layer.id);
	        // if this tile has no texture (level == -1), try use one from an ancestor
	        if (currentLevel === -1) {
	            ancestor = findAncestorWithValidTextureForLayer(node, _LayeredMaterial.l_COLOR, layer);
	        } else {
	            targetLevel = (0, _LayerUpdateStrategy.chooseNextLevelToFetch)(layer.updateStrategy.type, node.level, currentLevel, layer.updateStrategy.options);
	
	            if (targetLevel === currentLevel) {
	                return 'continue';
	            }
	            if (targetLevel < node.level) {
	                ancestor = node.getNodeAtLevel(targetLevel);
	            }
	        }
	
	        node.layerUpdateState[layer.id].newTry();
	
	        var command = {
	            /* mandatory */
	            layer: layer,
	            requester: node,
	            priority: nodeCommandQueuePriorityFunction(node),
	            earlyDropFunction: refinementCommandCancellationFn,
	            /* specific params */
	            ancestor: ancestor,
	            /* redraw only if we're aren't using a texture from our parent */
	            redraw: ancestor == null
	        };
	
	        promises.push(quadtree.scheduler.execute(command).then(function (result) {
	            var level = ancestor ? ancestor.level : node.level;
	            // Assign .level to texture
	            if (Array.isArray(result)) {
	                for (var j = 0; j < result.length; j++) {
	                    result[j].texture.level = level;
	                }
	
	                node.setTexturesLayer(result, _LayeredMaterial.l_COLOR, layer.id);
	            } else if (result.texture) {
	                result.texture.level = level;
	                node.setTexturesLayer([result], _LayeredMaterial.l_COLOR, layer.id);
	            } else {
	                // TODO: null texture is probably an error
	                // Maybe add an error counter for the node/layer,
	                // and stop retrying after X attempts.
	            }
	
	            node.layerUpdateState[layer.id].success();
	
	            return result;
	        }, function (err) {
	            if (err instanceof _Scheduler.CancelledCommandException) {
	                node.layerUpdateState[layer.id].success();
	            } else {
	                node.layerUpdateState[layer.id].failure(Date.now());
	                scene.notifyChange(node.layerUpdateState[layer.id].secondsUntilNextTry() * 1000, false);
	            }
	        }));
	    };
	
	    for (var i = 0; i < colorLayers.length; i++) {
	        var targetLevel;
	
	        var _ret = _loop(i);
	
	        if (_ret === 'continue') continue;
	    }
	
	    _promise2.default.all(promises).then(function () {
	        if (node.parent) {
	            node.loadingCheck();
	        }
	    });
	}
	
	function updateNodeElevation(scene, quadtree, node, layersConfig, force) {
	    // Elevation is currently handled differently from color layers.
	    // This is caused by a LayeredMaterial limitation: only 1 elevation texture
	    // can be used (where a tile can have N textures x M layers)
	    var ts = Date.now();
	    var elevationLayers = layersConfig.getElevationLayers();
	    var bestLayer = null;
	    var ancestor = null;
	
	    var currentElevation = node.materials[_RendererConstant2.default.FINAL].getElevationLayerLevel();
	
	    // Step 0: currentElevevation is -1 BUT material.loadedTexturesCount[l_ELEVATION] is > 0
	    // means that we already tried and failed to download an elevation texture
	    if (currentElevation == -1 && node.material.loadedTexturesCount[_LayeredMaterial.l_ELEVATION] > 0) {
	        return;
	    }
	
	    // First step: if currentElevation is empty (level is -1), we *must* use the texture from
	    // one of our parent. This allows for smooth transitions when subdividing
	    // We don't care about layer status (isLayerFrozen) or limits (tileInsideLimit) because
	    // we simply want to use ancestor's texture with a different pitch
	    if (currentElevation == -1) {
	        ancestor = findAncestorWithValidTextureForLayer(node, _LayeredMaterial.l_ELEVATION);
	    }
	
	    // We don't have a texture to reuse. This can happen in two cases:
	    //   * no ancestor texture to use
	    //   * we already have 1 texture (so currentElevation >= 0)
	    // Again, LayeredMaterial's 1 elevation texture limitation forces us to `break` as soon
	    // as one layer can supply a texture for this node. So ordering of elevation layers is important.
	    // Ordering way of loop is important to find the best layer with tileInsideLimit
	    for (var i = elevationLayers.length - 1; i >= 0; i--) {
	        var _layer2 = elevationLayers[i];
	
	        if (!_layer2.tileInsideLimit(node, _layer2)) {
	            continue;
	        }
	
	        if (layersConfig.isLayerFrozen(_layer2.id) && !force) {
	            continue;
	        }
	
	        if (node.layerUpdateState[_layer2.id] === undefined) {
	            node.layerUpdateState[_layer2.id] = new _LayerUpdateState2.default();
	        }
	
	        if (!node.layerUpdateState[_layer2.id].canTryUpdate(ts)) {
	            // If we'd use continue, we could have 2 parallel elevation layers updating
	            // at the same time. So we're forced to break here.
	            // TODO: if the first layer chosen ends up stalled in error we'll never try
	            // the second one...
	            break;
	        }
	
	        var targetLevel = (0, _LayerUpdateStrategy.chooseNextLevelToFetch)(_layer2.updateStrategy.type, node.level, currentElevation, _layer2.updateStrategy.options);
	
	        if (targetLevel <= currentElevation) {
	            continue;
	        }
	
	        // ancestor is not enough: we also need to know from which layer we're going to request the elevation texture (see how this is done for color texture).
	        // Right now this is done in the `for` loop below but this is hacky because there's no real warranty that bestLayer and ancestor really match.
	        // FIXME: we need to be able to set both ancestor and bestLayer at the same time
	        if (ancestor === null) {
	            ancestor = node.getNodeAtLevel(targetLevel);
	        }
	
	        bestLayer = _layer2;
	        break;
	    }
	
	    // If we found a usable layer, perform a query
	    if (bestLayer !== null) {
	        node.layerUpdateState[bestLayer.id].newTry();
	
	        var command = {
	            /* mandatory */
	            layer: bestLayer,
	            requester: node,
	            priority: nodeCommandQueuePriorityFunction(node),
	            earlyDropFunction: refinementCommandCancellationFn,
	            /* specific params */
	            ancestor: ancestor,
	            /* redraw only if we're aren't using a texture from our parent */
	            redraw: ancestor == null
	        };
	
	        quadtree.scheduler.execute(command).then(function (terrain) {
	            node.layerUpdateState[bestLayer.id].success();
	
	            if (node.material === null) {
	                return;
	            }
	
	            if (terrain.texture) {
	                terrain.texture.level = (ancestor || node).level;
	            }
	
	            if (terrain.max === undefined) {
	                terrain.min = (ancestor || node).bbox.bottom();
	                terrain.max = (ancestor || node).bbox.top();
	            }
	
	            node.setTextureElevation(terrain);
	        }, function (err) {
	            if (err instanceof _Scheduler.CancelledCommandException) {
	                node.layerUpdateState[bestLayer.id].success();
	            } else {
	                node.layerUpdateState[bestLayer.id].failure(Date.now());
	                scene.notifyChange(node.layerUpdateState[bestLayer.id].secondsUntilNextTry() * 1000, false);
	            }
	        });
	    }
	}
	
	NodeProcess.prototype.processNode = function processNode(node, camera, params) {
	    node.setDisplayed(false);
	    node.setSelected(false);
	
	    var isVisible = !this.isCulled(node, camera);
	
	    node.setVisibility(isVisible);
	
	    if (isVisible) {
	        // update node's sse value
	        node.sse = camera.computeNodeSSE(node);
	
	        var sse = this.checkNodeSSE(node);
	        var hidden = sse && node.childrenLoaded();
	
	        if (sse && params.tree.canSubdivideNode(node)) {
	            // big screen space error: subdivide node, display children if possible
	            this.subdivideNode(node, camera, params);
	        } else if (!hidden) {
	            // node is going to be displayed (either because !sse or because children aren't ready),
	            // so try to refine its textures
	            this.refineNodeLayers(node, camera, params);
	        }
	
	        // display children if possible
	        node.setDisplayed(!hidden);
	        // todo uniformsProcess
	    }
	
	    return isVisible;
	};
	
	/**
	 * @documentation: Cull node with frustrum and oriented bounding box of node
	 * @param {type} node
	 * @param {type} camera
	 * @returns {NodeProcess_L7.NodeProcess.prototype.frustumCullingOBB.node@pro;camera@call;getFrustum@call;intersectsBox}
	 */
	
	var frustum = new THREE.Frustum();
	var obbViewMatrix = new THREE.Matrix4();
	
	NodeProcess.prototype.frustumCullingOBB = function frustumCullingOBB(node, camera) {
	    // Move camera in OBB local space
	    obbViewMatrix.multiplyMatrices(camera.viewMatrix, node.OBB().matrixWorld);
	
	    frustum.setFromMatrix(obbViewMatrix);
	
	    return frustum.intersectsBox(node.OBB().box3D);
	};
	
	/**
	 * @documentation: Pre-computing for the upcoming processes
	 * @param  {type} camera
	 */
	NodeProcess.prototype.prepare = function prepare(camera) {
	    this.preHorizonCulling(camera);
	};
	
	/**
	 * @documentation:pre calcul for horizon culling
	 * @param {type} camera
	 * @returns {undefined}
	 */
	NodeProcess.prototype.preHorizonCulling = function preHorizonCulling(camera) {
	    this.cV.copy(camera.position()).divide(this.r);
	    this.vhMagnitudeSquared = this.cV.lengthSq() - 1.0;
	};
	
	/**
	 * @documentation: return true if point is occuled by horizon
	 * @param {type} pt
	 * @returns {Boolean}
	 */
	NodeProcess.prototype.pointHorizonCulling = function pointHorizonCulling(pt) {
	    var vT = pt.divide(this.r).sub(this.cV);
	
	    var vtMagnitudeSquared = vT.lengthSq();
	
	    var dot = -vT.dot(this.cV);
	
	    var isOccluded = this.vhMagnitudeSquared < dot && this.vhMagnitudeSquared < dot * dot / vtMagnitudeSquared;
	
	    return isOccluded;
	};
	
	/**
	 * @documentation: cull node with horizon
	 * @param {type} node
	 * @returns {Boolean}
	 */
	var point = new THREE.Vector3();
	
	NodeProcess.prototype.horizonCulling = function horizonCulling(node) {
	    // horizonCulling Oriented bounding box
	    var points = node.OBB().pointsWorld;
	    var isVisible = false;
	
	    for (var i = 0, max = points.length; i < max; i++) {
	        point = points[i].clone();
	        if (!this.pointHorizonCulling(point)) {
	            isVisible = true;
	            break;
	        }
	    }
	
	    return isVisible;
	};
	
	exports.default = NodeProcess;

/***/ },
/* 346 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.chooseNextLevelToFetch = chooseNextLevelToFetch;
	/**
	 * This modules implements various layer update strategies.
	 *
	 * Default strategy is STRATEGY_MIN_NETWORK_TRAFFIC which aims
	 * to reduce the amount of network traffic.
	 */
	
	var STRATEGY_MIN_NETWORK_TRAFFIC = exports.STRATEGY_MIN_NETWORK_TRAFFIC = 0;
	var STRATEGY_GROUP = exports.STRATEGY_GROUP = 1;
	var STRATEGY_PROGRESSIVE = exports.STRATEGY_PROGRESSIVE = 2;
	var STRATEGY_DICHOTOMY = exports.STRATEGY_DICHOTOMY = 3;
	
	function _minimizeNetworkTraffic(nodeLevel /* , currentLevel, options */) {
	    return nodeLevel;
	}
	
	// Maps nodeLevel to groups defined in layer's options
	// eg with groups = [3, 7, 12]:
	//     * nodeLevel = 2 -> 3
	//     * nodeLevel = 4 -> 3
	//     * nodeLevel = 7 -> 7
	//     * nodeLevel = 15 -> 12
	function _group(nodeLevel, currentLevel, options) {
	    var f = options.groups.filter(function (val) {
	        return val <= nodeLevel;
	    });
	    return f.length ? f[f.length - 1] : options.groups[0];
	}
	
	function _progressive(nodeLevel, currentLevel, options) {
	    return Math.min(nodeLevel, currentLevel + (options.increment || 1));
	}
	
	// Load textures at mid-point between current level and node's level.
	// This produces smoother transitions and a single fetch updates multiple
	// tiles thanks to caching.
	function _dichotomy(nodeLevel, currentLevel /* , options */) {
	    return Math.min(nodeLevel, Math.ceil((currentLevel + nodeLevel) / 2));
	}
	
	function chooseNextLevelToFetch(strategy, nodeLevel, currentLevel, options) {
	    switch (strategy) {
	        case STRATEGY_GROUP:
	            return _group(nodeLevel, currentLevel, options);
	        case STRATEGY_PROGRESSIVE:
	            return _progressive(nodeLevel, currentLevel, options);
	        case STRATEGY_DICHOTOMY:
	            return _dichotomy(nodeLevel, currentLevel, options);
	        // default strategy
	        case STRATEGY_MIN_NETWORK_TRAFFIC:
	        default:
	            return _minimizeNetworkTraffic(nodeLevel, currentLevel, options);
	    }
	}

/***/ },
/* 347 */
/***/ function(module, exports) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var UPDATE_STATE = {
	    IDLE: 0,
	    PENDING: 1,
	    ERROR: 2
	};
	var PAUSE_BETWEEN_ERRORS = [1.0, 3.0, 7.0, 60.0];
	
	/**
	 * LayerUpdateState is the update state of a layer, for a given object (e.g tile).
	 * It stores information to allow smart update decisions, and especially network
	 * error handling.
	 */
	function LayerUpdateState() {
	    this.state = UPDATE_STATE.IDLE;
	    this.lastErrorTimestamp = 0;
	    this.errorCount = 0;
	}
	
	LayerUpdateState.prototype.canTryUpdate = function canTryUpdate(timestamp) {
	    switch (this.state) {
	        case UPDATE_STATE.IDLE:
	            {
	                return true;
	            }
	        case UPDATE_STATE.PENDING:
	            {
	                return false;
	            }
	        case UPDATE_STATE.ERROR:
	        default:
	            {
	                var errorDuration = this.secondsUntilNextTry() * 1000;
	                return errorDuration <= timestamp - this.lastErrorTimestamp;
	            }
	    }
	};
	
	LayerUpdateState.prototype.secondsUntilNextTry = function secondsUntilNextTry() {
	    if (this.state !== UPDATE_STATE.ERROR) {
	        return 0;
	    }
	    var idx = Math.max(0, Math.min(this.errorCount, PAUSE_BETWEEN_ERRORS.length) - 1);
	
	    return PAUSE_BETWEEN_ERRORS[idx];
	};
	
	LayerUpdateState.prototype.newTry = function newTry() {
	    this.state = UPDATE_STATE.PENDING;
	};
	
	LayerUpdateState.prototype.success = function success() {
	    this.lastErrorTimestamp = 0;
	    this.state = UPDATE_STATE.IDLE;
	};
	
	LayerUpdateState.prototype.failure = function failure(timestamp) {
	    this.lastErrorTimestamp = timestamp;
	    this.state = UPDATE_STATE.ERROR;
	    this.errorCount++;
	};
	
	exports.default = LayerUpdateState;

/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function BrowseTree(engine) {
	    // Constructor
	
	    this.oneNode = 0;
	    this.gfxEngine = engine;
	    this.nodeProcess = undefined;
	    this.tree = undefined;
	    this.fogDistance = 1000000000.0;
	    this.mfogDistance = 1000000000.0;
	    this.selectedNodeId = -1;
	    this.selectedNode = null;
	
	    this.selectNode = function selectNode(node) {
	        this._selectNode(node);
	    };
	} /**
	   * Generated On: 2015-10-5
	   * Class: BrowseTree
	   * Description: BrowseTree parcourt un arbre de Node. Lors du parcours un ou plusieur NodeProcess peut etre appliqué sur certains Node.
	   */
	
	BrowseTree.prototype.addNodeProcess = function addNodeProcess(nodeProcess) {
	    this.nodeProcess = nodeProcess;
	};
	
	BrowseTree.prototype.NodeProcess = function NodeProcess() {
	    return this.nodeProcess;
	};
	
	BrowseTree.prototype.uniformsProcess = function getUniformsProcessFn() {
	    var positionWorld = new THREE.Vector3();
	
	    return function uniformsProcess(node, camera) {
	        node.setMatrixRTC(this.gfxEngine.getRTCMatrixFromCenter(positionWorld.setFromMatrixPosition(node.matrixWorld), camera));
	        node.setFog(this.fogDistance);
	
	        this.selectNode(node);
	    };
	}();
	
	BrowseTree.prototype._selectNode = function _selectNode(node) {
	    if (node.id === this.selectedNodeId) {
	        node.setSelected(node.visible && node.material.visible);
	        if (this.selectedNode !== node) {
	            this.selectedNode = node;
	            // eslint-disable-next-line no-console
	            console.info(node);
	        }
	    }
	};
	
	function applyFunctionToChildren(func, node) {
	    for (var i = 0; i < node.children.length; i++) {
	        func(node.children[i]);
	    }
	}
	
	/**
	 * @documentation: Initiate traverse tree
	 * @param {type} tree       : tree
	 * @param {type} camera     : current camera
	 * @param {type} process    : the process to apply to each node
	 * @param {type} optional   : optional process
	 * @returns {undefined}
	 */
	BrowseTree.prototype.browse = function browse(tree, camera, process, layersConfig) {
	    var _this = this;
	
	    this.tree = tree;
	
	    this.fogDistance = this.mfogDistance * Math.pow((camera.getDistanceFromOrigin() - 6300000) / 25000000, 1.6);
	
	    process.prepare(camera);
	
	    var params = {
	        tree: this.tree,
	        layersConfig: layersConfig
	    };
	
	    var rootNode = tree.children[0];
	    applyFunctionToChildren(function (n) {
	        return _this._browseDisplayableNode(n, camera, process, params);
	    }, rootNode);
	};
	
	/**
	 * @documentation: Recursive traverse tree
	 * @param {type} node       : current node
	 * @param {type} camera     : current camera
	 * @param {type} process    : the process to apply to each node
	 * @param {type} optional   : optional process
	 * @returns {undefined}
	 */
	BrowseTree.prototype._browseDisplayableNode = function _browseDisplayableNode(node, camera, process, params) {
	    var _this2 = this;
	
	    if (node.parent.isVisible() && process.processNode(node, camera, params)) {
	        if (node.isDisplayed()) {
	            this.uniformsProcess(node, camera);
	            applyFunctionToChildren(function (n) {
	                return _this2._browseNonDisplayableNode(n, node.level + 2, process, camera, params);
	            }, node);
	        } else {
	            applyFunctionToChildren(function (n) {
	                return _this2._browseDisplayableNode(n, camera, process, params);
	            }, node);
	        }
	    } else {
	        node.setVisibility(false);
	        node.setDisplayed(false);
	
	        applyFunctionToChildren(function (n) {
	            return _this2._browseNonDisplayableNode(n, node.level + 2, process, camera, params);
	        }, node);
	    }
	};
	
	BrowseTree.prototype._browseNonDisplayableNode = function _browseNonDisplayableNode(node, level, process, camera, params) {
	    // update node's sse value
	    node.sse = camera.computeNodeSSE(node);
	    node.setDisplayed(false);
	
	    var sse = process.checkNodeSSE(node);
	    if (!node.loaded) {
	        // Make sure this node is not stuck in a !loaded state
	        // TODO: we could be smarter and do this only for visible tiles for instance
	        // but we need to be careful due to the number of possible states for a tile (pendingSubdivision,
	        // loaded, disposed etc). Also: once this is fixed we should be able to simplify the commandC
	        // cancellation function to something like: `return !node.isVisible()`
	        process.refineNodeLayers(node, camera, params);
	    }
	
	    // recursively clean children
	    if (node.children.length > 0) {
	        var disposableChildrenCount = 0;
	        for (var i = 0; i < node.children.length; i++) {
	            if (this._browseNonDisplayableNode(node.children[i], level, process, camera, params)) {
	                disposableChildrenCount++;
	            }
	        }
	
	        // sse means we need to subdivide -> don't try to clean
	        if (disposableChildrenCount === node.children.length && !sse) {
	            // remove children and update visibility
	            node.disposeChildren();
	            node.setDisplayed(!node.parent.isDisplayed() && node.isVisible());
	        } else {
	            return false;
	        }
	    }
	
	    var cleanable = node.level >= level && !sse;
	
	    return cleanable;
	};
	
	/*
	 * @documentation: Recursive traverse tree to update a material specific uniform
	 * @returns {undefined}
	 */
	BrowseTree.prototype.updateMaterialUniform = function updateMaterialUniform(uniformName, value) {
	    for (var a = 0; a < this.tree.children.length; ++a) {
	        var root = this.tree.children[a];
	        for (var c = 0; c < root.children.length; c++) {
	            var node = root.children[c];
	            var lookMaterial = function lookMaterial(obj) {
	                obj.material.uniforms[uniformName].value = value;
	            };
	
	            if (node.traverse) {
	                node.traverse(lookMaterial);
	            }
	        }
	    }
	};
	
	BrowseTree.prototype.updateLayer = function updateLayer(layer, camera) {
	    var _this3 = this;
	
	    if (!layer.visible) {
	        return;
	    }
	
	    var root = layer.children[0];
	
	    var _loop = function _loop(c) {
	        var node = root.children[c];
	
	        cRTC = function getCRtcFn() {
	            var mRTC = this.gfxEngine.getRTCMatrixFromNode(node, camera);
	
	            return function cRTC(obj) {
	                if (obj.setMatrixRTC) {
	                    obj.setMatrixRTC(mRTC);
	                }
	            };
	        }.bind(_this3)();
	
	        node.traverse(cRTC);
	    };
	
	    for (var c = 0; c < root.children.length; c++) {
	        var cRTC;
	
	        _loop(c);
	    }
	};
	
	BrowseTree.prototype.updateMobileMappingLayer = function updateMobileMappingLayer(layer, camera) {
	    if (!layer.visible) {
	        return;
	    }
	
	    var root = layer.children[0];
	
	    for (var c = 0; c < root.children.length; c++) {
	        var node = root.children[c];
	        node.setMatrixRTC(this.gfxEngine.getRTCMatrixFromCenter(node.absoluteCenter, camera));
	    }
	};
	
	BrowseTree.prototype.updateQuadtree = function updateQuadtree(layer, layersConfiguration, camera) {
	    var quadtree = layer.node.tiles;
	
	    this.browse(quadtree, camera, layer.process, layersConfiguration);
	};
	
	exports.default = BrowseTree;

/***/ },
/* 349 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _Coordinates = __webpack_require__(289);
	
	var _Coordinates2 = _interopRequireDefault(_Coordinates);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var CoordStars = {
	    getSunPosition: function getSunPosition() {
	        var m = Math;
	        var PI = m.PI;
	        var sin = m.sin;
	        var cos = m.cos;
	        var tan = m.tan;
	        var asin = m.asin;
	        var atan = m.atan2;
	
	        var rad = PI / 180;
	        var dayMs = 1000 * 60 * 60 * 24;
	        var J1970 = 2440588;
	        var J2000 = 2451545;
	        var e = rad * 23.4397; // obliquity of the Earth
	
	        function toJulian(date) {
	            return date.valueOf() / dayMs - 0.5 + J1970;
	        }
	
	        function toDays(date) {
	            return toJulian(date) - J2000;
	        }
	
	        function getRightAscension(l, b) {
	            return atan(sin(l) * cos(e) - tan(b) * sin(e), cos(l));
	        }
	
	        function getDeclination(l, b) {
	            return asin(sin(b) * cos(e) + cos(b) * sin(e) * sin(l));
	        }
	
	        function getAzimuth(H, phi, dec) {
	            return atan(sin(H), cos(H) * sin(phi) - tan(dec) * cos(phi));
	        }
	
	        function getAltitude(H, phi, dec) {
	            return asin(sin(phi) * sin(dec) + cos(phi) * cos(dec) * cos(H));
	        }
	
	        function getSiderealTime(d, lw) {
	            return rad * (280.16 + 360.9856235 * d) - lw;
	        }
	
	        function getSolarMeanAnomaly(d) {
	            return rad * (357.5291 + 0.98560028 * d);
	        }
	
	        function getEquationOfCenter(M) {
	            return rad * (1.9148 * sin(M) + 0.0200 * sin(2 * M) + 0.0003 * sin(3 * M));
	        }
	
	        function getEclipticLongitude(M, C) {
	            var P = rad * 102.9372; // perihelion of the Earth
	            return M + C + P + PI;
	        }
	
	        return function getSunPosition(date, lat, lon) {
	            var lw = rad * -lon;
	            var phi = rad * lat;
	            var d = toDays(date);
	            var M = getSolarMeanAnomaly(d);
	            var C = getEquationOfCenter(M);
	            var L = getEclipticLongitude(M, C);
	            var D = getDeclination(L, 0);
	            var A = getRightAscension(L, 0);
	            var t = getSiderealTime(d, lw);
	            var H = t - A;
	
	            return {
	                EclipticLongitude: L,
	                declinaison: D,
	                ascension: A,
	                H: H,
	                SiderealTime: t,
	                altitude: getAltitude(H, phi, D),
	                azimuth: getAzimuth(H, phi, D) + PI / 2 };
	        };
	    },
	
	
	    // Return scene coordinate ({x,y,z}) of sun
	    getSunPositionInScene: function getSunPositionInScene(date, lat, lon) {
	        var sun = CoordStars.getSunPosition()(date, lat, lon);
	        var dayMilliSec = 24 * 3600000;
	        var longitude = sun.ascension + date % dayMilliSec / dayMilliSec * -360 + 180; // cause midday
	        var coSunCarto = new _Coordinates2.default('EPSG:4326', longitude, lat, 50000000).as('EPSG:4978').xyz();
	
	        return coSunCarto;
	    }
	}; /**
	    * Generated On: 2016-02-25
	    * Class: CoordStars
	    * Description: get coord of stars like earth...
	    */
	exports.default = CoordStars;

/***/ },
/* 350 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Layer = __webpack_require__(301);
	
	var _Layer2 = _interopRequireDefault(_Layer);
	
	var _c3DEngine = __webpack_require__(240);
	
	var _c3DEngine2 = _interopRequireDefault(_c3DEngine);
	
	var _Projection = __webpack_require__(302);
	
	var _Projection2 = _interopRequireDefault(_Projection);
	
	var _PanoramicProvider = __webpack_require__(351);
	
	var _PanoramicProvider2 = _interopRequireDefault(_PanoramicProvider);
	
	var _Coordinates = __webpack_require__(289);
	
	var _Coordinates2 = _interopRequireDefault(_Coordinates);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Layer for MobileMapping data. Up to now it is used for panoramic imagery
	 * It uses a Panoramic Provider
	 * @returns {MobileMappingLayer_L18.MobileMappingLayer}
	 */
	/**
	 * Generated On: 2016-10-5
	 * Class: MobileMappingLayer
	 * Description: Layer for mobileMappingData
	 */
	
	function MobileMappingLayer() {
	    var _this = this;
	
	    // Constructor
	
	    _Layer2.default.call(this);
	
	    this.panoramicMesh = null;
	    this.name = 'MobileMappingLayer';
	    this.mainMesh = new THREE.Object3D();
	    this.add(this.mainMesh);
	
	    this.panoramicProvider = null;
	
	    this.domElement = document;
	    // this.domElement.addEventListener('mousedown', onMouseDown, false).bind(this);
	    window.addEventListener('mousedown', function (event) {
	        if (event.button === 2) {
	            _this.updateData();
	        }
	    }, false);
	}
	
	MobileMappingLayer.prototype = (0, _create2.default)(_Layer2.default.prototype);
	MobileMappingLayer.prototype.constructor = MobileMappingLayer;
	
	MobileMappingLayer.prototype.initiatePanoramic = function initiatePanoramic(imageOpt) {
	    var _this2 = this;
	
	    var imagesOptions = imageOpt || this.getDefaultOptions();
	    // console.log(this.defaultOptions);
	    // Create and add the MobileMappingLayer with Panoramic imagery
	    this.panoramicProvider = new _PanoramicProvider2.default(imagesOptions);
	
	    this.panoramicProvider.getTextureProjectiveMesh(2.3348138, 48.8506030, 1000).then(function (projMesh) {
	        _this2.panoramicMesh = projMesh;
	        _this2.mainMesh.add(_this2.panoramicMesh);
	        (0, _c3DEngine2.default)().renderScene();
	
	        // Move camera to panoramic center
	        var panoInfo = _this2.panoramicProvider.panoInfo;
	        var posPanoWGS84 = new _Coordinates2.default('EPSG:4326', panoInfo.longitude, panoInfo.latitude, panoInfo.altitude);
	        var posPanoCartesian = posPanoWGS84.as('EPSG:4978').xyz();
	
	        _this2.moveCameraToScanPosition(posPanoCartesian);
	    });
	};
	
	MobileMappingLayer.prototype.updateData = function updateData() {
	    var _this3 = this;
	
	    var pos = (0, _c3DEngine2.default)().controls.getPickingPosition();
	    var posWGS84 = new _Projection2.default().cartesianToGeo(pos);
	    var lonDeg = posWGS84.longitude / Math.PI * 180;
	    var latDeg = posWGS84.latitude / Math.PI * 180;
	
	    // console.log("position clicked: ",pos, "wgs, longitude:", posWGS84.longitude/ Math.PI * 180, "   '",posWGS84.latitude/ Math.PI * 180, "  alti:", posWGS84.altitude);
	
	    this.panoramicProvider.updateMaterialImages(lonDeg, latDeg, 1000).then(function (panoInfo) {
	        // Move camera to new pos
	        //   var panoInfo = panoInfo; //this.panoramicProvider.panoInfo;
	        var posPanoWGS84 = new _Coordinates2.default('EPSG:4326', panoInfo.longitude, panoInfo.latitude, panoInfo.altitude);
	        var posPanoCartesian = posPanoWGS84.as('EPSG:4978').xyz();
	
	        _this3.moveCameraToScanPosition(posPanoCartesian);
	    });
	};
	
	MobileMappingLayer.prototype.moveCameraToScanPosition = function moveCameraToScanPosition(pos) {
	    var _this4 = this;
	
	    var speedMove = 0.1;
	    var currentPos = (0, _c3DEngine2.default)().camera.camera3D.position.clone();
	
	    var posx = currentPos.x + (pos.x - currentPos.x) * speedMove;
	    var posy = currentPos.y + (pos.y - currentPos.y) * speedMove;
	    var posz = currentPos.z + (pos.z - currentPos.z) * speedMove;
	
	    (0, _c3DEngine2.default)().camera.camera3D.position.set(posx, posy, posz);
	    (0, _c3DEngine2.default)().update();
	    var vCurrent = new THREE.Vector3(posx, posy, posz);
	    // requestAnimSelectionAlpha(OrientedImages_Provider.smoothTransition(pos,new THREE.Vector3(posx, posy, posz)));
	
	    if (vCurrent.distanceTo(pos) > 0.2) {
	        setTimeout(function () {
	            _this4.moveCameraToScanPosition(pos, vCurrent);
	        }, 20);
	    }
	};
	
	MobileMappingLayer.prototype.getDefaultOptions = function getDefaultOptions() {
	    var o = {
	        // HTTP access to itowns sample datasets
	        // url : "../{lod}/images/{YYMMDD}/Paris-{YYMMDD}_0740-{cam.cam}-00001_{pano.pano:07}.jpg",
	        url: '../{lod}/images/{YYMMDD2}/Paris-{YYMMDD2}_0740-{cam.cam}-00001_{splitIt}.jpg',
	        lods: ['itowns-sample-data'], // ['itowns-sample-data-small', 'itowns-sample-data'],
	        /*
	        // IIP server access
	            website   : "your.website.com",
	            path    : "your/path",
	            url : "http://{website}/cgi-bin/iipsrv.fcgi?FIF=/{path}/{YYMMDD}/Paris-{YYMMDD}_0740-{cam.id}-00001_{pano.id:07}.jp2&WID={lod.w}&QLT={lod.q}&CVT=JPEG",
	            lods : [{w:32,q:50},{w:256,q:80},{w:2048,q:80}],
	        */
	        cam: '../dist/itowns-sample-data/cameraCalibration.json',
	        pano: '../dist/itowns-sample-data/panoramicsMetaData.json',
	        buildings: '../dist/itowns-sample-data/buildingFootprint.json',
	        DTM: '../dist/itowns-sample-data/dtm.json',
	        YYMMDD2: function YYMMDD2() {
	            // "filename":"Paris-140616_0740-00-00001_0000500"
	            // console.log(this);
	            return this.pano.filename.match('-(.*?)_')[1];
	        },
	        splitIt: function splitIt() {
	            return this.pano.filename.split('_')[2];
	        },
	        YYMMDD: function YYMMDD() {
	            var d = new Date(this.pano.date);
	            return ('' + d.getUTCFullYear()).slice(-2) + ('0' + (d.getUTCMonth() + 1)).slice(-2) + ('0' + d.getUTCDate()).slice(-2);
	        },
	
	        UTCOffset: 15,
	        seconds: function seconds() {
	            var d = new Date(this.pano.date);
	            return (d.getUTCHours() * 60 + d.getUTCMinutes()) * 60 + d.getUTCSeconds() - this.UTCOffset;
	        },
	
	        visible: true
	    };
	
	    return o;
	};
	
	exports.default = MobileMappingLayer;

/***/ },
/* 351 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _promise = __webpack_require__(224);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Provider = __webpack_require__(337);
	
	var _Provider2 = _interopRequireDefault(_Provider);
	
	var _BuildingBox_Provider = __webpack_require__(352);
	
	var _BuildingBox_Provider2 = _interopRequireDefault(_BuildingBox_Provider);
	
	var _ProjectiveTexturingMaterial = __webpack_require__(355);
	
	var _ProjectiveTexturingMaterial2 = _interopRequireDefault(_ProjectiveTexturingMaterial);
	
	var _BasicMaterial = __webpack_require__(323);
	
	var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);
	
	var _PanoramicMesh = __webpack_require__(365);
	
	var _PanoramicMesh2 = _interopRequireDefault(_PanoramicMesh);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Creates a provider for panoramic images/
	 * Get metadata for extrinseque info and also intrinseque
	 * @class Manage the panoramic provider (url, request)
	 * @author alexandre devaux IGN
	 * @requires ThreeJS
	 *
	 */
	
	/* global Promise*/
	
	var _options = null;
	var _urlPano = '';
	var _urlImage = '';
	var _urlCam = '';
	var _panoramicsMetaDataPromise = void 0;
	
	function PanoramicProvider(options) {
	    if (options) {
	        _options = options;
	        _urlPano = options.pano;
	        _urlImage = options.url;
	        _urlCam = options.cam;
	    }
	    this.panoInfo = null;
	    this.geometry = null;
	    this.material = null;
	    this.absoluteCenter = null; // pivot in fact here, not absoluteCenter
	    this.geometryRoof = null;
	    this.panoramicMesh = null;
	    this.projectiveTexturedMesh = null;
	}
	
	PanoramicProvider.prototype = (0, _create2.default)(_Provider2.default.prototype);
	PanoramicProvider.prototype.constructor = PanoramicProvider;
	
	PanoramicProvider.prototype.init = function init(options) {
	    _urlPano = options.pano;
	    _urlImage = options.url;
	    _urlCam = options.cam;
	};
	
	/**
	 * Return metadata info for panoramic closest to position in parameter
	 * @param {type} longitude
	 * @param {type} latitude
	 * @param {type} distance
	 * @returns {Promise}
	 */
	PanoramicProvider.prototype.getMetaDataFromPos = function getMetaDataFromPos(longitude, latitude) {
	    var _this = this;
	
	    if (_panoramicsMetaDataPromise == null) {
	        var requestURL = _urlPano; // TODO : string_format
	        _panoramicsMetaDataPromise = new _promise2.default(function (resolve, reject) {
	            var req = new XMLHttpRequest();
	            req.open('GET', requestURL);
	
	            req.onload = function onloadFn() {
	                if (req.status === 200) {
	                    resolve(JSON.parse(req.response));
	                } else {
	                    reject(Error(req.statusText));
	                }
	            };
	
	            req.onerror = function onerrorFn() {
	                reject(Error('Network Error'));
	            };
	
	            req.send();
	        });
	    }
	    return _panoramicsMetaDataPromise.then(function (panoramicsMetaData) {
	        var indiceClosest = 0;
	        var distMin = 99999;
	        for (var i = 0; i < panoramicsMetaData.length; ++i) {
	            var p = panoramicsMetaData[i];
	            var dist = Math.sqrt((p.longitude - longitude) * (p.longitude - longitude) + (p.latitude - latitude) * (p.latitude - latitude));
	            if (dist < distMin) {
	                indiceClosest = i;
	                distMin = dist;
	            }
	        }
	        // FIXME: not concurrency-safe; modifying state depending on method call parameter
	        _this.panoInfo = panoramicsMetaData[indiceClosest];
	        return panoramicsMetaData[indiceClosest];
	    });
	};
	
	PanoramicProvider.prototype.getTextureMaterial = function getTextureMaterial(panoInfo, pivot) {
	    return _ProjectiveTexturingMaterial2.default.init(_options, panoInfo, pivot); // Initialize itself Ori
	
	    // ProjectiveTexturingMaterial.createShaderMat(_options);
	    // return ProjectiveTexturingMaterial.getShaderMat();
	};
	
	PanoramicProvider.prototype.updateTextureMaterial = function updateTextureMaterial(panoInfo, pivot) {
	    _ProjectiveTexturingMaterial2.default.updateUniforms(panoInfo, pivot);
	};
	
	PanoramicProvider.prototype.getGeometry = function getGeometry(longitude, latitude, altitude) {
	    var w = 0.003;
	    var bbox = {
	        minCarto: {
	            longitude: longitude - w,
	            latitude: latitude - w
	        },
	        maxCarto: {
	            longitude: longitude + w,
	            latitude: latitude + w
	        }
	    };
	    // console.log(bbox);
	    var options = options || {
	        url: 'http://wxs.ign.fr/72hpsel8j8nhb5qgdh07gcyp/geoportail/wfs?',
	        typename: 'BDTOPO_BDD_WLD_WGS84G:bati_remarquable,BDTOPO_BDD_WLD_WGS84G:bati_indifferencie',
	        bbox: bbox,
	        epsgCode: 4326
	    };
	
	    var buildingBox_Provider = new _BuildingBox_Provider2.default(options);
	
	    return buildingBox_Provider.getData(options.bbox, altitude).then(function () {
	        return {
	            geometry: buildingBox_Provider.geometry,
	            pivot: buildingBox_Provider.pivot,
	            roof: buildingBox_Provider.geometryRoof
	        };
	    });
	};
	
	// Manages 3 asynchronous functions
	// - Get Pano closest to lon lat (panoramic metadata)
	// - Get sensors informations (camera calibration)
	// - Get Building boxes from WFS
	PanoramicProvider.prototype.getTextureProjectiveMesh = function getTextureProjectiveMesh(longitude, latitude, distance) {
	    var _this2 = this;
	
	    return this.getMetaDataFromPos(longitude, latitude, distance).then(function (panoInfo) {
	        return _this2.getGeometry(panoInfo.longitude, panoInfo.latitude, panoInfo.altitude);
	    }).then(function (data) {
	        _this2.geometry = data.geometry;
	        _this2.absoluteCenter = data.pivot; // pivot in fact here, not absoluteCenter
	        _this2.geometryRoof = data.roof;
	
	        return _this2.getTextureMaterial(_this2.panoInfo, _this2.absoluteCenter);
	    }).then(function thenCb(shaderMaterial) {
	        this.material = shaderMaterial; // new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.8});
	        // this.projectiveTexturedMesh = new THREE.Mesh(this.geometry, this.material);
	        this.panoramicMesh = new _PanoramicMesh2.default(this.geometry, this.material, this.absoluteCenter);
	        var roofMesh = new _PanoramicMesh2.default(this.geometryRoof, new _BasicMaterial2.default(new THREE.Color(0xdddddd)), this.absoluteCenter);
	        roofMesh.material.side = THREE.DoubleSide;
	        roofMesh.material.transparent = true;
	        roofMesh.setDisplayed(true);
	        roofMesh.material.uniforms.lightingEnabled.value = false;
	
	        this.panoramicMesh.add(roofMesh);
	
	        // console.log(this.panoramicMesh);
	        // console.log(roofMesh);
	        return this.panoramicMesh;
	    });
	};
	
	// Update existing panoramic mesh with new images look for the closest to parameters position
	PanoramicProvider.prototype.updateMaterialImages = function updateMaterialImages(longitude, latitude, distance) {
	    var _this3 = this;
	
	    return this.getMetaDataFromPos(longitude, latitude, distance).then(function (panoInfo) {
	        _this3.updateTextureMaterial(panoInfo, _this3.absoluteCenter);
	        return panoInfo;
	    });
	};
	
	PanoramicProvider.prototype.getUrlImageFile = function getUrlImageFile() {
	    return _urlImage;
	};
	
	PanoramicProvider.prototype.getMetaDataSensorURL = function getMetaDataSensorURL() {
	    return _urlCam;
	};
	
	PanoramicProvider.prototype.getMetaDataSensor = function getMetaDataSensor() {};
	
	exports.default = PanoramicProvider;

/***/ },
/* 352 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _getIterator2 = __webpack_require__(28);
	
	var _getIterator3 = _interopRequireDefault(_getIterator2);
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _earcut = __webpack_require__(353);
	
	var _earcut2 = _interopRequireDefault(_earcut);
	
	var _Provider = __webpack_require__(337);
	
	var _Provider2 = _interopRequireDefault(_Provider);
	
	var _WFS_Provider = __webpack_require__(354);
	
	var _WFS_Provider2 = _interopRequireDefault(_WFS_Provider);
	
	var _Coordinates = __webpack_require__(289);
	
	var _Coordinates2 = _interopRequireDefault(_Coordinates);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function BuildingBox_Provider(options) {
	    // Constructor
	
	    // Provider.call( this,new IoDriver_XBIL());
	    // this.cache         = CacheRessource();
	    this.WFS_Provider = new _WFS_Provider2.default(options);
	    this.geometry = null;
	    this.geometryRoof = null;
	    this.pivot = null;
	    this.roadOn = true;
	    this.rtcOn = true;
	} /*
	   * To change this license header, choose License Headers in Project Properties.
	   * To change this template file, choose Tools | Templates
	   * and open the template in the editor.
	   */
	
	/**
	 * Generated On: 2015-10-5
	 * Class: WMTS_Provider
	 * Description: Fournisseur de données à travers un flux WMTS
	 */
	
	// TODO , will use WFS_Provider
	
	
	BuildingBox_Provider.prototype = (0, _create2.default)(_Provider2.default.prototype);
	BuildingBox_Provider.prototype.constructor = BuildingBox_Provider;
	
	/**
	 * Return url wmts MNT
	 * @param {type} coWMTS : coord WMTS
	 * @returns {Object@call;create.url.url|String}
	 */
	BuildingBox_Provider.prototype.url = function url(longitude, latitude, radius) {
	    // var key    = "wmybzw30d6zg563hjlq8eeqb";
	    // var key    = coWMTS.zoom > 11 ? "va5orxd0pgzvq3jxutqfuy0b" : "wmybzw30d6zg563hjlq8eeqb"; // clef pro va5orxd0pgzvq3jxutqfuy0b
	
	    var key = '72hpsel8j8nhb5qgdh07gcyp';
	
	    // var layer  = "BDTOPO_BDD_WLD_WGS84G:bati_remarquable,BDTOPO_BDD_WLD_WGS84G:bati_indifferencie"
	    var serviceVersionRequestLayer = 'service=WFS&version=2.0.0&REQUEST=GetFeature&typeName=BDTOPO_BDD_WLD_WGS84G:bati_remarquable,BDTOPO_BDD_WLD_WGS84G:bati_indifferencie';
	
	    var bottomLeft = new THREE.Vector2(longitude - radius, latitude - radius);
	    var topRight = new THREE.Vector2(longitude + radius, latitude + radius);
	
	    var url = 'http://wxs.ign.fr/' + key + '/geoportail/wfs?' + serviceVersionRequestLayer + '&bbox=' + bottomLeft.x + ',' + bottomLeft.y + ',' + topRight.x + ',' + topRight.y + ',epsg:4326&outputFormat=json';
	
	    return url;
	};
	
	BuildingBox_Provider.prototype.getData = function getData(bbox, altitude) {
	    var _this = this;
	
	    return this.WFS_Provider.getData(bbox).then(function (data) {
	        _this.generateMesh(data, bbox, altitude); // console.log(data);
	        return _this.geometry;
	    });
	};
	
	BuildingBox_Provider.prototype.generateMesh = function generateMesh(elements, bbox, altitude) {
	    var roofGeometry = new THREE.Geometry(); // for the roof
	    var _geometry = new THREE.Geometry(); // for the walls
	    var geometry = new THREE.Geometry(); // for the roof
	    var suppHeight = 10; // So we don't cut the roof
	    var features = elements.features;
	    var altitude_ground = altitude - 1.5; // 35;  // truck height
	
	    var _iteratorNormalCompletion = true;
	    var _didIteratorError = false;
	    var _iteratorError = undefined;
	
	    try {
	        for (var _iterator = (0, _getIterator3.default)(features), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
	            var feature = _step.value;
	
	            var hauteur = feature.properties.hauteur + suppHeight || 0;
	            var z_min = altitude_ground; // features[r].properties.z_min;  // altitude_ground // force altitude ground
	            var polygon = feature.geometry.coordinates[0][0];
	
	            var arrPoint2D = [];
	            if (polygon.length > 2) {
	                // VERTICES
	                for (var j = 0; j < polygon.length - 1; ++j) {
	                    var pt2DTab = polygon[j]; // .split(' ');
	                    var p1 = new THREE.Vector3(parseFloat(pt2DTab[0]), 0, parseFloat(pt2DTab[1]));
	
	                    var coordCarto1 = new _Coordinates2.default('EPSG:4326', p1.x, p1.z, z_min);
	                    var coordCarto2 = new _Coordinates2.default('EPSG:4326', p1.x, p1.z, z_min + hauteur); // + Math.random(1000) );
	                    var pgeo1 = coordCarto1.as('EPSG:4978').xyz();
	                    var pgeo2 = coordCarto2.as('EPSG:4978').xyz();
	
	                    var vector3_1 = new THREE.Vector3(pgeo1.x, pgeo1.y, pgeo1.z); // - x temporary, bug
	                    var vector3_2 = new THREE.Vector3(pgeo2.x, pgeo2.y, pgeo2.z);
	
	                    arrPoint2D.push(p1.z, p1.x);
	                    _geometry.vertices.push(vector3_1, vector3_2);
	                }
	
	                // FACES
	                // indice of the first point of the polygon 3D
	                for (var k = _geometry.vertices.length - (polygon.length - 1) * 2; k < _geometry.vertices.length; k += 2) {
	                    var l = k; // % (pts2DTab.length);
	                    if (l > _geometry.vertices.length - 4) {
	                        l = _geometry.vertices.length - (polygon.length - 1) * 2;
	                    }
	                    _geometry.faces.push(new THREE.Face3(l, l + 1, l + 3));
	                    _geometry.faces.push(new THREE.Face3(l, l + 3, l + 2));
	                }
	
	                var ll = _geometry.vertices.length - (polygon.length - 1) * 2;
	                _geometry.faces.push(new THREE.Face3(ll, ll + 1, _geometry.vertices.length - 1));
	                _geometry.faces.push(new THREE.Face3(ll, _geometry.vertices.length - 1, _geometry.vertices.length - 2));
	            }
	
	            //* *************** ROOF ****************************
	
	            var triangles = (0, _earcut2.default)(arrPoint2D);
	            for (var w = 0; w < triangles.length; w += 3) {
	                var pt1 = new THREE.Vector2(arrPoint2D[triangles[w] * 2], arrPoint2D[triangles[w] * 2 + 1]);
	                var pt2 = new THREE.Vector2(arrPoint2D[triangles[w + 1] * 2], arrPoint2D[triangles[w + 1] * 2 + 1]);
	                var pt3 = new THREE.Vector2(arrPoint2D[triangles[w + 2] * 2], arrPoint2D[triangles[w + 2] * 2 + 1]);
	                var c1 = new _Coordinates.C.EPSG_4326(pt1.x, pt1.y, z_min + hauteur);
	                var c2 = new _Coordinates.C.EPSG_4326(pt2.x, pt2.y, z_min + hauteur);
	                var c3 = new _Coordinates.C.EPSG_4326(pt3.x, pt3.y, z_min + hauteur);
	
	                roofGeometry.vertices.push(c1.as('EPSG:4978').xyz());
	                roofGeometry.vertices.push(c2.as('EPSG:4978').xyz());
	                roofGeometry.vertices.push(c3.as('EPSG:4978').xyz());
	
	                var face = new THREE.Face3(geometry.vertices.length - 3, geometry.vertices.length - 2, geometry.vertices.length - 1);
	                geometry.faces.push(face);
	            }
	        }
	    } catch (err) {
	        _didIteratorError = true;
	        _iteratorError = err;
	    } finally {
	        try {
	            if (!_iteratorNormalCompletion && _iterator.return) {
	                _iterator.return();
	            }
	        } finally {
	            if (_didIteratorError) {
	                throw _iteratorError;
	            }
	        }
	    }
	
	    if (this.roadOn) {
	        this.addRoad(_geometry, bbox, altitude_ground);
	    }
	
	    _geometry.computeFaceNormals(); // WARNING : VERY IMPORTANT WHILE WORKING WITH RAY CASTING ON CUSTOM MESH
	    geometry.computeFaceNormals();
	
	    /*
	        var matLambert = new THREE.MeshBasicMaterial({color: 0xffffff, transparent: true, opacity: 0.8});
	        var _currentMeshForRoof  = new THREE.Mesh(_geometry, matLambert);// //geometryClickToGo,mat);
	        gfxEngine().add3DScene(_currentMeshForRoof);
	    */
	
	    // Test if we return brute geometry or if we use local pivot (for useRTC)
	    var firstPos = new THREE.Vector3();
	    if (this.rtcOn) {
	        firstPos = _geometry.vertices[0].clone();
	        // create pivot from 1st pos vertex
	        var _iteratorNormalCompletion2 = true;
	        var _didIteratorError2 = false;
	        var _iteratorError2 = undefined;
	
	        try {
	            for (var _iterator2 = (0, _getIterator3.default)(_geometry.vertices), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
	                var vertice = _step2.value;
	
	                vertice.sub(firstPos);
	            }
	        } catch (err) {
	            _didIteratorError2 = true;
	            _iteratorError2 = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion2 && _iterator2.return) {
	                    _iterator2.return();
	                }
	            } finally {
	                if (_didIteratorError2) {
	                    throw _iteratorError2;
	                }
	            }
	        }
	
	        var _iteratorNormalCompletion3 = true;
	        var _didIteratorError3 = false;
	        var _iteratorError3 = undefined;
	
	        try {
	            for (var _iterator3 = (0, _getIterator3.default)(geometry.vertices), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
	                var _vertice = _step3.value;
	
	                _vertice.sub(firstPos);
	            }
	        } catch (err) {
	            _didIteratorError3 = true;
	            _iteratorError3 = err;
	        } finally {
	            try {
	                if (!_iteratorNormalCompletion3 && _iterator3.return) {
	                    _iterator3.return();
	                }
	            } finally {
	                if (_didIteratorError3) {
	                    throw _iteratorError3;
	                }
	            }
	        }
	    }
	
	    this.geometry = _geometry;
	    this.pivot = firstPos;
	    this.geometryRoof = geometry;
	
	    return {
	        geometry: _geometry,
	        pivot: firstPos,
	        geometryRoof: geometry
	    };
	};
	
	BuildingBox_Provider.prototype.addRoad = function addRoad(geometry, bbox, altitude_road) {
	    // Version using SIMPLE PLANE ROAD for Click and Go
	    var ratio = 0.2;
	    var roadWidth = (bbox.east() - bbox.west()) * ratio;
	    var roadHeight = (bbox.north() - bbox.south()) * ratio;
	    var pos = new THREE.Vector3((bbox.south() + bbox.north()) / 2, altitude_road, (bbox.west() + bbox.east()) / 2); // 48.8505774,  altitude_sol, 2.3348124);
	
	    var coordCarto1 = new _Coordinates2.default('EPSG:4326', pos.x - roadWidth, pos.z - roadHeight, altitude_road);
	    var coordCarto2 = new _Coordinates2.default('EPSG:4326', pos.x - roadWidth, pos.z + roadHeight, altitude_road);
	    var coordCarto3 = new _Coordinates2.default('EPSG:4326', pos.x + roadWidth, pos.z + roadHeight, altitude_road);
	    var coordCarto4 = new _Coordinates2.default('EPSG:4326', pos.x + roadWidth, pos.z - roadHeight, altitude_road);
	
	    var pgeo1 = coordCarto1.as('EPSG:4978').xyz();
	    var pgeo2 = coordCarto2.as('EPSG:4978').xyz();
	    var pgeo3 = coordCarto3.as('EPSG:4978').xyz();
	    var pgeo4 = coordCarto4.as('EPSG:4978').xyz();
	
	    geometry.vertices.push(new THREE.Vector3(pgeo1.x, pgeo1.y, pgeo1.z));
	    geometry.vertices.push(new THREE.Vector3(pgeo2.x, pgeo2.y, pgeo2.z));
	    geometry.vertices.push(new THREE.Vector3(pgeo3.x, pgeo3.y, pgeo3.z));
	    geometry.vertices.push(new THREE.Vector3(pgeo4.x, pgeo4.y, pgeo4.z));
	
	    var len = geometry.vertices.length;
	    geometry.faces.push(new THREE.Face3(len - 4, len - 3, len - 2));
	    geometry.faces.push(new THREE.Face3(len - 4, len - 2, len - 1));
	};
	
	exports.default = BuildingBox_Provider;

/***/ },
/* 353 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = earcut;
	
	function earcut(data, holeIndices, dim) {
	
	    dim = dim || 2;
	
	    var hasHoles = holeIndices && holeIndices.length,
	        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
	        outerNode = linkedList(data, 0, outerLen, dim, true),
	        triangles = [];
	
	    if (!outerNode) return triangles;
	
	    var minX, minY, maxX, maxY, x, y, size;
	
	    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);
	
	    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
	    if (data.length > 80 * dim) {
	        minX = maxX = data[0];
	        minY = maxY = data[1];
	
	        for (var i = dim; i < outerLen; i += dim) {
	            x = data[i];
	            y = data[i + 1];
	            if (x < minX) minX = x;
	            if (y < minY) minY = y;
	            if (x > maxX) maxX = x;
	            if (y > maxY) maxY = y;
	        }
	
	        // minX, minY and size are later used to transform coords into integers for z-order calculation
	        size = Math.max(maxX - minX, maxY - minY);
	    }
	
	    earcutLinked(outerNode, triangles, dim, minX, minY, size);
	
	    return triangles;
	}
	
	// create a circular doubly linked list from polygon points in the specified winding order
	function linkedList(data, start, end, dim, clockwise) {
	    var i, last;
	
	    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
	        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
	    } else {
	        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
	    }
	
	    if (last && equals(last, last.next)) {
	        removeNode(last);
	        last = last.next;
	    }
	
	    return last;
	}
	
	// eliminate colinear or duplicate points
	function filterPoints(start, end) {
	    if (!start) return start;
	    if (!end) end = start;
	
	    var p = start,
	        again;
	    do {
	        again = false;
	
	        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
	            removeNode(p);
	            p = end = p.prev;
	            if (p === p.next) return null;
	            again = true;
	
	        } else {
	            p = p.next;
	        }
	    } while (again || p !== end);
	
	    return end;
	}
	
	// main ear slicing loop which triangulates a polygon (given as a linked list)
	function earcutLinked(ear, triangles, dim, minX, minY, size, pass) {
	    if (!ear) return;
	
	    // interlink polygon nodes in z-order
	    if (!pass && size) indexCurve(ear, minX, minY, size);
	
	    var stop = ear,
	        prev, next;
	
	    // iterate through ears, slicing them one by one
	    while (ear.prev !== ear.next) {
	        prev = ear.prev;
	        next = ear.next;
	
	        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {
	            // cut off the triangle
	            triangles.push(prev.i / dim);
	            triangles.push(ear.i / dim);
	            triangles.push(next.i / dim);
	
	            removeNode(ear);
	
	            // skipping the next vertice leads to less sliver triangles
	            ear = next.next;
	            stop = next.next;
	
	            continue;
	        }
	
	        ear = next;
	
	        // if we looped through the whole remaining polygon and can't find any more ears
	        if (ear === stop) {
	            // try filtering points and slicing again
	            if (!pass) {
	                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);
	
	            // if this didn't work, try curing all small self-intersections locally
	            } else if (pass === 1) {
	                ear = cureLocalIntersections(ear, triangles, dim);
	                earcutLinked(ear, triangles, dim, minX, minY, size, 2);
	
	            // as a last resort, try splitting the remaining polygon into two
	            } else if (pass === 2) {
	                splitEarcut(ear, triangles, dim, minX, minY, size);
	            }
	
	            break;
	        }
	    }
	}
	
	// check whether a polygon node forms a valid ear with adjacent nodes
	function isEar(ear) {
	    var a = ear.prev,
	        b = ear,
	        c = ear.next;
	
	    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
	
	    // now make sure we don't have other points inside the potential ear
	    var p = ear.next.next;
	
	    while (p !== ear.prev) {
	        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
	            area(p.prev, p, p.next) >= 0) return false;
	        p = p.next;
	    }
	
	    return true;
	}
	
	function isEarHashed(ear, minX, minY, size) {
	    var a = ear.prev,
	        b = ear,
	        c = ear.next;
	
	    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear
	
	    // triangle bbox; min & max are calculated like this for speed
	    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
	        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
	        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
	        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
	
	    // z-order range for the current triangle bbox;
	    var minZ = zOrder(minTX, minTY, minX, minY, size),
	        maxZ = zOrder(maxTX, maxTY, minX, minY, size);
	
	    // first look for points inside the triangle in increasing z-order
	    var p = ear.nextZ;
	
	    while (p && p.z <= maxZ) {
	        if (p !== ear.prev && p !== ear.next &&
	            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
	            area(p.prev, p, p.next) >= 0) return false;
	        p = p.nextZ;
	    }
	
	    // then look for points in decreasing z-order
	    p = ear.prevZ;
	
	    while (p && p.z >= minZ) {
	        if (p !== ear.prev && p !== ear.next &&
	            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
	            area(p.prev, p, p.next) >= 0) return false;
	        p = p.prevZ;
	    }
	
	    return true;
	}
	
	// go through all polygon nodes and cure small local self-intersections
	function cureLocalIntersections(start, triangles, dim) {
	    var p = start;
	    do {
	        var a = p.prev,
	            b = p.next.next;
	
	        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
	
	            triangles.push(a.i / dim);
	            triangles.push(p.i / dim);
	            triangles.push(b.i / dim);
	
	            // remove two nodes involved
	            removeNode(p);
	            removeNode(p.next);
	
	            p = start = b;
	        }
	        p = p.next;
	    } while (p !== start);
	
	    return p;
	}
	
	// try splitting polygon into two and triangulate them independently
	function splitEarcut(start, triangles, dim, minX, minY, size) {
	    // look for a valid diagonal that divides the polygon into two
	    var a = start;
	    do {
	        var b = a.next.next;
	        while (b !== a.prev) {
	            if (a.i !== b.i && isValidDiagonal(a, b)) {
	                // split the polygon in two by the diagonal
	                var c = splitPolygon(a, b);
	
	                // filter colinear points around the cuts
	                a = filterPoints(a, a.next);
	                c = filterPoints(c, c.next);
	
	                // run earcut on each half
	                earcutLinked(a, triangles, dim, minX, minY, size);
	                earcutLinked(c, triangles, dim, minX, minY, size);
	                return;
	            }
	            b = b.next;
	        }
	        a = a.next;
	    } while (a !== start);
	}
	
	// link every hole into the outer loop, producing a single-ring polygon without holes
	function eliminateHoles(data, holeIndices, outerNode, dim) {
	    var queue = [],
	        i, len, start, end, list;
	
	    for (i = 0, len = holeIndices.length; i < len; i++) {
	        start = holeIndices[i] * dim;
	        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	        list = linkedList(data, start, end, dim, false);
	        if (list === list.next) list.steiner = true;
	        queue.push(getLeftmost(list));
	    }
	
	    queue.sort(compareX);
	
	    // process holes from left to right
	    for (i = 0; i < queue.length; i++) {
	        eliminateHole(queue[i], outerNode);
	        outerNode = filterPoints(outerNode, outerNode.next);
	    }
	
	    return outerNode;
	}
	
	function compareX(a, b) {
	    return a.x - b.x;
	}
	
	// find a bridge between vertices that connects hole with an outer ring and and link it
	function eliminateHole(hole, outerNode) {
	    outerNode = findHoleBridge(hole, outerNode);
	    if (outerNode) {
	        var b = splitPolygon(outerNode, hole);
	        filterPoints(b, b.next);
	    }
	}
	
	// David Eberly's algorithm for finding a bridge between hole and outer polygon
	function findHoleBridge(hole, outerNode) {
	    var p = outerNode,
	        hx = hole.x,
	        hy = hole.y,
	        qx = -Infinity,
	        m;
	
	    // find a segment intersected by a ray from the hole's leftmost point to the left;
	    // segment's endpoint with lesser x will be potential connection point
	    do {
	        if (hy <= p.y && hy >= p.next.y) {
	            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
	            if (x <= hx && x > qx) {
	                qx = x;
	                if (x === hx) {
	                    if (hy === p.y) return p;
	                    if (hy === p.next.y) return p.next;
	                }
	                m = p.x < p.next.x ? p : p.next;
	            }
	        }
	        p = p.next;
	    } while (p !== outerNode);
	
	    if (!m) return null;
	
	    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint
	
	    // look for points inside the triangle of hole point, segment intersection and endpoint;
	    // if there are no points found, we have a valid connection;
	    // otherwise choose the point of the minimum angle with the ray as connection point
	
	    var stop = m,
	        mx = m.x,
	        my = m.y,
	        tanMin = Infinity,
	        tan;
	
	    p = m.next;
	
	    while (p !== stop) {
	        if (hx >= p.x && p.x >= mx &&
	                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
	
	            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential
	
	            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
	                m = p;
	                tanMin = tan;
	            }
	        }
	
	        p = p.next;
	    }
	
	    return m;
	}
	
	// interlink polygon nodes in z-order
	function indexCurve(start, minX, minY, size) {
	    var p = start;
	    do {
	        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);
	        p.prevZ = p.prev;
	        p.nextZ = p.next;
	        p = p.next;
	    } while (p !== start);
	
	    p.prevZ.nextZ = null;
	    p.prevZ = null;
	
	    sortLinked(p);
	}
	
	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
	function sortLinked(list) {
	    var i, p, q, e, tail, numMerges, pSize, qSize,
	        inSize = 1;
	
	    do {
	        p = list;
	        list = null;
	        tail = null;
	        numMerges = 0;
	
	        while (p) {
	            numMerges++;
	            q = p;
	            pSize = 0;
	            for (i = 0; i < inSize; i++) {
	                pSize++;
	                q = q.nextZ;
	                if (!q) break;
	            }
	
	            qSize = inSize;
	
	            while (pSize > 0 || (qSize > 0 && q)) {
	
	                if (pSize === 0) {
	                    e = q;
	                    q = q.nextZ;
	                    qSize--;
	                } else if (qSize === 0 || !q) {
	                    e = p;
	                    p = p.nextZ;
	                    pSize--;
	                } else if (p.z <= q.z) {
	                    e = p;
	                    p = p.nextZ;
	                    pSize--;
	                } else {
	                    e = q;
	                    q = q.nextZ;
	                    qSize--;
	                }
	
	                if (tail) tail.nextZ = e;
	                else list = e;
	
	                e.prevZ = tail;
	                tail = e;
	            }
	
	            p = q;
	        }
	
	        tail.nextZ = null;
	        inSize *= 2;
	
	    } while (numMerges > 1);
	
	    return list;
	}
	
	// z-order of a point given coords and size of the data bounding box
	function zOrder(x, y, minX, minY, size) {
	    // coords are transformed into non-negative 15-bit integer range
	    x = 32767 * (x - minX) / size;
	    y = 32767 * (y - minY) / size;
	
	    x = (x | (x << 8)) & 0x00FF00FF;
	    x = (x | (x << 4)) & 0x0F0F0F0F;
	    x = (x | (x << 2)) & 0x33333333;
	    x = (x | (x << 1)) & 0x55555555;
	
	    y = (y | (y << 8)) & 0x00FF00FF;
	    y = (y | (y << 4)) & 0x0F0F0F0F;
	    y = (y | (y << 2)) & 0x33333333;
	    y = (y | (y << 1)) & 0x55555555;
	
	    return x | (y << 1);
	}
	
	// find the leftmost node of a polygon ring
	function getLeftmost(start) {
	    var p = start,
	        leftmost = start;
	    do {
	        if (p.x < leftmost.x) leftmost = p;
	        p = p.next;
	    } while (p !== start);
	
	    return leftmost;
	}
	
	// check if a point lies within a convex triangle
	function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
	    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
	           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
	           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
	}
	
	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
	function isValidDiagonal(a, b) {
	    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
	           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
	}
	
	// signed area of a triangle
	function area(p, q, r) {
	    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
	}
	
	// check if two points are equal
	function equals(p1, p2) {
	    return p1.x === p2.x && p1.y === p2.y;
	}
	
	// check if two segments intersect
	function intersects(p1, q1, p2, q2) {
	    if ((equals(p1, q1) && equals(p2, q2)) ||
	        (equals(p1, q2) && equals(p2, q1))) return true;
	    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
	           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
	}
	
	// check if a polygon diagonal intersects any polygon segments
	function intersectsPolygon(a, b) {
	    var p = a;
	    do {
	        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
	                intersects(p, p.next, a, b)) return true;
	        p = p.next;
	    } while (p !== a);
	
	    return false;
	}
	
	// check if a polygon diagonal is locally inside the polygon
	function locallyInside(a, b) {
	    return area(a.prev, a, a.next) < 0 ?
	        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
	        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
	}
	
	// check if the middle point of a polygon diagonal is inside the polygon
	function middleInside(a, b) {
	    var p = a,
	        inside = false,
	        px = (a.x + b.x) / 2,
	        py = (a.y + b.y) / 2;
	    do {
	        if (((p.y > py) !== (p.next.y > py)) && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
	            inside = !inside;
	        p = p.next;
	    } while (p !== a);
	
	    return inside;
	}
	
	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring
	function splitPolygon(a, b) {
	    var a2 = new Node(a.i, a.x, a.y),
	        b2 = new Node(b.i, b.x, b.y),
	        an = a.next,
	        bp = b.prev;
	
	    a.next = b;
	    b.prev = a;
	
	    a2.next = an;
	    an.prev = a2;
	
	    b2.next = a2;
	    a2.prev = b2;
	
	    bp.next = b2;
	    b2.prev = bp;
	
	    return b2;
	}
	
	// create a node and optionally link it with previous one (in a circular doubly linked list)
	function insertNode(i, x, y, last) {
	    var p = new Node(i, x, y);
	
	    if (!last) {
	        p.prev = p;
	        p.next = p;
	
	    } else {
	        p.next = last.next;
	        p.prev = last;
	        last.next.prev = p;
	        last.next = p;
	    }
	    return p;
	}
	
	function removeNode(p) {
	    p.next.prev = p.prev;
	    p.prev.next = p.next;
	
	    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
	    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
	}
	
	function Node(i, x, y) {
	    // vertice index in coordinates array
	    this.i = i;
	
	    // vertex coordinates
	    this.x = x;
	    this.y = y;
	
	    // previous and next vertice nodes in a polygon ring
	    this.prev = null;
	    this.next = null;
	
	    // z-order curve value
	    this.z = null;
	
	    // previous and next nodes in z-order
	    this.prevZ = null;
	    this.nextZ = null;
	
	    // indicates whether this is a steiner point
	    this.steiner = false;
	}
	
	// return a percentage difference between the polygon area and its triangulation area;
	// used to verify correctness of triangulation
	earcut.deviation = function (data, holeIndices, dim, triangles) {
	    var hasHoles = holeIndices && holeIndices.length;
	    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
	
	    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
	    if (hasHoles) {
	        for (var i = 0, len = holeIndices.length; i < len; i++) {
	            var start = holeIndices[i] * dim;
	            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
	            polygonArea -= Math.abs(signedArea(data, start, end, dim));
	        }
	    }
	
	    var trianglesArea = 0;
	    for (i = 0; i < triangles.length; i += 3) {
	        var a = triangles[i] * dim;
	        var b = triangles[i + 1] * dim;
	        var c = triangles[i + 2] * dim;
	        trianglesArea += Math.abs(
	            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
	            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
	    }
	
	    return polygonArea === 0 && trianglesArea === 0 ? 0 :
	        Math.abs((trianglesArea - polygonArea) / polygonArea);
	};
	
	function signedArea(data, start, end, dim) {
	    var sum = 0;
	    for (var i = start, j = end - dim; i < end; i += dim) {
	        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
	        j = i;
	    }
	    return sum;
	}
	
	// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
	earcut.flatten = function (data) {
	    var dim = data[0][0].length,
	        result = {vertices: [], holes: [], dimensions: dim},
	        holeIndex = 0;
	
	    for (var i = 0; i < data.length; i++) {
	        for (var j = 0; j < data[i].length; j++) {
	            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
	        }
	        if (i > 0) {
	            holeIndex += data[i - 1].length;
	            result.holes.push(holeIndex);
	        }
	    }
	    return result;
	};


/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _Provider = __webpack_require__(337);
	
	var _Provider2 = _interopRequireDefault(_Provider);
	
	var _Fetcher = __webpack_require__(340);
	
	var _Fetcher2 = _interopRequireDefault(_Fetcher);
	
	var _CacheRessource = __webpack_require__(341);
	
	var _CacheRessource2 = _interopRequireDefault(_CacheRessource);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Return url wmts MNT
	 * @param {String} options.url: service base url
	 * @param {String} options.layer: requested data layer
	 * @param {String} options.format: image format (default: format/jpeg)
	 * @returns {Object@call;create.url.url|String}
	 */
	function WFS_Provider(options) {
	  this.cache = (0, _CacheRessource2.default)();
	  this.baseUrl = options.url || '';
	  this.layer = options.layer || '';
	  this.typename = options.typename || '';
	  this.format = options.format === undefined ? 'json' : options.format;
	  this.epsgCode = options.epsgCode || 4326;
	} /**
	   * Generated On: 2016-03-5
	   * Class: WFS_Provider
	   * Description: Provides data from a WFS stream
	   */
	
	WFS_Provider.prototype = (0, _create2.default)(_Provider2.default.prototype);
	WFS_Provider.prototype.constructor = WFS_Provider;
	
	/**
	 * Returns the url for a WMS query with the specified bounding box
	 * @param {BoundingBox} bbox: requested bounding box
	 * @returns {Object@call;create.url.url|String}
	 * ex http://wxs.ign.fr/72hpsel8j8nhb5qgdh07gcyp/geoportail/wfs?service=WFS&version=2.0.0
	 * &REQUEST=GetFeature&typeName=BDTOPO_BDD_WLD_WGS84G:bati_remarquable,BDTOPO_BDD_WLD_WGS84G:bati_indifferencie
	 * &bbox=2.325,48.855,2.335,48.865,epsg:4326&outputFormat=json
	 */
	WFS_Provider.prototype.url = function url(bbox) {
	  var url = this.baseUrl + 'SERVICE=WFS&VERSION=2.0.0&REQUEST=GetFeature' + ('&typeName=' + this.typename + '&BBOX=' + bbox.west() + ',' + bbox.south() + ',' + bbox.east() + ',' + bbox.north() + ',epsg:' + this.epsgCode + '&outputFormat=' + this.format);
	
	  return url;
	};
	
	/*
	 * Return Data as Object (JSON parsed)
	 */
	WFS_Provider.prototype.getData = function getData(bbox) {
	  var url = this.url(bbox);
	  return _Fetcher2.default.json(url);
	};
	
	exports.default = WFS_Provider;

/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _url = __webpack_require__(356);
	
	var _url2 = _interopRequireDefault(_url);
	
	var _c3DEngine = __webpack_require__(240);
	
	var _c3DEngine2 = _interopRequireDefault(_c3DEngine);
	
	var _Ori = __webpack_require__(362);
	
	var _Ori2 = _interopRequireDefault(_Ori);
	
	var _Shader = __webpack_require__(364);
	
	var _Shader2 = _interopRequireDefault(_Shader);
	
	var _Ellipsoid = __webpack_require__(297);
	
	var _Ellipsoid2 = _interopRequireDefault(_Ellipsoid);
	
	var _Coordinates = __webpack_require__(289);
	
	var _Coordinates2 = _interopRequireDefault(_Coordinates);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	window.requestAnimSelectionAlpha = function getRequestAnimSelectionAlphaFn() {
	    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function requestAnimSelectionAlpha(callback) {
	        window.setTimeout(callback, 1000 / 60);
	    };
	}(); /**
	      *
	      * @author AD IGN
	      * Class generating shaders for projective texturing of MULTIPLE IMAGES in a single shader. This class can be used
	      * to texture any mesh. We need to set the matrix of Orientation of the projector
	      * and its projective camera information.
	      */
	
	var _shaderMat = null;
	var _initPromise = null;
	var _alpha = 1;
	var _infos = {};
	var ellipsoid = new _Ellipsoid2.default(new THREE.Vector3(6378137, 6356752.3142451793, 6378137));
	
	var ProjectiveTexturingMaterial = {
	    init: function init(infos, panoInfo, pivot) {
	        if (_initPromise == null) {
	            _initPromise = _Ori2.default.init(infos).then(function thenCb() {
	                // compute Camera Frame Rotation
	                var matRotationFrame = this.getCameraFrameRotation(panoInfo);
	                this.createShaderMat(panoInfo, matRotationFrame, pivot);
	                return _shaderMat;
	            });
	        }
	        return _initPromise;
	    },
	    isInitiated: function isInitiated() {
	        // XXX: this only says whether this.init() has been called, not whether it has resolved!
	        return _initPromise != null;
	    },
	    setGeneralOpacity: function setGeneralOpacity(value) {
	        _alpha = value;
	    },
	    tweenGeneralOpacityUp: function tweenGeneralOpacityUp() {
	        if (_alpha < 1) {
	            _alpha += (_alpha + 0.01) * 0.04;
	            if (_alpha > 1) _alpha = 1;
	            window.requestAnimSelectionAlpha(this.tweenGeneralOpacityUp.bind(this));
	        }
	    },
	    getCameraFrameRotation: function getCameraFrameRotation(panoInfo) {
	        var matRotation = _Ori2.default.computeMatOriFromHeadingPitchRoll(panoInfo.heading, panoInfo.pitch, panoInfo.roll);
	
	        // Then correct with position on ellipsoid
	        // Orientation on normal
	        var posPanoWGS84 = new _Coordinates2.default('EPSG:4326', panoInfo.longitude, panoInfo.latitude, panoInfo.altitude);
	        var posPanoCartesian = posPanoWGS84.as('EPSG:4978').xyz();
	
	        var normal = ellipsoid.geodeticSurfaceNormalCartographic(posPanoWGS84);
	        var quaternion = new THREE.Quaternion();
	        quaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), Math.PI / 2);
	
	        var child = new THREE.Object3D();
	        var localTarget = new THREE.Vector3().addVectors(posPanoCartesian.clone(), normal);
	        child.lookAt(localTarget);
	        child.quaternion.multiply(quaternion);
	        // child.position.copy(posCartesien.clone());
	        child.updateMatrix();
	        // console.log("matrice originale", matRotation,"MAtrice normale",child.matrix, "normal vec", normal );
	
	        var c = child.matrix; // .elements;
	        var m3 = new THREE.Matrix3().fromMatrix4(c);
	        // console.log(m3);
	        var matRotationOnGlobe = new THREE.Matrix3().multiplyMatrices(matRotation.clone(), m3); // child.matrix);
	
	        return matRotationOnGlobe;
	    },
	
	
	    // display all the images of the panoramics
	    nbImages: function nbImages() {
	        return _Ori2.default.sensors.length;
	    },
	    nbMasks: function nbMasks() {
	        if (!_infos.noMask) return 0;
	        var count = 0;
	        for (var i = 0; i < this.nbImages(); ++i) {
	            if (_Ori2.default.getMask(i)) ++count;
	        }
	        return count;
	    },
	
	
	    // throttle down the number of panoramics to meet the gl.MAX_* constraints
	    nbPanoramics: function nbPanoramics() {
	        var N = this.nbImages();
	        var gl = (0, _c3DEngine2.default)().getRenderer().getContext();
	        var M = this.nbMasks();
	        var maxVaryingVec = gl.getParameter(gl.MAX_VARYING_VECTORS);
	        var maxTextureImageUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
	        var maxNbPanoramics = Math.floor(Math.min(maxVaryingVec, maxTextureImageUnits - M) / N);
	        var P = Math.min(_infos.targetNbPanoramics, maxNbPanoramics);
	        /*       console.log("Masks : ", M);
	              console.log("Images per panoramic  : ", N );
	              console.log("Panoramics : ", P ," displayed /",_infos.targetNbPanoramics, " targeted");
	              console.log("Varyings : ", (N*P) ," used /",maxVaryingVec, " available");
	              console.log("Texture units : ", (M+N*P) ," used /",maxTextureImageUnits," available");
	         */
	        return P;
	    },
	    loadTexture: function loadTexture(src, infos, onload, data) {
	        //  console.log("src: ",src,"  infos: ",infos);
	        src = src.format(infos); // console.log("src: ",src);
	        var img = new Image();
	        img.crossOrigin = 'anonymous';
	        img.onload = function onLoad() {
	            var tex = new THREE.Texture(this, THREE.UVMapping, THREE.RepeatWrapping, THREE.RepeatWrapping, THREE.LinearFilter, THREE.LinearFilter, THREE.RGBFormat);
	            tex.needsUpdate = true;
	            tex.flipY = false;
	            onload(tex, data);
	        };
	        var baseUrl = '../dist/itowns-sample-data/cameraCalibration.json'; // _infos.url;//PanoramicProvider.getMetaDataSensorURL();
	        img.src = _url2.default.resolve(baseUrl, src);
	    },
	    createShaderMat: function createShaderMat(panoInfo, rot, pivot) {
	        var posPanoWGS84 = new _Coordinates2.default('EPSG:4326', panoInfo.longitude, panoInfo.latitude, panoInfo.altitude);
	        var posPanoCartesian = posPanoWGS84.as('EPSG:4978').xyz();
	        // console.log("posPanoCartesian: ",posPanoCartesian);
	        var spherePosPano = new THREE.Mesh(new THREE.SphereGeometry(0.5, 12, 12), new THREE.MeshBasicMaterial({
	            side: THREE.DoubleSide,
	            color: 0xff00ff
	        }));
	        spherePosPano.position.copy(posPanoCartesian);
	        (0, _c3DEngine2.default)().add3DScene(spherePosPano);
	
	        var posPiv = posPanoCartesian.clone().sub(pivot);
	        var posFrameWithPivot = new THREE.Vector4(posPiv.x, posPiv.y, posPiv.z, 1.0);
	        var N = this.nbImages();
	        var P = this.nbPanoramics();
	        var uniforms = {
	            useRTC: {
	                type: 'i',
	                value: 1
	            },
	            mVPMatRTC: {
	                type: 'm4',
	                value: new THREE.Matrix4()
	            },
	            distortion: {
	                type: 'v4v',
	                value: []
	            },
	            pps: {
	                type: 'v2v',
	                value: []
	            },
	            size: {
	                type: 'v2v',
	                value: []
	            },
	            alpha: {
	                type: 'fv1',
	                value: []
	            },
	            mvpp: {
	                type: 'm3v',
	                value: []
	            },
	            translation: {
	                type: 'v3v',
	                value: []
	            },
	            texture: {
	                type: 'tv',
	                value: []
	            },
	            mask: {
	                type: 'tv',
	                value: []
	            }
	        };
	        var idmask = [];
	        var iddist = [];
	        for (var i = 0; i < N; ++i) {
	            var mat = _Ori2.default.getMatrix(i).clone();
	            var mvpp = new THREE.Matrix3().multiplyMatrices(rot, mat).transpose();
	            var trans = posFrameWithPivot.clone().add(_Ori2.default.getSommet(i).clone().applyMatrix3(rot));
	            var m = -1;
	            if (!_infos.noMask && _Ori2.default.getMask(i)) {
	                m = uniforms.mask.value.length;
	                uniforms.mask.value[m] = null;
	            }
	            var d = -1;
	            if (!_infos.noDistortion && _Ori2.default.getDistortion(i)) {
	                d = uniforms.distortion.value.length;
	                uniforms.distortion.value[d] = _Ori2.default.getDistortion(i);
	                uniforms.pps.value[d] = _Ori2.default.getPPS(i);
	            }
	            for (var pano = 0; pano < P; ++pano) {
	                var j = i + N * pano;
	                uniforms.size.value[j] = _Ori2.default.getSize(i);
	                uniforms.alpha.value[j] = _alpha * (1 - pano);
	                uniforms.mvpp.value[j] = mvpp;
	                uniforms.translation.value[j] = trans;
	                uniforms.texture.value[j] = null;
	                idmask[j] = m;
	                iddist[j] = d;
	            }
	        }
	
	        // create the shader material for Three
	        _shaderMat = new THREE.ShaderMaterial({
	            uniforms: uniforms,
	            vertexShader: _Shader2.default.shaderTextureProjectiveVS(P * N),
	            fragmentShader: _Shader2.default.shaderTextureProjectiveFS(P * N, idmask, iddist),
	            side: THREE.DoubleSide, // THREE.BackSide,
	            transparent: true
	        });
	
	        function setMaskOnLoad(tex, m) {
	            _shaderMat.uniforms.mask.value[m] = tex;
	        }
	
	        function setTextureOnLoad(tex, i) {
	            _shaderMat.uniforms.texture.value[i] = tex;
	        }
	
	        _infos.pano = panoInfo;
	        _infos.lod = _infos.lods[0];
	        for (var _i = 0; _i < N; ++_i) {
	            _infos.cam = _Ori2.default.sensors[_i].infos; // console.log(_infos.cam);
	            var _m = idmask[_i];
	            if (_m >= 0) {
	                this.loadTexture(_Ori2.default.getMask(_i), {}, setMaskOnLoad, _m);
	            }
	            this.loadTexture(_infos.url, _infos, setTextureOnLoad, _i);
	        }
	        this.changePanoTextureAfterloading(panoInfo, posFrameWithPivot, rot, 1);
	
	        return _shaderMat;
	    },
	    updateUniforms: function updateUniforms(panoInfo, pivot) {
	        var matRotationFrame = this.getCameraFrameRotation(panoInfo);
	
	        // compute translation
	        var posPanoWGS84 = new _Coordinates2.default('EPSG:4326', panoInfo.longitude, panoInfo.latitude, panoInfo.altitude);
	        var posPanoCartesian = posPanoWGS84.as('EPSG:4978').xyz();
	        var posPiv = posPanoCartesian.clone().sub(pivot);
	        var posFrameWithPivot = new THREE.Vector4(posPiv.x, posPiv.y, posPiv.z, 1.0);
	
	        this.changePanoTextureAfterloading(panoInfo, posFrameWithPivot, matRotationFrame, 0);
	    },
	    tweenIndiceTime: function tweenIndiceTime(i) {
	        var alpha = _shaderMat.uniforms.alpha.value[i];
	        (0, _c3DEngine2.default)().renderScene(); // TEMP CAUSE NO GLOBAL RENDERING LOOP
	        if (alpha < 1) {
	            var j = i + this.nbImages();
	            alpha += 0.03;
	            if (alpha > 1) alpha = 1;
	            _shaderMat.uniforms.alpha.value[i] = _alpha * alpha;
	            _shaderMat.uniforms.alpha.value[j] = _alpha * (1 - alpha);
	            var that = this;
	            window.requestAnimSelectionAlpha(function () {
	                that.tweenIndiceTime(i);
	            });
	        }
	    },
	    changePanoTextureAfterloading: function changePanoTextureAfterloading(panoInfo, translation, rotation, lod) {
	        this.todo = [];
	        _infos.pano = panoInfo;
	        this.translation = translation || new THREE.Vector3();
	        this.rotation = rotation || new THREE.Matrix3();
	        for (var l = lod || 0; l < _infos.lods.length; ++l) {
	            for (var i = 0; i < _Ori2.default.sensors.length; ++i) {
	                this.todo.push({
	                    l: l,
	                    i: i
	                });
	            }
	        }
	
	        this.chargeOneImageCam();
	    },
	
	
	    // Load an Image(html) then use it as a texture. Wait loading before passing to the shader to avoid black effect
	    chargeOneImageCam: function chargeOneImageCam() {
	        if (this.todo.length == 0) return;
	        var todo = this.todo.shift();
	        var i = todo.i;
	        var lod = todo.l;
	        var that = this;
	        _infos.cam = _Ori2.default.sensors[todo.i].infos;
	        _infos.lod = _infos.lods[todo.l];
	        this.loadTexture(_infos.url, _infos, function (tex) {
	            var mat = _Ori2.default.getMatrix(i).clone();
	            var mvpp = new THREE.Matrix3().multiplyMatrices(that.rotation, mat).transpose();
	            var trans = _Ori2.default.getSommet(i).clone().applyMatrix3(that.rotation);
	            var j = i + that.nbImages();
	            if (lod === 0 && j < _shaderMat.uniforms.mvpp.value.length) {
	                _shaderMat.uniforms.mvpp.value[j] = _shaderMat.uniforms.mvpp.value[i];
	                _shaderMat.uniforms.translation.value[j] = _shaderMat.uniforms.translation.value[i];
	                _shaderMat.uniforms.texture.value[j] = _shaderMat.uniforms.texture.value[i];
	                _shaderMat.uniforms.alpha.value[j] = _alpha;
	                _shaderMat.uniforms.alpha.value[i] = 0;
	                that.tweenIndiceTime(i);
	            }
	
	            _shaderMat.uniforms.mvpp.value[i] = mvpp;
	            _shaderMat.uniforms.translation.value[i] = that.translation.clone().add(trans);
	            _shaderMat.uniforms.texture.value[i] = tex;
	
	            if (lod == 0) {
	                that.chargeOneImageCam();
	            } else {
	                setTimeout(function () {
	                    that.chargeOneImageCam();
	                }, 500);
	            }
	        });
	    },
	    getShaderMat: function getShaderMat() {
	        return _shaderMat;
	    }
	};
	exports.default = ProjectiveTexturingMaterial;

/***/ },
/* 356 */
/***/ function(module, exports, __webpack_require__) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var punycode = __webpack_require__(357);
	var util = __webpack_require__(358);
	
	exports.parse = urlParse;
	exports.resolve = urlResolve;
	exports.resolveObject = urlResolveObject;
	exports.format = urlFormat;
	
	exports.Url = Url;
	
	function Url() {
	  this.protocol = null;
	  this.slashes = null;
	  this.auth = null;
	  this.host = null;
	  this.port = null;
	  this.hostname = null;
	  this.hash = null;
	  this.search = null;
	  this.query = null;
	  this.pathname = null;
	  this.path = null;
	  this.href = null;
	}
	
	// Reference: RFC 3986, RFC 1808, RFC 2396
	
	// define these here so at least they only have to be
	// compiled once on the first module load.
	var protocolPattern = /^([a-z0-9.+-]+:)/i,
	    portPattern = /:[0-9]*$/,
	
	    // Special case for a simple path URL
	    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
	
	    // RFC 2396: characters reserved for delimiting URLs.
	    // We actually just auto-escape these.
	    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
	
	    // RFC 2396: characters not allowed for various reasons.
	    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
	
	    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
	    autoEscape = ['\''].concat(unwise),
	    // Characters that are never ever allowed in a hostname.
	    // Note that any invalid chars are also handled, but these
	    // are the ones that are *expected* to be seen, so we fast-path
	    // them.
	    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
	    hostEndingChars = ['/', '?', '#'],
	    hostnameMaxLen = 255,
	    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
	    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
	    // protocols that can allow "unsafe" and "unwise" chars.
	    unsafeProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that never have a hostname.
	    hostlessProtocol = {
	      'javascript': true,
	      'javascript:': true
	    },
	    // protocols that always contain a // bit.
	    slashedProtocol = {
	      'http': true,
	      'https': true,
	      'ftp': true,
	      'gopher': true,
	      'file': true,
	      'http:': true,
	      'https:': true,
	      'ftp:': true,
	      'gopher:': true,
	      'file:': true
	    },
	    querystring = __webpack_require__(359);
	
	function urlParse(url, parseQueryString, slashesDenoteHost) {
	  if (url && util.isObject(url) && url instanceof Url) return url;
	
	  var u = new Url;
	  u.parse(url, parseQueryString, slashesDenoteHost);
	  return u;
	}
	
	Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
	  if (!util.isString(url)) {
	    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
	  }
	
	  // Copy chrome, IE, opera backslash-handling behavior.
	  // Back slashes before the query string get converted to forward slashes
	  // See: https://code.google.com/p/chromium/issues/detail?id=25916
	  var queryIndex = url.indexOf('?'),
	      splitter =
	          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
	      uSplit = url.split(splitter),
	      slashRegex = /\\/g;
	  uSplit[0] = uSplit[0].replace(slashRegex, '/');
	  url = uSplit.join(splitter);
	
	  var rest = url;
	
	  // trim before proceeding.
	  // This is to support parse stuff like "  http://foo.com  \n"
	  rest = rest.trim();
	
	  if (!slashesDenoteHost && url.split('#').length === 1) {
	    // Try fast path regexp
	    var simplePath = simplePathPattern.exec(rest);
	    if (simplePath) {
	      this.path = rest;
	      this.href = rest;
	      this.pathname = simplePath[1];
	      if (simplePath[2]) {
	        this.search = simplePath[2];
	        if (parseQueryString) {
	          this.query = querystring.parse(this.search.substr(1));
	        } else {
	          this.query = this.search.substr(1);
	        }
	      } else if (parseQueryString) {
	        this.search = '';
	        this.query = {};
	      }
	      return this;
	    }
	  }
	
	  var proto = protocolPattern.exec(rest);
	  if (proto) {
	    proto = proto[0];
	    var lowerProto = proto.toLowerCase();
	    this.protocol = lowerProto;
	    rest = rest.substr(proto.length);
	  }
	
	  // figure out if it's got a host
	  // user@server is *always* interpreted as a hostname, and url
	  // resolution will treat //foo/bar as host=foo,path=bar because that's
	  // how the browser resolves relative URLs.
	  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
	    var slashes = rest.substr(0, 2) === '//';
	    if (slashes && !(proto && hostlessProtocol[proto])) {
	      rest = rest.substr(2);
	      this.slashes = true;
	    }
	  }
	
	  if (!hostlessProtocol[proto] &&
	      (slashes || (proto && !slashedProtocol[proto]))) {
	
	    // there's a hostname.
	    // the first instance of /, ?, ;, or # ends the host.
	    //
	    // If there is an @ in the hostname, then non-host chars *are* allowed
	    // to the left of the last @ sign, unless some host-ending character
	    // comes *before* the @-sign.
	    // URLs are obnoxious.
	    //
	    // ex:
	    // http://a@b@c/ => user:a@b host:c
	    // http://a@b?@c => user:a host:c path:/?@c
	
	    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
	    // Review our test case against browsers more comprehensively.
	
	    // find the first instance of any hostEndingChars
	    var hostEnd = -1;
	    for (var i = 0; i < hostEndingChars.length; i++) {
	      var hec = rest.indexOf(hostEndingChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	
	    // at this point, either we have an explicit point where the
	    // auth portion cannot go past, or the last @ char is the decider.
	    var auth, atSign;
	    if (hostEnd === -1) {
	      // atSign can be anywhere.
	      atSign = rest.lastIndexOf('@');
	    } else {
	      // atSign must be in auth portion.
	      // http://a@b/c@d => host:b auth:a path:/c@d
	      atSign = rest.lastIndexOf('@', hostEnd);
	    }
	
	    // Now we have a portion which is definitely the auth.
	    // Pull that off.
	    if (atSign !== -1) {
	      auth = rest.slice(0, atSign);
	      rest = rest.slice(atSign + 1);
	      this.auth = decodeURIComponent(auth);
	    }
	
	    // the host is the remaining to the left of the first non-host char
	    hostEnd = -1;
	    for (var i = 0; i < nonHostChars.length; i++) {
	      var hec = rest.indexOf(nonHostChars[i]);
	      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
	        hostEnd = hec;
	    }
	    // if we still have not hit it, then the entire thing is a host.
	    if (hostEnd === -1)
	      hostEnd = rest.length;
	
	    this.host = rest.slice(0, hostEnd);
	    rest = rest.slice(hostEnd);
	
	    // pull out port.
	    this.parseHost();
	
	    // we've indicated that there is a hostname,
	    // so even if it's empty, it has to be present.
	    this.hostname = this.hostname || '';
	
	    // if hostname begins with [ and ends with ]
	    // assume that it's an IPv6 address.
	    var ipv6Hostname = this.hostname[0] === '[' &&
	        this.hostname[this.hostname.length - 1] === ']';
	
	    // validate a little.
	    if (!ipv6Hostname) {
	      var hostparts = this.hostname.split(/\./);
	      for (var i = 0, l = hostparts.length; i < l; i++) {
	        var part = hostparts[i];
	        if (!part) continue;
	        if (!part.match(hostnamePartPattern)) {
	          var newpart = '';
	          for (var j = 0, k = part.length; j < k; j++) {
	            if (part.charCodeAt(j) > 127) {
	              // we replace non-ASCII char with a temporary placeholder
	              // we need this to make sure size of hostname is not
	              // broken by replacing non-ASCII by nothing
	              newpart += 'x';
	            } else {
	              newpart += part[j];
	            }
	          }
	          // we test again with ASCII char only
	          if (!newpart.match(hostnamePartPattern)) {
	            var validParts = hostparts.slice(0, i);
	            var notHost = hostparts.slice(i + 1);
	            var bit = part.match(hostnamePartStart);
	            if (bit) {
	              validParts.push(bit[1]);
	              notHost.unshift(bit[2]);
	            }
	            if (notHost.length) {
	              rest = '/' + notHost.join('.') + rest;
	            }
	            this.hostname = validParts.join('.');
	            break;
	          }
	        }
	      }
	    }
	
	    if (this.hostname.length > hostnameMaxLen) {
	      this.hostname = '';
	    } else {
	      // hostnames are always lower case.
	      this.hostname = this.hostname.toLowerCase();
	    }
	
	    if (!ipv6Hostname) {
	      // IDNA Support: Returns a punycoded representation of "domain".
	      // It only converts parts of the domain name that
	      // have non-ASCII characters, i.e. it doesn't matter if
	      // you call it with a domain that already is ASCII-only.
	      this.hostname = punycode.toASCII(this.hostname);
	    }
	
	    var p = this.port ? ':' + this.port : '';
	    var h = this.hostname || '';
	    this.host = h + p;
	    this.href += this.host;
	
	    // strip [ and ] from the hostname
	    // the host field still retains them, though
	    if (ipv6Hostname) {
	      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
	      if (rest[0] !== '/') {
	        rest = '/' + rest;
	      }
	    }
	  }
	
	  // now rest is set to the post-host stuff.
	  // chop off any delim chars.
	  if (!unsafeProtocol[lowerProto]) {
	
	    // First, make 100% sure that any "autoEscape" chars get
	    // escaped, even if encodeURIComponent doesn't think they
	    // need to be.
	    for (var i = 0, l = autoEscape.length; i < l; i++) {
	      var ae = autoEscape[i];
	      if (rest.indexOf(ae) === -1)
	        continue;
	      var esc = encodeURIComponent(ae);
	      if (esc === ae) {
	        esc = escape(ae);
	      }
	      rest = rest.split(ae).join(esc);
	    }
	  }
	
	
	  // chop off from the tail first.
	  var hash = rest.indexOf('#');
	  if (hash !== -1) {
	    // got a fragment string.
	    this.hash = rest.substr(hash);
	    rest = rest.slice(0, hash);
	  }
	  var qm = rest.indexOf('?');
	  if (qm !== -1) {
	    this.search = rest.substr(qm);
	    this.query = rest.substr(qm + 1);
	    if (parseQueryString) {
	      this.query = querystring.parse(this.query);
	    }
	    rest = rest.slice(0, qm);
	  } else if (parseQueryString) {
	    // no query string, but parseQueryString still requested
	    this.search = '';
	    this.query = {};
	  }
	  if (rest) this.pathname = rest;
	  if (slashedProtocol[lowerProto] &&
	      this.hostname && !this.pathname) {
	    this.pathname = '/';
	  }
	
	  //to support http.request
	  if (this.pathname || this.search) {
	    var p = this.pathname || '';
	    var s = this.search || '';
	    this.path = p + s;
	  }
	
	  // finally, reconstruct the href based on what has been validated.
	  this.href = this.format();
	  return this;
	};
	
	// format a parsed object into a url string
	function urlFormat(obj) {
	  // ensure it's an object, and not a string url.
	  // If it's an obj, this is a no-op.
	  // this way, you can call url_format() on strings
	  // to clean up potentially wonky urls.
	  if (util.isString(obj)) obj = urlParse(obj);
	  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
	  return obj.format();
	}
	
	Url.prototype.format = function() {
	  var auth = this.auth || '';
	  if (auth) {
	    auth = encodeURIComponent(auth);
	    auth = auth.replace(/%3A/i, ':');
	    auth += '@';
	  }
	
	  var protocol = this.protocol || '',
	      pathname = this.pathname || '',
	      hash = this.hash || '',
	      host = false,
	      query = '';
	
	  if (this.host) {
	    host = auth + this.host;
	  } else if (this.hostname) {
	    host = auth + (this.hostname.indexOf(':') === -1 ?
	        this.hostname :
	        '[' + this.hostname + ']');
	    if (this.port) {
	      host += ':' + this.port;
	    }
	  }
	
	  if (this.query &&
	      util.isObject(this.query) &&
	      Object.keys(this.query).length) {
	    query = querystring.stringify(this.query);
	  }
	
	  var search = this.search || (query && ('?' + query)) || '';
	
	  if (protocol && protocol.substr(-1) !== ':') protocol += ':';
	
	  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
	  // unless they had them to begin with.
	  if (this.slashes ||
	      (!protocol || slashedProtocol[protocol]) && host !== false) {
	    host = '//' + (host || '');
	    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
	  } else if (!host) {
	    host = '';
	  }
	
	  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
	  if (search && search.charAt(0) !== '?') search = '?' + search;
	
	  pathname = pathname.replace(/[?#]/g, function(match) {
	    return encodeURIComponent(match);
	  });
	  search = search.replace('#', '%23');
	
	  return protocol + host + pathname + search + hash;
	};
	
	function urlResolve(source, relative) {
	  return urlParse(source, false, true).resolve(relative);
	}
	
	Url.prototype.resolve = function(relative) {
	  return this.resolveObject(urlParse(relative, false, true)).format();
	};
	
	function urlResolveObject(source, relative) {
	  if (!source) return relative;
	  return urlParse(source, false, true).resolveObject(relative);
	}
	
	Url.prototype.resolveObject = function(relative) {
	  if (util.isString(relative)) {
	    var rel = new Url();
	    rel.parse(relative, false, true);
	    relative = rel;
	  }
	
	  var result = new Url();
	  var tkeys = Object.keys(this);
	  for (var tk = 0; tk < tkeys.length; tk++) {
	    var tkey = tkeys[tk];
	    result[tkey] = this[tkey];
	  }
	
	  // hash is always overridden, no matter what.
	  // even href="" will remove it.
	  result.hash = relative.hash;
	
	  // if the relative url is empty, then there's nothing left to do here.
	  if (relative.href === '') {
	    result.href = result.format();
	    return result;
	  }
	
	  // hrefs like //foo/bar always cut to the protocol.
	  if (relative.slashes && !relative.protocol) {
	    // take everything except the protocol from relative
	    var rkeys = Object.keys(relative);
	    for (var rk = 0; rk < rkeys.length; rk++) {
	      var rkey = rkeys[rk];
	      if (rkey !== 'protocol')
	        result[rkey] = relative[rkey];
	    }
	
	    //urlParse appends trailing / to urls like http://www.example.com
	    if (slashedProtocol[result.protocol] &&
	        result.hostname && !result.pathname) {
	      result.path = result.pathname = '/';
	    }
	
	    result.href = result.format();
	    return result;
	  }
	
	  if (relative.protocol && relative.protocol !== result.protocol) {
	    // if it's a known url protocol, then changing
	    // the protocol does weird things
	    // first, if it's not file:, then we MUST have a host,
	    // and if there was a path
	    // to begin with, then we MUST have a path.
	    // if it is file:, then the host is dropped,
	    // because that's known to be hostless.
	    // anything else is assumed to be absolute.
	    if (!slashedProtocol[relative.protocol]) {
	      var keys = Object.keys(relative);
	      for (var v = 0; v < keys.length; v++) {
	        var k = keys[v];
	        result[k] = relative[k];
	      }
	      result.href = result.format();
	      return result;
	    }
	
	    result.protocol = relative.protocol;
	    if (!relative.host && !hostlessProtocol[relative.protocol]) {
	      var relPath = (relative.pathname || '').split('/');
	      while (relPath.length && !(relative.host = relPath.shift()));
	      if (!relative.host) relative.host = '';
	      if (!relative.hostname) relative.hostname = '';
	      if (relPath[0] !== '') relPath.unshift('');
	      if (relPath.length < 2) relPath.unshift('');
	      result.pathname = relPath.join('/');
	    } else {
	      result.pathname = relative.pathname;
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    result.host = relative.host || '';
	    result.auth = relative.auth;
	    result.hostname = relative.hostname || relative.host;
	    result.port = relative.port;
	    // to support http.request
	    if (result.pathname || result.search) {
	      var p = result.pathname || '';
	      var s = result.search || '';
	      result.path = p + s;
	    }
	    result.slashes = result.slashes || relative.slashes;
	    result.href = result.format();
	    return result;
	  }
	
	  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
	      isRelAbs = (
	          relative.host ||
	          relative.pathname && relative.pathname.charAt(0) === '/'
	      ),
	      mustEndAbs = (isRelAbs || isSourceAbs ||
	                    (result.host && relative.pathname)),
	      removeAllDots = mustEndAbs,
	      srcPath = result.pathname && result.pathname.split('/') || [],
	      relPath = relative.pathname && relative.pathname.split('/') || [],
	      psychotic = result.protocol && !slashedProtocol[result.protocol];
	
	  // if the url is a non-slashed url, then relative
	  // links like ../.. should be able
	  // to crawl up to the hostname, as well.  This is strange.
	  // result.protocol has already been set by now.
	  // Later on, put the first path part into the host field.
	  if (psychotic) {
	    result.hostname = '';
	    result.port = null;
	    if (result.host) {
	      if (srcPath[0] === '') srcPath[0] = result.host;
	      else srcPath.unshift(result.host);
	    }
	    result.host = '';
	    if (relative.protocol) {
	      relative.hostname = null;
	      relative.port = null;
	      if (relative.host) {
	        if (relPath[0] === '') relPath[0] = relative.host;
	        else relPath.unshift(relative.host);
	      }
	      relative.host = null;
	    }
	    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
	  }
	
	  if (isRelAbs) {
	    // it's absolute.
	    result.host = (relative.host || relative.host === '') ?
	                  relative.host : result.host;
	    result.hostname = (relative.hostname || relative.hostname === '') ?
	                      relative.hostname : result.hostname;
	    result.search = relative.search;
	    result.query = relative.query;
	    srcPath = relPath;
	    // fall through to the dot-handling below.
	  } else if (relPath.length) {
	    // it's relative
	    // throw away the existing file, and take the new path instead.
	    if (!srcPath) srcPath = [];
	    srcPath.pop();
	    srcPath = srcPath.concat(relPath);
	    result.search = relative.search;
	    result.query = relative.query;
	  } else if (!util.isNullOrUndefined(relative.search)) {
	    // just pull out the search.
	    // like href='?foo'.
	    // Put this after the other two cases because it simplifies the booleans
	    if (psychotic) {
	      result.hostname = result.host = srcPath.shift();
	      //occationaly the auth can get stuck only in host
	      //this especially happens in cases like
	      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	      var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                       result.host.split('@') : false;
	      if (authInHost) {
	        result.auth = authInHost.shift();
	        result.host = result.hostname = authInHost.shift();
	      }
	    }
	    result.search = relative.search;
	    result.query = relative.query;
	    //to support http.request
	    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	      result.path = (result.pathname ? result.pathname : '') +
	                    (result.search ? result.search : '');
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  if (!srcPath.length) {
	    // no path at all.  easy.
	    // we've already handled the other stuff above.
	    result.pathname = null;
	    //to support http.request
	    if (result.search) {
	      result.path = '/' + result.search;
	    } else {
	      result.path = null;
	    }
	    result.href = result.format();
	    return result;
	  }
	
	  // if a url ENDs in . or .., then it must get a trailing slash.
	  // however, if it ends in anything else non-slashy,
	  // then it must NOT get a trailing slash.
	  var last = srcPath.slice(-1)[0];
	  var hasTrailingSlash = (
	      (result.host || relative.host || srcPath.length > 1) &&
	      (last === '.' || last === '..') || last === '');
	
	  // strip single dots, resolve double dots to parent dir
	  // if the path tries to go above the root, `up` ends up > 0
	  var up = 0;
	  for (var i = srcPath.length; i >= 0; i--) {
	    last = srcPath[i];
	    if (last === '.') {
	      srcPath.splice(i, 1);
	    } else if (last === '..') {
	      srcPath.splice(i, 1);
	      up++;
	    } else if (up) {
	      srcPath.splice(i, 1);
	      up--;
	    }
	  }
	
	  // if the path is allowed to go above the root, restore leading ..s
	  if (!mustEndAbs && !removeAllDots) {
	    for (; up--; up) {
	      srcPath.unshift('..');
	    }
	  }
	
	  if (mustEndAbs && srcPath[0] !== '' &&
	      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
	    srcPath.unshift('');
	  }
	
	  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
	    srcPath.push('');
	  }
	
	  var isAbsolute = srcPath[0] === '' ||
	      (srcPath[0] && srcPath[0].charAt(0) === '/');
	
	  // put the host back
	  if (psychotic) {
	    result.hostname = result.host = isAbsolute ? '' :
	                                    srcPath.length ? srcPath.shift() : '';
	    //occationaly the auth can get stuck only in host
	    //this especially happens in cases like
	    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
	    var authInHost = result.host && result.host.indexOf('@') > 0 ?
	                     result.host.split('@') : false;
	    if (authInHost) {
	      result.auth = authInHost.shift();
	      result.host = result.hostname = authInHost.shift();
	    }
	  }
	
	  mustEndAbs = mustEndAbs || (result.host && srcPath.length);
	
	  if (mustEndAbs && !isAbsolute) {
	    srcPath.unshift('');
	  }
	
	  if (!srcPath.length) {
	    result.pathname = null;
	    result.path = null;
	  } else {
	    result.pathname = srcPath.join('/');
	  }
	
	  //to support request.http
	  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
	    result.path = (result.pathname ? result.pathname : '') +
	                  (result.search ? result.search : '');
	  }
	  result.auth = relative.auth || result.auth;
	  result.slashes = result.slashes || relative.slashes;
	  result.href = result.format();
	  return result;
	};
	
	Url.prototype.parseHost = function() {
	  var host = this.host;
	  var port = portPattern.exec(host);
	  if (port) {
	    port = port[0];
	    if (port !== ':') {
	      this.port = port.substr(1);
	    }
	    host = host.substr(0, host.length - port.length);
	  }
	  if (host) this.hostname = host;
	};


/***/ },
/* 357 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(module, global) {/*! https://mths.be/punycode v1.3.2 by @mathias */
	;(function(root) {
	
		/** Detect free variables */
		var freeExports = typeof exports == 'object' && exports &&
			!exports.nodeType && exports;
		var freeModule = typeof module == 'object' && module &&
			!module.nodeType && module;
		var freeGlobal = typeof global == 'object' && global;
		if (
			freeGlobal.global === freeGlobal ||
			freeGlobal.window === freeGlobal ||
			freeGlobal.self === freeGlobal
		) {
			root = freeGlobal;
		}
	
		/**
		 * The `punycode` object.
		 * @name punycode
		 * @type Object
		 */
		var punycode,
	
		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1
	
		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'
	
		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators
	
		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},
	
		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,
	
		/** Temporary variable */
		key;
	
		/*--------------------------------------------------------------------------*/
	
		/**
		 * A generic error utility function.
		 * @private
		 * @param {String} type The error type.
		 * @returns {Error} Throws a `RangeError` with the applicable error message.
		 */
		function error(type) {
			throw RangeError(errors[type]);
		}
	
		/**
		 * A generic `Array#map` utility function.
		 * @private
		 * @param {Array} array The array to iterate over.
		 * @param {Function} callback The function that gets called for every array
		 * item.
		 * @returns {Array} A new array of values returned by the callback function.
		 */
		function map(array, fn) {
			var length = array.length;
			var result = [];
			while (length--) {
				result[length] = fn(array[length]);
			}
			return result;
		}
	
		/**
		 * A simple `Array#map`-like wrapper to work with domain name strings or email
		 * addresses.
		 * @private
		 * @param {String} domain The domain name or email address.
		 * @param {Function} callback The function that gets called for every
		 * character.
		 * @returns {Array} A new string of characters returned by the callback
		 * function.
		 */
		function mapDomain(string, fn) {
			var parts = string.split('@');
			var result = '';
			if (parts.length > 1) {
				// In email addresses, only the domain name should be punycoded. Leave
				// the local part (i.e. everything up to `@`) intact.
				result = parts[0] + '@';
				string = parts[1];
			}
			// Avoid `split(regex)` for IE8 compatibility. See #17.
			string = string.replace(regexSeparators, '\x2E');
			var labels = string.split('.');
			var encoded = map(labels, fn).join('.');
			return result + encoded;
		}
	
		/**
		 * Creates an array containing the numeric code points of each Unicode
		 * character in the string. While JavaScript uses UCS-2 internally,
		 * this function will convert a pair of surrogate halves (each of which
		 * UCS-2 exposes as separate characters) into a single code point,
		 * matching UTF-16.
		 * @see `punycode.ucs2.encode`
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode.ucs2
		 * @name decode
		 * @param {String} string The Unicode input string (UCS-2).
		 * @returns {Array} The new array of code points.
		 */
		function ucs2decode(string) {
			var output = [],
			    counter = 0,
			    length = string.length,
			    value,
			    extra;
			while (counter < length) {
				value = string.charCodeAt(counter++);
				if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
					// high surrogate, and there is a next character
					extra = string.charCodeAt(counter++);
					if ((extra & 0xFC00) == 0xDC00) { // low surrogate
						output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
					} else {
						// unmatched surrogate; only append this code unit, in case the next
						// code unit is the high surrogate of a surrogate pair
						output.push(value);
						counter--;
					}
				} else {
					output.push(value);
				}
			}
			return output;
		}
	
		/**
		 * Creates a string based on an array of numeric code points.
		 * @see `punycode.ucs2.decode`
		 * @memberOf punycode.ucs2
		 * @name encode
		 * @param {Array} codePoints The array of numeric code points.
		 * @returns {String} The new Unicode string (UCS-2).
		 */
		function ucs2encode(array) {
			return map(array, function(value) {
				var output = '';
				if (value > 0xFFFF) {
					value -= 0x10000;
					output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
					value = 0xDC00 | value & 0x3FF;
				}
				output += stringFromCharCode(value);
				return output;
			}).join('');
		}
	
		/**
		 * Converts a basic code point into a digit/integer.
		 * @see `digitToBasic()`
		 * @private
		 * @param {Number} codePoint The basic numeric code point value.
		 * @returns {Number} The numeric value of a basic code point (for use in
		 * representing integers) in the range `0` to `base - 1`, or `base` if
		 * the code point does not represent a value.
		 */
		function basicToDigit(codePoint) {
			if (codePoint - 48 < 10) {
				return codePoint - 22;
			}
			if (codePoint - 65 < 26) {
				return codePoint - 65;
			}
			if (codePoint - 97 < 26) {
				return codePoint - 97;
			}
			return base;
		}
	
		/**
		 * Converts a digit/integer into a basic code point.
		 * @see `basicToDigit()`
		 * @private
		 * @param {Number} digit The numeric value of a basic code point.
		 * @returns {Number} The basic code point whose value (when used for
		 * representing integers) is `digit`, which needs to be in the range
		 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
		 * used; else, the lowercase form is used. The behavior is undefined
		 * if `flag` is non-zero and `digit` has no uppercase form.
		 */
		function digitToBasic(digit, flag) {
			//  0..25 map to ASCII a..z or A..Z
			// 26..35 map to ASCII 0..9
			return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
		}
	
		/**
		 * Bias adaptation function as per section 3.4 of RFC 3492.
		 * http://tools.ietf.org/html/rfc3492#section-3.4
		 * @private
		 */
		function adapt(delta, numPoints, firstTime) {
			var k = 0;
			delta = firstTime ? floor(delta / damp) : delta >> 1;
			delta += floor(delta / numPoints);
			for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
				delta = floor(delta / baseMinusTMin);
			}
			return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
		}
	
		/**
		 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
		 * symbols.
		 * @memberOf punycode
		 * @param {String} input The Punycode string of ASCII-only symbols.
		 * @returns {String} The resulting string of Unicode symbols.
		 */
		function decode(input) {
			// Don't use UCS-2
			var output = [],
			    inputLength = input.length,
			    out,
			    i = 0,
			    n = initialN,
			    bias = initialBias,
			    basic,
			    j,
			    index,
			    oldi,
			    w,
			    k,
			    digit,
			    t,
			    /** Cached calculation results */
			    baseMinusT;
	
			// Handle the basic code points: let `basic` be the number of input code
			// points before the last delimiter, or `0` if there is none, then copy
			// the first basic code points to the output.
	
			basic = input.lastIndexOf(delimiter);
			if (basic < 0) {
				basic = 0;
			}
	
			for (j = 0; j < basic; ++j) {
				// if it's not a basic code point
				if (input.charCodeAt(j) >= 0x80) {
					error('not-basic');
				}
				output.push(input.charCodeAt(j));
			}
	
			// Main decoding loop: start just after the last delimiter if any basic code
			// points were copied; start at the beginning otherwise.
	
			for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {
	
				// `index` is the index of the next character to be consumed.
				// Decode a generalized variable-length integer into `delta`,
				// which gets added to `i`. The overflow checking is easier
				// if we increase `i` as we go, then subtract off its starting
				// value at the end to obtain `delta`.
				for (oldi = i, w = 1, k = base; /* no condition */; k += base) {
	
					if (index >= inputLength) {
						error('invalid-input');
					}
	
					digit = basicToDigit(input.charCodeAt(index++));
	
					if (digit >= base || digit > floor((maxInt - i) / w)) {
						error('overflow');
					}
	
					i += digit * w;
					t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
	
					if (digit < t) {
						break;
					}
	
					baseMinusT = base - t;
					if (w > floor(maxInt / baseMinusT)) {
						error('overflow');
					}
	
					w *= baseMinusT;
	
				}
	
				out = output.length + 1;
				bias = adapt(i - oldi, out, oldi == 0);
	
				// `i` was supposed to wrap around from `out` to `0`,
				// incrementing `n` each time, so we'll fix that now:
				if (floor(i / out) > maxInt - n) {
					error('overflow');
				}
	
				n += floor(i / out);
				i %= out;
	
				// Insert `n` at position `i` of the output
				output.splice(i++, 0, n);
	
			}
	
			return ucs2encode(output);
		}
	
		/**
		 * Converts a string of Unicode symbols (e.g. a domain name label) to a
		 * Punycode string of ASCII-only symbols.
		 * @memberOf punycode
		 * @param {String} input The string of Unicode symbols.
		 * @returns {String} The resulting Punycode string of ASCII-only symbols.
		 */
		function encode(input) {
			var n,
			    delta,
			    handledCPCount,
			    basicLength,
			    bias,
			    j,
			    m,
			    q,
			    k,
			    t,
			    currentValue,
			    output = [],
			    /** `inputLength` will hold the number of code points in `input`. */
			    inputLength,
			    /** Cached calculation results */
			    handledCPCountPlusOne,
			    baseMinusT,
			    qMinusT;
	
			// Convert the input in UCS-2 to Unicode
			input = ucs2decode(input);
	
			// Cache the length
			inputLength = input.length;
	
			// Initialize the state
			n = initialN;
			delta = 0;
			bias = initialBias;
	
			// Handle the basic code points
			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue < 0x80) {
					output.push(stringFromCharCode(currentValue));
				}
			}
	
			handledCPCount = basicLength = output.length;
	
			// `handledCPCount` is the number of code points that have been handled;
			// `basicLength` is the number of basic code points.
	
			// Finish the basic string - if it is not empty - with a delimiter
			if (basicLength) {
				output.push(delimiter);
			}
	
			// Main encoding loop:
			while (handledCPCount < inputLength) {
	
				// All non-basic code points < n have been handled already. Find the next
				// larger one:
				for (m = maxInt, j = 0; j < inputLength; ++j) {
					currentValue = input[j];
					if (currentValue >= n && currentValue < m) {
						m = currentValue;
					}
				}
	
				// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
				// but guard against overflow
				handledCPCountPlusOne = handledCPCount + 1;
				if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
					error('overflow');
				}
	
				delta += (m - n) * handledCPCountPlusOne;
				n = m;
	
				for (j = 0; j < inputLength; ++j) {
					currentValue = input[j];
	
					if (currentValue < n && ++delta > maxInt) {
						error('overflow');
					}
	
					if (currentValue == n) {
						// Represent delta as a generalized variable-length integer
						for (q = delta, k = base; /* no condition */; k += base) {
							t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
							if (q < t) {
								break;
							}
							qMinusT = q - t;
							baseMinusT = base - t;
							output.push(
								stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
							);
							q = floor(qMinusT / baseMinusT);
						}
	
						output.push(stringFromCharCode(digitToBasic(q, 0)));
						bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
						delta = 0;
						++handledCPCount;
					}
				}
	
				++delta;
				++n;
	
			}
			return output.join('');
		}
	
		/**
		 * Converts a Punycode string representing a domain name or an email address
		 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
		 * it doesn't matter if you call it on a string that has already been
		 * converted to Unicode.
		 * @memberOf punycode
		 * @param {String} input The Punycoded domain name or email address to
		 * convert to Unicode.
		 * @returns {String} The Unicode representation of the given Punycode
		 * string.
		 */
		function toUnicode(input) {
			return mapDomain(input, function(string) {
				return regexPunycode.test(string)
					? decode(string.slice(4).toLowerCase())
					: string;
			});
		}
	
		/**
		 * Converts a Unicode string representing a domain name or an email address to
		 * Punycode. Only the non-ASCII parts of the domain name will be converted,
		 * i.e. it doesn't matter if you call it with a domain that's already in
		 * ASCII.
		 * @memberOf punycode
		 * @param {String} input The domain name or email address to convert, as a
		 * Unicode string.
		 * @returns {String} The Punycode representation of the given domain name or
		 * email address.
		 */
		function toASCII(input) {
			return mapDomain(input, function(string) {
				return regexNonASCII.test(string)
					? 'xn--' + encode(string)
					: string;
			});
		}
	
		/*--------------------------------------------------------------------------*/
	
		/** Define the public API */
		punycode = {
			/**
			 * A string representing the current Punycode.js version number.
			 * @memberOf punycode
			 * @type String
			 */
			'version': '1.3.2',
			/**
			 * An object of methods to convert from JavaScript's internal character
			 * representation (UCS-2) to Unicode code points, and back.
			 * @see <https://mathiasbynens.be/notes/javascript-encoding>
			 * @memberOf punycode
			 * @type Object
			 */
			'ucs2': {
				'decode': ucs2decode,
				'encode': ucs2encode
			},
			'decode': decode,
			'encode': encode,
			'toASCII': toASCII,
			'toUnicode': toUnicode
		};
	
		/** Expose `punycode` */
		// Some AMD build optimizers, like r.js, check for specific condition patterns
		// like the following:
		if (
			true
		) {
			!(__WEBPACK_AMD_DEFINE_RESULT__ = function() {
				return punycode;
			}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
		} else if (freeExports && freeModule) {
			if (module.exports == freeExports) { // in Node.js or RingoJS v0.8.0+
				freeModule.exports = punycode;
			} else { // in Narwhal or RingoJS v0.7.0-
				for (key in punycode) {
					punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
				}
			}
		} else { // in Rhino or a web browser
			root.punycode = punycode;
		}
	
	}(this));
	
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(94)(module), (function() { return this; }())))

/***/ },
/* 358 */
/***/ function(module, exports) {

	'use strict';
	
	module.exports = {
	  isString: function(arg) {
	    return typeof(arg) === 'string';
	  },
	  isObject: function(arg) {
	    return typeof(arg) === 'object' && arg !== null;
	  },
	  isNull: function(arg) {
	    return arg === null;
	  },
	  isNullOrUndefined: function(arg) {
	    return arg == null;
	  }
	};


/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	exports.decode = exports.parse = __webpack_require__(360);
	exports.encode = exports.stringify = __webpack_require__(361);


/***/ },
/* 360 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	// If obj.hasOwnProperty has been overridden, then calling
	// obj.hasOwnProperty(prop) will break.
	// See: https://github.com/joyent/node/issues/1707
	function hasOwnProperty(obj, prop) {
	  return Object.prototype.hasOwnProperty.call(obj, prop);
	}
	
	module.exports = function(qs, sep, eq, options) {
	  sep = sep || '&';
	  eq = eq || '=';
	  var obj = {};
	
	  if (typeof qs !== 'string' || qs.length === 0) {
	    return obj;
	  }
	
	  var regexp = /\+/g;
	  qs = qs.split(sep);
	
	  var maxKeys = 1000;
	  if (options && typeof options.maxKeys === 'number') {
	    maxKeys = options.maxKeys;
	  }
	
	  var len = qs.length;
	  // maxKeys <= 0 means that we should not limit keys count
	  if (maxKeys > 0 && len > maxKeys) {
	    len = maxKeys;
	  }
	
	  for (var i = 0; i < len; ++i) {
	    var x = qs[i].replace(regexp, '%20'),
	        idx = x.indexOf(eq),
	        kstr, vstr, k, v;
	
	    if (idx >= 0) {
	      kstr = x.substr(0, idx);
	      vstr = x.substr(idx + 1);
	    } else {
	      kstr = x;
	      vstr = '';
	    }
	
	    k = decodeURIComponent(kstr);
	    v = decodeURIComponent(vstr);
	
	    if (!hasOwnProperty(obj, k)) {
	      obj[k] = v;
	    } else if (Array.isArray(obj[k])) {
	      obj[k].push(v);
	    } else {
	      obj[k] = [obj[k], v];
	    }
	  }
	
	  return obj;
	};


/***/ },
/* 361 */
/***/ function(module, exports) {

	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	'use strict';
	
	var stringifyPrimitive = function(v) {
	  switch (typeof v) {
	    case 'string':
	      return v;
	
	    case 'boolean':
	      return v ? 'true' : 'false';
	
	    case 'number':
	      return isFinite(v) ? v : '';
	
	    default:
	      return '';
	  }
	};
	
	module.exports = function(obj, sep, eq, name) {
	  sep = sep || '&';
	  eq = eq || '=';
	  if (obj === null) {
	    obj = undefined;
	  }
	
	  if (typeof obj === 'object') {
	    return Object.keys(obj).map(function(k) {
	      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
	      if (Array.isArray(obj[k])) {
	        return obj[k].map(function(v) {
	          return ks + encodeURIComponent(stringifyPrimitive(v));
	        }).join(sep);
	      } else {
	        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
	      }
	    }).join(sep);
	
	  }
	
	  if (!name) return '';
	  return encodeURIComponent(stringifyPrimitive(name)) + eq +
	         encodeURIComponent(stringifyPrimitive(obj));
	};


/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Sensor = __webpack_require__(363);
	
	var _Sensor2 = _interopRequireDefault(_Sensor);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	/**
	 *
	 * @author AD IGN
	 * Class where we get the Extrinseque and Intrinseque parameters of the system. Camera (laser soon).
	 * Next we will dynamically load configuration from server in case of changes
	 * @Depends Sensor.js
	 */
	
	var Ori = {
	
	    initiated: false,
	    options: null,
	    sensors: [],
	
	    init: function init(options) {
	        var _this = this;
	
	        var baseUrl = options.cam; // PanoramicProvider.getMetaDataSensorURL();
	
	        return fetch(baseUrl).then(function (response) {
	            if (response.status < 200 || response.status >= 300) {
	                throw new Error('Error loading ' + baseUrl + ': status ' + response.status);
	            }
	            return response.json();
	        }).then(function (data) {
	            _this.handleDBData(data);
	            return _this.initiated;
	        });
	    },
	    handleDBData: function handleDBData(data) {
	        for (var i = 0; i < data.length; ++i) // For all DB sensor info we create sensor object
	        {
	            this.sensors.push(new _Sensor2.default(data[i]));
	        }
	        this.initiated = true;
	        // console.log('Orientation module is loaded');
	    },
	
	
	    // Global orientation matrix of the vehicule
	    // Warning: heading pitch roll not all in right side in itowns ref
	    // Pitch and Roll are in opposite
	    computeMatOriFromHeadingPitchRoll: function computeMatOriFromHeadingPitchRoll(heading, pitch, roll) {
	        heading = (180 - parseFloat(heading)) / 180 * Math.PI; // parseFloat(heading) / 180 * Math.PI;  // Deg to Rad // Axe Y
	        pitch = parseFloat(pitch) / 180 * Math.PI; // Deg to Rad // axe X
	        roll = parseFloat(roll) / 180 * Math.PI; // Deg to Rad   // axe Z
	        // With quaternion  //set rotation.order to "YXZ", which is equivalent to "heading, pitch, and roll"
	        var q = new THREE.Quaternion().setFromEuler(new THREE.Euler(-pitch, heading, -roll, 'YXZ'), true);
	        return new THREE.Matrix3().makeRotationFromQuaternion(q);
	    },
	    getPosition: function getPosition() {
	        var sum = new THREE.Vector3(0, 0, 0);
	        for (var i = 0; i < this.sensors.length; ++i) {
	            sum = sum.add(this.sensors[i].position);
	        }
	        return sum.divideScalar(this.sensors.length);
	    },
	
	
	    // deprecated methods
	    getDistortion: function getDistortion(i) {
	        return this.sensors[i].distortion;
	    },
	    getSommet: function getSommet(i) {
	        return this.sensors[i].position;
	    },
	    getProjection: function getProjection(i) {
	        return this.sensors[i].projection;
	    },
	    getRotation: function getRotation(i) {
	        return this.sensors[i].rotation;
	    },
	    getMask: function getMask(i) {
	        return this.sensors[i].mask;
	    },
	    getSize: function getSize(i) {
	        return this.sensors[i].size;
	    },
	    getPPS: function getPPS(i) {
	        return this.sensors[i].pps;
	    },
	    getMatrix: function getMatrix(i) {
	        return new THREE.Matrix3().multiplyMatrices(this.getRotation(i), this.getProjection(i));
	    }
	};
	
	exports.default = Ori;

/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	var Sensor = function Sensor(infos) {
	    this.infos = infos;
	    this.position = new THREE.Vector3().fromArray(infos.position);
	    this.rotation = new THREE.Matrix3().fromArray(infos.rotation);
	    this.projection = new THREE.Matrix3().fromArray(infos.projection);
	    this.size = new THREE.Vector2().fromArray(infos.size);
	    if (infos.distortion) {
	        this.pps = new THREE.Vector2().fromArray(infos.distortion.pps);
	        var disto = new THREE.Vector3().fromArray(infos.distortion.poly357);
	        var r2max = this.getDistortion_r2max(disto);
	        this.distortion = new THREE.Vector4(disto.x, disto.y, disto.z, r2max);
	    }
	    this.mask = infos.mask;
	
	    // change conventions
	    this.orientation = infos.orientation;
	    this._itownsWay = new THREE.Matrix3().set(0, -1, 0, 0, 0, -1, 1, 0, 0);
	
	    this.Photogram_JMM = new THREE.Matrix3().set(0, 0, -1, -1, 0, 0, 0, 1, 0);
	
	    this.photgramme_image = new THREE.Matrix3().set(1, 0, 0, 0, -1, 0, 0, 0, -1);
	
	    this.rotation = this.getMatOrientationTotal();
	    this.position.applyMatrix3(this._itownsWay);
	}; /**
	    * @author AD IGN
	    * Class where we get the Intrinsic parameters of the system.
	    */
	
	Sensor.prototype.getDistortion_r2max = function getDistortion_r2max(disto) {
	    // returned the square of the smallest positive root of the derivativeof the distortion polynomial
	    // which tells where the distortion might no longer be bijective.
	    var roots = this.cardan_cubic_roots(7 * disto.z, 5 * disto.y, 3 * disto.x, 1);
	    var imax = -1;
	    for (var i in roots) {
	        if (roots[i] > 0 && (imax === -1 || roots[imax] > roots[i])) imax = i;
	    }
	    if (imax === -1) return Infinity; // no roots : all is valid !
	    return roots[imax];
	};
	
	// rotation * Photogram_JMM * getMatOrientationCapteur * photgramme_image
	Sensor.prototype.getMatOrientationTotal = function getMatOrientationTotal() {
	    var out = this.rotation.clone();
	    out = new THREE.Matrix3().multiplyMatrices(out.clone(), this.Photogram_JMM.clone());
	
	    out = new THREE.Matrix3().multiplyMatrices(out.clone(), this.getMatOrientationCapteur().clone());
	    out = new THREE.Matrix3().multiplyMatrices(out.clone(), this.photgramme_image.clone());
	
	    out = new THREE.Matrix3().multiplyMatrices(this._itownsWay, out.clone());
	    return out;
	};
	
	Sensor.prototype.getMatOrientationCapteur = function getMatOrientationCapteur() {
	    var ori0 = new THREE.Matrix3().set(0, -1, 0, 1, 0, 0, 0, 0, 1);
	
	    var ori1 = new THREE.Matrix3().set(0, 1, 0, -1, 0, 0, 0, 0, 1);
	
	    var ori2 = new THREE.Matrix3().set(-1, 0, 0, 0, -1, 0, 0, 0, 1);
	
	    var ori3 = new THREE.Matrix3().set(1, 0, 0, 0, 1, 0, 0, 0, 1);
	
	    switch (this.orientation) {
	        case 0:
	            return ori0;
	        case 1:
	            return ori1;
	        case 2:
	            return ori2;
	        case 3:
	        default:
	            return ori3;
	    }
	};
	
	Sensor.prototype.cardan_cubic_roots = function cardan_cubic_roots(a, b, c, d) {
	    // http://fr.wikipedia.org/wiki/Methode_de_Cardan  Thanks Bredif
	    var cardan_cubic_roots = function cardan_cubic_roots(a, b, c, d) {
	        if (a === 0) return quadratic_roots(b, c, d);
	        var vt = -b / (3 * a);
	        var a2 = a * a;
	        var b2 = b * b;
	        var a3 = a * a2;
	        var b3 = b * b2;
	        var p = c / a - b2 / (3 * a2);
	        var q = b3 / (a3 * 13.5) + d / a - b * c / (3 * a2);
	        if (p === 0) {
	            var x = cubic_root(-q) + vt;
	            return [x, x, x];
	        }
	        var p3_4_27 = p * p * p * 4 / 27;
	        var del = q * q + p3_4_27;
	
	        if (del > 0) {
	            var sqrt_del = Math.sqrt(del);
	            var u = cubic_root((-q + sqrt_del) / 2);
	            var v = cubic_root((-q - sqrt_del) / 2);
	            return [u + v + vt];
	        } else if (del === 0) {
	            var z0 = 3 * q / p;
	            var x0 = vt + z0;
	            var x12 = vt - z0 * 0.5;
	            return [x0, x12, x12];
	        } else // (del < 0)
	            {
	                var kos = Math.acos(-q / Math.sqrt(p3_4_27));
	                var r = 2 * Math.sqrt(-p / 3);
	                return [r * Math.cos(kos / 3) + vt, r * Math.cos((kos + Math.PI) / 3) + vt, r * Math.cos((kos + 2 * Math.PI) / 3) + vt];
	            }
	    };
	
	    var quadratic_roots = function quadratic_roots(a, b, c) {
	        var delta = b * b - 4 * a * c;
	        if (delta < 0) return [];
	        var x0 = -b / (2 * a);
	        if (delta === 0) return [x0];
	        var sqr_delta_2a = Math.sqrt(delta) / (2 * a);
	        return [x0 - sqr_delta_2a, x0 + sqr_delta_2a];
	    };
	
	    var sgn = function sgn(x) {
	        return (x > 0) - (x < 0);
	    };
	
	    var cubic_root = function cubic_root(x) {
	        return sgn(x) * Math.pow(Math.abs(x), 1 / 3);
	    };
	
	    return cardan_cubic_roots(a, b, c, d);
	};
	
	exports.default = Sensor;

/***/ },
/* 364 */
/***/ function(module, exports) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	var Shader = {
	
	    shadersURL: null, // shadersURL;
	    shaderNum: null, // shadersURL.length;
	    shaders: {},
	    loaded: false,
	    attributes: {
	        displacementx: {
	            type: 'f', // a float
	            value: [] },
	        displacementy: {
	            type: 'f', // a float
	            value: [] },
	        displacementz: {
	            type: 'f', // a float
	            value: [] },
	        colorattribute: {
	            type: 'v3',
	            value: []
	        },
	        uniqueid: {
	            type: 'i',
	            value: []
	        }
	    },
	
	    uniformslaser: {
	        indice_time_laser: {
	            type: 'f',
	            value: 1
	        },
	        currentidwork: {
	            type: 'f',
	            value: 100.0
	        },
	        point_size: {
	            type: 'f',
	            value: 1.0
	        },
	        alpha: {
	            type: 'f',
	            value: 0.5
	        },
	        colortest: {
	            type: 'v3',
	            value: {}
	        },
	        nb_time: {
	            type: 'i',
	            value: 0
	        }
	    },
	
	    init: function init(shadersURL) {
	        this.shadersURL = shadersURL;
	        this.shaderNum = shadersURL.length;
	    },
	    loadShaders: function loadShaders() {
	        var loadedShaders = 0;
	        var that = this;
	
	        function partialLoading(shaderContent, shaderName) {
	            loadedShaders++;
	            that.shaders[shaderName] = shaderContent;
	
	            // all shader files have been loaded
	            if (loadedShaders === that.shaderNum) {
	                that.loaded = true;
	                // console.log("Shaders are loaded");
	            }
	        }
	
	        var _loop = function _loop(i) {
	            var currentShaderURL = that.shadersURL[i];
	
	            var request = new XMLHttpRequest();
	            request.open('GET', currentShaderURL, true);
	
	            request.onload = function onloadFn() {
	                if (request.status >= 200 && request.status < 400) {
	                    // Success!
	                    partialLoading(request.responseText, currentShaderURL.substr(currentShaderURL.lastIndexOf('/') + 1));
	                } else {
	                    // console.error("Unable to load shader from file" + currentShaderURL);
	                }
	            };
	
	            request.onerror = function onerrorFn() {
	                // console.error("no  connection, Unable to load shader from file" + currentShaderURL);
	            };
	
	            request.send();
	            /*
	             (function(currentShaderURL) {
	                 $.ajax({
	                     url: currentShaderURL,
	                     success: function (data) {
	                         partialLoading($(data).html(),currentShaderURL.substr(currentShaderURL.lastIndexOf('/')+1));
	                     },
	                     dataType: 'html',
	                     error: function () {
	                         console.error("Unable to load shader from file" + currentShaderURL);
	                     }
	                 });
	             })(currentShaderURL);
	            */
	        };
	
	        for (var i = 0; i < that.shaderNum; i++) {
	            _loop(i);
	        }
	    },
	    shaderTextureProjectiveVS: function shaderTextureProjectiveVS(N) {
	        return ['#ifdef GL_ES', 'precision  highp float;', '#endif', '#ifdef USE_LOGDEPTHBUF', '#define EPSILON 1e-6', '#ifdef USE_LOGDEPTHBUF_EXT', 'varying float vFragDepth;', ' #endif', 'uniform float logDepthBufFC;', '#endif', '#define N ' + N, 'uniform int useRTC;', 'uniform mat4 mVPMatRTC;', 'uniform mat3 mvpp[N];', 'uniform vec3 translation[N];', 'varying vec3 v_texcoord[N];', 'vec4 pos;', 'void main() {', '    pos =  vec4(position,1.);', '    for(int i=0; i<N; ++i) v_texcoord[i] = mvpp[i] * (position-translation[i]);', '    mat4 projModelViewMatrix = (useRTC == 0) ? projectionMatrix * modelViewMatrix : mVPMatRTC;', '    gl_Position  =  projModelViewMatrix * pos;', '#ifdef USE_LOGDEPTHBUF', '    gl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;', '    #ifdef USE_LOGDEPTHBUF_EXT', '       vFragDepth = 1.0 + gl_Position.w;', '    #else', '       gl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;', '     #endif', '  #endif', '}'].join('\n');
	    },
	    shaderTextureProjectiveFS: function shaderTextureProjectiveFS(N, idmask, iddisto) {
	        idmask = idmask || [];
	        iddisto = iddisto || [];
	        var M = 0;
	        for (var i = 0; i < idmask.length; ++i) {
	            if (M <= idmask[i]) M = idmask[i] + 1;
	        }
	        var D = 0;
	        for (var _i = 0; _i < iddisto.length; ++_i) {
	            if (D <= iddisto[_i]) D = iddisto[_i] + 1;
	        }
	
	        var mainLoop = '';
	        for (var _i2 = 0; _i2 < N; ++_i2) {
	            var m = idmask[_i2];
	            var d = iddisto[_i2];
	            mainLoop += [
	            // if in front of the camera
	            'if(v_texcoord[' + _i2 + '].z>0.) {',
	            // projective divide to get pixel coordinates
	            '  vec2 p =  v_texcoord[' + _i2 + '].xy/v_texcoord[' + _i2 + '].z;',
	            // apply distortion, if any
	            d >= 0 ? '  distort(p,distortion[' + d + '],pps[' + d + ']);' : '',
	            // get [0,1] texture coordinates and the distance to the texture border, in pixels
	            '  float d = borderfadeoutinv * getUV(p,size[' + _i2 + ']);',
	            // apply mask, if any
	            m >= 0 ? '  d = min(d,1.-texture2D(mask[' + m + '],p).r);' : '',
	            // if still valid sample the texture and accumulate colors and counters
	            '  if(d>0.) { ', '    vec4 c = d*texture2D(texture[' + _i2 + '],p);', '    color0 += c;', '    color  += c * alpha[' + _i2 + '];', '    if(c.a>0.) ++blend;', '  }', '}', ''].join('\n');
	        }
	
	        return ['#ifdef GL_ES', 'precision  highp float;', '#endif', '#ifdef USE_LOGDEPTHBUF', '#define EPSILON 1e-6', '#ifdef USE_LOGDEPTHBUF_EXT', 'varying float vFragDepth;', ' #endif', 'uniform float logDepthBufFC;', '#endif', '#define M ' + M, '#define D ' + D, '#define N ' + N, 'varying vec3      v_texcoord[N];', M > 0 ? 'uniform sampler2D mask[M];' : '', 'uniform sampler2D texture[N];', 'uniform float     alpha[N];', 'uniform vec2      size[N];', D > 0 ? 'uniform vec2      pps[D];' : '', D > 0 ? 'uniform vec4      distortion[D];' : '', 'const float amin = 0.5;', 'const float borderfadeoutinv = 0.02;', // 50 pixel fade out at image borders
	
	        'void distort(inout vec2 p, vec4 dist, vec2 pps)', '{ ', '  vec2 v = p - pps;', '  float v2 = dot(v,v);', '  if(v2>dist.w) p = vec2(-1.);', // (-1,-1) or anything outside of the image
	        '  else p += (v2*(dist.x+v2*(dist.y+v2*dist.z)))*v;', '}', 'float getUV(inout vec2 p, vec2 size)', ' {  ', '   vec2 d = min(p.xy,size-p.xy);', '   p/=size;', '   return min(d.x,d.y);', ' }', ' void main(void)', ' { ', ' #if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)', '        gl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;', '      #endif', '  vec4 color  = vec4(0.);', '  vec4 color0 = vec4(0.);', '  int blend = 0;', mainLoop, '  if(color0.a>1.) color0 /= color0.a;',
	        // if blending 2 images or more with sufficient opacity, return the normalized opaque color
	        // else mix the alpha-weighted color with the non-alpha-weighted color
	        '  gl_FragColor = (blend>1 && color.a>amin) ? color/color.a : color/amin+(1.-color.a/amin)*color0; //vec4(1.,0.,0.,1.); ', '} '].join('\n');
	    },
	
	
	    shaderLaserVS: ['    #ifdef GL_ES ', '    precision mediump float;', '    #endif ', '    attribute vec3 displacement; ', '    attribute float uniqueid; ', '    varying vec3 colorpoint;', '    uniform float point_size;', '    uniform float indice_time_laser;', '    uniform float currentidwork;', '    uniform float indice_time_laser_tab[160];', '    uniform int movementLocked;', '    float getSize(float id){', '      return (0.5 -indice_time_laser_tab[int(id)]) * 15.;', '    }', '    void main()', '    {', '    vec3 newPosition = position;', '    gl_PointSize = point_size;     //2.* clamp(6. - (position.y + 2.), 0., 6.); //getSize(uniqueid);//point_size;', '    if(movementLocked!=1)', '           newPosition = vec3(position.x+ displacement.x*indice_time_laser_tab[int(uniqueid)],', '                              position.y+ displacement.y*indice_time_laser_tab[int(uniqueid)],', '                              position.z+ displacement.z*indice_time_laser_tab[int(uniqueid)]);', '           gl_Position  =  projectionMatrix *  modelViewMatrix * vec4(newPosition,1.);', '          colorpoint = color;', '      }'],
	
	    shaderLaserFS: ['      #ifdef GL_ES ', '        precision mediump float;', '      #endif', '       varying vec3 colorpoint;', '       uniform float alpha;', '       uniform sampler2D texturePoint;', '      void main() ', '       {', '         gl_FragColor = vec4(colorpoint,alpha);', '      }'],
	
	    shaderBati3DVS: ['#ifdef GL_ES', 'precision mediump float;', ' #endif', ' uniform int textureJPG;', ' attribute float materialindice;', ' varying float matindice;', ' varying vec2 vUv;', ' varying vec3 vNormal;', ' varying vec3 pos;', '   void main() {', ' vNormal = normal;', ' vUv = vec2( uv.x, uv.y );', ' if(textureJPG ==1) vUv = vec2(vUv.x, 1.- vUv.y);  ', ' matindice = materialindice;', '     pos = position;', '   gl_Position  =  projectionMatrix *  modelViewMatrix * vec4( position, 1.0 );', '}'],
	
	    shaderBati3DFS: [' #ifdef GL_ES ', ' precision highp float;', ' #endif', ' uniform sampler2D u_textures[16];', '  uniform int textureJPG;', '  uniform float alpha;', ' uniform vec3 light;', '  varying float matindice;', '  varying vec2 vUv;', ' varying vec3 vNormal;', '  varying vec3 pos;', '  vec4 color = vec4(1.,0.,0.,1.);', '  void main(void)', ' {', '         vec2 uv = vUv;', '         if (matindice<0.9)      color = texture2D(u_textures[0],uv);', '         else if (matindice<1.9) color = texture2D(u_textures[1],uv);', '         else if (matindice<2.9) color = texture2D(u_textures[2],uv);', '         else if (matindice<3.9) color = texture2D(u_textures[3],uv);', '         else if (matindice<4.9) color = texture2D(u_textures[4],uv);', '         else if (matindice<5.9) color = texture2D(u_textures[5],uv);', '         else if (matindice<6.9) color = texture2D(u_textures[6],uv);', '         else if (matindice<7.9) color = texture2D(u_textures[7],uv);', '         else if (matindice<8.9) color = texture2D(u_textures[8],uv);', '         else if (matindice<9.9) color = texture2D(u_textures[9],uv);', '         else if (matindice<10.9) color = texture2D(u_textures[10],uv);', '         else if (matindice<11.9) color = texture2D(u_textures[11],uv);', '         else if (matindice<12.9) color = texture2D(u_textures[12],uv);', '         else if (matindice<13.9) color = texture2D(u_textures[13],uv);', '         else if (matindice<14.9) color = texture2D(u_textures[14],uv);', '         else if (matindice<15.9) color = texture2D(u_textures[15],uv);', '         if(color.r == 0. && color.g ==0.) color =  vec4(vUv.x,vUv.x,vUv.x,0.5);',
	    // color =  vec4(matindice/2.,1.,1.,1.);
	    '        else', '               color.a = alpha;', '    gl_FragColor = color; //vec4(1.,1.,0.,1.);//texture2D(u_textures[0],uv);', ' }']
	
	};
	
	exports.default = Shader;

/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _NodeMesh = __webpack_require__(281);
	
	var _NodeMesh2 = _interopRequireDefault(_NodeMesh);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var PanoramicMesh = function PanoramicMesh(geom, mat, absC) {
	    _NodeMesh2.default.call(this);
	
	    this.matrixAutoUpdate = false;
	    this.rotationAutoUpdate = false;
	
	    this.geometry = geom;
	    this.material = mat;
	    this.absoluteCenter = absC;
	    this.position.copy(this.absoluteCenter);
	    this.name = 'terrestrialMesh';
	
	    this.frustumCulled = false;
	
	    // console.log("this.absoluteCenter",this.absoluteCenter);
	}; /**
	    * Generated On: 2015-10-5
	    * Class: PanoramicMesh
	    * PanoramicMesh is using projectiveTextureMaterial to texture geometryProj
	    *
	    */
	
	PanoramicMesh.prototype = (0, _create2.default)(_NodeMesh2.default.prototype);
	PanoramicMesh.prototype.constructor = PanoramicMesh;
	
	PanoramicMesh.prototype.setGeometry = function setGeometry(geom) {
	    this.geometry = geom;
	};
	
	PanoramicMesh.prototype.setMaterial = function setMaterial(mat) {
	    this.material = mat;
	};
	
	PanoramicMesh.prototype.setMatrixRTC = function setMatrixRTC(rtc) {
	    //  console.log(this.material);
	    this.material.uniforms.mVPMatRTC.value = rtc;
	};
	
	PanoramicMesh.prototype.enableRTC = function enableRTC() {
	    //  this.material.enableRTC(enable);
	};
	
	PanoramicMesh.prototype.setFog = function setFog() {
	    //  this.material.setFogDistance(fog);
	};
	
	PanoramicMesh.prototype.setSelected = function setSelected() {
	    //  this.material.setSelected(select);
	};
	
	exports.default = PanoramicMesh;

/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _Style = __webpack_require__(367);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function StyleManager() {
	    this.styles = [];
	} /**
	   * Generated On: 2015-10-5
	   * Class: StyleManager
	   * Description:
	   */
	
	StyleManager.prototype = (0, _create2.default)(StyleManager.prototype);
	
	StyleManager.prototype.constructor = StyleManager;
	
	StyleManager.prototype.getStyles = function getStyles() {
	    return this.styles;
	};
	
	StyleManager.prototype.addStyle = function addStyle(style) {
	    if (style instanceof _Style.Style) {
	        this.styles.push(style);
	    }
	};
	
	StyleManager.prototype.getStyle = function getStyle(idStyle) {
	    return this.styles.filter(function (element) {
	        return element.name === idStyle;
	    }).pop();
	};
	
	StyleManager.prototype.removeStyle = function removeStyle(idStyle) {
	    this.styles = this.styles.filter(function (element) {
	        return element.name === idStyle;
	    });
	};
	
	StyleManager.prototype.updateStyle = function updateStyle() {};
	
	exports.default = StyleManager;

/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/**
	 * Generated On: 2015-10-5
	 * Class: Style
	 * Description: style's Node. style is used to create the material's node
	 */
	
	var STYLE = {
	    // State
	    ST_Active: 0,
	    ST_Selected: 1,
	    ST_Frozen: 2,
	    // Alignement
	    AL_Left: 0,
	    AL_Center: 1,
	    AL_Right: 2
	};
	
	function PaintingTool(color, type) {
	    this.name = null;
	    this.color = color;
	    this.opacity = null;
	    this.visible = true;
	    this.contentType = type;
	
	    this.texture = null;
	    this.position = null;
	    this.scale = null;
	    this.effects = [];
	}
	
	PaintingTool.prototype = (0, _create2.default)(PaintingTool.prototype);
	
	PaintingTool.prototype.constructor = PaintingTool;
	
	PaintingTool.prototype.setTexture = function setTexture(texture) {
	    this.texture = texture;
	};
	
	PaintingTool.prototype.addEffect = function addEffect(effect) {
	    this.effects.push(effect);
	};
	
	function Pen(color) {
	    PaintingTool.call(this, color);
	    this.width = 1;
	}
	
	Pen.prototype = (0, _create2.default)(PaintingTool.prototype);
	
	Pen.prototype.constructor = Pen;
	
	function Font(color) {
	    PaintingTool.call(this, color);
	    // Text alignment, valid values are "Left", "Right" and "Center"
	    this.alignment = STYLE.AL_Left;
	}
	
	Font.prototype = (0, _create2.default)(PaintingTool.prototype);
	
	Font.prototype.constructor = Font;
	
	function Brush() {
	    PaintingTool.call(this);
	}
	
	Brush.prototype = (0, _create2.default)(PaintingTool.prototype);
	
	Brush.prototype.constructor = Brush;
	
	function SurfaceStyle() {
	    Brush.call(this);
	    this.pen = new Pen();
	    this.extrusion = 0;
	    this.colorExtrusion = 0;
	}
	
	SurfaceStyle.prototype = (0, _create2.default)(Brush.prototype);
	
	SurfaceStyle.prototype.constructor = SurfaceStyle;
	
	function TextStyle() {
	    SurfaceStyle.call(this);
	
	    this.font = new Font();
	
	    // Alignement
	    this.alignement = STYLE.AL_Left;
	
	    // The padding around the text for border computation, 1.0 is equal to font size. Default is 0.25
	    this.framePadding = 0.25;
	
	    // Activate a border around the text
	    this.borderEnabled = false;
	}
	
	TextStyle.prototype = (0, _create2.default)(SurfaceStyle.prototype);
	
	TextStyle.prototype.constructor = TextStyle;
	
	function Effect() {
	    this.name = null;
	}
	
	Effect.prototype = (0, _create2.default)(Effect.prototype);
	
	Effect.prototype.constructor = Effect;
	
	function Extrusion() {
	    Effect.call(this);
	
	    this.color = null;
	    this.amount = 0;
	}
	
	Extrusion.prototype = (0, _create2.default)(Effect.prototype);
	
	Extrusion.prototype.constructor = Extrusion;
	
	function Style(name) {
	    this.name = name;
	
	    // Icon
	    this.iconStyle = new SurfaceStyle();
	
	    // Line
	    this.line = new Pen();
	
	    // Surface
	    this.surface = new SurfaceStyle();
	    this.surface.addEffect(new Extrusion());
	
	    // Text
	    this.text = new TextStyle();
	}
	
	Style.prototype = (0, _create2.default)(Style.prototype);
	
	Style.prototype.constructor = Style;
	
	Style.prototype.applyPalette = function applyPalette(palette) {
	    this.line.color = palette.colorLine;
	    this.surface.color = palette.colorLine;
	    this.surface.pen.color = palette.colorLineSurface;
	    this.text.font.color = palette.colorFont;
	    this.surface.effects[0].color = palette.colorExtrusion;
	};
	
	exports.default = Style;

/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _promise = __webpack_require__(224);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _keys = __webpack_require__(369);
	
	var _keys2 = _interopRequireDefault(_keys);
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Provider = __webpack_require__(337);
	
	var _Provider2 = _interopRequireDefault(_Provider);
	
	var _Projection = __webpack_require__(302);
	
	var _Projection2 = _interopRequireDefault(_Projection);
	
	var _CoordWMTS = __webpack_require__(303);
	
	var _CoordWMTS2 = _interopRequireDefault(_CoordWMTS);
	
	var _IoDriver_XBIL = __webpack_require__(338);
	
	var _IoDriver_XBIL2 = _interopRequireDefault(_IoDriver_XBIL);
	
	var _Fetcher = __webpack_require__(340);
	
	var _Fetcher2 = _interopRequireDefault(_Fetcher);
	
	var _CacheRessource = __webpack_require__(341);
	
	var _CacheRessource2 = _interopRequireDefault(_CacheRessource);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var SIZE_TEXTURE_TILE = 256; /**
	                              * Generated On: 2015-10-5
	                              * Class: WMTS_Provider
	                              * Description: Fournisseur de données à travers un flux WMTS
	                              */
	
	function WMTS_Provider(options) {
	    // Constructor
	
	    _Provider2.default.call(this, new _IoDriver_XBIL2.default());
	    this.cache = (0, _CacheRessource2.default)();
	    this.projection = new _Projection2.default();
	    this.support = options.support || false;
	    this.getTextureFloat = null;
	
	    if (this.support) {
	        this.getTextureFloat = function getTextureFloat() {
	            return new THREE.Texture();
	        };
	    } else {
	        this.getTextureFloat = function getTextureFloat(buffer) {
	            // Start float to RGBA uint8
	            // var bufferUint = new Uint8Array(buffer.buffer);
	            // var texture = new THREE.DataTexture(bufferUint, 256, 256);
	
	            var texture = new THREE.DataTexture(buffer, SIZE_TEXTURE_TILE, SIZE_TEXTURE_TILE, THREE.AlphaFormat, THREE.FloatType);
	
	            texture.needsUpdate = true;
	            return texture;
	        };
	    }
	}
	
	WMTS_Provider.prototype = (0, _create2.default)(_Provider2.default.prototype);
	
	WMTS_Provider.prototype.constructor = WMTS_Provider;
	
	WMTS_Provider.prototype.customUrl = function customUrl(layer, url, tilematrix, row, col) {
	    var tm = Math.min(layer.zoom.max, tilematrix);
	
	    var urld = url.replace('%TILEMATRIX', tm.toString());
	    urld = urld.replace('%ROW', row.toString());
	    urld = urld.replace('%COL', col.toString());
	
	    return urld;
	};
	
	WMTS_Provider.prototype.removeLayer = function removeLayer() /* idLayer*/{};
	
	WMTS_Provider.prototype.preprocessDataLayer = function preprocessDataLayer(layer) {
	    layer.fx = layer.fx || 0.0;
	    if (layer.protocol === 'wmtsc') {
	        layer.zoom = {
	            min: 2,
	            max: 20
	        };
	    } else {
	        var options = layer.options;
	        options.version = options.version || '1.0.0';
	        options.tileMatrixSet = options.tileMatrixSet || 'WGS84';
	        options.mimetype = options.mimetype || 'image/png';
	        options.style = options.style || 'normal';
	        options.projection = options.projection || 'EPSG:3857';
	        var newBaseUrl = layer.url + '?LAYER=' + options.name + '&FORMAT=' + options.mimetype + '&SERVICE=WMTS' + '&VERSION=1.0.0' + ('&REQUEST=GetTile&STYLE=normal&TILEMATRIXSET=' + options.tileMatrixSet);
	
	        newBaseUrl += '&TILEMATRIX=%TILEMATRIX&TILEROW=%ROW&TILECOL=%COL';
	        var arrayLimits = (0, _keys2.default)(options.tileMatrixSetLimits);
	
	        var size = arrayLimits.length;
	        var maxZoom = Number(arrayLimits[size - 1]);
	        var minZoom = maxZoom - size + 1;
	
	        layer.zoom = {
	            min: minZoom,
	            max: maxZoom
	        };
	        layer.customUrl = newBaseUrl;
	    }
	};
	
	/**
	 * Return url wmts orthophoto
	 * @param {type} coWMTS
	 * @returns {Object@call;create.urlOrtho.url|String}
	 */
	WMTS_Provider.prototype.url = function url(coWMTS, layer) {
	    return this.customUrl(layer, layer.customUrl, coWMTS.zoom, coWMTS.row, coWMTS.col);
	};
	
	/**
	 * return texture float alpha THREE.js of MNT
	 * @param {type} coWMTS : coord WMTS
	 * @returns {WMTS_Provider_L15.WMTS_Provider.prototype@pro;_IoDriver@call;read@call;then}
	 */
	WMTS_Provider.prototype.getXbilTexture = function getXbilTexture(tile, layer, parameters) {
	    var _this = this;
	
	    var cooWMTS = tile.wmtsCoords[layer.options.tileMatrixSet][0];
	    var pitch = new THREE.Vector3(0.0, 0.0, 1.0);
	
	    if (parameters.ancestor) {
	        // account for possible level offset between coords and tile level
	        // (e.g for PM texture cooWMTS.level = tile.level + 1)
	        var levelOffset = cooWMTS.zoom - tile.level;
	
	        cooWMTS = this.projection.WMTS_WGS84Parent(cooWMTS, this.computeLevelToDownload(tile, parameters.ancestor, layer) + levelOffset, pitch);
	    }
	
	    var url = this.url(cooWMTS, layer);
	
	    // TODO: this is not optimal: if called again before the IoDriver resolves, it'll load the XBIL again
	    var textureCache = this.cache.getRessource(url);
	
	    if (textureCache !== undefined) {
	        var minmax = this._IoDriver.computeMinMaxElevation(textureCache.floatArray, SIZE_TEXTURE_TILE, SIZE_TEXTURE_TILE, pitch);
	        return _promise2.default.resolve({
	            pitch: pitch,
	            texture: textureCache.texture,
	            min: minmax.min,
	            max: minmax.max
	        });
	    }
	
	    // bug #74
	    // var limits = layer.tileMatrixSetLimits[coWMTS.zoom];
	    // if (!limits || !coWMTS.isInside(limits)) {
	    //     var texture = -1;
	    //     this.cache.addRessource(url, texture);
	    //     return Promise.resolve(texture);
	    // }
	    // -> bug #74
	
	    return this._IoDriver.read(url).then(function (result) {
	        result.pitch = pitch;
	        result.texture = _this.getTextureFloat(result.floatArray);
	        result.texture.generateMipmaps = false;
	        result.texture.magFilter = THREE.LinearFilter;
	        result.texture.minFilter = THREE.LinearFilter;
	        _this.cache.addRessource(url, { texture: result.texture, floatArray: result.floatArray });
	
	        return result;
	    });
	};
	
	/**
	 * Return texture RGBA THREE.js of orthophoto
	 * TODO : RGBA --> RGB remove alpha canal
	 * @param {type} coWMTS
	 * @param {type} id
	 * @returns {WMTS_Provider_L15.WMTS_Provider.prototype@pro;ioDriverImage@call;read@call;then}
	 */
	WMTS_Provider.prototype.getColorTexture = function getColorTexture(coWMTS, pitch, layer) {
	    var _this2 = this;
	
	    var result = {
	        pitch: pitch
	    };
	    var url = this.url(coWMTS, layer);
	
	    result.texture = this.cache.getRessource(url);
	
	    if (result.texture !== undefined) {
	        return _promise2.default.resolve(result);
	    }
	
	    var _Fetcher$texture = _Fetcher2.default.texture(url),
	        texture = _Fetcher$texture.texture,
	        promise = _Fetcher$texture.promise;
	
	    result.texture = texture;
	
	    result.texture.generateMipmaps = false;
	    result.texture.magFilter = THREE.LinearFilter;
	    result.texture.minFilter = THREE.LinearFilter;
	    result.texture.anisotropy = 16;
	
	    return promise.then(function () {
	        _this2.cache.addRessource(url, result.texture);
	        result.texture.needsUpdate = true;
	        return result;
	    });
	};
	
	function computeTileWMTSCoordinates(tile, wmtsLayer, projection) {
	    // Are WMTS coordinates ready?
	    if (!tile.wmtsCoords) {
	        tile.wmtsCoords = {};
	    }
	
	    var tileMatrixSet = wmtsLayer.options.tileMatrixSet;
	    if (!(tileMatrixSet in tile.wmtsCoords)) {
	        var tileCoord = projection.WGS84toWMTS(tile.bbox);
	
	        tile.wmtsCoords[tileMatrixSet] = projection.getCoordWMTS_WGS84(tileCoord, tile.bbox, tileMatrixSet);
	    }
	}
	
	WMTS_Provider.prototype.executeCommand = function executeCommand(command) {
	    var layer = command.layer;
	    var tile = command.requester;
	
	    computeTileWMTSCoordinates(tile, layer, this.projection);
	
	    var supportedFormats = {
	        'image/png': this.getColorTextures.bind(this),
	        'image/jpg': this.getColorTextures.bind(this),
	        'image/jpeg': this.getColorTextures.bind(this),
	        'image/x-bil;bits=32': this.getXbilTexture.bind(this)
	    };
	
	    var func = supportedFormats[layer.options.mimetype];
	    if (func) {
	        return func(tile, layer, command);
	    } else {
	        return _promise2.default.reject(new Error('Unsupported mimetype ' + layer.options.mimetype));
	    }
	};
	
	WMTS_Provider.prototype.computeLevelToDownload = function computeLevelToDownload(tile, ancestor, layer) {
	    // Use ancestor's level if valid, else fallback on tile's level
	    var lvl = ancestor ? ancestor.level : tile.level;
	
	    return Math.min(layer.zoom.max, Math.max(layer.zoom.min, lvl));
	};
	
	WMTS_Provider.prototype.tileTextureCount = function tileTextureCount(tile, layer) {
	    computeTileWMTSCoordinates(tile, layer, this.projection);
	
	    var tileMatrixSet = layer.options.tileMatrixSet;
	    return tile.wmtsCoords[tileMatrixSet][1].row - tile.wmtsCoords[tileMatrixSet][0].row + 1;
	};
	
	WMTS_Provider.prototype.tileInsideLimit = function tileInsideLimit(tile, layer) {
	    // This layer provides data starting at level = layer.zoom.min
	    // (the zoom.max property is used when building the url to make
	    //  sure we don't use invalid levels)
	    return layer.zoom.min <= tile.level;
	};
	
	WMTS_Provider.prototype.getColorTextures = function getColorTextures(tile, layer, parameters) {
	    var promises = [];
	    if (tile.material === null) {
	        return _promise2.default.resolve();
	    }
	    // Request parent's texture if no texture at all
	    if (this.tileInsideLimit(tile, layer)) {
	        var bcoord = tile.wmtsCoords[layer.options.tileMatrixSet];
	
	        // WARNING the direction textures is important
	        for (var row = bcoord[1].row; row >= bcoord[0].row; row--) {
	            var cooWMTS = new _CoordWMTS2.default(bcoord[0].zoom, row, bcoord[0].col);
	            var pitch = new THREE.Vector3(0.0, 0.0, 1.0);
	
	            if (parameters.ancestor) {
	                // account for possible level offset between coords and tile level
	                // (e.g for PM texture cooWMTS.level = tile.level + 1)
	                var levelOffset = cooWMTS.zoom - tile.level;
	
	                cooWMTS = this.projection.WMTS_WGS84Parent(cooWMTS, this.computeLevelToDownload(tile, parameters.ancestor, layer) + levelOffset, pitch);
	            }
	
	            promises.push(this.getColorTexture(cooWMTS, pitch, layer));
	        }
	    }
	
	    if (promises.length) {
	        return _promise2.default.all(promises);
	    } else {
	        return _promise2.default.resolve();
	    }
	};
	
	exports.default = WMTS_Provider;

/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = { "default": __webpack_require__(370), __esModule: true };

/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(371);
	module.exports = __webpack_require__(15).Object.keys;

/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	// 19.1.2.14 Object.keys(O)
	var toObject = __webpack_require__(5)
	  , $keys    = __webpack_require__(44);
	
	__webpack_require__(13)('keys', function(){
	  return function keys(it){
	    return $keys(toObject(it));
	  };
	});

/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _promise = __webpack_require__(224);
	
	var _promise2 = _interopRequireDefault(_promise);
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _Provider = __webpack_require__(337);
	
	var _Provider2 = _interopRequireDefault(_Provider);
	
	var _Projection = __webpack_require__(302);
	
	var _Projection2 = _interopRequireDefault(_Projection);
	
	var _BuilderEllipsoidTile = __webpack_require__(373);
	
	var _BuilderEllipsoidTile2 = _interopRequireDefault(_BuilderEllipsoidTile);
	
	var _TileGeometry = __webpack_require__(375);
	
	var _TileGeometry2 = _interopRequireDefault(_TileGeometry);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */
	
	/*
	 * A Faire
	 * Les tuiles de longitude identique ont le maillage et ne demande pas 1 seule calcul pour la génération du maillage
	 *
	 *
	 *
	 *
	 */
	
	function TileProvider() {
	    _Provider2.default.call(this, null);
	
	    this.projection = new _Projection2.default();
	    this.builder = new _BuilderEllipsoidTile2.default(this.projection);
	
	    this.nNode = 0;
	}
	
	TileProvider.prototype = (0, _create2.default)(_Provider2.default.prototype);
	
	TileProvider.prototype.constructor = TileProvider;
	
	TileProvider.prototype.executeCommand = function executeCommand(command) {
	    var bbox = command.bbox;
	
	    var parent = command.requester;
	
	    // build tile
	    var params = {
	        bbox: bbox,
	        level: command.level === undefined ? parent.level + 1 : command.level,
	        segment: 16
	    };
	
	    var geometry = new _TileGeometry2.default(params, this.builder);
	
	    var tile = new command.type(geometry, params);
	
	    tile.setUuid(this.nNode++);
	    tile.link = parent.link;
	    tile.geometricError = Math.pow(2, 18 - params.level);
	
	    parent.worldToLocal(params.center);
	
	    tile.position.copy(params.center);
	    tile.setVisibility(false);
	
	    parent.add(tile);
	    tile.updateMatrix();
	    tile.updateMatrixWorld();
	    tile.OBB().parent = tile; // TODO: we should use tile.add(tile.OBB())
	    tile.OBB().update();
	
	    return _promise2.default.resolve(tile);
	};
	
	exports.default = TileProvider;

/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Coordinates = __webpack_require__(289);
	
	var _OBB = __webpack_require__(374);
	
	var _OBB2 = _interopRequireDefault(_OBB);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function BuilderEllipsoidTile(projector) {
	    this.projector = projector;
	}
	
	BuilderEllipsoidTile.prototype.constructor = BuilderEllipsoidTile;
	
	// prepare params
	// init projected object -> params.projected
	BuilderEllipsoidTile.prototype.Prepare = function Prepare(params) {
	    params.nbRow = Math.pow(2.0, params.level + 1.0);
	
	    var st1 = this.projector.WGS84ToOneSubY(params.bbox.south());
	
	    if (!isFinite(st1)) {
	        st1 = 0;
	    }
	
	    var sizeTexture = 1.0 / params.nbRow;
	
	    var start = st1 % sizeTexture;
	
	    params.deltaUV1 = (st1 - start) * params.nbRow;
	
	    // let's avoid building too much temp objects
	    params.projected = { longitudeRad: 0, latitudeRad: 0 };
	};
	
	// get center tile in cartesian 3D
	BuilderEllipsoidTile.prototype.Center = function Center(params) {
	    params.center = params.bbox.center().as('EPSG:4978').xyz();
	    return params.center;
	};
	
	// get position 3D cartesian
	BuilderEllipsoidTile.prototype.VertexPosition = function VertexPosition(params) {
	    params.cartesianPosition = new _Coordinates.C.EPSG_4326_Radians(params.projected.longitudeRad, params.projected.latitudeRad).as('EPSG:4978');
	    return params.cartesianPosition;
	};
	
	// get normal for last vertex
	BuilderEllipsoidTile.prototype.VertexNormal = function VertexNormal(params) {
	    return params.cartesianPosition.xyz().normalize();
	};
	
	// coord u tile to projected
	BuilderEllipsoidTile.prototype.uProjecte = function uProjecte(u, params) {
	    params.projected.longitudeRad = this.projector.UnitaryToLongitudeWGS84(u, params.bbox);
	};
	
	// coord v tile to projected
	BuilderEllipsoidTile.prototype.vProjecte = function vProjecte(v, params) {
	    params.projected.latitudeRad = this.projector.UnitaryToLatitudeWGS84(v, params.bbox);
	};
	
	// Compute uv 1, if isn't defined the uv1 isn't computed
	BuilderEllipsoidTile.prototype.getUV_PM = function getUV_PM(params) {
	    var t = this.projector.WGS84ToOneSubY(params.projected.latitudeRad) * params.nbRow;
	
	    if (!isFinite(t)) {
	        t = 0;
	    }
	
	    return t - params.deltaUV1;
	};
	
	// get oriented bounding box of tile
	BuilderEllipsoidTile.prototype.OBB = function OBBFn(params) {
	    var cardinals = [];
	
	    var normal = params.center.clone().normalize();
	
	    var bboxDimension = params.bbox.dimensions(_Coordinates.UNIT.RADIAN);
	    var phiStart = params.bbox.west();
	    var phiLength = bboxDimension.x;
	
	    var thetaStart = params.bbox.south();
	    var thetaLength = bboxDimension.y;
	
	    //      0---1---2
	    //      |       |
	    //      7       3
	    //      |       |
	    //      6---5---4
	
	    cardinals.push(new _Coordinates.C.EPSG_4326_Radians(phiStart, thetaStart));
	    cardinals.push(new _Coordinates.C.EPSG_4326_Radians(phiStart + bboxDimension.x * 0.5, thetaStart));
	    cardinals.push(new _Coordinates.C.EPSG_4326_Radians(phiStart + phiLength, thetaStart));
	    cardinals.push(new _Coordinates.C.EPSG_4326_Radians(phiStart + phiLength, thetaStart + bboxDimension.y * 0.5));
	    cardinals.push(new _Coordinates.C.EPSG_4326_Radians(phiStart + phiLength, thetaStart + thetaLength));
	    cardinals.push(new _Coordinates.C.EPSG_4326_Radians(phiStart + bboxDimension.x * 0.5, thetaStart + thetaLength));
	    cardinals.push(new _Coordinates.C.EPSG_4326_Radians(phiStart, thetaStart + thetaLength));
	    cardinals.push(new _Coordinates.C.EPSG_4326_Radians(phiStart, thetaStart + bboxDimension.y * 0.5));
	
	    var cardinals3D = [];
	    var cardin3DPlane = [];
	
	    var maxV = new THREE.Vector3(-1000, -1000, -1000);
	    var minV = new THREE.Vector3(1000, 1000, 1000);
	    var maxHeight = 0;
	    var planeZ = new THREE.Quaternion();
	    var qRotY = new THREE.Quaternion();
	    var vec = new THREE.Vector3();
	    var tangentPlane = new THREE.Plane(normal);
	
	    planeZ.setFromUnitVectors(normal, new THREE.Vector3(0, 1, 0));
	    qRotY.setFromAxisAngle(new THREE.Vector3(0, 1, 0), -params.bbox.center()._values[0]);
	    qRotY.multiply(planeZ);
	
	    for (var i = 0; i < cardinals.length; i++) {
	        cardinals3D.push(cardinals[i].as('EPSG:4978'));
	        cardin3DPlane.push(tangentPlane.projectPoint(cardinals3D[i].xyz()));
	        vec.subVectors(cardinals3D[i].xyz(), params.center);
	        maxHeight = Math.max(maxHeight, cardin3DPlane[i].distanceTo(vec));
	        cardin3DPlane[i].applyQuaternion(qRotY);
	        maxV.max(cardin3DPlane[i]);
	        minV.min(cardin3DPlane[i]);
	    }
	
	    maxHeight *= 0.5;
	    var width = Math.abs(maxV.z - minV.z) * 0.5;
	    var height = Math.abs(maxV.x - minV.x) * 0.5;
	    var delta = height - Math.abs(cardin3DPlane[5].x);
	    var max = new THREE.Vector3(width, height, maxHeight);
	    var min = new THREE.Vector3(-width, -height, -maxHeight);
	
	    var translate = new THREE.Vector3(0, delta, -maxHeight);
	    var obb = new _OBB2.default(min, max, normal, translate);
	
	    return obb;
	};
	
	exports.default = BuilderEllipsoidTile;

/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function OBB(min, max, lookAt, translate) {
	    THREE.Object3D.call(this);
	    this.box3D = new THREE.Box3(min, max);
	
	    this.natBox = this.box3D.clone();
	
	    this.quaInv = this.quaternion.clone().inverse();
	
	    if (lookAt) {
	        this.lookAt(lookAt);
	    }
	
	    if (translate) {
	        this.translateX(translate.x);
	        this.translateY(translate.y);
	        this.translateZ(translate.z);
	    }
	
	    this.oPosition = new THREE.Vector3();
	
	    this.update();
	
	    this.oPosition = this.position.clone();
	} /*
	   * To change this license header, choose License Headers in Project Properties.
	   * To change this template file, choose Tools | Templates
	   * and open the template in the editor.
	   */
	
	OBB.prototype = (0, _create2.default)(THREE.Object3D.prototype);
	OBB.prototype.constructor = OBB;
	
	OBB.prototype.update = function update() {
	    this.updateMatrix();
	    this.updateMatrixWorld();
	
	    this.quaInv = this.quaternion.clone().inverse();
	
	    this.pointsWorld = this.cPointsWorld(this.points());
	};
	
	OBB.prototype.inverseQuaternion = function inverseQuaternion() {
	    return this.quaInv;
	};
	
	OBB.prototype.addHeight = function addHeight(bbox) {
	    var depth = Math.abs(this.natBox.min.z - this.natBox.max.z);
	    //
	    this.box3D.min.z = this.natBox.min.z + bbox.bottom();
	    this.box3D.max.z = this.natBox.max.z + bbox.top();
	
	    // TODO à vérifier --->
	
	    var nHalfSize = Math.abs(this.box3D.min.z - this.box3D.max.z) * 0.5;
	    var translaZ = this.box3D.min.z + nHalfSize;
	    this.box3D.min.z = -nHalfSize;
	    this.box3D.max.z = nHalfSize;
	
	    this.position.copy(this.oPosition);
	    //    this.updateMatrix();
	    //    this.updateMatrixWorld(true);
	
	    this.translateZ(translaZ);
	
	    this.update();
	
	    return new THREE.Vector2(nHalfSize - depth * 0.5, translaZ);
	
	    // TODO <---- à vérifier
	};
	
	OBB.prototype.points = function points() {
	    var points = [new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3(), new THREE.Vector3()];
	
	    points[0].set(this.box3D.min.x, this.box3D.min.y, this.box3D.min.z);
	    points[1].set(this.box3D.min.x, this.box3D.min.y, this.box3D.max.z);
	    points[2].set(this.box3D.min.x, this.box3D.max.y, this.box3D.min.z);
	    points[3].set(this.box3D.min.x, this.box3D.max.y, this.box3D.max.z);
	    points[4].set(this.box3D.max.x, this.box3D.min.y, this.box3D.min.z);
	    points[5].set(this.box3D.max.x, this.box3D.min.y, this.box3D.max.z);
	    points[6].set(this.box3D.max.x, this.box3D.max.y, this.box3D.min.z);
	    points[7].set(this.box3D.max.x, this.box3D.max.y, this.box3D.max.z);
	
	    return points;
	};
	
	OBB.prototype.cPointsWorld = function cPointsWorld(points) {
	    var m = this.matrixWorld;
	
	    for (var i = 0, max = points.length; i < max; i++) {
	        points[i].applyMatrix4(m);
	    }
	
	    return points;
	};
	
	exports.default = OBB;

/***/ },
/* 375 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _CacheRessource = __webpack_require__(341);
	
	var _CacheRessource2 = _interopRequireDefault(_CacheRessource);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	// TODO Why? it's not necessary
	
	/* global  Uint32Array */
	
	/**
	 * Generated On: 2015-10-5
	 * Class: TileGeometry
	 * Description: Tuile géométrique. Buffer des vertex et des faces
	 */
	/* global Float32Array*/
	var cache = (0, _CacheRessource2.default)(); // TODO /!\ singleton
	
	
	function Buffers() {
	    this.index = null;
	    this.position = null;
	    this.normal = null;
	    // 2 UV set per tile: wgs84 and pm
	    //    - wgs84: 1 texture per tile because tiles are using wgs84 projection
	    //    - pm: use multiple textures per tile.
	    //      +-------------------------+
	    //      |                         |
	    //      |     Texture 0           |
	    //      +-------------------------+
	    //      |                         |
	    //      |     Texture 1           |
	    //      +-------------------------+
	    //      |                         |
	    //      |     Texture 2           |
	    //      +-------------------------+
	    //        * u = wgs84.u
	    //        * v = textureid + v in this texture
	    this.uv = {
	        wgs84: null,
	        pm: null
	    };
	}
	
	function TileGeometry(params, builder) {
	    // Constructor
	    THREE.BufferGeometry.call(this);
	
	    this.center = builder.Center(params);
	    this.OBB = builder.OBB(params);
	
	    // TODO : free array
	
	    var bufferAttribs = this.computeBuffers(params, builder);
	
	    this.setIndex(bufferAttribs.index);
	    this.addAttribute('position', bufferAttribs.position);
	    this.addAttribute('normal', bufferAttribs.normal);
	    this.addAttribute('uv_wgs84', bufferAttribs.uv.wgs84);
	    this.addAttribute('uv_pm', bufferAttribs.uv.pm);
	
	    bufferAttribs.position = null;
	    bufferAttribs.normal = null;
	    bufferAttribs.uv.pm = null;
	
	    // Update cache
	    if (!cache.getRessource(params.segment)) {
	        cache.addRessource(params.segment, bufferAttribs);
	    }
	
	    // ---> for SSE
	    this.computeBoundingSphere();
	}
	
	TileGeometry.prototype = (0, _create2.default)(THREE.BufferGeometry.prototype);
	
	TileGeometry.prototype.constructor = TileGeometry;
	
	TileGeometry.prototype.computeBuffers = function computeBuffers(params, builder) {
	    // Create output buffers.
	    var outBuffers = new Buffers();
	    // Create temp buffers
	    var scratchBuffers = new Buffers();
	
	    var nSeg = params.segment || 32;
	    var nVertex = (nSeg + 1) * (nSeg + 1) + 8 * (nSeg - 1); // correct pour uniquement les vertex
	    var triangles = nSeg * nSeg + 16 * (nSeg - 1); // correct pour uniquement les vertex
	
	    scratchBuffers.position = new Float32Array(nVertex * 3);
	    scratchBuffers.normal = new Float32Array(nVertex * 3);
	    scratchBuffers.uv.pm = new Float32Array(nVertex);
	
	    // Read previously cached values
	    var cachedBuffers = cache.getRessource(params.segment);
	    if (cachedBuffers) {
	        outBuffers.index = cachedBuffers.index;
	        outBuffers.uv.wgs84 = cachedBuffers.uv.wgs84;
	    } else {
	        scratchBuffers.index = new Uint32Array(triangles * 3 * 2);
	        scratchBuffers.uv.wgs84 = new Float32Array(nVertex * 2);
	    }
	
	    var widthSegments = Math.max(2, Math.floor(nSeg) || 2);
	    var heightSegments = Math.max(2, Math.floor(nSeg) || 2);
	
	    var idVertex = 0;
	    var x = void 0;
	    var y = void 0;
	    var vertices = [];
	    var skirt = [];
	    var skirtEnd = [];
	    var u = void 0;
	    var v = void 0;
	
	    builder.Prepare(params);
	
	    var UV_WGS84 = function UV_WGS84() {};
	    var UV_PM = function UV_PM() {};
	
	    // Define UV computation functions if needed
	    if (outBuffers.uv.wgs84 === null) {
	        UV_WGS84 = function UV_WGS84(out, id, u, v) {
	            out.uv.wgs84[id * 2 + 0] = u;
	            out.uv.wgs84[id * 2 + 1] = v;
	        };
	    }
	    if (outBuffers.uv.pm === null && builder.getUV_PM) {
	        UV_PM = function UV_PM(out, id, u) {
	            out.uv.pm[id] = u;
	        };
	    }
	
	    var id_m3 = void 0;
	    var v1 = void 0;
	    var v2 = void 0;
	    var v3 = void 0;
	    var v4 = void 0;
	
	    for (y = 0; y <= heightSegments; y++) {
	        var verticesRow = [];
	
	        v = y / heightSegments;
	
	        builder.vProjecte(v, params);
	
	        var uv_pm = builder.getUV_PM ? builder.getUV_PM(params) : undefined;
	
	        for (x = 0; x <= widthSegments; x++) {
	            u = x / widthSegments;
	
	            builder.uProjecte(u, params);
	
	            var vertex = builder.VertexPosition(params, params.projected);
	
	            id_m3 = idVertex * 3;
	
	            scratchBuffers.position[id_m3 + 0] = vertex.x() - this.center.x;
	            scratchBuffers.position[id_m3 + 1] = vertex.y() - this.center.y;
	            scratchBuffers.position[id_m3 + 2] = vertex.z() - this.center.z;
	
	            var normal = builder.VertexNormal(params);
	
	            scratchBuffers.normal[id_m3 + 0] = normal.x;
	            scratchBuffers.normal[id_m3 + 1] = normal.y;
	            scratchBuffers.normal[id_m3 + 2] = normal.z;
	
	            UV_WGS84(scratchBuffers, idVertex, u, v);
	            UV_PM(scratchBuffers, idVertex, uv_pm);
	
	            if (y !== 0 && y !== heightSegments) {
	                if (x === widthSegments) {
	                    skirt.push(idVertex);
	                } else if (x === 0) {
	                    skirtEnd.push(idVertex);
	                }
	            }
	
	            verticesRow.push(idVertex);
	
	            idVertex++;
	        }
	
	        vertices.push(verticesRow);
	
	        if (y === 0) {
	            skirt = skirt.concat(verticesRow);
	        } else if (y === heightSegments) {
	            skirt = skirt.concat(verticesRow.slice().reverse());
	        }
	    }
	
	    skirt = skirt.concat(skirtEnd.reverse());
	
	    function bufferize(va, vb, vc, idVertex) {
	        scratchBuffers.index[idVertex + 0] = va;
	        scratchBuffers.index[idVertex + 1] = vb;
	        scratchBuffers.index[idVertex + 2] = vc;
	        return idVertex + 3;
	    }
	
	    var idVertex2 = 0;
	
	    if (outBuffers.index === null) {
	        for (y = 0; y < heightSegments; y++) {
	            for (x = 0; x < widthSegments; x++) {
	                v1 = vertices[y][x + 1];
	                v2 = vertices[y][x];
	                v3 = vertices[y + 1][x];
	                v4 = vertices[y + 1][x + 1];
	
	                idVertex2 = bufferize(v4, v2, v1, idVertex2);
	                idVertex2 = bufferize(v4, v3, v2, idVertex2);
	            }
	        }
	    }
	
	    var iStart = idVertex;
	
	    // TODO: WARNING beware skirt's size influences performance
	    // Fix Me: Compute correct the skirt's size : minimize the size without crack between tiles
	    // This size must be take into account the bbox's size
	    // For the moment, I reduce the size to increase performance (pixel shader performance)
	
	    var r = 5 * (20 - params.level + 10);
	
	    var buildIndexSkirt = function buildIndexSkirt() {};
	    var buildUVSkirt = function buildUVSkirt() {};
	
	    if (outBuffers.index === null) {
	        buildIndexSkirt = function buildIndexSkirt(id, v1, v2, v3, v4) {
	            id = bufferize(v1, v2, v3, id);
	            id = bufferize(v1, v3, v4, id);
	            return id;
	        };
	
	        buildUVSkirt = function buildUVSkirt(id) {
	            scratchBuffers.uv.wgs84[idVertex * 2 + 0] = scratchBuffers.uv.wgs84[id * 2 + 0];
	            scratchBuffers.uv.wgs84[idVertex * 2 + 1] = scratchBuffers.uv.wgs84[id * 2 + 1];
	        };
	    }
	
	    for (var i = 0; i < skirt.length; i++) {
	        var id = skirt[i];
	        id_m3 = idVertex * 3;
	        var id2_m3 = id * 3;
	
	        scratchBuffers.position[id_m3 + 0] = scratchBuffers.position[id2_m3 + 0] - scratchBuffers.normal[id2_m3 + 0] * r;
	        scratchBuffers.position[id_m3 + 1] = scratchBuffers.position[id2_m3 + 1] - scratchBuffers.normal[id2_m3 + 1] * r;
	        scratchBuffers.position[id_m3 + 2] = scratchBuffers.position[id2_m3 + 2] - scratchBuffers.normal[id2_m3 + 2] * r;
	
	        scratchBuffers.normal[id_m3 + 0] = scratchBuffers.normal[id2_m3 + 0];
	        scratchBuffers.normal[id_m3 + 1] = scratchBuffers.normal[id2_m3 + 1];
	        scratchBuffers.normal[id_m3 + 2] = scratchBuffers.normal[id2_m3 + 2];
	
	        buildUVSkirt(id);
	
	        scratchBuffers.uv.pm[idVertex] = scratchBuffers.uv.pm[id];
	
	        var idf = (i + 1) % skirt.length;
	
	        v1 = id;
	        v2 = idVertex;
	        v3 = idVertex + 1;
	        v4 = skirt[idf];
	
	        if (idf === 0) {
	            v3 = iStart;
	        }
	
	        idVertex2 = buildIndexSkirt(idVertex2, v1, v2, v3, v4);
	
	        idVertex++;
	    }
	
	    // Copy missing buffer in outBuffers from scratchBuffers
	    // TODO : free array
	    if (outBuffers.index === null) {
	        outBuffers.index = new THREE.BufferAttribute(scratchBuffers.index, 1);
	    }
	    outBuffers.position = new THREE.BufferAttribute(scratchBuffers.position, 3);
	    outBuffers.normal = new THREE.BufferAttribute(scratchBuffers.normal, 3);
	    if (outBuffers.uv.wgs84 === null) {
	        outBuffers.uv.wgs84 = new THREE.BufferAttribute(scratchBuffers.uv.wgs84, 2);
	    }
	    outBuffers.uv.pm = new THREE.BufferAttribute(scratchBuffers.uv.pm, 1);
	
	    scratchBuffers.position = null;
	    scratchBuffers.bufferIndex = null;
	    scratchBuffers.normal = null;
	    scratchBuffers.uv.wgs84 = null;
	    scratchBuffers.uv.pm = null;
	
	    return outBuffers;
	};
	
	exports.default = TileGeometry;

/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	exports.default = loadGpx;
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _Fetcher = __webpack_require__(340);
	
	var _Fetcher2 = _interopRequireDefault(_Fetcher);
	
	var _Coordinates = __webpack_require__(289);
	
	var _Coordinates2 = _interopRequireDefault(_Coordinates);
	
	var _ItownsLine = __webpack_require__(377);
	
	var _ItownsLine2 = _interopRequireDefault(_ItownsLine);
	
	var _ItownsPoint = __webpack_require__(381);
	
	var _ItownsPoint2 = _interopRequireDefault(_ItownsPoint);
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _gpxToWayPointsArray(gpxXML) {
	    return gpxXML.getElementsByTagName('wpt');
	} /**
	   * Generated On: 2016-07-07
	   * Class: GpxUtils
	   * Description: Parse Gpx file to get [lat, lon, alt]
	   */
	
	function _gGpxToWTrackPointsArray(gpxXML) {
	    return gpxXML.getElementsByTagName('trkpt');
	}
	
	function _gpxPtToCartesian(pt) {
	    var longitude = Number(pt.attributes.lon.nodeValue);
	    var latitude = Number(pt.attributes.lat.nodeValue);
	    var elevation = Number(pt.getElementsByTagName('ele')[0].childNodes[0].nodeValue);
	
	    return new _Coordinates2.default('EPSG:4326', longitude, latitude, elevation).as('EPSG:4978').xyz();
	}
	
	function _gpxToWayPointsMesh(gpxXML) {
	    var wayPts = _gpxToWayPointsArray(gpxXML);
	
	    if (wayPts.length) {
	        var colorPoint = new THREE.Color('rgb(0, 255, 0)');
	        var points = new _ItownsPoint2.default({
	            time: 1.0,
	            useTexture: false,
	            texture: 'data/strokes/pstar1.png',
	            color: [colorPoint.r, colorPoint.g, colorPoint.b],
	            opacity: 1.0
	        });
	
	        for (var i = 0; i < wayPts.length; i++) {
	            points.addPoint(_gpxPtToCartesian(wayPts[i]), colorPoint, 600.0);
	        }
	
	        points.process();
	
	        return points;
	    } else {
	        return null;
	    }
	}
	
	function _gpxToWTrackPointsMesh(gpxXML) {
	    var trackPts = _gGpxToWTrackPointsArray(gpxXML);
	
	    if (trackPts.length) {
	        var colorLine = new THREE.Color('rgb(255, 0, 0)');
	        var line = new _ItownsLine2.default({
	            time: 1.0,
	            linewidth: 100.0,
	            texture: 'data/strokes/hway1.png',
	            useTexture: false,
	            opacity: 1.0,
	            sizeAttenuation: 1.0,
	            color: [colorLine.r, colorLine.g, colorLine.b]
	        });
	
	        for (var k = 0; k < trackPts.length; k++) {
	            line.addPoint(_gpxPtToCartesian(trackPts[k]));
	        }
	
	        line.process();
	
	        return line;
	    } else {
	        return null;
	    }
	}
	
	function _gpxToMesh(gpxXML) {
	    if (!gpxXML) {
	        return undefined;
	    }
	
	    var gpxMesh = new THREE.Object3D();
	
	    // Getting the track points
	    var trackPts = _gpxToWTrackPointsMesh(gpxXML);
	
	    if (trackPts) {
	        gpxMesh.add(trackPts);
	    }
	
	    // Getting the waypoint points
	    var wayPts = _gpxToWayPointsMesh(gpxXML);
	
	    if (wayPts) {
	        gpxMesh.add(wayPts);
	    }
	
	    return gpxMesh;
	}
	
	function loadGpx(urlFile) {
	    return _Fetcher2.default.xml(urlFile).then(function (gpxXML) {
	        return _gpxToMesh(gpxXML);
	    });
	}

/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _ItownsLineMaterial = __webpack_require__(378);
	
	var _ItownsLineMaterial2 = _interopRequireDefault(_ItownsLineMaterial);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ItownsLine = function ItownsLine(options) {
	    THREE.Mesh.call(this);
	
	    this.positions = [];
	    this.previous = [];
	    this.next = [];
	    this.side = [];
	    this.width = [];
	    this.indices_array = [];
	    this.uvs = [];
	
	    this.geometry = new THREE.BufferGeometry();
	    this.material = new _ItownsLineMaterial2.default(options);
	    this.widthCallback = null;
	};
	
	ItownsLine.prototype = (0, _create2.default)(THREE.Mesh.prototype);
	ItownsLine.prototype.constructor = ItownsLine;
	
	ItownsLine.prototype.setGeometry = function setGeometry(g, c) {
	    this.widthCallback = c;
	    this.positions = [];
	
	    var j;
	
	    if (g instanceof THREE.Geometry) {
	        for (j = 0; j < g.vertices.length; j++) {
	            var v = g.vertices[j];
	            this.positions.push(v.x, v.y, v.z);
	            this.positions.push(v.x, v.y, v.z);
	        }
	    }
	
	    if (g instanceof THREE.BufferGeometry) {
	        // read attribute positions ?
	    }
	
	    if (g instanceof Float32Array || g instanceof Array) {
	        for (j = 0; j < g.length; j += 3) {
	            this.positions.push(g[j], g[j + 1], g[j + 2]);
	            this.positions.push(g[j], g[j + 1], g[j + 2]);
	        }
	    }
	
	    this.process();
	};
	
	ItownsLine.prototype.addPoint = function addPoint(v) {
	    if (v instanceof THREE.Vector3) {
	        this.positions.push(v.x, v.y, v.z);
	        this.positions.push(v.x, v.y, v.z);
	    }
	};
	
	ItownsLine.prototype.compareV3 = function compareV3(a, b) {
	    var aa = a * 6;
	    var ab = b * 6;
	    return this.positions[aa] === this.positions[ab] && this.positions[aa + 1] === this.positions[ab + 1] && this.positions[aa + 2] === this.positions[ab + 2];
	};
	
	ItownsLine.prototype.copyV3 = function copyV3(a) {
	    var aa = a * 6;
	    return [this.positions[aa], this.positions[aa + 1], this.positions[aa + 2]];
	};
	
	ItownsLine.prototype.process = function process() {
	    var l = this.positions.length / 6;
	
	    this.previous = [];
	    this.next = [];
	    this.side = [];
	    this.width = [];
	    this.indices_array = [];
	    this.uvs = [];
	
	    var j;
	
	    for (j = 0; j < l; j++) {
	        this.side.push(1);
	        this.side.push(-1);
	    }
	
	    var w;
	    for (j = 0; j < l; j++) {
	        if (this.widthCallback) w = this.widthCallback(j / (l - 1));else w = 1;
	        this.width.push(w);
	        this.width.push(w);
	    }
	
	    for (j = 0; j < l; j++) {
	        this.uvs.push(j / (l - 1), 0);
	        this.uvs.push(j / (l - 1), 1);
	    }
	
	    var v;
	
	    if (this.compareV3(0, l - 1)) {
	        v = this.copyV3(l - 2);
	    } else {
	        v = this.copyV3(0);
	    }
	
	    this.previous.push(v[0], v[1], v[2]);
	    this.previous.push(v[0], v[1], v[2]);
	
	    for (j = 0; j < l - 1; j++) {
	        v = this.copyV3(j);
	        this.previous.push(v[0], v[1], v[2]);
	        this.previous.push(v[0], v[1], v[2]);
	    }
	
	    for (j = 1; j < l; j++) {
	        v = this.copyV3(j);
	        this.next.push(v[0], v[1], v[2]);
	        this.next.push(v[0], v[1], v[2]);
	    }
	
	    if (this.compareV3(l - 1, 0)) {
	        v = this.copyV3(1);
	    } else {
	        v = this.copyV3(l - 1);
	    }
	
	    this.next.push(v[0], v[1], v[2]);
	    this.next.push(v[0], v[1], v[2]);
	
	    for (j = 0; j < l - 1; j++) {
	        var n = j * 2;
	        this.indices_array.push(n, n + 1, n + 2);
	        this.indices_array.push(n + 2, n + 1, n + 3);
	    }
	
	    this.geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(this.positions), 3));
	    this.geometry.addAttribute('previous', new THREE.BufferAttribute(new Float32Array(this.previous), 3));
	    this.geometry.addAttribute('next', new THREE.BufferAttribute(new Float32Array(this.next), 3));
	    this.geometry.addAttribute('side', new THREE.BufferAttribute(new Float32Array(this.side), 1));
	    this.geometry.addAttribute('width', new THREE.BufferAttribute(new Float32Array(this.width), 1));
	    this.geometry.addAttribute('uv', new THREE.BufferAttribute(new Float32Array(this.uvs), 2));
	    this.geometry.setIndex(new THREE.BufferAttribute(new Uint16Array(this.indices_array), 1));
	};
	
	ItownsLine.prototype.createQuad = function createQuad(pt1, pt2) {
	    // Définition propre a chaque géométrie
	    var geometry = new THREE.BufferGeometry();
	
	    // les 6 points
	    var vertices = new Float32Array([pt1.x, pt1.y, pt1.z, // -1
	    pt2.x, pt2.y, pt2.z, // -1
	    pt2.x, pt2.y, pt2.z, //  1
	
	    pt2.x, pt2.y, pt2.z, //  1
	    pt1.x, pt1.y, pt1.z, //  1
	    pt1.x, pt1.y, pt1.z]);
	
	    // pour chacun des six points, le point opposé correspondant
	    var vertices2 = new Float32Array([pt2.x, pt2.y, pt2.z, pt1.x, pt1.y, pt1.z, pt1.x, pt1.y, pt1.z, pt1.x, pt1.y, pt1.z, pt2.x, pt2.y, pt2.z, pt2.x, pt2.y, pt2.z]);
	
	    geometry.addAttribute('position', new THREE.BufferAttribute(vertices, 3));
	    // geometry.setIndex( new THREE.BufferAttribute( indices, 1 ) );
	    geometry.addAttribute('position2', new THREE.BufferAttribute(vertices2, 3));
	
	    var uv = new Float32Array([-1, -1, 1, -1, 1, 1, 1, 1, -1, 1, -1, -1]);
	
	    geometry.addAttribute('uv', new THREE.BufferAttribute(uv, 2));
	
	    return geometry;
	};
	
	ItownsLine.prototype.createSegments = function createSegments(pt1, pt2, pt3) {
	    // Définition propre a chaque géométrie
	    var geometry = new THREE.BufferGeometry();
	    var point1 = new Float32Array([pt1.x, pt1.y, pt1.z]);
	
	    var point2 = new Float32Array([pt2.x, pt2.y, pt2.z]);
	
	    var point3 = new Float32Array([pt3.x, pt3.y, pt3.z]);
	
	    geometry.addAttribute('previousPoint', new THREE.BufferAttribute(point1, 3));
	    geometry.addAttribute('position', new THREE.BufferAttribute(point2, 3));
	    geometry.addAttribute('nextPoint', new THREE.BufferAttribute(point3, 3));
	    return geometry;
	};
	
	exports.default = ItownsLine;

/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	  value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _BasicMaterial = __webpack_require__(323);
	
	var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);
	
	var _LineVS = __webpack_require__(379);
	
	var _LineVS2 = _interopRequireDefault(_LineVS);
	
	var _LineFS = __webpack_require__(380);
	
	var _LineFS2 = _interopRequireDefault(_LineFS);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	/*
	 * To change this license header, choose License Headers in Project Properties.
	 * To change this template file, choose Tools | Templates
	 * and open the template in the editor.
	 */
	
	var ItownsLineMaterial = function ItownsLineMaterial(options) {
	  _BasicMaterial2.default.call(this);
	
	  if (options === undefined) {
	    throw new Error('options is required');
	  }
	
	  this.vertexShader = _LineVS2.default;
	  this.fragmentShader = _LineFS2.default;
	
	  this.wireframe = false;
	
	  var texture = new THREE.TextureLoader().load(options.texture);
	
	  this.uniforms.time = { value: options.time };
	  this.uniforms.THICKNESS = { value: options.linewidth };
	  this.uniforms.MITER_LIMIT = { value: 1.0 };
	  this.uniforms.WIN_SCALE = { value: new THREE.Vector2(window.innerWidth, window.innerHeight) };
	  this.uniforms.texture = { type: 't', value: texture };
	  this.uniforms.useTexture = { value: options.useTexture };
	  this.uniforms.opacity = { type: 'f', value: options.opacity };
	  this.uniforms.sizeAttenuation = { type: 'f', value: options.sizeAttenuation };
	  this.uniforms.color = { type: 'v3', value: options.color };
	
	  this.transparent = true;
	};
	
	ItownsLineMaterial.prototype = (0, _create2.default)(_BasicMaterial2.default.prototype);
	ItownsLineMaterial.prototype.constructor = ItownsLineMaterial;
	
	exports.default = ItownsLineMaterial;

/***/ },
/* 379 */
/***/ function(module, exports) {

	module.exports = "#version 100\n\nprecision highp float;\nprecision highp int;\n\n//#define SHADER_NAME LineShaderMaterial\n\n#define USE_LOGDEPTHBUF\n#define USE_LOGDEPTHBUF_EXT\n\n#ifdef USE_LOGDEPTHBUF\n\n    #define EPSILON 1e-6\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\n\nattribute vec3  position;\nattribute vec3  previous;\nattribute vec3  next;\n\nattribute float side;\nattribute float width;\nattribute vec2 uv;\n\n\nuniform mat4   projectionMatrix;\nuniform mat4   modelViewMatrix;\n\nuniform float\tTHICKNESS;\t// the thickness of the line in pixels\nuniform float\tMITER_LIMIT;\t// 1.0: always miter, -1.0: never miter, 0.75: default\nuniform vec2\tWIN_SCALE;\t// the size of the viewport in pixels\n\nuniform float opacity;\nuniform float sizeAttenuation;\nuniform vec3 color;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying vec3 vPosition;\n\n\nvec2 screen_space(vec4 vertex)\n{\n\treturn vec2( vertex.xy / vertex.w ) * WIN_SCALE;\n}\n\nvec2 fix( vec4 i, float aspect ) {\n    vec2 res = i.xy / i.w;\n    res.x *= aspect;\n    return res;\n}\n\nvoid main() {\n\n                float aspect = WIN_SCALE.x / WIN_SCALE.y;\n        \tfloat pixelWidthRatio = 1. / (WIN_SCALE.x * projectionMatrix[0][0]);\n                vColor = vec4( color, opacity );\n                vUV = uv;\n\n\t\tvec4 projectedPrePoint = projectionMatrix * modelViewMatrix * vec4(previous,1.0);\n\t\tvec4 projectedCurPoint = projectionMatrix * modelViewMatrix *vec4(position,1.0);\n\t\tvec4 projectedNextPoint = projectionMatrix * modelViewMatrix *vec4(next,1.0);\n\n                #ifdef USE_LOGDEPTHBUF\n\n                    projectedPrePoint.z = log2(max( EPSILON, projectedPrePoint.w + 1.0 )) * logDepthBufFC;\n                    projectedCurPoint.z = log2(max( EPSILON, projectedCurPoint.w + 1.0 )) * logDepthBufFC;\n                    projectedNextPoint.z = log2(max( EPSILON, projectedNextPoint.w + 1.0 )) * logDepthBufFC;\n\n                    #ifdef USE_LOGDEPTHBUF_EXT\n\n                        vFragDepth = 1.0 + gl_Position.w;\n\n                    #else\n\n                        projectedPrePoint.z = (projectedPrePoint.z - 1.0) * projectedPrePoint.w;\n                        projectedCurPoint.z = (projectedCurPoint.z - 1.0) * projectedCurPoint.w;\n                        projectedNextPoint.z = (projectedNextPoint.z - 1.0) * projectedNextPoint.w;\n\n                    #endif\n\n                #endif\n\n                \n                vec2 previousScreen = fix( projectedPrePoint,aspect );\t// start of previous segment\n                vec2 currentScreen = fix( projectedCurPoint ,aspect);\t// end of previous segment, start of current segment\n                vec2 nextScreen = fix( projectedNextPoint ,aspect);\t// end of current segment, start of next segment\n\n\n                float pixelWidth = projectedCurPoint.w * pixelWidthRatio;\n                float w = 1.8*pixelWidth * THICKNESS * width;\n\n                if(sizeAttenuation == 1.0) {\n                        w = 1.8 * THICKNESS * width;\n                }\n\n                //starting point uses (next - current)\n                vec2 dir = vec2(0.0);\n                //float len = THICKNESS;\n\n                if (currentScreen == previousScreen) {\n                        dir = normalize(nextScreen - currentScreen);\n                } \n                //ending point uses (current - previous)\n                else if (currentScreen == nextScreen) {\n                       dir = normalize(currentScreen - previousScreen);\n                }\n                //somewhere in middle, needs a join\n                else {\n                         //get directions from (C - B) and (B - A)\n                         vec2 dirA = normalize((currentScreen - previousScreen));\n                         if (MITER_LIMIT == 1.0) {\n                                vec2 dirB = normalize(nextScreen - currentScreen);\n                                //now compute the miter join normal and length\n                                vec2 tangent = normalize(dirA + dirB);\n                                vec2 perp = vec2(-dirA.y, dirA.x);\n                                vec2 miter = vec2(-tangent.y, tangent.x);\n                                dir = tangent;\n                                //len = THICKNESS / dot(miter, perp);\n                                //w = clamp( w / dot( miter, perp ), 0., 4. * THICKNESS * width );\n                        } else {\n                             dir = dirA;\n                        }\n                }\n\n                vec2 normal = vec2(-dir.y, dir.x);\n                normal.x /= aspect;\n                normal *= 0.5 * w;\n                //normal *= len/2.0;\n\n                vec4 offset = vec4(normal*side, 0.0, 1.0);\n                projectedCurPoint.xy += offset.xy;\n               \n                vPosition    = ( modelViewMatrix * vec4( position, 1. ) ).xyz;\n                gl_Position  = projectedCurPoint;\n                gl_PointSize = 10.0;\n}"

/***/ },
/* 380 */
/***/ function(module, exports) {

	module.exports = "#extension GL_OES_standard_derivatives : enable\n//#define SHADER_NAME LineShaderMaterial\n\nprecision highp float;\nprecision highp int;\n\n\n#define USE_LOGDEPTHBUF\n#define USE_LOGDEPTHBUF_EXT\n\n#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        //#extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\n\nuniform sampler2D texture;\nuniform float useTexture;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying vec3 vPosition;\n\nvoid main() {\n\tvec4 c = vColor;\n        if( useTexture == 1. ) c = texture2D( texture, vUV );\n        gl_FragColor = c;\n}"

/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _ItownsPointMaterial = __webpack_require__(382);
	
	var _ItownsPointMaterial2 = _interopRequireDefault(_ItownsPointMaterial);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ItownsPoint = function ItownsPoint(options) {
	    THREE.Points.call(this);
	
	    if (options === undefined) {
	        throw new Error('options is required');
	    }
	
	    this.positions = [];
	    this.colors = [];
	    this.sizes = [];
	    this.geometry = new THREE.BufferGeometry();
	    this.material = new _ItownsPointMaterial2.default(options);
	};
	
	ItownsPoint.prototype = (0, _create2.default)(THREE.Points.prototype);
	ItownsPoint.prototype.constructor = ItownsPoint;
	
	ItownsPoint.prototype.addPoint = function addPoint(v, c, s) {
	    if (v instanceof THREE.Vector3) {
	        this.positions.push(v.x, v.y, v.z);
	
	        if (c instanceof THREE.Color) {
	            this.colors.push(c.r, c.g, c.b);
	        }
	
	        this.sizes.push(s);
	    }
	};
	
	ItownsPoint.prototype.process = function process() {
	    this.geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(this.positions), 3));
	    this.geometry.addAttribute('customColor', new THREE.BufferAttribute(new Float32Array(this.colors), 3));
	    this.geometry.addAttribute('size', new THREE.BufferAttribute(new Float32Array(this.sizes), 1));
	};
	
	exports.default = ItownsPoint;

/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';
	
	Object.defineProperty(exports, "__esModule", {
	    value: true
	});
	
	var _create = __webpack_require__(243);
	
	var _create2 = _interopRequireDefault(_create);
	
	var _three = __webpack_require__(241);
	
	var THREE = _interopRequireWildcard(_three);
	
	var _BasicMaterial = __webpack_require__(323);
	
	var _BasicMaterial2 = _interopRequireDefault(_BasicMaterial);
	
	var _PointVS = __webpack_require__(383);
	
	var _PointVS2 = _interopRequireDefault(_PointVS);
	
	var _PointFS = __webpack_require__(384);
	
	var _PointFS2 = _interopRequireDefault(_PointFS);
	
	function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }
	
	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
	
	var ItownsPointMaterial = function ItownsPointMaterial(options) {
	    _BasicMaterial2.default.call(this);
	
	    if (options === undefined) {
	        throw new Error('options is required');
	    }
	
	    this.vertexShader = _PointVS2.default;
	    this.fragmentShader = _PointFS2.default;
	
	    var texture = new THREE.TextureLoader().load(options.texture);
	
	    this.uniforms.time = { value: options.time };
	    this.uniforms.useTexture = { value: options.useTexture };
	    this.uniforms.texture = { type: 't', value: texture };
	    this.uniforms.color = { type: 'v3', value: options.color };
	    this.uniforms.opacity = { type: 'f', value: options.opacity };
	    this.uniforms.resolution = { value: new THREE.Vector2(window.innerWidth, window.innerHeight) };
	    this.transparent = true;
	};
	
	ItownsPointMaterial.prototype = (0, _create2.default)(_BasicMaterial2.default.prototype);
	ItownsPointMaterial.prototype.constructor = ItownsPointMaterial;
	
	exports.default = ItownsPointMaterial;

/***/ },
/* 383 */
/***/ function(module, exports) {

	module.exports = "//#version 100\n\nprecision highp float;\nprecision highp int;\n\n#define USE_LOGDEPTHBUF\n#define USE_LOGDEPTHBUF_EXT\n\n#ifdef USE_LOGDEPTHBUF\n\n    #define EPSILON 1e-6\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        varying float vFragDepth;\n\n    #endif\n\n    uniform float logDepthBufFC;\n\n#endif\n\nconst float SIZE_MULTIPLIER = 300.0;\n\nattribute vec3  position;\nattribute float size;\nattribute vec3  customColor;\n\nuniform float  opacity;\nuniform mat4   projectionMatrix;\nuniform mat4   modelViewMatrix;\nuniform vec2   resolution;\n\nvarying vec4 vColor;\n\nvoid main() {\n\t\tvColor = vec4( customColor, opacity );\n\n\t\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\n\t\tvec4 projectedPoint = projectionMatrix * mvPosition;\n\n                #ifdef USE_LOGDEPTHBUF\n\n                    projectedPoint.z = log2(max( EPSILON, projectedPoint.w + 1.0 )) * logDepthBufFC;\n\n                    #ifdef USE_LOGDEPTHBUF_EXT\n\n                        vFragDepth = 1.0 + gl_Position.w;\n\n                    #else\n\n                        projectedPoint.z = (projectedPoint.z - 1.0) * projectedPoint.w;\n\n                    #endif\n\n                #endif            \n\n\n                float spriteDist;\n\n                if (projectedPoint.w == 0.0) {\n                        spriteDist = 0.00001;\n                } else {\n                        spriteDist = projectedPoint.w;\n                }\n\n                gl_PointSize = (((size * SIZE_MULTIPLIER * (resolution.x/resolution.y)) / spriteDist) * (resolution.x/resolution.y));\n                gl_Position  = projectedPoint;\n}\n"

/***/ },
/* 384 */
/***/ function(module, exports) {

	module.exports = "//#extension GL_OES_standard_derivatives : enable\n\nprecision highp float;\nprecision highp int;\n\n\n#define USE_LOGDEPTHBUF\n#define USE_LOGDEPTHBUF_EXT\n\n#ifdef USE_LOGDEPTHBUF\n\n    uniform float logDepthBufFC;\n\n    #ifdef USE_LOGDEPTHBUF_EXT\n\n        //#extension GL_EXT_frag_depth : enable\n        varying float vFragDepth;\n\n    #endif\n\n#endif\n\n\nuniform vec3 color;\nuniform sampler2D texture;\nuniform float useTexture;\nuniform float  opacity;\n\nvarying vec4 vColor;\n\nvoid main() {\n\t\t\n        vec4 c = vColor;\n        if( useTexture == 1. ) {\n            c = texture2D( texture, gl_PointCoord );\n            float alpha = step(0.9, c.a);\n            gl_FragColor = c;//vec4(c.rgb * vLighting, c.a);\n            gl_FragColor *= alpha;\n\t}else\n            gl_FragColor = c;\n}"

/***/ }
/******/ ])
});
;
//# sourceMappingURL=itowns.js.map